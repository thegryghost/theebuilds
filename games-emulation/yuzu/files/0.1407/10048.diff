diff --git a/src/core/crypto/key_manager.cpp b/src/core/crypto/key_manager.cpp
index 65a9fe802715..fd1ee4e21a2e 100644
--- a/src/core/crypto/key_manager.cpp
+++ b/src/core/crypto/key_manager.cpp
@@ -156,6 +156,10 @@ u64 GetSignatureTypePaddingSize(SignatureType type) {
     UNREACHABLE();
 }
 
+bool Ticket::IsValid() const {
+    return !std::holds_alternative<std::monostate>(data);
+}
+
 SignatureType Ticket::GetSignatureType() const {
     if (const auto* ticket = std::get_if<RSA4096Ticket>(&data)) {
         return ticket->sig_type;
@@ -210,6 +214,37 @@ Ticket Ticket::SynthesizeCommon(Key128 title_key, const std::array<u8, 16>& righ
     return Ticket{out};
 }
 
+bool Ticket::Read(Ticket& ticket_out, const FileSys::VirtualFile& file) {
+    SignatureType sig_type;
+    if (file->Read(reinterpret_cast<u8*>(&sig_type), sizeof(sig_type), 0) < sizeof(sig_type)) {
+        return false;
+    }
+
+    switch (sig_type) {
+    case SignatureType::RSA_4096_SHA1:
+    case SignatureType::RSA_4096_SHA256: {
+        ticket_out.data.emplace<RSA4096Ticket>();
+        file->Read(reinterpret_cast<u8*>(&ticket_out.data), sizeof(RSA4096Ticket), 0);
+        return true;
+    }
+    case SignatureType::RSA_2048_SHA1:
+    case SignatureType::RSA_2048_SHA256: {
+        ticket_out.data.emplace<RSA2048Ticket>();
+        file->Read(reinterpret_cast<u8*>(&ticket_out.data), sizeof(RSA2048Ticket), 0);
+        return true;
+    }
+    case SignatureType::ECDSA_SHA1:
+    case SignatureType::ECDSA_SHA256: {
+        ticket_out.data.emplace<ECDSATicket>();
+        file->Read(reinterpret_cast<u8*>(&ticket_out.data), sizeof(ECDSATicket), 0);
+        return true;
+    }
+    default:
+        ticket_out.data.emplace<std::monostate>();
+        return false;
+    }
+}
+
 Key128 GenerateKeyEncryptionKey(Key128 source, Key128 master, Key128 kek_seed, Key128 key_seed) {
     Key128 out{};
 
@@ -290,9 +325,9 @@ void KeyManager::DeriveGeneralPurposeKeys(std::size_t crypto_revision) {
     }
 }
 
-RSAKeyPair<2048> KeyManager::GetETicketRSAKey() const {
+void KeyManager::DeriveETicketRSAKey() {
     if (IsAllZeroArray(eticket_extended_kek) || !HasKey(S128KeyType::ETicketRSAKek)) {
-        return {};
+        return;
     }
 
     const auto eticket_final = GetKey(S128KeyType::ETicketRSAKek);
@@ -304,12 +339,12 @@ RSAKeyPair<2048> KeyManager::GetETicketRSAKey() const {
     rsa_1.Transcode(eticket_extended_kek.data() + 0x10, eticket_extended_kek.size() - 0x10,
                     extended_dec.data(), Op::Decrypt);
 
-    RSAKeyPair<2048> rsa_key{};
-    std::memcpy(rsa_key.decryption_key.data(), extended_dec.data(), rsa_key.decryption_key.size());
-    std::memcpy(rsa_key.modulus.data(), extended_dec.data() + 0x100, rsa_key.modulus.size());
-    std::memcpy(rsa_key.exponent.data(), extended_dec.data() + 0x200, rsa_key.exponent.size());
-
-    return rsa_key;
+    std::memcpy(eticket_rsa_keypair.decryption_key.data(), extended_dec.data(),
+                eticket_rsa_keypair.decryption_key.size());
+    std::memcpy(eticket_rsa_keypair.modulus.data(), extended_dec.data() + 0x100,
+                eticket_rsa_keypair.modulus.size());
+    std::memcpy(eticket_rsa_keypair.exponent.data(), extended_dec.data() + 0x200,
+                eticket_rsa_keypair.exponent.size());
 }
 
 Key128 DeriveKeyblobMACKey(const Key128& keyblob_key, const Key128& mac_source) {
@@ -505,67 +540,75 @@ static std::optional<u64> FindTicketOffset(const std::array<u8, size>& data) {
 
 std::optional<std::pair<Key128, Key128>> ParseTicket(const Ticket& ticket,
                                                      const RSAKeyPair<2048>& key) {
-    const auto issuer = ticket.GetData().issuer;
-    if (IsAllZeroArray(issuer)) {
+    if (!ticket.IsValid()) {
         return std::nullopt;
     }
-    if (issuer[0] != 'R' || issuer[1] != 'o' || issuer[2] != 'o' || issuer[3] != 't') {
-        LOG_INFO(Crypto, "Attempting to parse ticket with non-standard certificate authority.");
-    }
 
-    Key128 rights_id = ticket.GetData().rights_id;
+    // Dirty hack, figure out why ticket.data variant is invalid
+    try {
+        const auto issuer = ticket.GetData().issuer;
+        if (IsAllZeroArray(issuer)) {
+            return std::nullopt;
+        }
+        if (issuer[0] != 'R' || issuer[1] != 'o' || issuer[2] != 'o' || issuer[3] != 't') {
+            LOG_INFO(Crypto, "Attempting to parse ticket with non-standard certificate authority.");
+        }
 
-    if (rights_id == Key128{}) {
-        return std::nullopt;
-    }
+        Key128 rights_id = ticket.GetData().rights_id;
 
-    if (!std::any_of(ticket.GetData().title_key_common_pad.begin(),
-                     ticket.GetData().title_key_common_pad.end(), [](u8 b) { return b != 0; })) {
-        return std::make_pair(rights_id, ticket.GetData().title_key_common);
-    }
+        if (rights_id == Key128{}) {
+            return std::nullopt;
+        }
 
-    mbedtls_mpi D; // RSA Private Exponent
-    mbedtls_mpi N; // RSA Modulus
-    mbedtls_mpi S; // Input
-    mbedtls_mpi M; // Output
+        if (ticket.GetData().type == TitleKeyType::Common) {
+            return std::make_pair(rights_id, ticket.GetData().title_key_common);
+        }
 
-    mbedtls_mpi_init(&D);
-    mbedtls_mpi_init(&N);
-    mbedtls_mpi_init(&S);
-    mbedtls_mpi_init(&M);
+        mbedtls_mpi D; // RSA Private Exponent
+        mbedtls_mpi N; // RSA Modulus
+        mbedtls_mpi S; // Input
+        mbedtls_mpi M; // Output
 
-    mbedtls_mpi_read_binary(&D, key.decryption_key.data(), key.decryption_key.size());
-    mbedtls_mpi_read_binary(&N, key.modulus.data(), key.modulus.size());
-    mbedtls_mpi_read_binary(&S, ticket.GetData().title_key_block.data(), 0x100);
+        mbedtls_mpi_init(&D);
+        mbedtls_mpi_init(&N);
+        mbedtls_mpi_init(&S);
+        mbedtls_mpi_init(&M);
 
-    mbedtls_mpi_exp_mod(&M, &S, &D, &N, nullptr);
+        mbedtls_mpi_read_binary(&D, key.decryption_key.data(), key.decryption_key.size());
+        mbedtls_mpi_read_binary(&N, key.modulus.data(), key.modulus.size());
+        mbedtls_mpi_read_binary(&S, ticket.GetData().title_key_block.data(), 0x100);
 
-    std::array<u8, 0x100> rsa_step;
-    mbedtls_mpi_write_binary(&M, rsa_step.data(), rsa_step.size());
+        mbedtls_mpi_exp_mod(&M, &S, &D, &N, nullptr);
 
-    u8 m_0 = rsa_step[0];
-    std::array<u8, 0x20> m_1;
-    std::memcpy(m_1.data(), rsa_step.data() + 0x01, m_1.size());
-    std::array<u8, 0xDF> m_2;
-    std::memcpy(m_2.data(), rsa_step.data() + 0x21, m_2.size());
+        std::array<u8, 0x100> rsa_step;
+        mbedtls_mpi_write_binary(&M, rsa_step.data(), rsa_step.size());
 
-    if (m_0 != 0) {
-        return std::nullopt;
-    }
+        u8 m_0 = rsa_step[0];
+        std::array<u8, 0x20> m_1;
+        std::memcpy(m_1.data(), rsa_step.data() + 0x01, m_1.size());
+        std::array<u8, 0xDF> m_2;
+        std::memcpy(m_2.data(), rsa_step.data() + 0x21, m_2.size());
 
-    m_1 = m_1 ^ MGF1<0x20>(m_2);
-    m_2 = m_2 ^ MGF1<0xDF>(m_1);
+        if (m_0 != 0) {
+            return std::nullopt;
+        }
 
-    const auto offset = FindTicketOffset(m_2);
-    if (!offset) {
-        return std::nullopt;
-    }
-    ASSERT(*offset > 0);
+        m_1 = m_1 ^ MGF1<0x20>(m_2);
+        m_2 = m_2 ^ MGF1<0xDF>(m_1);
 
-    Key128 key_temp{};
-    std::memcpy(key_temp.data(), m_2.data() + *offset, key_temp.size());
+        const auto offset = FindTicketOffset(m_2);
+        if (!offset) {
+            return std::nullopt;
+        }
+        ASSERT(*offset > 0);
 
-    return std::make_pair(rights_id, key_temp);
+        Key128 key_temp{};
+        std::memcpy(key_temp.data(), m_2.data() + *offset, key_temp.size());
+
+        return std::make_pair(rights_id, key_temp);
+    } catch (const std::bad_variant_access&) {
+        return std::nullopt;
+    }
 }
 
 KeyManager::KeyManager() {
@@ -665,6 +708,14 @@ void KeyManager::LoadFromFile(const std::filesystem::path& file_path, bool is_ti
                 encrypted_keyblobs[index] = Common::HexStringToArray<0xB0>(out[1]);
             } else if (out[0].compare(0, 20, "eticket_extended_kek") == 0) {
                 eticket_extended_kek = Common::HexStringToArray<576>(out[1]);
+            } else if (out[0].compare(0, 19, "eticket_rsa_keypair") == 0) {
+                const auto key_data = Common::HexStringToArray<528>(out[1]);
+                std::memcpy(eticket_rsa_keypair.decryption_key.data(), key_data.data(),
+                            eticket_rsa_keypair.decryption_key.size());
+                std::memcpy(eticket_rsa_keypair.modulus.data(), key_data.data() + 0x100,
+                            eticket_rsa_keypair.modulus.size());
+                std::memcpy(eticket_rsa_keypair.exponent.data(), key_data.data() + 0x200,
+                            eticket_rsa_keypair.exponent.size());
             } else {
                 for (const auto& kv : KEYS_VARIABLE_LENGTH) {
                     if (!ValidCryptoRevisionString(out[0], kv.second.size(), 2)) {
@@ -1102,13 +1153,12 @@ void KeyManager::DeriveETicket(PartitionDataManager& data,
 
     eticket_extended_kek = data.GetETicketExtendedKek();
     WriteKeyToFile(KeyCategory::Console, "eticket_extended_kek", eticket_extended_kek);
+    DeriveETicketRSAKey();
     PopulateTickets();
 }
 
 void KeyManager::PopulateTickets() {
-    const auto rsa_key = GetETicketRSAKey();
-
-    if (rsa_key == RSAKeyPair<2048>{}) {
+    if (eticket_rsa_keypair == RSAKeyPair<2048>{}) {
         return;
     }
 
@@ -1136,7 +1186,7 @@ void KeyManager::PopulateTickets() {
 
     for (std::size_t i = 0; i < res.size(); ++i) {
         const auto common = i < idx;
-        const auto pair = ParseTicket(res[i], rsa_key);
+        const auto pair = ParseTicket(res[i], eticket_rsa_keypair);
         if (!pair) {
             continue;
         }
@@ -1284,12 +1334,11 @@ const std::map<u128, Ticket>& KeyManager::GetPersonalizedTickets() const {
 }
 
 bool KeyManager::AddTicketCommon(Ticket raw) {
-    const auto rsa_key = GetETicketRSAKey();
-    if (rsa_key == RSAKeyPair<2048>{}) {
+    if (eticket_rsa_keypair == RSAKeyPair<2048>{}) {
         return false;
     }
 
-    const auto pair = ParseTicket(raw, rsa_key);
+    const auto pair = ParseTicket(raw, eticket_rsa_keypair);
     if (!pair) {
         return false;
     }
@@ -1303,12 +1352,11 @@ bool KeyManager::AddTicketCommon(Ticket raw) {
 }
 
 bool KeyManager::AddTicketPersonalized(Ticket raw) {
-    const auto rsa_key = GetETicketRSAKey();
-    if (rsa_key == RSAKeyPair<2048>{}) {
+    if (eticket_rsa_keypair == RSAKeyPair<2048>{}) {
         return false;
     }
 
-    const auto pair = ParseTicket(raw, rsa_key);
+    const auto pair = ParseTicket(raw, eticket_rsa_keypair);
     if (!pair) {
         return false;
     }
@@ -1316,7 +1364,7 @@ bool KeyManager::AddTicketPersonalized(Ticket raw) {
     const auto& [rid, key] = *pair;
     u128 rights_id;
     std::memcpy(rights_id.data(), rid.data(), rid.size());
-    common_tickets[rights_id] = raw;
+    personal_tickets[rights_id] = raw;
     SetKey(S128KeyType::Titlekey, key, rights_id[1], rights_id[0]);
     return true;
 }
diff --git a/src/core/crypto/key_manager.h b/src/core/crypto/key_manager.h
index 673cec463e5b..3cc0e0e3d66b 100644
--- a/src/core/crypto/key_manager.h
+++ b/src/core/crypto/key_manager.h
@@ -29,8 +29,6 @@ enum class ResultStatus : u16;
 
 namespace Core::Crypto {
 
-constexpr u64 TICKET_FILE_TITLEKEY_OFFSET = 0x180;
-
 using Key128 = std::array<u8, 0x10>;
 using Key256 = std::array<u8, 0x20>;
 using SHA256Hash = std::array<u8, 0x20>;
@@ -98,14 +96,16 @@ struct ECDSATicket {
 };
 
 struct Ticket {
-    std::variant<RSA4096Ticket, RSA2048Ticket, ECDSATicket> data;
+    std::variant<std::monostate, RSA4096Ticket, RSA2048Ticket, ECDSATicket> data;
 
+    bool IsValid() const;
     SignatureType GetSignatureType() const;
     TicketData& GetData();
     const TicketData& GetData() const;
     u64 GetSize() const;
 
     static Ticket SynthesizeCommon(Key128 title_key, const std::array<u8, 0x10>& rights_id);
+    static bool Read(Ticket& ticket_out, const FileSys::VirtualFile& file);
 };
 
 static_assert(sizeof(Key128) == 16, "Key128 must be 128 bytes big.");
@@ -280,6 +280,7 @@ class KeyManager {
     std::array<std::array<u8, 0xB0>, 0x20> encrypted_keyblobs{};
     std::array<std::array<u8, 0x90>, 0x20> keyblobs{};
     std::array<u8, 576> eticket_extended_kek{};
+    RSAKeyPair<2048> eticket_rsa_keypair{};
 
     bool dev_mode;
     void LoadFromFile(const std::filesystem::path& file_path, bool is_title_keys);
@@ -290,7 +291,7 @@ class KeyManager {
 
     void DeriveGeneralPurposeKeys(std::size_t crypto_revision);
 
-    RSAKeyPair<2048> GetETicketRSAKey() const;
+    void DeriveETicketRSAKey();
 
     void SetKeyWrapped(S128KeyType id, Key128 key, u64 field1 = 0, u64 field2 = 0);
     void SetKeyWrapped(S256KeyType id, Key256 key, u64 field1 = 0, u64 field2 = 0);
diff --git a/src/core/file_sys/submission_package.cpp b/src/core/file_sys/submission_package.cpp
index c90e6e37215f..4b4b72e8faf4 100644
--- a/src/core/file_sys/submission_package.cpp
+++ b/src/core/file_sys/submission_package.cpp
@@ -164,24 +164,6 @@ VirtualFile NSP::GetNCAFile(u64 title_id, ContentRecordType type, TitleType titl
     return nullptr;
 }
 
-std::vector<Core::Crypto::Key128> NSP::GetTitlekey() const {
-    if (extracted)
-        LOG_WARNING(Service_FS, "called on an NSP that is of type extracted.");
-    std::vector<Core::Crypto::Key128> out;
-    for (const auto& ticket_file : ticket_files) {
-        if (ticket_file == nullptr ||
-            ticket_file->GetSize() <
-                Core::Crypto::TICKET_FILE_TITLEKEY_OFFSET + sizeof(Core::Crypto::Key128)) {
-            continue;
-        }
-
-        out.emplace_back();
-        ticket_file->Read(out.back().data(), out.back().size(),
-                          Core::Crypto::TICKET_FILE_TITLEKEY_OFFSET);
-    }
-    return out;
-}
-
 std::vector<VirtualFile> NSP::GetFiles() const {
     return pfs->GetFiles();
 }
@@ -208,22 +190,17 @@ void NSP::SetTicketKeys(const std::vector<VirtualFile>& files) {
             continue;
         }
 
-        if (ticket_file->GetSize() <
-            Core::Crypto::TICKET_FILE_TITLEKEY_OFFSET + sizeof(Core::Crypto::Key128)) {
+        Core::Crypto::Ticket ticket{};
+        if (!Core::Crypto::Ticket::Read(ticket, ticket_file)) {
+            LOG_WARNING(Common_Filesystem, "Could not read NSP ticket {}", ticket_file->GetName());
             continue;
         }
 
-        Core::Crypto::Key128 key{};
-        ticket_file->Read(key.data(), key.size(), Core::Crypto::TICKET_FILE_TITLEKEY_OFFSET);
-
-        // We get the name without the extension in order to create the rights ID.
-        std::string name_only(ticket_file->GetName());
-        name_only.erase(name_only.size() - 4);
-
-        const auto rights_id_raw = Common::HexStringToArray<16>(name_only);
-        u128 rights_id;
-        std::memcpy(rights_id.data(), rights_id_raw.data(), sizeof(u128));
-        keys.SetKey(Core::Crypto::S128KeyType::Titlekey, key, rights_id[1], rights_id[0]);
+        if (ticket.GetData().type == Core::Crypto::TitleKeyType::Common) {
+            keys.AddTicketCommon(ticket);
+        } else {
+            keys.AddTicketPersonalized(ticket);
+        }
     }
 }
 
diff --git a/src/core/file_sys/submission_package.h b/src/core/file_sys/submission_package.h
index 3226b884a0ac..e34643ec9694 100644
--- a/src/core/file_sys/submission_package.h
+++ b/src/core/file_sys/submission_package.h
@@ -52,7 +52,6 @@ class NSP : public ReadOnlyVfsDirectory {
                                 TitleType title_type = TitleType::Application) const;
     VirtualFile GetNCAFile(u64 title_id, ContentRecordType type,
                            TitleType title_type = TitleType::Application) const;
-    std::vector<Core::Crypto::Key128> GetTitlekey() const;
 
     std::vector<VirtualFile> GetFiles() const override;
 
