diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index b2dc71d4cb7..46e2dc83996 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -596,6 +596,10 @@ add_library(core STATIC
     hle/service/mii/types/ver3_store_data.h
     hle/service/mii/mii.cpp
     hle/service/mii/mii.h
+    hle/service/mii/mii_database.cpp
+    hle/service/mii/mii_database.h
+    hle/service/mii/mii_database_manager.cpp
+    hle/service/mii/mii_database_manager.h
     hle/service/mii/mii_manager.cpp
     hle/service/mii/mii_manager.h
     hle/service/mii/mii_result.h
diff --git a/src/core/hle/service/mii/mii.cpp b/src/core/hle/service/mii/mii.cpp
index 3b83c5ed7dc..13e6f661b69 100644
--- a/src/core/hle/service/mii/mii.cpp
+++ b/src/core/hle/service/mii/mii.cpp
@@ -8,6 +8,9 @@
 #include "core/hle/service/mii/mii.h"
 #include "core/hle/service/mii/mii_manager.h"
 #include "core/hle/service/mii/mii_result.h"
+#include "core/hle/service/mii/types/char_info.h"
+#include "core/hle/service/mii/types/store_data.h"
+#include "core/hle/service/mii/types/ver3_store_data.h"
 #include "core/hle/service/server_manager.h"
 #include "core/hle/service/service.h"
 
@@ -27,29 +30,31 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
             {5, &IDatabaseService::UpdateLatest, "UpdateLatest"},
             {6, &IDatabaseService::BuildRandom, "BuildRandom"},
             {7, &IDatabaseService::BuildDefault, "BuildDefault"},
-            {8, nullptr, "Get2"},
-            {9, nullptr, "Get3"},
-            {10, nullptr, "UpdateLatest1"},
-            {11, nullptr, "FindIndex"},
-            {12, nullptr, "Move"},
-            {13, nullptr, "AddOrReplace"},
-            {14, nullptr, "Delete"},
-            {15, nullptr, "DestroyFile"},
-            {16, nullptr, "DeleteFile"},
-            {17, nullptr, "Format"},
+            {8, &IDatabaseService::Get2, "Get2"},
+            {9, &IDatabaseService::Get3, "Get3"},
+            {10, &IDatabaseService::UpdateLatest1, "UpdateLatest1"},
+            {11, &IDatabaseService::FindIndex, "FindIndex"},
+            {12, &IDatabaseService::Move, "Move"},
+            {13, &IDatabaseService::AddOrReplace, "AddOrReplace"},
+            {14, &IDatabaseService::Delete, "Delete"},
+            {15, &IDatabaseService::DestroyFile, "DestroyFile"},
+            {16, &IDatabaseService::DeleteFile, "DeleteFile"},
+            {17, &IDatabaseService::Format, "Format"},
             {18, nullptr, "Import"},
             {19, nullptr, "Export"},
-            {20, nullptr, "IsBrokenDatabaseWithClearFlag"},
+            {20, &IDatabaseService::IsBrokenDatabaseWithClearFlag, "IsBrokenDatabaseWithClearFlag"},
             {21, &IDatabaseService::GetIndex, "GetIndex"},
             {22, &IDatabaseService::SetInterfaceVersion, "SetInterfaceVersion"},
             {23, &IDatabaseService::Convert, "Convert"},
-            {24, nullptr, "ConvertCoreDataToCharInfo"},
-            {25, nullptr, "ConvertCharInfoToCoreData"},
-            {26, nullptr, "Append"},
+            {24, &IDatabaseService::ConvertCoreDataToCharInfo, "ConvertCoreDataToCharInfo"},
+            {25, &IDatabaseService::ConvertCharInfoToCoreData, "ConvertCharInfoToCoreData"},
+            {26,  &IDatabaseService::Append, "Append"},
         };
         // clang-format on
 
         RegisterHandlers(functions);
+
+        manager.Initialize(metadata);
     }
 
 private:
@@ -80,10 +85,10 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
         IPC::RequestParser rp{ctx};
         const auto source_flag{rp.PopRaw<SourceFlag>()};
 
-        LOG_DEBUG(Service_Mii, "called with source_flag={}", source_flag);
-
         const u32 mii_count = manager.GetCount(metadata, source_flag);
 
+        LOG_DEBUG(Service_Mii, "called with source_flag={}, mii_count={}", source_flag, mii_count);
+
         IPC::ResponseBuilder rb{ctx, 3};
         rb.Push(ResultSuccess);
         rb.Push(mii_count);
@@ -94,16 +99,17 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
         const auto source_flag{rp.PopRaw<SourceFlag>()};
         const auto output_size{ctx.GetWriteBufferNumElements<CharInfoElement>()};
 
-        LOG_DEBUG(Service_Mii, "called with source_flag={}, out_size={}", source_flag, output_size);
-
         u32 mii_count{};
         std::vector<CharInfoElement> char_info_elements(output_size);
-        Result result = manager.Get(metadata, char_info_elements, mii_count, source_flag);
+        const auto result = manager.Get(metadata, char_info_elements, mii_count, source_flag);
 
         if (mii_count != 0) {
             ctx.WriteBuffer(char_info_elements);
         }
 
+        LOG_INFO(Service_Mii, "called with source_flag={}, out_size={}, mii_count={}", source_flag,
+                 output_size, mii_count);
+
         IPC::ResponseBuilder rb{ctx, 3};
         rb.Push(result);
         rb.Push(mii_count);
@@ -114,16 +120,17 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
         const auto source_flag{rp.PopRaw<SourceFlag>()};
         const auto output_size{ctx.GetWriteBufferNumElements<CharInfo>()};
 
-        LOG_DEBUG(Service_Mii, "called with source_flag={}, out_size={}", source_flag, output_size);
-
         u32 mii_count{};
         std::vector<CharInfo> char_info(output_size);
-        Result result = manager.Get(metadata, char_info, mii_count, source_flag);
+        const auto result = manager.Get(metadata, char_info, mii_count, source_flag);
 
         if (mii_count != 0) {
             ctx.WriteBuffer(char_info);
         }
 
+        LOG_INFO(Service_Mii, "called with source_flag={}, out_size={}, mii_count={}", source_flag,
+                 output_size, mii_count);
+
         IPC::ResponseBuilder rb{ctx, 3};
         rb.Push(result);
         rb.Push(mii_count);
@@ -134,7 +141,7 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
         const auto char_info{rp.PopRaw<CharInfo>()};
         const auto source_flag{rp.PopRaw<SourceFlag>()};
 
-        LOG_DEBUG(Service_Mii, "called with source_flag={}", source_flag);
+        LOG_INFO(Service_Mii, "called with source_flag={}", source_flag);
 
         CharInfo new_char_info{};
         const auto result = manager.UpdateLatest(metadata, new_char_info, char_info, source_flag);
@@ -146,7 +153,7 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
 
         IPC::ResponseBuilder rb{ctx, 2 + sizeof(CharInfo) / sizeof(u32)};
         rb.Push(ResultSuccess);
-        rb.PushRaw<CharInfo>(new_char_info);
+        rb.PushRaw(new_char_info);
     }
 
     void BuildRandom(HLERequestContext& ctx) {
@@ -180,14 +187,14 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
 
         IPC::ResponseBuilder rb{ctx, 2 + sizeof(CharInfo) / sizeof(u32)};
         rb.Push(ResultSuccess);
-        rb.PushRaw<CharInfo>(char_info);
+        rb.PushRaw(char_info);
     }
 
     void BuildDefault(HLERequestContext& ctx) {
         IPC::RequestParser rp{ctx};
         const auto index{rp.Pop<u32>()};
 
-        LOG_INFO(Service_Mii, "called with index={}", index);
+        LOG_DEBUG(Service_Mii, "called with index={}", index);
 
         if (index > 5) {
             IPC::ResponseBuilder rb{ctx, 2};
@@ -200,7 +207,239 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
 
         IPC::ResponseBuilder rb{ctx, 2 + sizeof(CharInfo) / sizeof(u32)};
         rb.Push(ResultSuccess);
-        rb.PushRaw<CharInfo>(char_info);
+        rb.PushRaw(char_info);
+    }
+
+    void Get2(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto source_flag{rp.PopRaw<SourceFlag>()};
+        const auto output_size{ctx.GetWriteBufferNumElements<StoreDataElement>()};
+
+        u32 mii_count{};
+        std::vector<StoreDataElement> store_data_elements(output_size);
+        const auto result = manager.Get(metadata, store_data_elements, mii_count, source_flag);
+
+        if (mii_count != 0) {
+            ctx.WriteBuffer(store_data_elements);
+        }
+
+        LOG_INFO(Service_Mii, "called with source_flag={}, out_size={}, mii_count={}", source_flag,
+                 output_size, mii_count);
+
+        IPC::ResponseBuilder rb{ctx, 3};
+        rb.Push(result);
+        rb.Push(mii_count);
+    }
+
+    void Get3(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto source_flag{rp.PopRaw<SourceFlag>()};
+        const auto output_size{ctx.GetWriteBufferNumElements<StoreData>()};
+
+        u32 mii_count{};
+        std::vector<StoreData> store_data(output_size);
+        const auto result = manager.Get(metadata, store_data, mii_count, source_flag);
+
+        if (mii_count != 0) {
+            ctx.WriteBuffer(store_data);
+        }
+
+        LOG_INFO(Service_Mii, "called with source_flag={}, out_size={}, mii_count={}", source_flag,
+                 output_size, mii_count);
+
+        IPC::ResponseBuilder rb{ctx, 3};
+        rb.Push(result);
+        rb.Push(mii_count);
+    }
+
+    void UpdateLatest1(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto store_data{rp.PopRaw<StoreData>()};
+        const auto source_flag{rp.PopRaw<SourceFlag>()};
+
+        LOG_INFO(Service_Mii, "called with source_flag={}", source_flag);
+
+        Result result = ResultSuccess;
+        if (!is_system) {
+            result = ResultPermissionDenied;
+        }
+
+        StoreData new_store_data{};
+        if (result.IsSuccess()) {
+            result = manager.UpdateLatest(metadata, new_store_data, store_data, source_flag);
+        }
+
+        if (result.IsFailure()) {
+            IPC::ResponseBuilder rb{ctx, 2};
+            rb.Push(result);
+            return;
+        }
+
+        IPC::ResponseBuilder rb{ctx, 2 + sizeof(StoreData) / sizeof(u32)};
+        rb.Push(ResultSuccess);
+        rb.PushRaw<StoreData>(new_store_data);
+    }
+
+    void FindIndex(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto create_id{rp.PopRaw<Common::UUID>()};
+        const auto is_special{rp.PopRaw<bool>()};
+
+        LOG_INFO(Service_Mii, "called with create_id={}, is_special={}",
+                 create_id.FormattedString(), is_special);
+
+        const s32 index = manager.FindIndex(create_id, is_special);
+
+        IPC::ResponseBuilder rb{ctx, 3};
+        rb.Push(ResultSuccess);
+        rb.Push(index);
+    }
+
+    void Move(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto create_id{rp.PopRaw<Common::UUID>()};
+        const auto new_index{rp.PopRaw<s32>()};
+
+        LOG_INFO(Service_Mii, "called with create_id={}, new_index={}", create_id.FormattedString(),
+                 new_index);
+
+        Result result = ResultSuccess;
+        if (!is_system) {
+            result = ResultPermissionDenied;
+        }
+
+        if (result.IsSuccess()) {
+            const u32 count = manager.GetCount(metadata, SourceFlag::Database);
+            if (new_index < 0 || new_index >= static_cast<s32>(count)) {
+                result = ResultInvalidArgument;
+            }
+        }
+
+        if (result.IsSuccess()) {
+            result = manager.Move(metadata, new_index, create_id);
+        }
+
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(result);
+    }
+
+    void AddOrReplace(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto store_data{rp.PopRaw<StoreData>()};
+
+        LOG_INFO(Service_Mii, "called");
+
+        Result result = ResultSuccess;
+
+        if (!is_system) {
+            result = ResultPermissionDenied;
+        }
+
+        if (result.IsSuccess()) {
+            result = manager.AddOrReplace(metadata, store_data);
+        }
+
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(result);
+    }
+
+    void Delete(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto create_id{rp.PopRaw<Common::UUID>()};
+
+        LOG_INFO(Service_Mii, "called, create_id={}", create_id.FormattedString());
+
+        Result result = ResultSuccess;
+
+        if (!is_system) {
+            result = ResultPermissionDenied;
+        }
+
+        if (result.IsSuccess()) {
+            result = manager.Delete(metadata, create_id);
+        }
+
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(result);
+    }
+
+    void DestroyFile(HLERequestContext& ctx) {
+        // This calls nn::settings::fwdbg::GetSettingsItemValue("is_db_test_mode_enabled");
+        const bool is_db_test_mode_enabled = false;
+
+        LOG_INFO(Service_Mii, "called is_db_test_mode_enabled={}", is_db_test_mode_enabled);
+
+        Result result = ResultSuccess;
+
+        if (!is_db_test_mode_enabled) {
+            result = ResultTestModeOnly;
+        }
+
+        if (result.IsSuccess()) {
+            result = manager.DestroyFile(metadata);
+        }
+
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(result);
+    }
+
+    void DeleteFile(HLERequestContext& ctx) {
+        // This calls nn::settings::fwdbg::GetSettingsItemValue("is_db_test_mode_enabled");
+        const bool is_db_test_mode_enabled = false;
+
+        LOG_INFO(Service_Mii, "called is_db_test_mode_enabled={}", is_db_test_mode_enabled);
+
+        Result result = ResultSuccess;
+
+        if (!is_db_test_mode_enabled) {
+            result = ResultTestModeOnly;
+        }
+
+        if (result.IsSuccess()) {
+            result = manager.DeleteFile();
+        }
+
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(result);
+    }
+
+    void Format(HLERequestContext& ctx) {
+        // This calls nn::settings::fwdbg::GetSettingsItemValue("is_db_test_mode_enabled");
+        const bool is_db_test_mode_enabled = false;
+
+        LOG_INFO(Service_Mii, "called is_db_test_mode_enabled={}", is_db_test_mode_enabled);
+
+        Result result = ResultSuccess;
+
+        if (!is_db_test_mode_enabled) {
+            result = ResultTestModeOnly;
+        }
+
+        if (result.IsSuccess()) {
+            result = manager.Format(metadata);
+        }
+
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(result);
+    }
+
+    void IsBrokenDatabaseWithClearFlag(HLERequestContext& ctx) {
+        LOG_DEBUG(Service_Mii, "called");
+
+        bool is_broken_with_clear_flag = false;
+        Result result = ResultSuccess;
+
+        if (!is_system) {
+            result = ResultPermissionDenied;
+        }
+
+        if (result.IsSuccess()) {
+            is_broken_with_clear_flag = manager.IsBrokenWithClearFlag(metadata);
+        }
+
+        IPC::ResponseBuilder rb{ctx, 3};
+        rb.Push(result);
+        rb.Push<u8>(is_broken_with_clear_flag);
     }
 
     void GetIndex(HLERequestContext& ctx) {
@@ -236,13 +475,53 @@ class IDatabaseService final : public ServiceFramework<IDatabaseService> {
         LOG_INFO(Service_Mii, "called");
 
         CharInfo char_info{};
-        manager.ConvertV3ToCharInfo(char_info, mii_v3);
+        const auto result = manager.ConvertV3ToCharInfo(char_info, mii_v3);
 
         IPC::ResponseBuilder rb{ctx, 2 + sizeof(CharInfo) / sizeof(u32)};
-        rb.Push(ResultSuccess);
+        rb.Push(result);
+        rb.PushRaw<CharInfo>(char_info);
+    }
+
+    void ConvertCoreDataToCharInfo(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto core_data{rp.PopRaw<CoreData>()};
+
+        LOG_INFO(Service_Mii, "called");
+
+        CharInfo char_info{};
+        const auto result = manager.ConvertCoreDataToCharInfo(char_info, core_data);
+
+        IPC::ResponseBuilder rb{ctx, 2 + sizeof(CharInfo) / sizeof(u32)};
+        rb.Push(result);
         rb.PushRaw<CharInfo>(char_info);
     }
 
+    void ConvertCharInfoToCoreData(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto char_info{rp.PopRaw<CharInfo>()};
+
+        LOG_INFO(Service_Mii, "called");
+
+        CoreData core_data{};
+        const auto result = manager.ConvertCharInfoToCoreData(core_data, char_info);
+
+        IPC::ResponseBuilder rb{ctx, 2 + sizeof(CoreData) / sizeof(u32)};
+        rb.Push(result);
+        rb.PushRaw<CoreData>(core_data);
+    }
+
+    void Append(HLERequestContext& ctx) {
+        IPC::RequestParser rp{ctx};
+        const auto char_info{rp.PopRaw<CharInfo>()};
+
+        LOG_INFO(Service_Mii, "called");
+
+        const auto result = manager.Append(metadata, char_info);
+
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(result);
+    }
+
     MiiManager manager{};
     DatabaseSessionMetadata metadata{};
     bool is_system{};
@@ -267,7 +546,7 @@ class MiiDBModule final : public ServiceFramework<MiiDBModule> {
         rb.Push(ResultSuccess);
         rb.PushIpcInterface<IDatabaseService>(system, is_system);
 
-        LOG_DEBUG(Service_Mii, "called");
+        LOG_CRITICAL(Service_Mii, "called");
     }
 
     bool is_system{};
@@ -278,9 +557,9 @@ class MiiImg final : public ServiceFramework<MiiImg> {
     explicit MiiImg(Core::System& system_) : ServiceFramework{system_, "miiimg"} {
         // clang-format off
         static const FunctionInfo functions[] = {
-            {0, nullptr, "Initialize"},
+            {0, &MiiImg::Initialize, "Initialize"},
             {10, nullptr, "Reload"},
-            {11, nullptr, "GetCount"},
+            {11, &MiiImg::GetCount, "GetCount"},
             {12, nullptr, "IsEmpty"},
             {13, nullptr, "IsFull"},
             {14, nullptr, "GetAttribute"},
@@ -297,6 +576,22 @@ class MiiImg final : public ServiceFramework<MiiImg> {
 
         RegisterHandlers(functions);
     }
+
+private:
+    void Initialize(HLERequestContext& ctx) {
+        LOG_INFO(Service_Mii, "called");
+
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(ResultSuccess);
+    }
+
+    void GetCount(HLERequestContext& ctx) {
+        LOG_DEBUG(Service_Mii, "called");
+
+        IPC::ResponseBuilder rb{ctx, 3};
+        rb.Push(ResultSuccess);
+        rb.Push(0);
+    }
 };
 
 void LoopProcess(Core::System& system) {
diff --git a/src/core/hle/service/mii/mii_database.cpp b/src/core/hle/service/mii/mii_database.cpp
new file mode 100644
index 00000000000..3803e58e285
--- /dev/null
+++ b/src/core/hle/service/mii/mii_database.cpp
@@ -0,0 +1,142 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include "core/hle/service/mii/mii_database.h"
+#include "core/hle/service/mii/mii_result.h"
+#include "core/hle/service/mii/mii_util.h"
+
+namespace Service::Mii {
+
+u8 NintendoFigurineDatabase::GetDatabaseLength() const {
+    return database_length;
+}
+
+bool NintendoFigurineDatabase::IsFull() const {
+    return database_length >= MaxDatabaseLength;
+}
+
+StoreData NintendoFigurineDatabase::Get(std::size_t index) const {
+    StoreData store_data = miis.at(index);
+
+    // This hack is to make external database dumps compatible
+    store_data.SetDeviceChecksum();
+
+    return store_data;
+}
+
+u32 NintendoFigurineDatabase::GetCount(const DatabaseSessionMetadata& metadata) const {
+    if (magic == MiiMagic) {
+        return GetDatabaseLength();
+    }
+
+    u32 mii_count{};
+    for (std::size_t index = 0; index < mii_count; ++index) {
+        const auto& store_data = Get(index);
+        if (!store_data.IsSpecial()) {
+            mii_count++;
+        }
+    }
+
+    return mii_count;
+}
+
+bool NintendoFigurineDatabase::GetIndexByCreatorId(u32& out_index,
+                                                   const Common::UUID& create_id) const {
+    for (std::size_t index = 0; index < database_length; ++index) {
+        if (miis[index].GetCreateId() == create_id) {
+            out_index = static_cast<u32>(index);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+Result NintendoFigurineDatabase::Move(u32 current_index, u32 new_index) {
+    if (current_index == new_index) {
+        return ResultNotUpdated;
+    }
+
+    const StoreData store_data = miis[current_index];
+
+    if (new_index > current_index) {
+        // Shift left
+        const u32 index_diff = new_index - current_index;
+        for (std::size_t i = 0; i < index_diff; i++) {
+            miis[current_index + i] = miis[current_index + i + 1];
+        }
+    } else {
+        // Shift right
+        const u32 index_diff = current_index - new_index;
+        for (std::size_t i = 0; i < index_diff; i++) {
+            miis[current_index - i] = miis[current_index - i - 1];
+        }
+    }
+
+    miis[new_index] = store_data;
+    crc = GenerateDatabaseCrc();
+    return ResultSuccess;
+}
+
+void NintendoFigurineDatabase::Replace(u32 index, const StoreData& store_data) {
+    miis[index] = store_data;
+    crc = GenerateDatabaseCrc();
+}
+
+void NintendoFigurineDatabase::Add(const StoreData& store_data) {
+    miis[database_length] = store_data;
+    database_length++;
+    crc = GenerateDatabaseCrc();
+}
+
+void NintendoFigurineDatabase::Delete(u32 index) {
+    // Shift left
+    const s32 new_database_size = database_length - 1;
+    if (static_cast<s32>(index) < new_database_size) {
+        for (std::size_t i = index; i < static_cast<std::size_t>(new_database_size); i++) {
+            miis[i] = miis[i + 1];
+        }
+    }
+
+    database_length = static_cast<u8>(new_database_size);
+    crc = GenerateDatabaseCrc();
+}
+
+void NintendoFigurineDatabase::CleanDatabase() {
+    miis = {};
+    version = 1;
+    magic = DatabaseMagic;
+    database_length = 0;
+    crc = GenerateDatabaseCrc();
+}
+
+void NintendoFigurineDatabase::CorruptCrc() {
+    crc = GenerateDatabaseCrc();
+    crc = ~crc;
+}
+
+Result NintendoFigurineDatabase::CheckIntegrity() {
+    if (magic != DatabaseMagic) {
+        return ResultInvalidDatabaseSignature;
+    }
+
+    if (version != 1) {
+        return ResultInvalidDatabaseVersion;
+    }
+
+    if (crc != GenerateDatabaseCrc()) {
+        return ResultInvalidDatabaseChecksum;
+    }
+
+    if (database_length >= MaxDatabaseLength) {
+        return ResultInvalidDatabaseLength;
+    }
+
+    return ResultSuccess;
+}
+
+u16 NintendoFigurineDatabase::GenerateDatabaseCrc() {
+    return MiiUtil::CalculateCrc16(&magic, sizeof(NintendoFigurineDatabase) - sizeof(crc));
+}
+
+} // namespace Service::Mii
diff --git a/src/core/hle/service/mii/mii_database.h b/src/core/hle/service/mii/mii_database.h
new file mode 100644
index 00000000000..3bd240f93b7
--- /dev/null
+++ b/src/core/hle/service/mii/mii_database.h
@@ -0,0 +1,66 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#pragma once
+
+#include "core/hle/result.h"
+#include "core/hle/service/mii/types/store_data.h"
+
+namespace Service::Mii {
+
+constexpr std::size_t MaxDatabaseLength{100};
+constexpr u32 MiiMagic{0xa523b78f};
+constexpr u32 DatabaseMagic{0x4244464e}; // NFDB
+
+class NintendoFigurineDatabase {
+public:
+    /// Returns the total mii count.
+    u8 GetDatabaseLength() const;
+
+    /// Returns true if database is full.
+    bool IsFull() const;
+
+    /// Returns the mii of the specified index.
+    StoreData Get(std::size_t index) const;
+
+    /// Returns the total mii count. Ignoring special mii.
+    u32 GetCount(const DatabaseSessionMetadata& metadata) const;
+
+    /// Returns the index of a mii. If the mii isn't found returns false.
+    bool GetIndexByCreatorId(u32& out_index, const Common::UUID& create_id) const;
+
+    /// Moves the location of a specific mii.
+    Result Move(u32 current_index, u32 new_index);
+
+    /// Replaces mii with new data.
+    void Replace(u32 index, const StoreData& store_data);
+
+    /// Adds a new mii to the end of the database.
+    void Add(const StoreData& store_data);
+
+    /// Removes mii from database and shifts left the remainding data.
+    void Delete(u32 index);
+
+    /// Deletes all contents with a fresh database
+    void CleanDatabase();
+
+    /// Intentionally sets a bad checksum
+    void CorruptCrc();
+
+    /// Returns success if database is valid otherwise returns the corresponding error code.
+    Result CheckIntegrity();
+
+private:
+    /// Returns the checksum of the database
+    u16 GenerateDatabaseCrc();
+
+    u32 magic{}; // 'NFDB'
+    std::array<StoreData, MaxDatabaseLength> miis{};
+    u8 version{};
+    u8 database_length{};
+    u16 crc{};
+};
+static_assert(sizeof(NintendoFigurineDatabase) == 0x1A98,
+              "NintendoFigurineDatabase has incorrect size.");
+
+}; // namespace Service::Mii
diff --git a/src/core/hle/service/mii/mii_database_manager.cpp b/src/core/hle/service/mii/mii_database_manager.cpp
new file mode 100644
index 00000000000..06c7ce40f07
--- /dev/null
+++ b/src/core/hle/service/mii/mii_database_manager.cpp
@@ -0,0 +1,418 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include "common/assert.h"
+#include "common/fs/file.h"
+#include "common/fs/fs.h"
+#include "common/fs/path_util.h"
+#include "common/logging/log.h"
+#include "common/string_util.h"
+
+#include "core/hle/service/mii/mii_database_manager.h"
+#include "core/hle/service/mii/mii_result.h"
+#include "core/hle/service/mii/mii_util.h"
+#include "core/hle/service/mii/types/char_info.h"
+#include "core/hle/service/mii/types/store_data.h"
+
+namespace Service::Mii {
+DatabaseManager::DatabaseManager() {}
+
+Result DatabaseManager::MountSaveData() {
+    if (!is_save_data_mounted) {
+        system_save_dir =
+            Common::FS::GetYuzuPath(Common::FS::YuzuPath::NANDDir) / "system/save/8000000000000030";
+        if (is_test_db) {
+            system_save_dir = Common::FS::GetYuzuPath(Common::FS::YuzuPath::NANDDir) /
+                              "system/save/8000000000000031";
+        }
+
+        // mount point should be "mii:"
+
+        if (!Common::FS::CreateDirs(system_save_dir)) {
+            return ResultUnknown;
+        }
+    }
+
+    is_save_data_mounted = true;
+    return ResultSuccess;
+}
+
+Result DatabaseManager::Initialize(DatabaseSessionMetadata& metadata, bool& is_database_broken) {
+    is_database_broken = false;
+    if (!is_save_data_mounted) {
+        return ResultInvalidArgument;
+    }
+
+    database.CleanDatabase();
+    update_counter++;
+    metadata.update_counter = update_counter;
+
+    const Common::FS::IOFile db_file{system_save_dir / DbFileName, Common::FS::FileAccessMode::Read,
+                                     Common::FS::FileType::BinaryFile};
+
+    if (!db_file.IsOpen()) {
+        return SaveDatabase();
+    }
+
+    if (Common::FS::GetSize(system_save_dir / DbFileName) != sizeof(NintendoFigurineDatabase)) {
+        is_database_broken = true;
+    }
+
+    if (db_file.Read(database) != 1) {
+        is_database_broken = true;
+    }
+
+    if (is_database_broken) {
+        // Dragons happen here for simplicity just clean the database
+        LOG_ERROR(Service_Mii, "Mii database is corrupted");
+        database.CleanDatabase();
+        return ResultUnknown;
+    }
+
+    const auto result = database.CheckIntegrity();
+
+    if (result.IsError()) {
+        LOG_ERROR(Service_Mii, "Mii database is corrupted 0x{:0x}", result.raw);
+        database.CleanDatabase();
+        return ResultSuccess;
+    }
+
+    LOG_INFO(Service_Mii, "Successfully loaded mii database. size={}",
+             database.GetDatabaseLength());
+    return ResultSuccess;
+}
+
+bool DatabaseManager::IsFullDatabase() const {
+    return database.GetDatabaseLength() == MaxDatabaseLength;
+}
+
+bool DatabaseManager::IsModified() const {
+    return is_moddified;
+}
+
+u64 DatabaseManager::GetUpdateCounter() const {
+    return update_counter;
+}
+
+u32 DatabaseManager::GetCount(const DatabaseSessionMetadata& metadata) const {
+    const u32 database_size = database.GetDatabaseLength();
+    if (metadata.magic == MiiMagic) {
+        return database_size;
+    }
+
+    // Special mii can't be used. Skip those.
+
+    u32 mii_count{};
+    for (std::size_t index = 0; index < database_size; ++index) {
+        const auto& store_data = database.Get(index);
+        if (store_data.IsSpecial()) {
+            continue;
+        }
+        mii_count++;
+    }
+
+    return mii_count;
+}
+
+void DatabaseManager::Get(StoreData& out_store_data, std::size_t index,
+                          const DatabaseSessionMetadata& metadata) const {
+    if (metadata.magic == MiiMagic) {
+        out_store_data = database.Get(index);
+        return;
+    }
+
+    // The index refeers to the mii index without special mii.
+    // Search on the database until we find it
+
+    u32 virtual_index = 0;
+    const u32 database_size = database.GetDatabaseLength();
+    for (std::size_t i = 0; i < database_size; ++i) {
+        const auto& store_data = database.Get(i);
+        if (store_data.IsSpecial()) {
+            continue;
+        }
+        if (virtual_index == index) {
+            out_store_data = store_data;
+            return;
+        }
+        virtual_index++;
+    }
+
+    // This function doesn't fail. It returns the first mii instead
+    out_store_data = database.Get(0);
+}
+
+Result DatabaseManager::FindIndex(s32& out_index, const Common::UUID& create_id,
+                                  bool is_special) const {
+    u32 index{};
+    const bool is_found = database.GetIndexByCreatorId(index, create_id);
+
+    if (!is_found) {
+        return ResultNotFound;
+    }
+
+    if (is_special) {
+        out_index = index;
+        return ResultSuccess;
+    }
+
+    if (database.Get(index).IsSpecial()) {
+        return ResultNotFound;
+    }
+
+    out_index = 0;
+
+    if (index < 1) {
+        return ResultSuccess;
+    }
+
+    for (std::size_t i = 0; i <= index; ++i) {
+        if (database.Get(i).IsSpecial()) {
+            continue;
+        }
+        out_index++;
+    }
+    return ResultSuccess;
+}
+
+Result DatabaseManager::FindIndex(const DatabaseSessionMetadata& metadata, u32& out_index,
+                                  const Common::UUID& create_id) const {
+    u32 index{};
+    const bool is_found = database.GetIndexByCreatorId(index, create_id);
+
+    if (!is_found) {
+        return ResultNotFound;
+    }
+
+    if (metadata.magic == MiiMagic) {
+        out_index = index;
+        return ResultSuccess;
+    }
+
+    if (database.Get(index).IsSpecial()) {
+        return ResultNotFound;
+    }
+
+    out_index = 0;
+
+    if (index < 1) {
+        return ResultSuccess;
+    }
+
+    // The index refeers to the mii index without special mii.
+    // Search on the database until we find it
+
+    for (std::size_t i = 0; i <= index; ++i) {
+        const auto& store_data = database.Get(i);
+        if (store_data.IsSpecial()) {
+            continue;
+        }
+        out_index++;
+    }
+    return ResultSuccess;
+}
+
+Result DatabaseManager::FindMoveIndex(u32& out_index, u32 new_index,
+                                      const Common::UUID& create_id) const {
+    const auto database_size = database.GetDatabaseLength();
+
+    if (database_size >= 1) {
+        u32 virtual_index{};
+        for (std::size_t i = 0; i < database_size; ++i) {
+            const StoreData& store_data = database.Get(i);
+            if (store_data.IsSpecial()) {
+                continue;
+            }
+            if (virtual_index == new_index) {
+                const bool is_found = database.GetIndexByCreatorId(out_index, create_id);
+                if (!is_found) {
+                    return ResultNotFound;
+                }
+                if (store_data.IsSpecial()) {
+                    return ResultInvalidOperation;
+                }
+                return ResultSuccess;
+            }
+            virtual_index++;
+        }
+    }
+
+    const bool is_found = database.GetIndexByCreatorId(out_index, create_id);
+    if (!is_found) {
+        return ResultNotFound;
+    }
+    const StoreData& store_data = database.Get(out_index);
+    if (store_data.IsSpecial()) {
+        return ResultInvalidOperation;
+    }
+    return ResultSuccess;
+}
+
+Result DatabaseManager::Move(DatabaseSessionMetadata& metadata, u32 new_index,
+                             const Common::UUID& create_id) {
+    u32 current_index{};
+    if (metadata.magic == MiiMagic) {
+        const bool is_found = database.GetIndexByCreatorId(current_index, create_id);
+        if (!is_found) {
+            return ResultNotFound;
+        }
+    } else {
+        const auto result = FindMoveIndex(current_index, new_index, create_id);
+        if (result.IsError()) {
+            return result;
+        }
+    }
+
+    const auto result = database.Move(current_index, new_index);
+    if (result.IsFailure()) {
+        return result;
+    }
+
+    is_moddified = true;
+    update_counter++;
+    metadata.update_counter = update_counter;
+    return ResultSuccess;
+}
+
+Result DatabaseManager::AddOrReplace(DatabaseSessionMetadata& metadata,
+                                     const StoreData& store_data) {
+    if (store_data.IsValid() != ValidationResult::NoErrors) {
+        return ResultInvalidStoreData;
+    }
+    if (metadata.magic != MiiMagic && store_data.IsSpecial()) {
+        return ResultInvalidOperation;
+    }
+
+    u32 index{};
+    const bool is_found = database.GetIndexByCreatorId(index, store_data.GetCreateId());
+    if (is_found) {
+        const StoreData& old_store_data = database.Get(index);
+
+        if (store_data.IsSpecial() != old_store_data.IsSpecial()) {
+            return ResultInvalidOperation;
+        }
+
+        database.Replace(index, store_data);
+    } else {
+        if (database.IsFull()) {
+            return ResultDatabaseFull;
+        }
+
+        database.Add(store_data);
+    }
+
+    is_moddified = true;
+    update_counter++;
+    metadata.update_counter = update_counter;
+    return ResultSuccess;
+}
+
+Result DatabaseManager::Delete(DatabaseSessionMetadata& metadata, const Common::UUID& create_id) {
+    u32 index{};
+    const bool is_found = database.GetIndexByCreatorId(index, create_id);
+    if (!is_found) {
+        return ResultNotFound;
+    }
+
+    if (metadata.magic != MiiMagic) {
+        const auto& store_data = database.Get(index);
+        if (store_data.IsSpecial()) {
+            return ResultInvalidOperation;
+        }
+    }
+
+    database.Delete(index);
+
+    is_moddified = true;
+    update_counter++;
+    metadata.update_counter = update_counter;
+    return ResultSuccess;
+}
+
+Result DatabaseManager::Append(DatabaseSessionMetadata& metadata, const CharInfo& char_info) {
+    if (char_info.Verify() != ValidationResult::NoErrors) {
+        return ResultInvalidCharInfo2;
+    }
+    if (char_info.GetType() == 1) {
+        return ResultInvalidCharInfoType;
+    }
+
+    u32 index{};
+    StoreData store_data{};
+
+    // Loop until the mii we created is not on the database
+    do {
+        store_data.BuildWithCharInfo(char_info);
+    } while (database.GetIndexByCreatorId(index, store_data.GetCreateId()));
+
+    const Result result = store_data.Restore();
+
+    if (result.IsSuccess() || result == ResultNotUpdated) {
+        return AddOrReplace(metadata, store_data);
+    }
+
+    return result;
+}
+
+Result DatabaseManager::DestroyFile(DatabaseSessionMetadata& metadata) {
+    database.CorruptCrc();
+
+    is_moddified = true;
+    update_counter++;
+    metadata.update_counter = update_counter;
+
+    const auto result = SaveDatabase();
+    database.CleanDatabase();
+
+    return result;
+}
+
+Result DatabaseManager::DeleteFile() {
+    const bool result = Common::FS::RemoveFile(system_save_dir / DbFileName);
+    // TODO: Return proper FS error here
+    return result ? ResultSuccess : ResultUnknown;
+}
+
+void DatabaseManager::Format(DatabaseSessionMetadata& metadata) {
+    database.CleanDatabase();
+    is_moddified = true;
+    update_counter++;
+    metadata.update_counter = update_counter;
+}
+
+Result DatabaseManager::SaveDatabase() {
+    // TODO: Replace unknown error codes with proper FS error codes when available
+
+    if (!Common::FS::Exists(system_save_dir / DbFileName)) {
+        if (!Common::FS::NewFile(system_save_dir / DbFileName)) {
+            LOG_ERROR(Service_Mii, "Failed to create mii database");
+            return ResultUnknown;
+        }
+    }
+
+    const auto file_size = Common::FS::GetSize(system_save_dir / DbFileName);
+    if (file_size != 0 && file_size != sizeof(NintendoFigurineDatabase)) {
+        if (!Common::FS::RemoveFile(system_save_dir / DbFileName)) {
+            LOG_ERROR(Service_Mii, "Failed to delete mii database");
+            return ResultUnknown;
+        }
+        if (!Common::FS::NewFile(system_save_dir / DbFileName)) {
+            LOG_ERROR(Service_Mii, "Failed to create mii database");
+            return ResultUnknown;
+        }
+    }
+
+    const Common::FS::IOFile db_file{system_save_dir / DbFileName,
+                                     Common::FS::FileAccessMode::ReadWrite,
+                                     Common::FS::FileType::BinaryFile};
+
+    if (db_file.Write(database) != 1) {
+        LOG_ERROR(Service_Mii, "Failed to save mii database");
+        return ResultUnknown;
+    }
+
+    is_moddified = false;
+    return ResultSuccess;
+}
+
+} // namespace Service::Mii
diff --git a/src/core/hle/service/mii/mii_database_manager.h b/src/core/hle/service/mii/mii_database_manager.h
new file mode 100644
index 00000000000..78a555a9d72
--- /dev/null
+++ b/src/core/hle/service/mii/mii_database_manager.h
@@ -0,0 +1,59 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#pragma once
+
+#include "common/fs/fs.h"
+#include "core/hle/result.h"
+#include "core/hle/service/mii/mii_database.h"
+
+namespace Service::Mii {
+class CharInfo;
+class StoreData;
+
+class DatabaseManager {
+public:
+    DatabaseManager();
+    Result MountSaveData();
+    Result Initialize(DatabaseSessionMetadata& metadata, bool& is_database_broken);
+
+    bool IsFullDatabase() const;
+    bool IsModified() const;
+    u64 GetUpdateCounter() const;
+
+    void Get(StoreData& out_store_data, std::size_t index,
+             const DatabaseSessionMetadata& metadata) const;
+    u32 GetCount(const DatabaseSessionMetadata& metadata) const;
+
+    Result FindIndex(s32& out_index, const Common::UUID& create_id, bool is_special) const;
+    Result FindIndex(const DatabaseSessionMetadata& metadata, u32& out_index,
+                     const Common::UUID& create_id) const;
+    Result FindMoveIndex(u32& out_index, u32 new_index, const Common::UUID& create_id) const;
+
+    Result Move(DatabaseSessionMetadata& metadata, u32 current_index,
+                const Common::UUID& create_id);
+    Result AddOrReplace(DatabaseSessionMetadata& metadata, const StoreData& out_store_data);
+    Result Delete(DatabaseSessionMetadata& metadata, const Common::UUID& create_id);
+    Result Append(DatabaseSessionMetadata& metadata, const CharInfo& char_info);
+
+    Result DestroyFile(DatabaseSessionMetadata& metadata);
+    Result DeleteFile();
+    void Format(DatabaseSessionMetadata& metadata);
+
+    Result SaveDatabase();
+
+private:
+    // This is the global value of
+    // nn::settings::fwdbg::GetSettingsItemValue("is_db_test_mode_enabled");
+    bool is_test_db{};
+
+    bool is_moddified{};
+    bool is_save_data_mounted{};
+    u64 update_counter{};
+    NintendoFigurineDatabase database{};
+
+    std::filesystem::path system_save_dir{};
+    const std::string DbFileName = "MiiDatabase.dat";
+};
+
+}; // namespace Service::Mii
diff --git a/src/core/hle/service/mii/mii_manager.cpp b/src/core/hle/service/mii/mii_manager.cpp
index 292d6377738..a5a2a923298 100644
--- a/src/core/hle/service/mii/mii_manager.cpp
+++ b/src/core/hle/service/mii/mii_manager.cpp
@@ -1,38 +1,63 @@
 // SPDX-FileCopyrightText: Copyright 2020 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include <cstring>
-#include <random>
-
-#include "common/assert.h"
 #include "common/logging/log.h"
-#include "common/string_util.h"
-
-#include "core/hle/service/acc/profile_manager.h"
+#include "core/hle/service/mii/mii_database_manager.h"
 #include "core/hle/service/mii/mii_manager.h"
 #include "core/hle/service/mii/mii_result.h"
 #include "core/hle/service/mii/mii_util.h"
+#include "core/hle/service/mii/types/char_info.h"
 #include "core/hle/service/mii/types/core_data.h"
 #include "core/hle/service/mii/types/raw_data.h"
+#include "core/hle/service/mii/types/store_data.h"
+#include "core/hle/service/mii/types/ver3_store_data.h"
 
 namespace Service::Mii {
 constexpr std::size_t DefaultMiiCount{RawData::DefaultMii.size()};
 
 MiiManager::MiiManager() {}
 
+Result MiiManager::Initialize(DatabaseSessionMetadata& metadata) {
+    database_manager.MountSaveData();
+    database_manager.Initialize(metadata, is_broken_with_clear_flag);
+    return ResultSuccess;
+}
+
+void MiiManager::BuildDefault(CharInfo& out_char_info, u32 index) const {
+    StoreData store_data{};
+    store_data.BuildDefault(index);
+    out_char_info.SetFromStoreData(store_data);
+}
+
+void MiiManager::BuildBase(CharInfo& out_char_info, Gender gender) const {
+    StoreData store_data{};
+    store_data.BuildBase(gender);
+    out_char_info.SetFromStoreData(store_data);
+}
+
+void MiiManager::BuildRandom(CharInfo& out_char_info, Age age, Gender gender, Race race) const {
+    StoreData store_data{};
+    store_data.BuildRandom(age, gender, race);
+    out_char_info.SetFromStoreData(store_data);
+}
+
+bool MiiManager::IsFullDatabase() const {
+    return database_manager.IsFullDatabase();
+}
+
+void MiiManager::SetInterfaceVersion(DatabaseSessionMetadata& metadata, u32 version) const {
+    metadata.interface_version = version;
+}
+
 bool MiiManager::IsUpdated(DatabaseSessionMetadata& metadata, SourceFlag source_flag) const {
     if ((source_flag & SourceFlag::Database) == SourceFlag::None) {
         return false;
     }
 
-    const auto metadata_update_counter = metadata.update_counter;
-    metadata.update_counter = update_counter;
-    return metadata_update_counter != update_counter;
-}
-
-bool MiiManager::IsFullDatabase() const {
-    // TODO(bunnei): We don't implement the Mii database, so it cannot be full
-    return false;
+    const u64 metadata_update_counter = metadata.update_counter;
+    const u64 database_update_counter = database_manager.GetUpdateCounter();
+    metadata.update_counter = database_update_counter;
+    return metadata_update_counter != database_update_counter;
 }
 
 u32 MiiManager::GetCount(const DatabaseSessionMetadata& metadata, SourceFlag source_flag) const {
@@ -41,72 +66,343 @@ u32 MiiManager::GetCount(const DatabaseSessionMetadata& metadata, SourceFlag sou
         mii_count += DefaultMiiCount;
     }
     if ((source_flag & SourceFlag::Database) != SourceFlag::None) {
-        // TODO(bunnei): We don't implement the Mii database, but when we do, update this
+        mii_count += database_manager.GetCount(metadata);
     }
     return mii_count;
 }
 
-Result MiiManager::UpdateLatest(DatabaseSessionMetadata& metadata, CharInfo& out_char_info,
-                                const CharInfo& char_info, SourceFlag source_flag) {
-    if ((source_flag & SourceFlag::Database) == SourceFlag::None) {
+Result MiiManager::Move(DatabaseSessionMetadata& metadata, u32 index,
+                        const Common::UUID& create_id) {
+    const auto result = database_manager.Move(metadata, index, create_id);
+
+    if (result.IsFailure()) {
+        return result;
+    }
+
+    if (!database_manager.IsModified()) {
+        return ResultNotUpdated;
+    }
+
+    return database_manager.SaveDatabase();
+}
+
+Result MiiManager::AddOrReplace(DatabaseSessionMetadata& metadata, const StoreData& store_data) {
+    const auto result = database_manager.AddOrReplace(metadata, store_data);
+
+    if (result.IsFailure()) {
+        return result;
+    }
+
+    if (!database_manager.IsModified()) {
+        return ResultNotUpdated;
+    }
+
+    return database_manager.SaveDatabase();
+}
+
+Result MiiManager::Delete(DatabaseSessionMetadata& metadata, const Common::UUID& create_id) {
+    const auto result = database_manager.Delete(metadata, create_id);
+
+    if (result.IsFailure()) {
+        return result;
+    }
+
+    if (!database_manager.IsModified()) {
+        return ResultNotUpdated;
+    }
+
+    return database_manager.SaveDatabase();
+}
+
+s32 MiiManager::FindIndex(const Common::UUID& create_id, bool is_special) const {
+    s32 index{};
+    const auto result = database_manager.FindIndex(index, create_id, is_special);
+    if (result.IsError()) {
+        index = -1;
+    }
+    return index;
+}
+
+Result MiiManager::GetIndex(const DatabaseSessionMetadata& metadata, const CharInfo& char_info,
+                            s32& out_index) const {
+    if (char_info.Verify() != ValidationResult::NoErrors) {
+        return ResultInvalidCharInfo;
+    }
+
+    s32 index{};
+    Result result = {};
+    // FindIndex(index);
+
+    if (result.IsError()) {
+        return ResultNotFound;
+    }
+
+    if (index == -1) {
         return ResultNotFound;
     }
 
-    // TODO(bunnei): We don't implement the Mii database, so we can't have an entry
-    return ResultNotFound;
+    out_index = index;
+    return ResultSuccess;
 }
 
-void MiiManager::BuildDefault(CharInfo& out_char_info, u32 index) const {
-    StoreData store_data{};
-    store_data.BuildDefault(index);
-    out_char_info.SetFromStoreData(store_data);
+Result MiiManager::Append(DatabaseSessionMetadata& metadata, const CharInfo& char_info) {
+    const auto result = database_manager.Append(metadata, char_info);
+
+    if (result.IsError()) {
+        return ResultNotFound;
+    }
+
+    if (!database_manager.IsModified()) {
+        return ResultNotUpdated;
+    }
+
+    return database_manager.SaveDatabase();
 }
 
-void MiiManager::BuildBase(CharInfo& out_char_info, Gender gender) const {
+bool MiiManager::IsBrokenWithClearFlag(DatabaseSessionMetadata& metadata) {
+    const bool is_broken = is_broken_with_clear_flag;
+    if (is_broken_with_clear_flag) {
+        is_broken_with_clear_flag = false;
+        database_manager.Format(metadata);
+        database_manager.SaveDatabase();
+    }
+    return is_broken;
+}
+
+Result MiiManager::DestroyFile(DatabaseSessionMetadata& metadata) {
+    is_broken_with_clear_flag = true;
+    return database_manager.DestroyFile(metadata);
+}
+
+Result MiiManager::DeleteFile() {
+    return database_manager.DeleteFile();
+}
+
+Result MiiManager::Format(DatabaseSessionMetadata& metadata) {
+    database_manager.Format(metadata);
+
+    if (!database_manager.IsModified()) {
+        return ResultNotUpdated;
+    }
+    return database_manager.SaveDatabase();
+}
+
+Result MiiManager::ConvertV3ToCharInfo(CharInfo& out_char_info, const Ver3StoreData& mii_v3) const {
+    if (!mii_v3.IsValid()) {
+        return ResultInvalidCharInfo;
+    }
+
     StoreData store_data{};
-    store_data.BuildBase(gender);
+    mii_v3.BuildToStoreData(store_data);
+    const auto name = store_data.GetNickname();
+    if (!MiiUtil::IsFontRegionValid(store_data.GetFontRegion(), name.data)) {
+        store_data.SetInvalidName();
+    }
+
     out_char_info.SetFromStoreData(store_data);
+    return ResultSuccess;
 }
 
-void MiiManager::BuildRandom(CharInfo& out_char_info, Age age, Gender gender, Race race) const {
+Result MiiManager::ConvertCoreDataToCharInfo(CharInfo& out_char_info,
+                                             const CoreData& core_data) const {
+    if (core_data.IsValid() != ValidationResult::NoErrors) {
+        return ResultInvalidCharInfo;
+    }
+
     StoreData store_data{};
-    store_data.BuildRandom(age, gender, race);
+    store_data.BuildWithCoreData(core_data);
+    const auto name = store_data.GetNickname();
+    if (!MiiUtil::IsFontRegionValid(store_data.GetFontRegion(), name.data)) {
+        store_data.SetInvalidName();
+    }
+
     out_char_info.SetFromStoreData(store_data);
+    return ResultSuccess;
+}
+
+Result MiiManager::ConvertCharInfoToCoreData(CoreData& out_core_data,
+                                             const CharInfo& char_info) const {
+    if (char_info.Verify() != ValidationResult::NoErrors) {
+        return ResultInvalidCharInfo;
+    }
+
+    out_core_data.BuildFromCharInfo(char_info);
+    const auto name = out_core_data.GetNickname();
+    if (!MiiUtil::IsFontRegionValid(out_core_data.GetFontRegion(), name.data)) {
+        out_core_data.SetNickname(out_core_data.GetInvalidNickname());
+    }
+
+    return ResultSuccess;
 }
 
-void MiiManager::ConvertV3ToCharInfo(CharInfo& out_char_info, const Ver3StoreData& mii_v3) const {
+Result MiiManager::UpdateLatest(const DatabaseSessionMetadata& metadata, CharInfo& out_char_info,
+                                const CharInfo& char_info, SourceFlag source_flag) const {
+    if ((source_flag & SourceFlag::Database) == SourceFlag::None) {
+        return ResultNotFound;
+    }
+
+    if (metadata.IsInterfaceVersionSupported(1)) {
+        if (char_info.Verify() != ValidationResult::NoErrors) {
+            return ResultInvalidCharInfo;
+        }
+    }
+
+    u32 index{};
+    Result result = database_manager.FindIndex(metadata, index, char_info.GetCreateId());
+
+    if (result.IsError()) {
+        return result;
+    }
+
     StoreData store_data{};
-    mii_v3.BuildToStoreData(store_data);
+    database_manager.Get(store_data, index, metadata);
+
+    if (store_data.GetType() != char_info.GetType()) {
+        return ResultNotFound;
+    }
+
     out_char_info.SetFromStoreData(store_data);
+
+    if (char_info == out_char_info) {
+        return ResultNotUpdated;
+    }
+
+    return ResultSuccess;
+}
+
+Result MiiManager::UpdateLatest(const DatabaseSessionMetadata& metadata, StoreData& out_store_data,
+                                const StoreData& store_data, SourceFlag source_flag) const {
+    if ((source_flag & SourceFlag::Database) == SourceFlag::None) {
+        return ResultNotFound;
+    }
+
+    if (metadata.IsInterfaceVersionSupported(1)) {
+        if (store_data.IsValid() != ValidationResult::NoErrors) {
+            return ResultInvalidCharInfo;
+        }
+    }
+
+    u32 index{};
+    Result result = database_manager.FindIndex(metadata, index, store_data.GetCreateId());
+
+    if (result.IsError()) {
+        return result;
+    }
+
+    database_manager.Get(out_store_data, index, metadata);
+
+    if (out_store_data.GetType() != store_data.GetType()) {
+        return ResultNotFound;
+    }
+
+    if (store_data == out_store_data) {
+        return ResultNotUpdated;
+    }
+
+    return ResultSuccess;
 }
 
 Result MiiManager::Get(const DatabaseSessionMetadata& metadata,
                        std::span<CharInfoElement> out_elements, u32& out_count,
-                       SourceFlag source_flag) {
+                       SourceFlag source_flag) const {
     if ((source_flag & SourceFlag::Database) == SourceFlag::None) {
         return BuildDefault(out_elements, out_count, source_flag);
     }
 
-    // TODO(bunnei): We don't implement the Mii database, so we can't have an entry
+    const auto mii_count = database_manager.GetCount(metadata);
+
+    for (std::size_t index = 0; index < mii_count; ++index) {
+        if (out_elements.size() <= static_cast<std::size_t>(out_count)) {
+            return ResultInvalidArgumentSize;
+        }
+
+        StoreData store_data{};
+        database_manager.Get(store_data, index, metadata);
+
+        out_elements[out_count].source = Source::Database;
+        out_elements[out_count].char_info.SetFromStoreData(store_data);
+        out_count++;
+    }
 
     // Include default Mii at the end of the list
     return BuildDefault(out_elements, out_count, source_flag);
 }
 
 Result MiiManager::Get(const DatabaseSessionMetadata& metadata, std::span<CharInfo> out_char_info,
-                       u32& out_count, SourceFlag source_flag) {
+                       u32& out_count, SourceFlag source_flag) const {
     if ((source_flag & SourceFlag::Database) == SourceFlag::None) {
         return BuildDefault(out_char_info, out_count, source_flag);
     }
 
-    // TODO(bunnei): We don't implement the Mii database, so we can't have an entry
+    const auto mii_count = database_manager.GetCount(metadata);
+
+    for (std::size_t index = 0; index < mii_count; ++index) {
+        if (out_char_info.size() <= static_cast<std::size_t>(out_count)) {
+            return ResultInvalidArgumentSize;
+        }
+
+        StoreData store_data{};
+        database_manager.Get(store_data, index, metadata);
+
+        out_char_info[out_count].SetFromStoreData(store_data);
+        out_count++;
+    }
 
     // Include default Mii at the end of the list
     return BuildDefault(out_char_info, out_count, source_flag);
 }
 
+Result MiiManager::Get(const DatabaseSessionMetadata& metadata,
+                       std::span<StoreDataElement> out_elements, u32& out_count,
+                       SourceFlag source_flag) const {
+    if ((source_flag & SourceFlag::Database) == SourceFlag::None) {
+        return BuildDefault(out_elements, out_count, source_flag);
+    }
+
+    const auto mii_count = database_manager.GetCount(metadata);
+
+    for (std::size_t index = 0; index < mii_count; ++index) {
+        if (out_elements.size() <= static_cast<std::size_t>(out_count)) {
+            return ResultInvalidArgumentSize;
+        }
+
+        StoreData store_data{};
+        database_manager.Get(store_data, index, metadata);
+
+        out_elements[out_count].store_data = store_data;
+        out_elements[out_count].source = Source::Database;
+        out_count++;
+    }
+
+    // Include default Mii at the end of the list
+    return BuildDefault(out_elements, out_count, source_flag);
+}
+
+Result MiiManager::Get(const DatabaseSessionMetadata& metadata, std::span<StoreData> out_store_data,
+                       u32& out_count, SourceFlag source_flag) const {
+    if ((source_flag & SourceFlag::Database) == SourceFlag::None) {
+        return BuildDefault(out_store_data, out_count, source_flag);
+    }
+
+    const auto mii_count = database_manager.GetCount(metadata);
+
+    for (std::size_t index = 0; index < mii_count; ++index) {
+        if (out_store_data.size() <= static_cast<std::size_t>(out_count)) {
+            return ResultInvalidArgumentSize;
+        }
+
+        StoreData store_data{};
+        database_manager.Get(store_data, index, metadata);
+
+        out_store_data[out_count] = store_data;
+        out_count++;
+    }
+
+    // Include default Mii at the end of the list
+    return BuildDefault(out_store_data, out_count, source_flag);
+}
 Result MiiManager::BuildDefault(std::span<CharInfoElement> out_elements, u32& out_count,
-                                SourceFlag source_flag) {
+                                SourceFlag source_flag) const {
     if ((source_flag & SourceFlag::Default) == SourceFlag::None) {
         return ResultSuccess;
     }
@@ -129,7 +425,7 @@ Result MiiManager::BuildDefault(std::span<CharInfoElement> out_elements, u32& ou
 }
 
 Result MiiManager::BuildDefault(std::span<CharInfo> out_char_info, u32& out_count,
-                                SourceFlag source_flag) {
+                                SourceFlag source_flag) const {
     if ((source_flag & SourceFlag::Default) == SourceFlag::None) {
         return ResultSuccess;
     }
@@ -150,23 +446,41 @@ Result MiiManager::BuildDefault(std::span<CharInfo> out_char_info, u32& out_coun
     return ResultSuccess;
 }
 
-Result MiiManager::GetIndex(const DatabaseSessionMetadata& metadata, const CharInfo& char_info,
-                            s32& out_index) {
-
-    if (char_info.Verify() != ValidationResult::NoErrors) {
-        return ResultInvalidCharInfo;
+Result MiiManager::BuildDefault(std::span<StoreDataElement> out_elements, u32& out_count,
+                                SourceFlag source_flag) const {
+    if ((source_flag & SourceFlag::Default) == SourceFlag::None) {
+        return ResultSuccess;
     }
 
-    constexpr u32 INVALID_INDEX{0xFFFFFFFF};
+    for (std::size_t index = 0; index < DefaultMiiCount; ++index) {
+        if (out_elements.size() <= static_cast<std::size_t>(out_count)) {
+            return ResultInvalidArgumentSize;
+        }
 
-    out_index = INVALID_INDEX;
+        out_elements[out_count].store_data.BuildDefault(static_cast<u32>(index));
+        out_elements[out_count].source = Source::Default;
+        out_count++;
+    }
 
-    // TODO(bunnei): We don't implement the Mii database, so we can't have an index
-    return ResultNotFound;
+    return ResultSuccess;
 }
 
-void MiiManager::SetInterfaceVersion(DatabaseSessionMetadata& metadata, u32 version) {
-    metadata.interface_version = version;
+Result MiiManager::BuildDefault(std::span<StoreData> out_char_info, u32& out_count,
+                                SourceFlag source_flag) const {
+    if ((source_flag & SourceFlag::Default) == SourceFlag::None) {
+        return ResultSuccess;
+    }
+
+    for (std::size_t index = 0; index < DefaultMiiCount; ++index) {
+        if (out_char_info.size() <= static_cast<std::size_t>(out_count)) {
+            return ResultInvalidArgumentSize;
+        }
+
+        out_char_info[out_count].BuildDefault(static_cast<u32>(index));
+        out_count++;
+    }
+
+    return ResultSuccess;
 }
 
 } // namespace Service::Mii
diff --git a/src/core/hle/service/mii/mii_manager.h b/src/core/hle/service/mii/mii_manager.h
index a2e7a6d7343..48d8e8bb7d6 100644
--- a/src/core/hle/service/mii/mii_manager.h
+++ b/src/core/hle/service/mii/mii_manager.h
@@ -3,47 +3,85 @@
 
 #pragma once
 
-#include <vector>
+#include <span>
 
 #include "core/hle/result.h"
+#include "core/hle/service/mii/mii_database_manager.h"
 #include "core/hle/service/mii/mii_types.h"
-#include "core/hle/service/mii/types/char_info.h"
-#include "core/hle/service/mii/types/store_data.h"
-#include "core/hle/service/mii/types/ver3_store_data.h"
 
 namespace Service::Mii {
+class CharInfo;
+class CoreData;
+class StoreData;
+class Ver3StoreData;
 
-// The Mii manager is responsible for loading and storing the Miis to the database in NAND along
-// with providing an easy interface for HLE emulation of the mii service.
+struct CharInfoElement;
+struct StoreDataElement;
+
+// The Mii manager is responsible for handling mii operations along with providing an easy interface
+// for HLE emulation of the mii service.
 class MiiManager {
 public:
     MiiManager();
+    Result Initialize(DatabaseSessionMetadata& metadata);
 
-    bool IsUpdated(DatabaseSessionMetadata& metadata, SourceFlag source_flag) const;
+    // Auto generated mii
+    void BuildDefault(CharInfo& out_char_info, u32 index) const;
+    void BuildBase(CharInfo& out_char_info, Gender gender) const;
+    void BuildRandom(CharInfo& out_char_info, Age age, Gender gender, Race race) const;
 
+    // Database operations
     bool IsFullDatabase() const;
+    void SetInterfaceVersion(DatabaseSessionMetadata& metadata, u32 version) const;
+    bool IsUpdated(DatabaseSessionMetadata& metadata, SourceFlag source_flag) const;
     u32 GetCount(const DatabaseSessionMetadata& metadata, SourceFlag source_flag) const;
-    Result UpdateLatest(DatabaseSessionMetadata& metadata, CharInfo& out_char_info,
-                        const CharInfo& char_info, SourceFlag source_flag);
+    Result Move(DatabaseSessionMetadata& metadata, u32 index, const Common::UUID& create_id);
+    Result AddOrReplace(DatabaseSessionMetadata& metadata, const StoreData& store_data);
+    Result Delete(DatabaseSessionMetadata& metadata, const Common::UUID& create_id);
+    s32 FindIndex(const Common::UUID& create_id, bool is_special) const;
+    Result GetIndex(const DatabaseSessionMetadata& metadata, const CharInfo& char_info,
+                    s32& out_index) const;
+    Result Append(DatabaseSessionMetadata& metadata, const CharInfo& char_info);
+
+    // Test database operations
+    bool IsBrokenWithClearFlag(DatabaseSessionMetadata& metadata);
+    Result DestroyFile(DatabaseSessionMetadata& metadata);
+    Result DeleteFile();
+    Result Format(DatabaseSessionMetadata& metadata);
+
+    // Mii conversions
+    Result ConvertV3ToCharInfo(CharInfo& out_char_info, const Ver3StoreData& mii_v3) const;
+    Result ConvertCoreDataToCharInfo(CharInfo& out_char_info, const CoreData& core_data) const;
+    Result ConvertCharInfoToCoreData(CoreData& out_core_data, const CharInfo& char_info) const;
+    Result UpdateLatest(const DatabaseSessionMetadata& metadata, CharInfo& out_char_info,
+                        const CharInfo& char_info, SourceFlag source_flag) const;
+    Result UpdateLatest(const DatabaseSessionMetadata& metadata, StoreData& out_store_data,
+                        const StoreData& store_data, SourceFlag source_flag) const;
+
+    // Overloaded getters
     Result Get(const DatabaseSessionMetadata& metadata, std::span<CharInfoElement> out_elements,
-               u32& out_count, SourceFlag source_flag);
+               u32& out_count, SourceFlag source_flag) const;
     Result Get(const DatabaseSessionMetadata& metadata, std::span<CharInfo> out_char_info,
-               u32& out_count, SourceFlag source_flag);
-    void BuildDefault(CharInfo& out_char_info, u32 index) const;
-    void BuildBase(CharInfo& out_char_info, Gender gender) const;
-    void BuildRandom(CharInfo& out_char_info, Age age, Gender gender, Race race) const;
-    void ConvertV3ToCharInfo(CharInfo& out_char_info, const Ver3StoreData& mii_v3) const;
-    std::vector<CharInfoElement> GetDefault(SourceFlag source_flag);
-    Result GetIndex(const DatabaseSessionMetadata& metadata, const CharInfo& char_info,
-                    s32& out_index);
-    void SetInterfaceVersion(DatabaseSessionMetadata& metadata, u32 version);
+               u32& out_count, SourceFlag source_flag) const;
+    Result Get(const DatabaseSessionMetadata& metadata, std::span<StoreDataElement> out_elements,
+               u32& out_count, SourceFlag source_flag) const;
+    Result Get(const DatabaseSessionMetadata& metadata, std::span<StoreData> out_store_data,
+               u32& out_count, SourceFlag source_flag) const;
 
 private:
     Result BuildDefault(std::span<CharInfoElement> out_elements, u32& out_count,
-                        SourceFlag source_flag);
-    Result BuildDefault(std::span<CharInfo> out_char_info, u32& out_count, SourceFlag source_flag);
+                        SourceFlag source_flag) const;
+    Result BuildDefault(std::span<CharInfo> out_char_info, u32& out_count,
+                        SourceFlag source_flag) const;
+    Result BuildDefault(std::span<StoreDataElement> out_char_info, u32& out_count,
+                        SourceFlag source_flag) const;
+    Result BuildDefault(std::span<StoreData> out_char_info, u32& out_count,
+                        SourceFlag source_flag) const;
+
+    DatabaseManager database_manager{};
 
-    u64 update_counter{};
+    // This should be a global value
+    bool is_broken_with_clear_flag{};
 };
 
 }; // namespace Service::Mii
diff --git a/src/core/hle/service/mii/mii_result.h b/src/core/hle/service/mii/mii_result.h
index 021cb76da25..e2c36e556d6 100644
--- a/src/core/hle/service/mii/mii_result.h
+++ b/src/core/hle/service/mii/mii_result.h
@@ -1,4 +1,4 @@
-// SPDX-FileCopyrightText: Copyright 2020 yuzu Emulator Project
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #pragma once
@@ -13,8 +13,15 @@ constexpr Result ResultNotUpdated{ErrorModule::Mii, 3};
 constexpr Result ResultNotFound{ErrorModule::Mii, 4};
 constexpr Result ResultDatabaseFull{ErrorModule::Mii, 5};
 constexpr Result ResultInvalidCharInfo{ErrorModule::Mii, 100};
+constexpr Result ResultInvalidDatabaseChecksum{ErrorModule::Mii, 101};
+constexpr Result ResultInvalidDatabaseSignature{ErrorModule::Mii, 103};
+constexpr Result ResultInvalidDatabaseVersion{ErrorModule::Mii, 104};
+constexpr Result ResultInvalidDatabaseLength{ErrorModule::Mii, 105};
+constexpr Result ResultInvalidCharInfo2{ErrorModule::Mii, 107};
 constexpr Result ResultInvalidStoreData{ErrorModule::Mii, 109};
 constexpr Result ResultInvalidOperation{ErrorModule::Mii, 202};
 constexpr Result ResultPermissionDenied{ErrorModule::Mii, 203};
+constexpr Result ResultTestModeOnly{ErrorModule::Mii, 204};
+constexpr Result ResultInvalidCharInfoType{ErrorModule::Mii, 205};
 
 }; // namespace Service::Mii
diff --git a/src/core/hle/service/mii/mii_types.h b/src/core/hle/service/mii/mii_types.h
index 611ff4f81a1..f43efd83cef 100644
--- a/src/core/hle/service/mii/mii_types.h
+++ b/src/core/hle/service/mii/mii_types.h
@@ -1,4 +1,4 @@
-// SPDX-FileCopyrightText: Copyright 2020 yuzu Emulator Project
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #pragma once
@@ -13,6 +13,7 @@
 
 namespace Service::Mii {
 
+constexpr std::size_t MaxNameSize = 10;
 constexpr u8 MaxHeight = 127;
 constexpr u8 MaxBuild = 127;
 constexpr u8 MaxType = 1;
@@ -26,14 +27,14 @@ constexpr u8 MaxEyebrowScale = 8;
 constexpr u8 MaxEyebrowAspect = 6;
 constexpr u8 MaxEyebrowRotate = 11;
 constexpr u8 MaxEyebrowX = 12;
-constexpr u8 MaxEyebrowY = 18;
+constexpr u8 MaxEyebrowY = 15;
 constexpr u8 MaxNoseScale = 8;
 constexpr u8 MaxNoseY = 18;
 constexpr u8 MaxMouthScale = 8;
 constexpr u8 MaxMoutAspect = 6;
 constexpr u8 MaxMouthY = 18;
 constexpr u8 MaxMustacheScale = 8;
-constexpr u8 MasMustacheY = 16;
+constexpr u8 MaxMustacheY = 16;
 constexpr u8 MaxGlassScale = 7;
 constexpr u8 MaxGlassY = 20;
 constexpr u8 MaxMoleScale = 8;
@@ -599,12 +600,12 @@ enum class ValidationResult : u32 {
     InvalidRegionMove = 0x31,
     InvalidCreateId = 0x32,
     InvalidName = 0x33,
+    InvalidChecksum = 0x34,
     InvalidType = 0x35,
 };
 
 struct Nickname {
-    static constexpr std::size_t MaxNameSize = 10;
-    std::array<char16_t, MaxNameSize> data;
+    std::array<char16_t, MaxNameSize> data{};
 
     // Checks for null or dirty strings
     bool IsValid() const {
diff --git a/src/core/hle/service/mii/mii_util.h b/src/core/hle/service/mii/mii_util.h
index ddb544c23d8..3534fa31d5b 100644
--- a/src/core/hle/service/mii/mii_util.h
+++ b/src/core/hle/service/mii/mii_util.h
@@ -28,6 +28,32 @@ class MiiUtil {
         return Common::swap16(static_cast<u16>(crc));
     }
 
+    static u16 CalculateDeviceCrc16(const Common::UUID& uuid, std::size_t data_size) {
+        constexpr u16 magic{0x1021};
+        s32 crc{};
+
+        for (std::size_t i = 0; i < uuid.uuid.size(); i++) {
+            for (std::size_t j = 0; j < 8; j++) {
+                crc <<= 1;
+                if ((crc & 0x10000) != 0) {
+                    crc = crc ^ magic;
+                }
+            }
+            crc ^= uuid.uuid[i];
+        }
+
+        // As much as this looks wrong this is what N's does
+
+        for (std::size_t i = 0; i < data_size * 8; i++) {
+            crc <<= 1;
+            if ((crc & 0x10000) != 0) {
+                crc = crc ^ magic;
+            }
+        }
+
+        return Common::swap16(static_cast<u16>(crc));
+    }
+
     static Common::UUID MakeCreateId() {
         return Common::UUID::MakeRandomRFC4122V4();
     }
diff --git a/src/core/hle/service/mii/types/char_info.cpp b/src/core/hle/service/mii/types/char_info.cpp
index bb948c62815..e90124af4ca 100644
--- a/src/core/hle/service/mii/types/char_info.cpp
+++ b/src/core/hle/service/mii/types/char_info.cpp
@@ -37,7 +37,7 @@ void CharInfo::SetFromStoreData(const StoreData& store_data) {
     eyebrow_aspect = store_data.GetEyebrowAspect();
     eyebrow_rotate = store_data.GetEyebrowRotate();
     eyebrow_x = store_data.GetEyebrowX();
-    eyebrow_y = store_data.GetEyebrowY();
+    eyebrow_y = store_data.GetEyebrowY() + 3;
     nose_type = store_data.GetNoseType();
     nose_scale = store_data.GetNoseScale();
     nose_y = store_data.GetNoseY();
@@ -150,7 +150,7 @@ ValidationResult CharInfo::Verify() const {
     if (eyebrow_x > MaxEyebrowX) {
         return ValidationResult::InvalidEyebrowX;
     }
-    if (eyebrow_y > MaxEyebrowY) {
+    if (eyebrow_y - 3 > MaxEyebrowY) {
         return ValidationResult::InvalidEyebrowY;
     }
     if (nose_type > NoseType::Max) {
@@ -189,7 +189,7 @@ ValidationResult CharInfo::Verify() const {
     if (mustache_scale > MaxMustacheScale) {
         return ValidationResult::InvalidMustacheScale;
     }
-    if (mustache_y > MasMustacheY) {
+    if (mustache_y > MaxMustacheY) {
         return ValidationResult::InvalidMustacheY;
     }
     if (glass_type > GlassType::Max) {
diff --git a/src/core/hle/service/mii/types/char_info.h b/src/core/hle/service/mii/types/char_info.h
index d069b221f54..d0c457fd566 100644
--- a/src/core/hle/service/mii/types/char_info.h
+++ b/src/core/hle/service/mii/types/char_info.h
@@ -70,59 +70,59 @@ class CharInfo {
     bool operator==(const CharInfo& info);
 
 private:
-    Common::UUID create_id;
-    Nickname name;
-    u16 null_terminator;
-    FontRegion font_region;
-    FavoriteColor favorite_color;
-    Gender gender;
-    u8 height;
-    u8 build;
-    u8 type;
-    u8 region_move;
-    FacelineType faceline_type;
-    FacelineColor faceline_color;
-    FacelineWrinkle faceline_wrinkle;
-    FacelineMake faceline_make;
-    HairType hair_type;
-    CommonColor hair_color;
-    HairFlip hair_flip;
-    EyeType eye_type;
-    CommonColor eye_color;
-    u8 eye_scale;
-    u8 eye_aspect;
-    u8 eye_rotate;
-    u8 eye_x;
-    u8 eye_y;
-    EyebrowType eyebrow_type;
-    CommonColor eyebrow_color;
-    u8 eyebrow_scale;
-    u8 eyebrow_aspect;
-    u8 eyebrow_rotate;
-    u8 eyebrow_x;
-    u8 eyebrow_y;
-    NoseType nose_type;
-    u8 nose_scale;
-    u8 nose_y;
-    MouthType mouth_type;
-    CommonColor mouth_color;
-    u8 mouth_scale;
-    u8 mouth_aspect;
-    u8 mouth_y;
-    CommonColor beard_color;
-    BeardType beard_type;
-    MustacheType mustache_type;
-    u8 mustache_scale;
-    u8 mustache_y;
-    GlassType glass_type;
-    CommonColor glass_color;
-    u8 glass_scale;
-    u8 glass_y;
-    MoleType mole_type;
-    u8 mole_scale;
-    u8 mole_x;
-    u8 mole_y;
-    u8 padding;
+    Common::UUID create_id{};
+    Nickname name{};
+    u16 null_terminator{};
+    FontRegion font_region{};
+    FavoriteColor favorite_color{};
+    Gender gender{};
+    u8 height{};
+    u8 build{};
+    u8 type{};
+    u8 region_move{};
+    FacelineType faceline_type{};
+    FacelineColor faceline_color{};
+    FacelineWrinkle faceline_wrinkle{};
+    FacelineMake faceline_make{};
+    HairType hair_type{};
+    CommonColor hair_color{};
+    HairFlip hair_flip{};
+    EyeType eye_type{};
+    CommonColor eye_color{};
+    u8 eye_scale{};
+    u8 eye_aspect{};
+    u8 eye_rotate{};
+    u8 eye_x{};
+    u8 eye_y{};
+    EyebrowType eyebrow_type{};
+    CommonColor eyebrow_color{};
+    u8 eyebrow_scale{};
+    u8 eyebrow_aspect{};
+    u8 eyebrow_rotate{};
+    u8 eyebrow_x{};
+    u8 eyebrow_y{};
+    NoseType nose_type{};
+    u8 nose_scale{};
+    u8 nose_y{};
+    MouthType mouth_type{};
+    CommonColor mouth_color{};
+    u8 mouth_scale{};
+    u8 mouth_aspect{};
+    u8 mouth_y{};
+    CommonColor beard_color{};
+    BeardType beard_type{};
+    MustacheType mustache_type{};
+    u8 mustache_scale{};
+    u8 mustache_y{};
+    GlassType glass_type{};
+    CommonColor glass_color{};
+    u8 glass_scale{};
+    u8 glass_y{};
+    MoleType mole_type{};
+    u8 mole_scale{};
+    u8 mole_x{};
+    u8 mole_y{};
+    u8 padding{};
 };
 static_assert(sizeof(CharInfo) == 0x58, "CharInfo has incorrect size.");
 static_assert(std::has_unique_object_representations_v<CharInfo>,
diff --git a/src/core/hle/service/mii/types/core_data.cpp b/src/core/hle/service/mii/types/core_data.cpp
index 659288b5122..465c6293ab2 100644
--- a/src/core/hle/service/mii/types/core_data.cpp
+++ b/src/core/hle/service/mii/types/core_data.cpp
@@ -3,6 +3,7 @@
 
 #include "common/assert.h"
 #include "core/hle/service/mii/mii_util.h"
+#include "core/hle/service/mii/types/char_info.h"
 #include "core/hle/service/mii/types/core_data.h"
 #include "core/hle/service/mii/types/raw_data.h"
 
@@ -185,9 +186,211 @@ void CoreData::BuildRandom(Age age, Gender gender, Race race) {
     SetMoleY(20);
 }
 
-u32 CoreData::IsValid() const {
-    // TODO: Complete this
-    return 0;
+void CoreData::BuildFromCharInfo(const CharInfo& char_info) {
+    name = char_info.GetNickname();
+    SetFontRegion(char_info.GetFontRegion());
+    SetFavoriteColor(char_info.GetFavoriteColor());
+    SetGender(char_info.GetGender());
+    SetHeight(char_info.GetHeight());
+    SetBuild(char_info.GetBuild());
+    SetType(char_info.GetType());
+    SetRegionMove(char_info.GetRegionMove());
+    SetFacelineType(char_info.GetFacelineType());
+    SetFacelineColor(char_info.GetFacelineColor());
+    SetFacelineWrinkle(char_info.GetFacelineWrinkle());
+    SetFacelineMake(char_info.GetFacelineMake());
+    SetHairType(char_info.GetHairType());
+    SetHairColor(char_info.GetHairColor());
+    SetHairFlip(char_info.GetHairFlip());
+    SetEyeType(char_info.GetEyeType());
+    SetEyeColor(char_info.GetEyeColor());
+    SetEyeScale(char_info.GetEyeScale());
+    SetEyeAspect(char_info.GetEyeAspect());
+    SetEyeRotate(char_info.GetEyeRotate());
+    SetEyeX(char_info.GetEyeX());
+    SetEyeY(char_info.GetEyeY());
+    SetEyebrowType(char_info.GetEyebrowType());
+    SetEyebrowColor(char_info.GetEyebrowColor());
+    SetEyebrowScale(char_info.GetEyebrowScale());
+    SetEyebrowAspect(char_info.GetEyebrowAspect());
+    SetEyebrowRotate(char_info.GetEyebrowRotate());
+    SetEyebrowX(char_info.GetEyebrowX());
+    SetEyebrowY(char_info.GetEyebrowY() - 3);
+    SetNoseType(char_info.GetNoseType());
+    SetNoseScale(char_info.GetNoseScale());
+    SetNoseY(char_info.GetNoseY());
+    SetMouthType(char_info.GetMouthType());
+    SetMouthColor(char_info.GetMouthColor());
+    SetMouthScale(char_info.GetMouthScale());
+    SetMouthAspect(char_info.GetMouthAspect());
+    SetMouthY(char_info.GetMouthY());
+    SetBeardColor(char_info.GetBeardColor());
+    SetBeardType(char_info.GetBeardType());
+    SetMustacheType(char_info.GetMustacheType());
+    SetMustacheScale(char_info.GetMustacheScale());
+    SetMustacheY(char_info.GetMustacheY());
+    SetGlassType(char_info.GetGlassType());
+    SetGlassColor(char_info.GetGlassColor());
+    SetGlassScale(char_info.GetGlassScale());
+    SetGlassY(char_info.GetGlassY());
+    SetMoleType(char_info.GetMoleType());
+    SetMoleScale(char_info.GetMoleScale());
+    SetMoleX(char_info.GetMoleX());
+    SetMoleY(char_info.GetMoleY());
+}
+
+ValidationResult CoreData::IsValid() const {
+    if (!name.IsValid()) {
+        return ValidationResult::InvalidName;
+    }
+    if (GetFontRegion() > FontRegion::Max) {
+        return ValidationResult::InvalidFont;
+    }
+    if (GetFavoriteColor() > FavoriteColor::Max) {
+        return ValidationResult::InvalidColor;
+    }
+    if (GetGender() > Gender::Max) {
+        return ValidationResult::InvalidGender;
+    }
+    if (GetHeight() > MaxHeight) {
+        return ValidationResult::InvalidHeight;
+    }
+    if (GetBuild() > MaxBuild) {
+        return ValidationResult::InvalidBuild;
+    }
+    if (GetType() > MaxType) {
+        return ValidationResult::InvalidType;
+    }
+    if (GetRegionMove() > MaxRegionMove) {
+        return ValidationResult::InvalidRegionMove;
+    }
+    if (GetFacelineType() > FacelineType::Max) {
+        return ValidationResult::InvalidFacelineType;
+    }
+    if (GetFacelineColor() > FacelineColor::Max) {
+        return ValidationResult::InvalidFacelineColor;
+    }
+    if (GetFacelineWrinkle() > FacelineWrinkle::Max) {
+        return ValidationResult::InvalidFacelineWrinkle;
+    }
+    if (GetFacelineMake() > FacelineMake::Max) {
+        return ValidationResult::InvalidFacelineMake;
+    }
+    if (GetHairType() > HairType::Max) {
+        return ValidationResult::InvalidHairType;
+    }
+    if (GetHairColor() > CommonColor::Max) {
+        return ValidationResult::InvalidHairColor;
+    }
+    if (GetHairFlip() > HairFlip::Max) {
+        return ValidationResult::InvalidHairFlip;
+    }
+    if (GetEyeType() > EyeType::Max) {
+        return ValidationResult::InvalidEyeType;
+    }
+    if (GetEyeColor() > CommonColor::Max) {
+        return ValidationResult::InvalidEyeColor;
+    }
+    if (GetEyeScale() > MaxEyeScale) {
+        return ValidationResult::InvalidEyeScale;
+    }
+    if (GetEyeAspect() > MaxEyeAspect) {
+        return ValidationResult::InvalidEyeAspect;
+    }
+    if (GetEyeRotate() > MaxEyeRotate) {
+        return ValidationResult::InvalidEyeRotate;
+    }
+    if (GetEyeX() > MaxEyeX) {
+        return ValidationResult::InvalidEyeX;
+    }
+    if (GetEyeY() > MaxEyeY) {
+        return ValidationResult::InvalidEyeY;
+    }
+    if (GetEyebrowType() > EyebrowType::Max) {
+        return ValidationResult::InvalidEyebrowType;
+    }
+    if (GetEyebrowColor() > CommonColor::Max) {
+        return ValidationResult::InvalidEyebrowColor;
+    }
+    if (GetEyebrowScale() > MaxEyebrowScale) {
+        return ValidationResult::InvalidEyebrowScale;
+    }
+    if (GetEyebrowAspect() > MaxEyebrowAspect) {
+        return ValidationResult::InvalidEyebrowAspect;
+    }
+    if (GetEyebrowRotate() > MaxEyebrowRotate) {
+        return ValidationResult::InvalidEyebrowRotate;
+    }
+    if (GetEyebrowX() > MaxEyebrowX) {
+        return ValidationResult::InvalidEyebrowX;
+    }
+    if (GetEyebrowY() > MaxEyebrowY) {
+        return ValidationResult::InvalidEyebrowY;
+    }
+    if (GetNoseType() > NoseType::Max) {
+        return ValidationResult::InvalidNoseType;
+    }
+    if (GetNoseScale() > MaxNoseScale) {
+        return ValidationResult::InvalidNoseScale;
+    }
+    if (GetNoseY() > MaxNoseY) {
+        return ValidationResult::InvalidNoseY;
+    }
+    if (GetMouthType() > MouthType::Max) {
+        return ValidationResult::InvalidMouthType;
+    }
+    if (GetMouthColor() > CommonColor::Max) {
+        return ValidationResult::InvalidMouthColor;
+    }
+    if (GetMouthScale() > MaxMouthScale) {
+        return ValidationResult::InvalidMouthScale;
+    }
+    if (GetMouthAspect() > MaxMoutAspect) {
+        return ValidationResult::InvalidMouthAspect;
+    }
+    if (GetMouthY() > MaxMouthY) {
+        return ValidationResult::InvalidMouthY;
+    }
+    if (GetBeardColor() > CommonColor::Max) {
+        return ValidationResult::InvalidBeardColor;
+    }
+    if (GetBeardType() > BeardType::Max) {
+        return ValidationResult::InvalidBeardType;
+    }
+    if (GetMustacheType() > MustacheType::Max) {
+        return ValidationResult::InvalidMustacheType;
+    }
+    if (GetMustacheScale() > MaxMustacheScale) {
+        return ValidationResult::InvalidMustacheScale;
+    }
+    if (GetMustacheY() > MaxMustacheY) {
+        return ValidationResult::InvalidMustacheY;
+    }
+    if (GetGlassType() > GlassType::Max) {
+        return ValidationResult::InvalidGlassType;
+    }
+    if (GetGlassColor() > CommonColor::Max) {
+        return ValidationResult::InvalidGlassColor;
+    }
+    if (GetGlassScale() > MaxGlassScale) {
+        return ValidationResult::InvalidGlassScale;
+    }
+    if (GetGlassY() > MaxGlassY) {
+        return ValidationResult::InvalidGlassY;
+    }
+    if (GetMoleType() > MoleType::Max) {
+        return ValidationResult::InvalidMoleType;
+    }
+    if (GetMoleScale() > MaxMoleScale) {
+        return ValidationResult::InvalidMoleScale;
+    }
+    if (GetMoleX() > MaxMoleX) {
+        return ValidationResult::InvalidMoleX;
+    }
+    if (GetMoleY() > MaxMoleY) {
+        return ValidationResult::InvalidMoleY;
+    }
+    return ValidationResult::NoErrors;
 }
 
 void CoreData::SetFontRegion(FontRegion value) {
@@ -314,8 +517,8 @@ void CoreData::SetNoseY(u8 value) {
     data.nose_y.Assign(value);
 }
 
-void CoreData::SetMouthType(u8 value) {
-    data.mouth_type.Assign(value);
+void CoreData::SetMouthType(MouthType value) {
+    data.mouth_type.Assign(static_cast<u32>(value));
 }
 
 void CoreData::SetMouthColor(CommonColor value) {
diff --git a/src/core/hle/service/mii/types/core_data.h b/src/core/hle/service/mii/types/core_data.h
index cebcd2ee442..8897e4f3b32 100644
--- a/src/core/hle/service/mii/types/core_data.h
+++ b/src/core/hle/service/mii/types/core_data.h
@@ -6,6 +6,7 @@
 #include "core/hle/service/mii/mii_types.h"
 
 namespace Service::Mii {
+class CharInfo;
 
 struct StoreDataBitFields {
     union {
@@ -100,8 +101,9 @@ class CoreData {
 public:
     void SetDefault();
     void BuildRandom(Age age, Gender gender, Race race);
+    void BuildFromCharInfo(const CharInfo& char_info);
 
-    u32 IsValid() const;
+    ValidationResult IsValid() const;
 
     void SetFontRegion(FontRegion value);
     void SetFavoriteColor(FavoriteColor value);
@@ -134,7 +136,7 @@ class CoreData {
     void SetNoseType(NoseType value);
     void SetNoseScale(u8 value);
     void SetNoseY(u8 value);
-    void SetMouthType(u8 value);
+    void SetMouthType(MouthType value);
     void SetMouthColor(CommonColor value);
     void SetMouthScale(u8 value);
     void SetMouthAspect(u8 value);
@@ -212,5 +214,6 @@ class CoreData {
     Nickname name{};
 };
 static_assert(sizeof(CoreData) == 0x30, "CoreData has incorrect size.");
+static_assert(std::is_trivially_copyable_v<CoreData>, "CoreData type must be trivially copyable.");
 
 }; // namespace Service::Mii
diff --git a/src/core/hle/service/mii/types/store_data.cpp b/src/core/hle/service/mii/types/store_data.cpp
index 8fce636c7b6..127221fdb61 100644
--- a/src/core/hle/service/mii/types/store_data.cpp
+++ b/src/core/hle/service/mii/types/store_data.cpp
@@ -1,6 +1,7 @@
 // SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#include "core/hle/service/mii/mii_result.h"
 #include "core/hle/service/mii/mii_util.h"
 #include "core/hle/service/mii/types/raw_data.h"
 #include "core/hle/service/mii/types/store_data.h"
@@ -35,13 +36,13 @@ void StoreData::BuildDefault(u32 mii_index) {
     core_data.SetEyebrowAspect(static_cast<u8>(default_mii.eyebrow_aspect));
     core_data.SetEyebrowRotate(static_cast<u8>(default_mii.eyebrow_rotate));
     core_data.SetEyebrowX(static_cast<u8>(default_mii.eyebrow_x));
-    core_data.SetEyebrowY(static_cast<u8>(default_mii.eyebrow_y));
+    core_data.SetEyebrowY(static_cast<u8>(default_mii.eyebrow_y - 3));
 
     core_data.SetNoseType(static_cast<NoseType>(default_mii.nose_type));
     core_data.SetNoseScale(static_cast<u8>(default_mii.nose_scale));
     core_data.SetNoseY(static_cast<u8>(default_mii.nose_y));
 
-    core_data.SetMouthType(static_cast<u8>(default_mii.mouth_type));
+    core_data.SetMouthType(static_cast<MouthType>(default_mii.mouth_type));
     core_data.SetMouthColor(
         RawData::GetMouthColorFromVer3(static_cast<u8>(default_mii.mouth_color)));
     core_data.SetMouthScale(static_cast<u8>(default_mii.mouth_scale));
@@ -75,10 +76,8 @@ void StoreData::BuildDefault(u32 mii_index) {
     core_data.SetType(static_cast<u8>(default_mii.type));
     core_data.SetNickname(default_mii.nickname);
 
-    const auto device_id = MiiUtil::GetDeviceId();
     create_id = MiiUtil::MakeCreateId();
-    device_crc = MiiUtil::CalculateCrc16(&device_id, sizeof(Common::UUID));
-    data_crc = MiiUtil::CalculateCrc16(&core_data, sizeof(CoreData));
+    SetChecksum();
 }
 
 void StoreData::BuildBase(Gender gender) {
@@ -109,13 +108,13 @@ void StoreData::BuildBase(Gender gender) {
     core_data.SetEyebrowAspect(static_cast<u8>(default_mii.eyebrow_aspect));
     core_data.SetEyebrowRotate(static_cast<u8>(default_mii.eyebrow_rotate));
     core_data.SetEyebrowX(static_cast<u8>(default_mii.eyebrow_x));
-    core_data.SetEyebrowY(static_cast<u8>(default_mii.eyebrow_y));
+    core_data.SetEyebrowY(static_cast<u8>(default_mii.eyebrow_y - 3));
 
     core_data.SetNoseType(static_cast<NoseType>(default_mii.nose_type));
     core_data.SetNoseScale(static_cast<u8>(default_mii.nose_scale));
     core_data.SetNoseY(static_cast<u8>(default_mii.nose_y));
 
-    core_data.SetMouthType(static_cast<u8>(default_mii.mouth_type));
+    core_data.SetMouthType(static_cast<MouthType>(default_mii.mouth_type));
     core_data.SetMouthColor(
         RawData::GetMouthColorFromVer3(static_cast<u8>(default_mii.mouth_color)));
     core_data.SetMouthScale(static_cast<u8>(default_mii.mouth_scale));
@@ -149,37 +148,51 @@ void StoreData::BuildBase(Gender gender) {
     core_data.SetType(static_cast<u8>(default_mii.type));
     core_data.SetNickname(default_mii.nickname);
 
-    const auto device_id = MiiUtil::GetDeviceId();
     create_id = MiiUtil::MakeCreateId();
-    device_crc = MiiUtil::CalculateCrc16(&device_id, sizeof(Common::UUID));
-    data_crc = MiiUtil::CalculateCrc16(&core_data, sizeof(CoreData));
+    SetChecksum();
 }
 
 void StoreData::BuildRandom(Age age, Gender gender, Race race) {
     core_data.BuildRandom(age, gender, race);
-    const auto device_id = MiiUtil::GetDeviceId();
     create_id = MiiUtil::MakeCreateId();
-    device_crc = MiiUtil::CalculateCrc16(&device_id, sizeof(Common::UUID));
-    data_crc = MiiUtil::CalculateCrc16(&core_data, sizeof(CoreData));
+    SetChecksum();
 }
 
-void StoreData::SetInvalidName() {
-    const auto& invalid_name = core_data.GetInvalidNickname();
+void StoreData::BuildWithCharInfo(const CharInfo& char_info) {
+    core_data.BuildFromCharInfo(char_info);
+    create_id = MiiUtil::MakeCreateId();
+    SetChecksum();
+}
+
+void StoreData::BuildWithCoreData(const CoreData& in_core_data) {
+    core_data = in_core_data;
+    create_id = MiiUtil::MakeCreateId();
+    SetChecksum();
+}
+
+Result StoreData::Restore() {
+    // TODO: Implement this
+    return ResultNotUpdated;
+}
+
+ValidationResult StoreData::IsValid() const {
+    if (core_data.IsValid() != ValidationResult::NoErrors) {
+        return core_data.IsValid();
+    }
+    if (data_crc != MiiUtil::CalculateCrc16(&core_data, sizeof(CoreData) + sizeof(Common::UUID))) {
+        return ValidationResult::InvalidChecksum;
+    }
     const auto device_id = MiiUtil::GetDeviceId();
-    core_data.SetNickname(invalid_name);
-    device_crc = MiiUtil::CalculateCrc16(&device_id, sizeof(Common::UUID));
-    data_crc = MiiUtil::CalculateCrc16(&core_data, sizeof(CoreData));
+    if (device_crc != MiiUtil::CalculateDeviceCrc16(device_id, sizeof(StoreData))) {
+        return ValidationResult::InvalidChecksum;
+    }
+    return ValidationResult::NoErrors;
 }
 
 bool StoreData::IsSpecial() const {
     return GetType() == 1;
 }
 
-u32 StoreData::IsValid() const {
-    // TODO: complete this
-    return 0;
-}
-
 void StoreData::SetFontRegion(FontRegion value) {
     core_data.SetFontRegion(value);
 }
@@ -304,7 +317,7 @@ void StoreData::SetNoseY(u8 value) {
     core_data.SetNoseY(value);
 }
 
-void StoreData::SetMouthType(u8 value) {
+void StoreData::SetMouthType(MouthType value) {
     core_data.SetMouthType(value);
 }
 
@@ -380,6 +393,26 @@ void StoreData::SetNickname(Nickname value) {
     core_data.SetNickname(value);
 }
 
+void StoreData::SetInvalidName() {
+    const auto& invalid_name = core_data.GetInvalidNickname();
+    core_data.SetNickname(invalid_name);
+    SetChecksum();
+}
+
+void StoreData::SetChecksum() {
+    SetDataChecksum();
+    SetDeviceChecksum();
+}
+
+void StoreData::SetDataChecksum() {
+    data_crc = MiiUtil::CalculateCrc16(&core_data, sizeof(CoreData) + sizeof(Common::UUID));
+}
+
+void StoreData::SetDeviceChecksum() {
+    const auto device_id = MiiUtil::GetDeviceId();
+    device_crc = MiiUtil::CalculateDeviceCrc16(device_id, sizeof(StoreData));
+}
+
 Common::UUID StoreData::GetCreateId() const {
     return create_id;
 }
@@ -585,7 +618,7 @@ Nickname StoreData::GetNickname() const {
 }
 
 bool StoreData::operator==(const StoreData& data) {
-    bool is_identical = data.core_data.IsValid() == 0;
+    bool is_identical = data.core_data.IsValid() == ValidationResult::NoErrors;
     is_identical &= core_data.GetNickname().data == data.core_data.GetNickname().data;
     is_identical &= GetCreateId() == data.GetCreateId();
     is_identical &= GetFontRegion() == data.GetFontRegion();
diff --git a/src/core/hle/service/mii/types/store_data.h b/src/core/hle/service/mii/types/store_data.h
index 224c32cf8ef..ed5dfb94947 100644
--- a/src/core/hle/service/mii/types/store_data.h
+++ b/src/core/hle/service/mii/types/store_data.h
@@ -3,6 +3,7 @@
 
 #pragma once
 
+#include "core/hle/result.h"
 #include "core/hle/service/mii/mii_types.h"
 #include "core/hle/service/mii/types/core_data.h"
 
@@ -10,17 +11,16 @@ namespace Service::Mii {
 
 class StoreData {
 public:
-    // nn::mii::detail::StoreDataRaw::BuildDefault
     void BuildDefault(u32 mii_index);
-    // nn::mii::detail::StoreDataRaw::BuildDefault
-
     void BuildBase(Gender gender);
-    // nn::mii::detail::StoreDataRaw::BuildRandom
     void BuildRandom(Age age, Gender gender, Race race);
+    void BuildWithCharInfo(const CharInfo& char_info);
+    void BuildWithCoreData(const CoreData& in_core_data);
+    Result Restore();
 
-    bool IsSpecial() const;
+    ValidationResult IsValid() const;
 
-    u32 IsValid() const;
+    bool IsSpecial() const;
 
     void SetFontRegion(FontRegion value);
     void SetFavoriteColor(FavoriteColor value);
@@ -53,7 +53,7 @@ class StoreData {
     void SetNoseType(NoseType value);
     void SetNoseScale(u8 value);
     void SetNoseY(u8 value);
-    void SetMouthType(u8 value);
+    void SetMouthType(MouthType value);
     void SetMouthColor(CommonColor value);
     void SetMouthScale(u8 value);
     void SetMouthAspect(u8 value);
@@ -73,6 +73,9 @@ class StoreData {
     void SetMoleY(u8 value);
     void SetNickname(Nickname nickname);
     void SetInvalidName();
+    void SetChecksum();
+    void SetDataChecksum();
+    void SetDeviceChecksum();
 
     Common::UUID GetCreateId() const;
     FontRegion GetFontRegion() const;
@@ -135,6 +138,8 @@ class StoreData {
     u16 device_crc{};
 };
 static_assert(sizeof(StoreData) == 0x44, "StoreData has incorrect size.");
+static_assert(std::is_trivially_copyable_v<StoreData>,
+              "StoreData type must be trivially copyable.");
 
 struct StoreDataElement {
     StoreData store_data{};
diff --git a/src/core/hle/service/mii/types/ver3_store_data.cpp b/src/core/hle/service/mii/types/ver3_store_data.cpp
index 1c28e0b1b5d..a019cc9f719 100644
--- a/src/core/hle/service/mii/types/ver3_store_data.cpp
+++ b/src/core/hle/service/mii/types/ver3_store_data.cpp
@@ -22,12 +22,6 @@ void NfpStoreDataExtension::SetFromStoreData(const StoreData& store_data) {
 void Ver3StoreData::BuildToStoreData(StoreData& out_store_data) const {
     out_store_data.BuildBase(Gender::Male);
 
-    if (!IsValid()) {
-        return;
-    }
-
-    // TODO: We are ignoring a bunch of data from the mii_v3
-
     out_store_data.SetGender(static_cast<Gender>(mii_information.gender.Value()));
     out_store_data.SetFavoriteColor(
         static_cast<FavoriteColor>(mii_information.favorite_color.Value()));
@@ -36,65 +30,71 @@ void Ver3StoreData::BuildToStoreData(StoreData& out_store_data) const {
 
     out_store_data.SetNickname(mii_name);
     out_store_data.SetFontRegion(
-        static_cast<FontRegion>(static_cast<u8>(region_information.font_region)));
+        static_cast<FontRegion>(static_cast<u8>(region_information.font_region.Value())));
 
     out_store_data.SetFacelineType(
         static_cast<FacelineType>(appearance_bits1.faceline_type.Value()));
     out_store_data.SetFacelineColor(
-        static_cast<FacelineColor>(appearance_bits1.faceline_color.Value()));
+        RawData::GetFacelineColorFromVer3(appearance_bits1.faceline_color.Value()));
     out_store_data.SetFacelineWrinkle(
         static_cast<FacelineWrinkle>(appearance_bits2.faceline_wrinkle.Value()));
     out_store_data.SetFacelineMake(
         static_cast<FacelineMake>(appearance_bits2.faceline_make.Value()));
 
     out_store_data.SetHairType(static_cast<HairType>(hair_type));
-    out_store_data.SetHairColor(static_cast<CommonColor>(appearance_bits3.hair_color.Value()));
+    out_store_data.SetHairColor(RawData::GetHairColorFromVer3(appearance_bits3.hair_color.Value()));
     out_store_data.SetHairFlip(static_cast<HairFlip>(appearance_bits3.hair_flip.Value()));
 
     out_store_data.SetEyeType(static_cast<EyeType>(appearance_bits4.eye_type.Value()));
-    out_store_data.SetEyeColor(static_cast<CommonColor>(appearance_bits4.eye_color.Value()));
-    out_store_data.SetEyeScale(static_cast<u8>(appearance_bits4.eye_scale));
-    out_store_data.SetEyeAspect(static_cast<u8>(appearance_bits4.eye_aspect));
-    out_store_data.SetEyeRotate(static_cast<u8>(appearance_bits4.eye_rotate));
-    out_store_data.SetEyeX(static_cast<u8>(appearance_bits4.eye_x));
-    out_store_data.SetEyeY(static_cast<u8>(appearance_bits4.eye_y));
+    out_store_data.SetEyeColor(RawData::GetEyeColorFromVer3(appearance_bits4.eye_color.Value()));
+    out_store_data.SetEyeScale(static_cast<u8>(appearance_bits4.eye_scale.Value()));
+    out_store_data.SetEyeAspect(static_cast<u8>(appearance_bits4.eye_aspect.Value()));
+    out_store_data.SetEyeRotate(static_cast<u8>(appearance_bits4.eye_rotate.Value()));
+    out_store_data.SetEyeX(static_cast<u8>(appearance_bits4.eye_x.Value()));
+    out_store_data.SetEyeY(static_cast<u8>(appearance_bits4.eye_y.Value()));
 
     out_store_data.SetEyebrowType(static_cast<EyebrowType>(appearance_bits5.eyebrow_type.Value()));
     out_store_data.SetEyebrowColor(
-        static_cast<CommonColor>(appearance_bits5.eyebrow_color.Value()));
-    out_store_data.SetEyebrowScale(static_cast<u8>(appearance_bits5.eyebrow_scale));
-    out_store_data.SetEyebrowAspect(static_cast<u8>(appearance_bits5.eyebrow_aspect));
-    out_store_data.SetEyebrowRotate(static_cast<u8>(appearance_bits5.eyebrow_rotate));
-    out_store_data.SetEyebrowX(static_cast<u8>(appearance_bits5.eyebrow_x));
-    out_store_data.SetEyebrowY(static_cast<u8>(appearance_bits5.eyebrow_y));
+        RawData::GetHairColorFromVer3(appearance_bits5.eyebrow_color.Value()));
+    out_store_data.SetEyebrowScale(static_cast<u8>(appearance_bits5.eyebrow_scale.Value()));
+    out_store_data.SetEyebrowAspect(static_cast<u8>(appearance_bits5.eyebrow_aspect.Value()));
+    out_store_data.SetEyebrowRotate(static_cast<u8>(appearance_bits5.eyebrow_rotate.Value()));
+    out_store_data.SetEyebrowX(static_cast<u8>(appearance_bits5.eyebrow_x.Value()));
+    out_store_data.SetEyebrowY(static_cast<u8>(appearance_bits5.eyebrow_y.Value() - 3));
 
     out_store_data.SetNoseType(static_cast<NoseType>(appearance_bits6.nose_type.Value()));
-    out_store_data.SetNoseScale(static_cast<u8>(appearance_bits6.nose_scale));
-    out_store_data.SetNoseY(static_cast<u8>(appearance_bits6.nose_y));
+    out_store_data.SetNoseScale(static_cast<u8>(appearance_bits6.nose_scale.Value()));
+    out_store_data.SetNoseY(static_cast<u8>(appearance_bits6.nose_y.Value()));
 
-    out_store_data.SetMouthType(static_cast<u8>(appearance_bits7.mouth_type));
-    out_store_data.SetMouthColor(static_cast<CommonColor>(appearance_bits7.mouth_color.Value()));
-    out_store_data.SetMouthScale(static_cast<u8>(appearance_bits7.mouth_scale));
-    out_store_data.SetMouthAspect(static_cast<u8>(appearance_bits7.mouth_aspect));
-    out_store_data.SetMouthY(static_cast<u8>(appearance_bits8.mouth_y));
+    out_store_data.SetMouthType(static_cast<MouthType>(appearance_bits7.mouth_type.Value()));
+    out_store_data.SetMouthColor(
+        RawData::GetMouthColorFromVer3(appearance_bits7.mouth_color.Value()));
+    out_store_data.SetMouthScale(static_cast<u8>(appearance_bits7.mouth_scale.Value()));
+    out_store_data.SetMouthAspect(static_cast<u8>(appearance_bits7.mouth_aspect.Value()));
+    out_store_data.SetMouthY(static_cast<u8>(appearance_bits8.mouth_y.Value()));
 
     out_store_data.SetMustacheType(
         static_cast<MustacheType>(appearance_bits8.mustache_type.Value()));
-    out_store_data.SetMustacheScale(static_cast<u8>(appearance_bits9.mustache_scale));
-    out_store_data.SetMustacheY(static_cast<u8>(appearance_bits9.mustache_y));
+    out_store_data.SetMustacheScale(static_cast<u8>(appearance_bits9.mustache_scale.Value()));
+    out_store_data.SetMustacheY(static_cast<u8>(appearance_bits9.mustache_y.Value()));
 
     out_store_data.SetBeardType(static_cast<BeardType>(appearance_bits9.beard_type.Value()));
-    out_store_data.SetBeardColor(static_cast<CommonColor>(appearance_bits9.beard_color.Value()));
+    out_store_data.SetBeardColor(
+        RawData::GetHairColorFromVer3(appearance_bits9.beard_color.Value()));
 
+    // Glass type is compatible as it is. It doesn't need a table
     out_store_data.SetGlassType(static_cast<GlassType>(appearance_bits10.glass_type.Value()));
-    out_store_data.SetGlassColor(static_cast<CommonColor>(appearance_bits10.glass_color.Value()));
-    out_store_data.SetGlassScale(static_cast<u8>(appearance_bits10.glass_scale));
-    out_store_data.SetGlassY(static_cast<u8>(appearance_bits10.glass_y));
+    out_store_data.SetGlassColor(
+        RawData::GetGlassColorFromVer3(appearance_bits10.glass_color.Value()));
+    out_store_data.SetGlassScale(static_cast<u8>(appearance_bits10.glass_scale.Value()));
+    out_store_data.SetGlassY(static_cast<u8>(appearance_bits10.glass_y.Value()));
 
     out_store_data.SetMoleType(static_cast<MoleType>(appearance_bits11.mole_type.Value()));
-    out_store_data.SetMoleScale(static_cast<u8>(appearance_bits11.mole_scale));
-    out_store_data.SetMoleX(static_cast<u8>(appearance_bits11.mole_x));
-    out_store_data.SetMoleY(static_cast<u8>(appearance_bits11.mole_y));
+    out_store_data.SetMoleScale(static_cast<u8>(appearance_bits11.mole_scale.Value()));
+    out_store_data.SetMoleX(static_cast<u8>(appearance_bits11.mole_x.Value()));
+    out_store_data.SetMoleY(static_cast<u8>(appearance_bits11.mole_y.Value()));
+
+    out_store_data.SetChecksum();
 }
 
 void Ver3StoreData::BuildFromStoreData(const StoreData& store_data) {
@@ -220,7 +220,7 @@ u32 Ver3StoreData::IsValid() const {
 
     is_valid = is_valid && (appearance_bits8.mustache_type <= static_cast<u8>(MustacheType::Max));
     is_valid = is_valid && (appearance_bits9.mustache_scale < MaxMustacheScale);
-    is_valid = is_valid && (appearance_bits9.mustache_y <= MasMustacheY);
+    is_valid = is_valid && (appearance_bits9.mustache_y <= MaxMustacheY);
 
     is_valid = is_valid && (appearance_bits9.beard_type <= static_cast<u8>(BeardType::Max));
     is_valid = is_valid && (appearance_bits9.beard_color <= MaxVer3CommonColor);
@@ -228,7 +228,7 @@ u32 Ver3StoreData::IsValid() const {
     is_valid = is_valid && (appearance_bits10.glass_type <= MaxVer3GlassType);
     is_valid = is_valid && (appearance_bits10.glass_color <= MaxVer3CommonColor - 2);
     is_valid = is_valid && (appearance_bits10.glass_scale <= MaxGlassScale);
-    is_valid = is_valid && (appearance_bits10.glass_y <= MaxGlassScale);
+    is_valid = is_valid && (appearance_bits10.glass_y <= MaxGlassY);
 
     is_valid = is_valid && (appearance_bits11.mole_type <= static_cast<u8>(MoleType::Max));
     is_valid = is_valid && (appearance_bits11.mole_scale <= MaxMoleScale);
diff --git a/src/core/hle/service/nfc/common/device.cpp b/src/core/hle/service/nfc/common/device.cpp
index 674d2e4b256..05951d8cbb5 100644
--- a/src/core/hle/service/nfc/common/device.cpp
+++ b/src/core/hle/service/nfc/common/device.cpp
@@ -439,6 +439,7 @@ Result NfcDevice::Mount(NFP::ModelType model_type, NFP::MountTarget mount_target
 
     device_state = DeviceState::TagMounted;
     mount_target = mount_target_;
+
     return ResultSuccess;
 }
 
@@ -716,12 +717,13 @@ Result NfcDevice::GetRegisterInfoPrivate(NFP::RegisterInfoPrivate& register_info
         return ResultRegistrationIsNotInitialized;
     }
 
-    Service::Mii::MiiManager manager;
+    Mii::StoreData store_data{};
     const auto& settings = tag_data.settings;
+    tag_data.owner_mii.BuildToStoreData(store_data);
 
     // TODO: Validate and complete this data
     register_info = {
-        .mii_store_data = {},
+        .mii_store_data = store_data,
         .creation_date = settings.init_date.GetWriteDate(),
         .amiibo_name = GetAmiiboName(settings),
         .font_region = settings.settings.font_region,
@@ -1372,7 +1374,7 @@ NFP::AmiiboName NfcDevice::GetAmiiboName(const NFP::AmiiboSettings& settings) co
 
     // Convert from utf16 to utf8
     const auto amiibo_name_utf8 = Common::UTF16ToUTF8(settings_amiibo_name.data());
-    memcpy(amiibo_name.data(), amiibo_name_utf8.data(), amiibo_name_utf8.size());
+    memcpy(amiibo_name.data(), amiibo_name_utf8.data(), amiibo_name_utf8.size() - 1);
 
     return amiibo_name;
 }
