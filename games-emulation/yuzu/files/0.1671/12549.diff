diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index dfba79267ccd..e2ec2164c79e 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -549,6 +549,10 @@ add_library(core STATIC
     hle/service/hid/xcd.cpp
     hle/service/hid/xcd.h
     hle/service/hid/errors.h
+    hle/service/hid/controllers/npad/npad_data.cpp
+    hle/service/hid/controllers/npad/npad_data.h
+    hle/service/hid/controllers/npad/npad_resource.cpp
+    hle/service/hid/controllers/npad/npad_resource.h
     hle/service/hid/controllers/types/debug_pad_types.h
     hle/service/hid/controllers/types/keyboard_types.h
     hle/service/hid/controllers/types/mouse_types.h
diff --git a/src/core/hid/hid_types.h b/src/core/hid/hid_types.h
index 4bf285f361a1..a81ed6af03a9 100644
--- a/src/core/hid/hid_types.h
+++ b/src/core/hid/hid_types.h
@@ -267,6 +267,7 @@ enum class NpadStyleSet : u32 {
     All = 0xFFFFFFFFU,
 };
 static_assert(sizeof(NpadStyleSet) == 4, "NpadStyleSet is an invalid size");
+DECLARE_ENUM_FLAG_OPERATORS(NpadStyleSet)
 
 // This is nn::hid::VibrationDevicePosition
 enum class VibrationDevicePosition : u32 {
diff --git a/src/core/hle/service/hid/controllers/applet_resource.h b/src/core/hle/service/hid/controllers/applet_resource.h
index 52cc4cf42bec..0862fdc2f749 100644
--- a/src/core/hle/service/hid/controllers/applet_resource.h
+++ b/src/core/hle/service/hid/controllers/applet_resource.h
@@ -25,6 +25,7 @@ class AppletResource;
 class NPadResource;
 
 static constexpr std::size_t AruidIndexMax = 0x20;
+static constexpr u64 SystemAruid = 0;
 
 enum class RegistrationStatus : u32 {
     None,
diff --git a/src/core/hle/service/hid/controllers/capture_button.cpp b/src/core/hle/service/hid/controllers/capture_button.cpp
index 8b486fcb515a..7847c080e8dc 100644
--- a/src/core/hle/service/hid/controllers/capture_button.cpp
+++ b/src/core/hle/service/hid/controllers/capture_button.cpp
@@ -21,10 +21,11 @@ void CaptureButton::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
         return;
     }
 
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/console_six_axis.cpp b/src/core/hle/service/hid/controllers/console_six_axis.cpp
index 8eba2c292c21..4b574c2e58a2 100644
--- a/src/core/hle/service/hid/controllers/console_six_axis.cpp
+++ b/src/core/hle/service/hid/controllers/console_six_axis.cpp
@@ -20,10 +20,11 @@ void ConsoleSixAxis::OnInit() {}
 void ConsoleSixAxis::OnRelease() {}
 
 void ConsoleSixAxis::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/controller_base.cpp b/src/core/hle/service/hid/controllers/controller_base.cpp
index 2083ccfad945..afca7154c69c 100644
--- a/src/core/hle/service/hid/controllers/controller_base.cpp
+++ b/src/core/hle/service/hid/controllers/controller_base.cpp
@@ -32,8 +32,10 @@ bool ControllerBase::IsControllerActivated() const {
     return is_activated;
 }
 
-void ControllerBase::SetAppletResource(std::shared_ptr<AppletResource> resource) {
+void ControllerBase::SetAppletResource(std::shared_ptr<AppletResource> resource,
+                                       std::recursive_mutex* resource_mutex) {
     applet_resource = resource;
+    shared_mutex = resource_mutex;
 }
 
 } // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/controller_base.h b/src/core/hle/service/hid/controllers/controller_base.h
index 759ae0053a67..b34b85ece879 100644
--- a/src/core/hle/service/hid/controllers/controller_base.h
+++ b/src/core/hle/service/hid/controllers/controller_base.h
@@ -42,11 +42,13 @@ class ControllerBase {
 
     bool IsControllerActivated() const;
 
-    void SetAppletResource(std::shared_ptr<AppletResource> resource);
+    void SetAppletResource(std::shared_ptr<AppletResource> resource,
+                           std::recursive_mutex* resource_mutex);
 
 protected:
     bool is_activated{false};
     std::shared_ptr<AppletResource> applet_resource{nullptr};
+    std::recursive_mutex* shared_mutex{nullptr};
 
     Core::HID::HIDCore& hid_core;
 };
diff --git a/src/core/hle/service/hid/controllers/debug_mouse.cpp b/src/core/hle/service/hid/controllers/debug_mouse.cpp
index f2f1a27f8ed8..ceeb78d36d3d 100644
--- a/src/core/hle/service/hid/controllers/debug_mouse.cpp
+++ b/src/core/hle/service/hid/controllers/debug_mouse.cpp
@@ -21,10 +21,11 @@ void DebugMouse::OnInit() {}
 void DebugMouse::OnRelease() {}
 
 void DebugMouse::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/debug_pad.cpp b/src/core/hle/service/hid/controllers/debug_pad.cpp
index 1811cf6206fb..dc83f90f3b15 100644
--- a/src/core/hle/service/hid/controllers/debug_pad.cpp
+++ b/src/core/hle/service/hid/controllers/debug_pad.cpp
@@ -23,10 +23,11 @@ void DebugPad::OnInit() {}
 void DebugPad::OnRelease() {}
 
 void DebugPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/digitizer.cpp b/src/core/hle/service/hid/controllers/digitizer.cpp
index c01580fd6da8..d5514c96531d 100644
--- a/src/core/hle/service/hid/controllers/digitizer.cpp
+++ b/src/core/hle/service/hid/controllers/digitizer.cpp
@@ -21,10 +21,11 @@ void Digitizer::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
         return;
     }
 
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/gesture.cpp b/src/core/hle/service/hid/controllers/gesture.cpp
index 6e686fe65cd6..c73da13ee19d 100644
--- a/src/core/hle/service/hid/controllers/gesture.cpp
+++ b/src/core/hle/service/hid/controllers/gesture.cpp
@@ -28,10 +28,11 @@ Gesture::Gesture(Core::HID::HIDCore& hid_core_) : ControllerBase(hid_core_) {
 Gesture::~Gesture() = default;
 
 void Gesture::OnInit() {
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
@@ -44,10 +45,11 @@ void Gesture::OnInit() {
 void Gesture::OnRelease() {}
 
 void Gesture::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/home_button.cpp b/src/core/hle/service/hid/controllers/home_button.cpp
index 71dd9bc08db6..1397379f39bb 100644
--- a/src/core/hle/service/hid/controllers/home_button.cpp
+++ b/src/core/hle/service/hid/controllers/home_button.cpp
@@ -21,10 +21,11 @@ void HomeButton::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
         return;
     }
 
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/keyboard.cpp b/src/core/hle/service/hid/controllers/keyboard.cpp
index c72b3e5ce1f9..c069bcbb25d6 100644
--- a/src/core/hle/service/hid/controllers/keyboard.cpp
+++ b/src/core/hle/service/hid/controllers/keyboard.cpp
@@ -22,10 +22,11 @@ void Keyboard::OnInit() {}
 void Keyboard::OnRelease() {}
 
 void Keyboard::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/mouse.cpp b/src/core/hle/service/hid/controllers/mouse.cpp
index 58deafbc5629..3a8d1751b5ab 100644
--- a/src/core/hle/service/hid/controllers/mouse.cpp
+++ b/src/core/hle/service/hid/controllers/mouse.cpp
@@ -21,10 +21,11 @@ void Mouse::OnInit() {}
 void Mouse::OnRelease() {}
 
 void Mouse::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/npad.cpp b/src/core/hle/service/hid/controllers/npad.cpp
index c7aa606bc118..17cd0d7a079e 100644
--- a/src/core/hle/service/hid/controllers/npad.cpp
+++ b/src/core/hle/service/hid/controllers/npad.cpp
@@ -24,37 +24,94 @@
 #include "core/hle/service/kernel_helpers.h"
 
 namespace Service::HID {
-constexpr std::array<Core::HID::NpadIdType, 10> npad_id_list{
-    Core::HID::NpadIdType::Player1,  Core::HID::NpadIdType::Player2, Core::HID::NpadIdType::Player3,
-    Core::HID::NpadIdType::Player4,  Core::HID::NpadIdType::Player5, Core::HID::NpadIdType::Player6,
-    Core::HID::NpadIdType::Player7,  Core::HID::NpadIdType::Player8, Core::HID::NpadIdType::Other,
-    Core::HID::NpadIdType::Handheld,
-};
 
 NPad::NPad(Core::HID::HIDCore& hid_core_, KernelHelpers::ServiceContext& service_context_)
-    : ControllerBase{hid_core_}, service_context{service_context_} {
-    for (std::size_t i = 0; i < controller_data.size(); ++i) {
-        auto& controller = controller_data[i];
-        controller.device = hid_core.GetEmulatedControllerByIndex(i);
-        controller.vibration[Core::HID::EmulatedDeviceIndex::LeftIndex].latest_vibration_value =
-            Core::HID::DEFAULT_VIBRATION_VALUE;
-        controller.vibration[Core::HID::EmulatedDeviceIndex::RightIndex].latest_vibration_value =
-            Core::HID::DEFAULT_VIBRATION_VALUE;
-        Core::HID::ControllerUpdateCallback engine_callback{
-            .on_change = [this,
-                          i](Core::HID::ControllerTriggerType type) { ControllerUpdate(type, i); },
-            .is_npad_service = true,
-        };
-        controller.callback_key = controller.device->SetCallback(engine_callback);
+    : hid_core{hid_core_}, service_context{service_context_}, npad_resource{service_context} {
+    for (std::size_t aruid_index = 0; aruid_index < AruidIndexMax; ++aruid_index) {
+        for (std::size_t i = 0; i < controller_data[aruid_index].size(); ++i) {
+            auto& controller = controller_data[aruid_index][i];
+            controller.device = hid_core.GetEmulatedControllerByIndex(i);
+            controller.vibration[Core::HID::EmulatedDeviceIndex::LeftIndex].latest_vibration_value =
+                Core::HID::DEFAULT_VIBRATION_VALUE;
+            controller.vibration[Core::HID::EmulatedDeviceIndex::RightIndex]
+                .latest_vibration_value = Core::HID::DEFAULT_VIBRATION_VALUE;
+            Core::HID::ControllerUpdateCallback engine_callback{
+                .on_change =
+                    [this, i](Core::HID::ControllerTriggerType type) { ControllerUpdate(type, i); },
+                .is_npad_service = true,
+            };
+            controller.callback_key = controller.device->SetCallback(engine_callback);
+        }
     }
 }
 
 NPad::~NPad() {
-    for (std::size_t i = 0; i < controller_data.size(); ++i) {
-        auto& controller = controller_data[i];
-        controller.device->DeleteCallback(controller.callback_key);
+    for (std::size_t aruid_index = 0; aruid_index < AruidIndexMax; ++aruid_index) {
+        for (std::size_t i = 0; i < controller_data[aruid_index].size(); ++i) {
+            auto& controller = controller_data[aruid_index][i];
+            controller.device->DeleteCallback(controller.callback_key);
+        }
+    }
+}
+
+Result NPad::Activate() {
+    if (ref_counter == std::numeric_limits<s32>::max() - 1) {
+        return ResultNpadResourceOverflow;
+    }
+
+    if (ref_counter == 0) {
+        std::scoped_lock lock{mutex};
+
+        // TODO: Activate handlers and AbstractedPad
+    }
+
+    ref_counter++;
+    return ResultSuccess;
+}
+
+Result NPad::Activate(u64 aruid) {
+    std::scoped_lock lock{mutex};
+    std::scoped_lock shared_lock{*applet_resource_holder.shared_mutex};
+
+    auto* data = applet_resource_holder.applet_resource->GetAruidData(aruid);
+    const auto aruid_index = applet_resource_holder.applet_resource->GetIndexFromAruid(aruid);
+
+    if (data == nullptr || !data->flag.is_assigned) {
+        return ResultSuccess;
+    }
+
+    for (std::size_t i = 0; i < controller_data[aruid_index].size(); ++i) {
+        auto& controller = controller_data[aruid_index][i];
+        controller.shared_memory = &data->shared_memory_format->npad.npad_entry[i].internal_state;
+    }
+
+    // Prefill controller buffers
+    for (auto& controller : controller_data[aruid_index]) {
+        auto* npad = controller.shared_memory;
+        npad->fullkey_color = {
+            .attribute = ColorAttribute::NoController,
+            .fullkey = {},
+        };
+        npad->joycon_color = {
+            .attribute = ColorAttribute::NoController,
+            .left = {},
+            .right = {},
+        };
+        // HW seems to initialize the first 19 entries
+        for (std::size_t i = 0; i < 19; ++i) {
+            WriteEmptyEntry(npad);
+        }
     }
-    OnRelease();
+
+    return ResultSuccess;
+}
+
+Result NPad::ActivateNpadResource() {
+    return npad_resource.Activate();
+}
+
+Result NPad::ActivateNpadResource(u64 aruid) {
+    return npad_resource.Activate(aruid);
 }
 
 void NPad::ControllerUpdate(Core::HID::ControllerTriggerType type, std::size_t controller_idx) {
@@ -63,41 +120,50 @@ void NPad::ControllerUpdate(Core::HID::ControllerTriggerType type, std::size_t c
         ControllerUpdate(Core::HID::ControllerTriggerType::Battery, controller_idx);
         return;
     }
-    if (controller_idx >= controller_data.size()) {
-        return;
-    }
 
-    auto& controller = controller_data[controller_idx];
-    const auto is_connected = controller.device->IsConnected();
-    const auto npad_type = controller.device->GetNpadStyleIndex();
-    const auto npad_id = controller.device->GetNpadIdType();
-    switch (type) {
-    case Core::HID::ControllerTriggerType::Connected:
-    case Core::HID::ControllerTriggerType::Disconnected:
-        if (is_connected == controller.is_connected) {
+    for (std::size_t aruid_index = 0; aruid_index < AruidIndexMax; aruid_index++) {
+        if (controller_idx >= controller_data[aruid_index].size()) {
             return;
         }
-        UpdateControllerAt(npad_type, npad_id, is_connected);
-        break;
-    case Core::HID::ControllerTriggerType::Battery: {
-        if (!controller.device->IsConnected()) {
-            return;
+
+        auto* data = applet_resource_holder.applet_resource->GetAruidDataByIndex(aruid_index);
+
+        if (!data->flag.is_assigned) {
+            continue;
+        }
+
+        auto& controller = controller_data[aruid_index][controller_idx];
+        const auto is_connected = controller.device->IsConnected();
+        const auto npad_type = controller.device->GetNpadStyleIndex();
+        const auto npad_id = controller.device->GetNpadIdType();
+        switch (type) {
+        case Core::HID::ControllerTriggerType::Connected:
+        case Core::HID::ControllerTriggerType::Disconnected:
+            if (is_connected == controller.is_connected) {
+                return;
+            }
+            UpdateControllerAt(data->aruid, npad_type, npad_id, is_connected);
+            break;
+        case Core::HID::ControllerTriggerType::Battery: {
+            if (!controller.device->IsConnected()) {
+                return;
+            }
+            auto* shared_memory = controller.shared_memory;
+            const auto& battery_level = controller.device->GetBattery();
+            shared_memory->battery_level_dual = battery_level.dual.battery_level;
+            shared_memory->battery_level_left = battery_level.left.battery_level;
+            shared_memory->battery_level_right = battery_level.right.battery_level;
+            break;
+        }
+        default:
+            break;
         }
-        auto* shared_memory = controller.shared_memory;
-        const auto& battery_level = controller.device->GetBattery();
-        shared_memory->battery_level_dual = battery_level.dual.battery_level;
-        shared_memory->battery_level_left = battery_level.left.battery_level;
-        shared_memory->battery_level_right = battery_level.right.battery_level;
-        break;
-    }
-    default:
-        break;
     }
 }
 
-void NPad::InitNewlyAddedController(Core::HID::NpadIdType npad_id) {
-    auto& controller = GetControllerFromNpadIdType(npad_id);
-    if (!IsControllerSupported(controller.device->GetNpadStyleIndex())) {
+void NPad::InitNewlyAddedController(u64 aruid, Core::HID::NpadIdType npad_id) {
+    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
+    if (!npad_resource.IsControllerSupported(aruid, controller.device->GetNpadStyleIndex())) {
         return;
     }
     LOG_DEBUG(Service_HID, "Npad connected {}", npad_id);
@@ -106,7 +172,7 @@ void NPad::InitNewlyAddedController(Core::HID::NpadIdType npad_id) {
     const auto& battery_level = controller.device->GetBattery();
     auto* shared_memory = controller.shared_memory;
     if (controller_type == Core::HID::NpadStyleIndex::None) {
-        controller.styleset_changed_event->Signal();
+        npad_resource.SignalStyleSetUpdateEvent(aruid, npad_id);
         return;
     }
 
@@ -290,53 +356,11 @@ void NPad::InitNewlyAddedController(Core::HID::NpadIdType npad_id) {
                                           Common::Input::PollingMode::Active);
     }
 
-    SignalStyleSetChangedEvent(npad_id);
+    npad_resource.SignalStyleSetUpdateEvent(aruid, npad_id);
     WriteEmptyEntry(controller.shared_memory);
     hid_core.SetLastActiveController(npad_id);
 }
 
-void NPad::OnInit() {
-    const u64 aruid = applet_resource->GetActiveAruid();
-    auto* data = applet_resource->GetAruidData(aruid);
-
-    if (data == nullptr) {
-        return;
-    }
-
-    if (!IsControllerActivated()) {
-        return;
-    }
-
-    for (std::size_t i = 0; i < controller_data.size(); ++i) {
-        auto& controller = controller_data[i];
-        controller.shared_memory = &data->shared_memory_format->npad.npad_entry[i].internal_state;
-        controller.styleset_changed_event =
-            service_context.CreateEvent(fmt::format("npad:NpadStyleSetChanged_{}", i));
-    }
-
-    supported_npad_id_types.resize(npad_id_list.size());
-    std::memcpy(supported_npad_id_types.data(), npad_id_list.data(),
-                npad_id_list.size() * sizeof(Core::HID::NpadIdType));
-
-    // Prefill controller buffers
-    for (auto& controller : controller_data) {
-        auto* npad = controller.shared_memory;
-        npad->fullkey_color = {
-            .attribute = ColorAttribute::NoController,
-            .fullkey = {},
-        };
-        npad->joycon_color = {
-            .attribute = ColorAttribute::NoController,
-            .left = {},
-            .right = {},
-        };
-        // HW seems to initialize the first 19 entries
-        for (std::size_t i = 0; i < 19; ++i) {
-            WriteEmptyEntry(npad);
-        }
-    }
-}
-
 void NPad::WriteEmptyEntry(NpadInternalState* npad) {
     NPadGenericState dummy_pad_state{};
     NpadGcTriggerState dummy_gc_state{};
@@ -358,33 +382,20 @@ void NPad::WriteEmptyEntry(NpadInternalState* npad) {
     npad->gc_trigger_lifo.WriteNextEntry(dummy_gc_state);
 }
 
-void NPad::OnRelease() {
-    is_controller_initialized = false;
-    for (std::size_t i = 0; i < controller_data.size(); ++i) {
-        auto& controller = controller_data[i];
-        if (controller.styleset_changed_event) {
-            service_context.CloseEvent(controller.styleset_changed_event);
-        }
-        for (std::size_t device_idx = 0; device_idx < controller.vibration.size(); ++device_idx) {
-            VibrateControllerAtIndex(controller.device->GetNpadIdType(), device_idx, {});
-        }
-    }
-}
-
-void NPad::RequestPadStateUpdate(Core::HID::NpadIdType npad_id) {
-    std::scoped_lock lock{mutex};
-    auto& controller = GetControllerFromNpadIdType(npad_id);
+void NPad::RequestPadStateUpdate(u64 aruid, Core::HID::NpadIdType npad_id) {
+    std::scoped_lock lock{*applet_resource_holder.shared_mutex};
+    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
     const auto controller_type = controller.device->GetNpadStyleIndex();
 
     if (!controller.device->IsConnected() && controller.is_connected) {
-        DisconnectNpad(npad_id);
+        DisconnectNpad(aruid, npad_id);
         return;
     }
     if (!controller.device->IsConnected()) {
         return;
     }
     if (controller.device->IsConnected() && !controller.is_connected) {
-        InitNewlyAddedController(npad_id);
+        InitNewlyAddedController(aruid, npad_id);
     }
 
     // This function is unique to yuzu for the turbo buttons and motion to work properly
@@ -441,230 +452,232 @@ void NPad::RequestPadStateUpdate(Core::HID::NpadIdType npad_id) {
 }
 
 void NPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
-    const u64 aruid = applet_resource->GetActiveAruid();
-    auto* data = applet_resource->GetAruidData(aruid);
-
-    if (data == nullptr) {
-        return;
-    }
-
-    if (!IsControllerActivated()) {
+    if (ref_counter == 0) {
         return;
     }
 
-    for (std::size_t i = 0; i < controller_data.size(); ++i) {
-        auto& controller = controller_data[i];
-        controller.shared_memory = &data->shared_memory_format->npad.npad_entry[i].internal_state;
-        auto* npad = controller.shared_memory;
+    std::scoped_lock lock{*applet_resource_holder.shared_mutex};
+    for (std::size_t aruid_index = 0; aruid_index < AruidIndexMax; ++aruid_index) {
+        const auto* data = applet_resource_holder.applet_resource->GetAruidDataByIndex(aruid_index);
+        const auto aruid = data->aruid;
 
-        const auto& controller_type = controller.device->GetNpadStyleIndex();
-
-        if (controller_type == Core::HID::NpadStyleIndex::None ||
-            !controller.device->IsConnected()) {
+        if (!data->flag.is_assigned) {
             continue;
         }
 
-        RequestPadStateUpdate(controller.device->GetNpadIdType());
-        auto& pad_state = controller.npad_pad_state;
-        auto& libnx_state = controller.npad_libnx_state;
-        auto& trigger_state = controller.npad_trigger_state;
-
-        // LibNX exclusively uses this section, so we always update it since LibNX doesn't activate
-        // any controllers.
-        libnx_state.connection_status.raw = 0;
-        libnx_state.connection_status.is_connected.Assign(1);
-        switch (controller_type) {
-        case Core::HID::NpadStyleIndex::None:
-            ASSERT(false);
-            break;
-        case Core::HID::NpadStyleIndex::ProController:
-        case Core::HID::NpadStyleIndex::NES:
-        case Core::HID::NpadStyleIndex::SNES:
-        case Core::HID::NpadStyleIndex::N64:
-        case Core::HID::NpadStyleIndex::SegaGenesis:
-            pad_state.connection_status.raw = 0;
-            pad_state.connection_status.is_connected.Assign(1);
-            pad_state.connection_status.is_wired.Assign(1);
-
-            libnx_state.connection_status.is_wired.Assign(1);
-            pad_state.sampling_number =
-                npad->fullkey_lifo.ReadCurrentEntry().state.sampling_number + 1;
-            npad->fullkey_lifo.WriteNextEntry(pad_state);
-            break;
-        case Core::HID::NpadStyleIndex::Handheld:
-            pad_state.connection_status.raw = 0;
-            pad_state.connection_status.is_connected.Assign(1);
-            pad_state.connection_status.is_wired.Assign(1);
-            pad_state.connection_status.is_left_connected.Assign(1);
-            pad_state.connection_status.is_right_connected.Assign(1);
-            pad_state.connection_status.is_left_wired.Assign(1);
-            pad_state.connection_status.is_right_wired.Assign(1);
-
-            libnx_state.connection_status.is_wired.Assign(1);
-            libnx_state.connection_status.is_left_connected.Assign(1);
-            libnx_state.connection_status.is_right_connected.Assign(1);
-            libnx_state.connection_status.is_left_wired.Assign(1);
-            libnx_state.connection_status.is_right_wired.Assign(1);
-            pad_state.sampling_number =
-                npad->handheld_lifo.ReadCurrentEntry().state.sampling_number + 1;
-            npad->handheld_lifo.WriteNextEntry(pad_state);
-            break;
-        case Core::HID::NpadStyleIndex::JoyconDual:
-            pad_state.connection_status.raw = 0;
-            pad_state.connection_status.is_connected.Assign(1);
-            if (controller.is_dual_left_connected) {
+        for (std::size_t i = 0; i < controller_data[aruid_index].size(); ++i) {
+            auto& controller = controller_data[aruid_index][i];
+            controller.shared_memory =
+                &data->shared_memory_format->npad.npad_entry[i].internal_state;
+            auto* npad = controller.shared_memory;
+
+            const auto& controller_type = controller.device->GetNpadStyleIndex();
+
+            if (controller_type == Core::HID::NpadStyleIndex::None ||
+                !controller.device->IsConnected()) {
+                continue;
+            }
+
+            RequestPadStateUpdate(aruid, controller.device->GetNpadIdType());
+            auto& pad_state = controller.npad_pad_state;
+            auto& libnx_state = controller.npad_libnx_state;
+            auto& trigger_state = controller.npad_trigger_state;
+
+            // LibNX exclusively uses this section, so we always update it since LibNX doesn't
+            // activate any controllers.
+            libnx_state.connection_status.raw = 0;
+            libnx_state.connection_status.is_connected.Assign(1);
+            switch (controller_type) {
+            case Core::HID::NpadStyleIndex::None:
+                ASSERT(false);
+                break;
+            case Core::HID::NpadStyleIndex::ProController:
+            case Core::HID::NpadStyleIndex::NES:
+            case Core::HID::NpadStyleIndex::SNES:
+            case Core::HID::NpadStyleIndex::N64:
+            case Core::HID::NpadStyleIndex::SegaGenesis:
+                pad_state.connection_status.raw = 0;
+                pad_state.connection_status.is_connected.Assign(1);
+                pad_state.connection_status.is_wired.Assign(1);
+
+                libnx_state.connection_status.is_wired.Assign(1);
+                pad_state.sampling_number =
+                    npad->fullkey_lifo.ReadCurrentEntry().state.sampling_number + 1;
+                npad->fullkey_lifo.WriteNextEntry(pad_state);
+                break;
+            case Core::HID::NpadStyleIndex::Handheld:
+                pad_state.connection_status.raw = 0;
+                pad_state.connection_status.is_connected.Assign(1);
+                pad_state.connection_status.is_wired.Assign(1);
                 pad_state.connection_status.is_left_connected.Assign(1);
+                pad_state.connection_status.is_right_connected.Assign(1);
+                pad_state.connection_status.is_left_wired.Assign(1);
+                pad_state.connection_status.is_right_wired.Assign(1);
+
+                libnx_state.connection_status.is_wired.Assign(1);
                 libnx_state.connection_status.is_left_connected.Assign(1);
-            }
-            if (controller.is_dual_right_connected) {
+                libnx_state.connection_status.is_right_connected.Assign(1);
+                libnx_state.connection_status.is_left_wired.Assign(1);
+                libnx_state.connection_status.is_right_wired.Assign(1);
+                pad_state.sampling_number =
+                    npad->handheld_lifo.ReadCurrentEntry().state.sampling_number + 1;
+                npad->handheld_lifo.WriteNextEntry(pad_state);
+                break;
+            case Core::HID::NpadStyleIndex::JoyconDual:
+                pad_state.connection_status.raw = 0;
+                pad_state.connection_status.is_connected.Assign(1);
+                if (controller.is_dual_left_connected) {
+                    pad_state.connection_status.is_left_connected.Assign(1);
+                    libnx_state.connection_status.is_left_connected.Assign(1);
+                }
+                if (controller.is_dual_right_connected) {
+                    pad_state.connection_status.is_right_connected.Assign(1);
+                    libnx_state.connection_status.is_right_connected.Assign(1);
+                }
+
+                pad_state.sampling_number =
+                    npad->joy_dual_lifo.ReadCurrentEntry().state.sampling_number + 1;
+                npad->joy_dual_lifo.WriteNextEntry(pad_state);
+                break;
+            case Core::HID::NpadStyleIndex::JoyconLeft:
+                pad_state.connection_status.raw = 0;
+                pad_state.connection_status.is_connected.Assign(1);
+                pad_state.connection_status.is_left_connected.Assign(1);
+
+                libnx_state.connection_status.is_left_connected.Assign(1);
+                pad_state.sampling_number =
+                    npad->joy_left_lifo.ReadCurrentEntry().state.sampling_number + 1;
+                npad->joy_left_lifo.WriteNextEntry(pad_state);
+                break;
+            case Core::HID::NpadStyleIndex::JoyconRight:
+                pad_state.connection_status.raw = 0;
+                pad_state.connection_status.is_connected.Assign(1);
                 pad_state.connection_status.is_right_connected.Assign(1);
+
                 libnx_state.connection_status.is_right_connected.Assign(1);
+                pad_state.sampling_number =
+                    npad->joy_right_lifo.ReadCurrentEntry().state.sampling_number + 1;
+                npad->joy_right_lifo.WriteNextEntry(pad_state);
+                break;
+            case Core::HID::NpadStyleIndex::GameCube:
+                pad_state.connection_status.raw = 0;
+                pad_state.connection_status.is_connected.Assign(1);
+                pad_state.connection_status.is_wired.Assign(1);
+
+                libnx_state.connection_status.is_wired.Assign(1);
+                pad_state.sampling_number =
+                    npad->fullkey_lifo.ReadCurrentEntry().state.sampling_number + 1;
+                trigger_state.sampling_number =
+                    npad->gc_trigger_lifo.ReadCurrentEntry().state.sampling_number + 1;
+                npad->fullkey_lifo.WriteNextEntry(pad_state);
+                npad->gc_trigger_lifo.WriteNextEntry(trigger_state);
+                break;
+            case Core::HID::NpadStyleIndex::Pokeball:
+                pad_state.connection_status.raw = 0;
+                pad_state.connection_status.is_connected.Assign(1);
+                pad_state.sampling_number =
+                    npad->palma_lifo.ReadCurrentEntry().state.sampling_number + 1;
+                npad->palma_lifo.WriteNextEntry(pad_state);
+                break;
+            default:
+                break;
             }
 
-            pad_state.sampling_number =
-                npad->joy_dual_lifo.ReadCurrentEntry().state.sampling_number + 1;
-            npad->joy_dual_lifo.WriteNextEntry(pad_state);
-            break;
-        case Core::HID::NpadStyleIndex::JoyconLeft:
-            pad_state.connection_status.raw = 0;
-            pad_state.connection_status.is_connected.Assign(1);
-            pad_state.connection_status.is_left_connected.Assign(1);
-
-            libnx_state.connection_status.is_left_connected.Assign(1);
-            pad_state.sampling_number =
-                npad->joy_left_lifo.ReadCurrentEntry().state.sampling_number + 1;
-            npad->joy_left_lifo.WriteNextEntry(pad_state);
-            break;
-        case Core::HID::NpadStyleIndex::JoyconRight:
-            pad_state.connection_status.raw = 0;
-            pad_state.connection_status.is_connected.Assign(1);
-            pad_state.connection_status.is_right_connected.Assign(1);
-
-            libnx_state.connection_status.is_right_connected.Assign(1);
-            pad_state.sampling_number =
-                npad->joy_right_lifo.ReadCurrentEntry().state.sampling_number + 1;
-            npad->joy_right_lifo.WriteNextEntry(pad_state);
-            break;
-        case Core::HID::NpadStyleIndex::GameCube:
-            pad_state.connection_status.raw = 0;
-            pad_state.connection_status.is_connected.Assign(1);
-            pad_state.connection_status.is_wired.Assign(1);
-
-            libnx_state.connection_status.is_wired.Assign(1);
-            pad_state.sampling_number =
-                npad->fullkey_lifo.ReadCurrentEntry().state.sampling_number + 1;
-            trigger_state.sampling_number =
-                npad->gc_trigger_lifo.ReadCurrentEntry().state.sampling_number + 1;
-            npad->fullkey_lifo.WriteNextEntry(pad_state);
-            npad->gc_trigger_lifo.WriteNextEntry(trigger_state);
-            break;
-        case Core::HID::NpadStyleIndex::Pokeball:
-            pad_state.connection_status.raw = 0;
-            pad_state.connection_status.is_connected.Assign(1);
-            pad_state.sampling_number =
-                npad->palma_lifo.ReadCurrentEntry().state.sampling_number + 1;
-            npad->palma_lifo.WriteNextEntry(pad_state);
-            break;
-        default:
-            break;
-        }
-
-        libnx_state.npad_buttons.raw = pad_state.npad_buttons.raw;
-        libnx_state.l_stick = pad_state.l_stick;
-        libnx_state.r_stick = pad_state.r_stick;
-        npad->system_ext_lifo.WriteNextEntry(pad_state);
+            libnx_state.npad_buttons.raw = pad_state.npad_buttons.raw;
+            libnx_state.l_stick = pad_state.l_stick;
+            libnx_state.r_stick = pad_state.r_stick;
+            npad->system_ext_lifo.WriteNextEntry(pad_state);
 
-        press_state |= static_cast<u64>(pad_state.npad_buttons.raw);
+            press_state |= static_cast<u64>(pad_state.npad_buttons.raw);
+        }
     }
 }
 
-void NPad::SetSupportedStyleSet(Core::HID::NpadStyleTag style_set) {
-    hid_core.SetSupportedStyleTag(style_set);
-
-    if (is_controller_initialized) {
-        return;
+Result NPad::SetSupportedNpadStyleSet(u64 aruid, Core::HID::NpadStyleSet supported_style_set) {
+    std::scoped_lock lock{mutex};
+    hid_core.SetSupportedStyleTag({supported_style_set});
+    const Result result = npad_resource.SetSupportedNpadStyleSet(aruid, supported_style_set);
+    if (result.IsSuccess()) {
+        OnUpdate({});
     }
-
-    // Once SetSupportedStyleSet is called controllers are fully initialized
-    is_controller_initialized = true;
+    return result;
 }
 
-Core::HID::NpadStyleTag NPad::GetSupportedStyleSet() const {
-    if (!is_controller_initialized) {
-        return {Core::HID::NpadStyleSet::None};
+Result NPad::GetSupportedNpadStyleSet(u64 aruid,
+                                      Core::HID::NpadStyleSet& out_supported_style_set) const {
+    std::scoped_lock lock{mutex};
+    const Result result = npad_resource.GetSupportedNpadStyleSet(out_supported_style_set, aruid);
+
+    if (result == ResultUndefinedStyleset) {
+        out_supported_style_set = Core::HID::NpadStyleSet::None;
+        return ResultSuccess;
     }
-    return hid_core.GetSupportedStyleTag();
+
+    return result;
 }
 
-Result NPad::SetSupportedNpadIdTypes(std::span<const u8> data) {
-    constexpr std::size_t max_number_npad_ids = 0xa;
-    const auto length = data.size();
-    ASSERT(length > 0 && (length % sizeof(u32)) == 0);
-    const std::size_t elements = length / sizeof(u32);
+Result NPad::GetMaskedSupportedNpadStyleSet(
+    u64 aruid, Core::HID::NpadStyleSet& out_supported_style_set) const {
+    std::scoped_lock lock{mutex};
+    const Result result =
+        npad_resource.GetMaskedSupportedNpadStyleSet(out_supported_style_set, aruid);
 
-    if (elements > max_number_npad_ids) {
-        return InvalidArraySize;
+    if (result == ResultUndefinedStyleset) {
+        out_supported_style_set = Core::HID::NpadStyleSet::None;
+        return ResultSuccess;
     }
 
-    supported_npad_id_types.clear();
-    supported_npad_id_types.resize(elements);
-    std::memcpy(supported_npad_id_types.data(), data.data(), length);
-    return ResultSuccess;
+    return result;
 }
 
-void NPad::GetSupportedNpadIdTypes(u32* data, std::size_t max_length) {
-    const auto copy_amount = supported_npad_id_types.size() * sizeof(u32);
-    ASSERT(max_length <= copy_amount);
-    std::memcpy(data, supported_npad_id_types.data(), copy_amount);
-}
+Result NPad::SetSupportedNpadIdType(u64 aruid,
+                                    std::span<const Core::HID::NpadIdType> supported_npad_list) {
+    std::scoped_lock lock{mutex};
+    if (supported_npad_list.size() > MaxSupportedNpadIdTypes) {
+        return ResultInvalidArraySize;
+    }
 
-std::size_t NPad::GetSupportedNpadIdTypesSize() const {
-    return supported_npad_id_types.size();
-}
+    Result result = npad_resource.SetSupportedNpadIdType(aruid, supported_npad_list);
 
-void NPad::SetHoldType(NpadJoyHoldType joy_hold_type) {
-    if (joy_hold_type != NpadJoyHoldType::Horizontal &&
-        joy_hold_type != NpadJoyHoldType::Vertical) {
-        LOG_ERROR(Service_HID, "Npad joy hold type needs to be valid, joy_hold_type={}",
-                  joy_hold_type);
-        return;
+    if (result.IsSuccess()) {
+        OnUpdate({});
     }
-    hold_type = joy_hold_type;
-}
 
-NpadJoyHoldType NPad::GetHoldType() const {
-    return hold_type;
+    return result;
 }
 
-void NPad::SetNpadHandheldActivationMode(NpadHandheldActivationMode activation_mode) {
-    if (activation_mode >= NpadHandheldActivationMode::MaxActivationMode) {
-        ASSERT_MSG(false, "Activation mode should be always None, Single or Dual");
-        return;
-    }
-
-    handheld_activation_mode = activation_mode;
+Result NPad::SetNpadJoyHoldType(u64 aruid, NpadJoyHoldType hold_type) {
+    std::scoped_lock lock{mutex};
+    return npad_resource.SetNpadJoyHoldType(aruid, hold_type);
 }
 
-NpadHandheldActivationMode NPad::GetNpadHandheldActivationMode() const {
-    return handheld_activation_mode;
+Result NPad::GetNpadJoyHoldType(u64 aruid, NpadJoyHoldType& out_hold_type) const {
+    std::scoped_lock lock{mutex};
+    return npad_resource.GetNpadJoyHoldType(out_hold_type, aruid);
 }
 
-void NPad::SetNpadCommunicationMode(NpadCommunicationMode communication_mode_) {
-    communication_mode = communication_mode_;
+Result NPad::SetNpadHandheldActivationMode(u64 aruid, NpadHandheldActivationMode mode) {
+    std::scoped_lock lock{mutex};
+    Result result = npad_resource.SetNpadHandheldActivationMode(aruid, mode);
+    if (result.IsSuccess()) {
+        OnUpdate({});
+    }
+    return result;
 }
 
-NpadCommunicationMode NPad::GetNpadCommunicationMode() const {
-    return communication_mode;
+Result NPad::GetNpadHandheldActivationMode(u64 aruid, NpadHandheldActivationMode& out_mode) const {
+    std::scoped_lock lock{mutex};
+    return npad_resource.GetNpadHandheldActivationMode(out_mode, aruid);
 }
 
-bool NPad::SetNpadMode(Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType npad_id,
+bool NPad::SetNpadMode(u64 aruid, Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType npad_id,
                        NpadJoyDeviceType npad_device_type, NpadJoyAssignmentMode assignment_mode) {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         return false;
     }
 
-    auto& controller = GetControllerFromNpadIdType(npad_id);
+    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
     if (controller.shared_memory->assignment_mode != assignment_mode) {
         controller.shared_memory->assignment_mode = assignment_mode;
     }
@@ -675,17 +688,17 @@ bool NPad::SetNpadMode(Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType
 
     if (assignment_mode == NpadJoyAssignmentMode::Dual) {
         if (controller.device->GetNpadStyleIndex() == Core::HID::NpadStyleIndex::JoyconLeft) {
-            DisconnectNpad(npad_id);
+            DisconnectNpad(aruid, npad_id);
             controller.is_dual_left_connected = true;
             controller.is_dual_right_connected = false;
-            UpdateControllerAt(Core::HID::NpadStyleIndex::JoyconDual, npad_id, true);
+            UpdateControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconDual, npad_id, true);
             return false;
         }
         if (controller.device->GetNpadStyleIndex() == Core::HID::NpadStyleIndex::JoyconRight) {
-            DisconnectNpad(npad_id);
+            DisconnectNpad(aruid, npad_id);
             controller.is_dual_left_connected = false;
             controller.is_dual_right_connected = true;
-            UpdateControllerAt(Core::HID::NpadStyleIndex::JoyconDual, npad_id, true);
+            UpdateControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconDual, npad_id, true);
             return false;
         }
         return false;
@@ -699,37 +712,38 @@ bool NPad::SetNpadMode(Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType
     }
 
     if (controller.is_dual_left_connected && !controller.is_dual_right_connected) {
-        DisconnectNpad(npad_id);
-        UpdateControllerAt(Core::HID::NpadStyleIndex::JoyconLeft, npad_id, true);
+        DisconnectNpad(aruid, npad_id);
+        UpdateControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconLeft, npad_id, true);
         return false;
     }
     if (!controller.is_dual_left_connected && controller.is_dual_right_connected) {
-        DisconnectNpad(npad_id);
-        UpdateControllerAt(Core::HID::NpadStyleIndex::JoyconRight, npad_id, true);
+        DisconnectNpad(aruid, npad_id);
+        UpdateControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconRight, npad_id, true);
         return false;
     }
 
     // We have two controllers connected to the same npad_id we need to split them
     new_npad_id = hid_core.GetFirstDisconnectedNpadId();
-    auto& controller_2 = GetControllerFromNpadIdType(new_npad_id);
-    DisconnectNpad(npad_id);
+    auto& controller_2 = GetControllerFromNpadIdType(aruid, new_npad_id);
+    DisconnectNpad(aruid, npad_id);
     if (npad_device_type == NpadJoyDeviceType::Left) {
-        UpdateControllerAt(Core::HID::NpadStyleIndex::JoyconLeft, npad_id, true);
+        UpdateControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconLeft, npad_id, true);
         controller_2.is_dual_left_connected = false;
         controller_2.is_dual_right_connected = true;
-        UpdateControllerAt(Core::HID::NpadStyleIndex::JoyconDual, new_npad_id, true);
+        UpdateControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconDual, new_npad_id, true);
     } else {
-        UpdateControllerAt(Core::HID::NpadStyleIndex::JoyconRight, npad_id, true);
+        UpdateControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconRight, npad_id, true);
         controller_2.is_dual_left_connected = true;
         controller_2.is_dual_right_connected = false;
-        UpdateControllerAt(Core::HID::NpadStyleIndex::JoyconDual, new_npad_id, true);
+        UpdateControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconDual, new_npad_id, true);
     }
     return true;
 }
 
-bool NPad::VibrateControllerAtIndex(Core::HID::NpadIdType npad_id, std::size_t device_index,
+bool NPad::VibrateControllerAtIndex(u64 aruid, Core::HID::NpadIdType npad_id,
+                                    std::size_t device_index,
                                     const Core::HID::VibrationValue& vibration_value) {
-    auto& controller = GetControllerFromNpadIdType(npad_id);
+    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
     if (!controller.device->IsConnected()) {
         return false;
     }
@@ -772,7 +786,8 @@ bool NPad::VibrateControllerAtIndex(Core::HID::NpadIdType npad_id, std::size_t d
     return controller.device->SetVibration(device_index, vibration);
 }
 
-void NPad::VibrateController(const Core::HID::VibrationDeviceHandle& vibration_device_handle,
+void NPad::VibrateController(u64 aruid,
+                             const Core::HID::VibrationDeviceHandle& vibration_device_handle,
                              const Core::HID::VibrationValue& vibration_value) {
     if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
         return;
@@ -782,7 +797,7 @@ void NPad::VibrateController(const Core::HID::VibrationDeviceHandle& vibration_d
         return;
     }
 
-    auto& controller = GetControllerFromHandle(vibration_device_handle);
+    auto& controller = GetControllerFromHandle(aruid, vibration_device_handle);
     const auto device_index = static_cast<std::size_t>(vibration_device_handle.device_index);
 
     if (!controller.vibration[device_index].device_mounted || !controller.device->IsConnected()) {
@@ -812,14 +827,14 @@ void NPad::VibrateController(const Core::HID::VibrationDeviceHandle& vibration_d
         return;
     }
 
-    if (VibrateControllerAtIndex(controller.device->GetNpadIdType(), device_index,
+    if (VibrateControllerAtIndex(aruid, controller.device->GetNpadIdType(), device_index,
                                  vibration_value)) {
         controller.vibration[device_index].latest_vibration_value = vibration_value;
     }
 }
 
 void NPad::VibrateControllers(
-    std::span<const Core::HID::VibrationDeviceHandle> vibration_device_handles,
+    u64 aruid, std::span<const Core::HID::VibrationDeviceHandle> vibration_device_handles,
     std::span<const Core::HID::VibrationValue> vibration_values) {
     if (!Settings::values.vibration_enabled.GetValue() && !permit_vibration_session_enabled) {
         return;
@@ -831,17 +846,17 @@ void NPad::VibrateControllers(
         "this is undefined behavior!");
 
     for (std::size_t i = 0; i < vibration_device_handles.size(); ++i) {
-        VibrateController(vibration_device_handles[i], vibration_values[i]);
+        VibrateController(aruid, vibration_device_handles[i], vibration_values[i]);
     }
 }
 
 Core::HID::VibrationValue NPad::GetLastVibration(
-    const Core::HID::VibrationDeviceHandle& vibration_device_handle) const {
+    u64 aruid, const Core::HID::VibrationDeviceHandle& vibration_device_handle) const {
     if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
         return {};
     }
 
-    const auto& controller = GetControllerFromHandle(vibration_device_handle);
+    const auto& controller = GetControllerFromHandle(aruid, vibration_device_handle);
     const auto device_index = static_cast<std::size_t>(vibration_device_handle.device_index);
     return controller.vibration[device_index].latest_vibration_value;
 }
@@ -852,14 +867,15 @@ void NPad::InitializeVibrationDevice(
         return;
     }
 
+    const auto aruid = applet_resource_holder.applet_resource->GetActiveAruid();
     const auto npad_index = static_cast<Core::HID::NpadIdType>(vibration_device_handle.npad_id);
     const auto device_index = static_cast<std::size_t>(vibration_device_handle.device_index);
-    InitializeVibrationDeviceAtIndex(npad_index, device_index);
+    InitializeVibrationDeviceAtIndex(aruid, npad_index, device_index);
 }
 
-void NPad::InitializeVibrationDeviceAtIndex(Core::HID::NpadIdType npad_id,
+void NPad::InitializeVibrationDeviceAtIndex(u64 aruid, Core::HID::NpadIdType npad_id,
                                             std::size_t device_index) {
-    auto& controller = GetControllerFromNpadIdType(npad_id);
+    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
     if (!Settings::values.vibration_enabled.GetValue()) {
         controller.vibration[device_index].device_mounted = false;
         return;
@@ -874,60 +890,50 @@ void NPad::SetPermitVibrationSession(bool permit_vibration_session) {
 }
 
 bool NPad::IsVibrationDeviceMounted(
-    const Core::HID::VibrationDeviceHandle& vibration_device_handle) const {
+    u64 aruid, const Core::HID::VibrationDeviceHandle& vibration_device_handle) const {
     if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
         return false;
     }
 
-    const auto& controller = GetControllerFromHandle(vibration_device_handle);
+    const auto& controller = GetControllerFromHandle(aruid, vibration_device_handle);
     const auto device_index = static_cast<std::size_t>(vibration_device_handle.device_index);
     return controller.vibration[device_index].device_mounted;
 }
 
-Kernel::KReadableEvent& NPad::GetStyleSetChangedEvent(Core::HID::NpadIdType npad_id) {
-    if (!IsNpadIdValid(npad_id)) {
-        LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
-        // Fallback to player 1
-        const auto& controller = GetControllerFromNpadIdType(Core::HID::NpadIdType::Player1);
-        return controller.styleset_changed_event->GetReadableEvent();
-    }
-
-    const auto& controller = GetControllerFromNpadIdType(npad_id);
-    return controller.styleset_changed_event->GetReadableEvent();
-}
-
-void NPad::SignalStyleSetChangedEvent(Core::HID::NpadIdType npad_id) const {
-    const auto& controller = GetControllerFromNpadIdType(npad_id);
-    controller.styleset_changed_event->Signal();
+Result NPad::AcquireNpadStyleSetUpdateEventHandle(u64 aruid, Kernel::KReadableEvent** out_event,
+                                                  Core::HID::NpadIdType npad_id) {
+    std::scoped_lock lock{mutex};
+    return npad_resource.AcquireNpadStyleSetUpdateEventHandle(aruid, out_event, npad_id);
 }
 
-void NPad::AddNewControllerAt(Core::HID::NpadStyleIndex controller, Core::HID::NpadIdType npad_id) {
-    UpdateControllerAt(controller, npad_id, true);
+void NPad::AddNewControllerAt(u64 aruid, Core::HID::NpadStyleIndex controller,
+                              Core::HID::NpadIdType npad_id) {
+    UpdateControllerAt(aruid, controller, npad_id, true);
 }
 
-void NPad::UpdateControllerAt(Core::HID::NpadStyleIndex type, Core::HID::NpadIdType npad_id,
-                              bool connected) {
-    auto& controller = GetControllerFromNpadIdType(npad_id);
+void NPad::UpdateControllerAt(u64 aruid, Core::HID::NpadStyleIndex type,
+                              Core::HID::NpadIdType npad_id, bool connected) {
+    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
     if (!connected) {
-        DisconnectNpad(npad_id);
+        DisconnectNpad(aruid, npad_id);
         return;
     }
 
     controller.device->SetNpadStyleIndex(type);
-    InitNewlyAddedController(npad_id);
+    InitNewlyAddedController(aruid, npad_id);
 }
 
-Result NPad::DisconnectNpad(Core::HID::NpadIdType npad_id) {
+Result NPad::DisconnectNpad(u64 aruid, Core::HID::NpadIdType npad_id) {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
-        return InvalidNpadId;
+        return ResultInvalidNpadId;
     }
 
     LOG_DEBUG(Service_HID, "Npad disconnected {}", npad_id);
-    auto& controller = GetControllerFromNpadIdType(npad_id);
+    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
     for (std::size_t device_idx = 0; device_idx < controller.vibration.size(); ++device_idx) {
         // Send an empty vibration to stop any vibrations.
-        VibrateControllerAtIndex(npad_id, device_idx, {});
+        VibrateControllerAtIndex(aruid, npad_id, device_idx, {});
         controller.vibration[device_idx].device_mounted = false;
     }
 
@@ -961,47 +967,48 @@ Result NPad::DisconnectNpad(Core::HID::NpadIdType npad_id) {
     controller.is_dual_right_connected = true;
     controller.is_connected = false;
     controller.device->Disconnect();
-    SignalStyleSetChangedEvent(npad_id);
+    npad_resource.SignalStyleSetUpdateEvent(aruid, npad_id);
     WriteEmptyEntry(shared_memory);
     return ResultSuccess;
 }
 
 Result NPad::IsFirmwareUpdateAvailableForSixAxisSensor(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_firmware_available) const {
+    u64 aruid, const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+    bool& is_firmware_available) const {
     const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
     if (is_valid.IsError()) {
         LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
         return is_valid;
     }
 
-    const auto& sixaxis_properties = GetSixaxisProperties(sixaxis_handle);
+    const auto& sixaxis_properties = GetSixaxisProperties(aruid, sixaxis_handle);
     is_firmware_available = sixaxis_properties.is_firmware_update_available != 0;
     return ResultSuccess;
 }
 
 Result NPad::ResetIsSixAxisSensorDeviceNewlyAssigned(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle) {
+    u64 aruid, const Core::HID::SixAxisSensorHandle& sixaxis_handle) {
     const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
     if (is_valid.IsError()) {
         LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
         return is_valid;
     }
 
-    auto& sixaxis_properties = GetSixaxisProperties(sixaxis_handle);
+    auto& sixaxis_properties = GetSixaxisProperties(aruid, sixaxis_handle);
     sixaxis_properties.is_newly_assigned.Assign(0);
 
     return ResultSuccess;
 }
 
-Result NPad::MergeSingleJoyAsDualJoy(Core::HID::NpadIdType npad_id_1,
+Result NPad::MergeSingleJoyAsDualJoy(u64 aruid, Core::HID::NpadIdType npad_id_1,
                                      Core::HID::NpadIdType npad_id_2) {
     if (!IsNpadIdValid(npad_id_1) || !IsNpadIdValid(npad_id_2)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id_1:{}, npad_id_2:{}", npad_id_1,
                   npad_id_2);
-        return InvalidNpadId;
+        return ResultInvalidNpadId;
     }
-    auto& controller_1 = GetControllerFromNpadIdType(npad_id_1);
-    auto& controller_2 = GetControllerFromNpadIdType(npad_id_2);
+    auto& controller_1 = GetControllerFromNpadIdType(aruid, npad_id_1);
+    auto& controller_2 = GetControllerFromNpadIdType(aruid, npad_id_2);
     auto controller_style_1 = controller_1.device->GetNpadStyleIndex();
     auto controller_style_2 = controller_2.device->GetNpadStyleIndex();
 
@@ -1048,51 +1055,62 @@ Result NPad::MergeSingleJoyAsDualJoy(Core::HID::NpadIdType npad_id_1,
     }
 
     // Disconnect the joycons and connect them as dual joycon at the first index.
-    DisconnectNpad(npad_id_1);
-    DisconnectNpad(npad_id_2);
+    DisconnectNpad(aruid, npad_id_1);
+    DisconnectNpad(aruid, npad_id_2);
     controller_1.is_dual_left_connected = true;
     controller_1.is_dual_right_connected = true;
-    AddNewControllerAt(Core::HID::NpadStyleIndex::JoyconDual, npad_id_1);
+    AddNewControllerAt(aruid, Core::HID::NpadStyleIndex::JoyconDual, npad_id_1);
     return ResultSuccess;
 }
 
-void NPad::StartLRAssignmentMode() {
-    // Nothing internally is used for lr assignment mode. Since we have the ability to set the
-    // controller types from boot, it doesn't really matter about showing a selection screen
-    is_in_lr_assignment_mode = true;
+Result NPad::StartLrAssignmentMode(u64 aruid) {
+    std::scoped_lock lock{mutex};
+    bool is_enabled{};
+    Result result = npad_resource.GetLrAssignmentMode(is_enabled, aruid);
+    if (result.IsSuccess() && is_enabled == false) {
+        result = npad_resource.SetLrAssignmentMode(aruid, true);
+    }
+    return result;
 }
 
-void NPad::StopLRAssignmentMode() {
-    is_in_lr_assignment_mode = false;
+Result NPad::StopLrAssignmentMode(u64 aruid) {
+    std::scoped_lock lock{mutex};
+    bool is_enabled{};
+    Result result = npad_resource.GetLrAssignmentMode(is_enabled, aruid);
+    if (result.IsSuccess() && is_enabled == true) {
+        result = npad_resource.SetLrAssignmentMode(aruid, false);
+    }
+    return result;
 }
 
-Result NPad::SwapNpadAssignment(Core::HID::NpadIdType npad_id_1, Core::HID::NpadIdType npad_id_2) {
+Result NPad::SwapNpadAssignment(u64 aruid, Core::HID::NpadIdType npad_id_1,
+                                Core::HID::NpadIdType npad_id_2) {
     if (!IsNpadIdValid(npad_id_1) || !IsNpadIdValid(npad_id_2)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id_1:{}, npad_id_2:{}", npad_id_1,
                   npad_id_2);
-        return InvalidNpadId;
+        return ResultInvalidNpadId;
     }
     if (npad_id_1 == Core::HID::NpadIdType::Handheld ||
         npad_id_2 == Core::HID::NpadIdType::Handheld || npad_id_1 == Core::HID::NpadIdType::Other ||
         npad_id_2 == Core::HID::NpadIdType::Other) {
         return ResultSuccess;
     }
-    const auto& controller_1 = GetControllerFromNpadIdType(npad_id_1).device;
-    const auto& controller_2 = GetControllerFromNpadIdType(npad_id_2).device;
+    const auto& controller_1 = GetControllerFromNpadIdType(aruid, npad_id_1).device;
+    const auto& controller_2 = GetControllerFromNpadIdType(aruid, npad_id_2).device;
     const auto type_index_1 = controller_1->GetNpadStyleIndex();
     const auto type_index_2 = controller_2->GetNpadStyleIndex();
     const auto is_connected_1 = controller_1->IsConnected();
     const auto is_connected_2 = controller_2->IsConnected();
 
-    if (!IsControllerSupported(type_index_1) && is_connected_1) {
-        return NpadNotConnected;
+    if (!npad_resource.IsControllerSupported(aruid, type_index_1) && is_connected_1) {
+        return ResultNpadNotConnected;
     }
-    if (!IsControllerSupported(type_index_2) && is_connected_2) {
-        return NpadNotConnected;
+    if (!npad_resource.IsControllerSupported(aruid, type_index_2) && is_connected_2) {
+        return ResultNpadNotConnected;
     }
 
-    UpdateControllerAt(type_index_2, npad_id_1, is_connected_2);
-    UpdateControllerAt(type_index_1, npad_id_2, is_connected_1);
+    UpdateControllerAt(aruid, type_index_2, npad_id_1, is_connected_2);
+    UpdateControllerAt(aruid, type_index_1, npad_id_2, is_connected_1);
 
     return ResultSuccess;
 }
@@ -1100,68 +1118,68 @@ Result NPad::SwapNpadAssignment(Core::HID::NpadIdType npad_id_1, Core::HID::Npad
 Result NPad::GetLedPattern(Core::HID::NpadIdType npad_id, Core::HID::LedPattern& pattern) const {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
-        return InvalidNpadId;
+        return ResultInvalidNpadId;
     }
-    const auto& controller = GetControllerFromNpadIdType(npad_id).device;
+    const auto aruid = applet_resource_holder.applet_resource->GetActiveAruid();
+    const auto& controller = GetControllerFromNpadIdType(aruid, npad_id).device;
     pattern = controller->GetLedPattern();
     return ResultSuccess;
 }
 
-Result NPad::IsUnintendedHomeButtonInputProtectionEnabled(Core::HID::NpadIdType npad_id,
-                                                          bool& is_valid) const {
-    if (!IsNpadIdValid(npad_id)) {
-        LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
-        return InvalidNpadId;
-    }
-    const auto& controller = GetControllerFromNpadIdType(npad_id);
-    is_valid = controller.unintended_home_button_input_protection;
-    return ResultSuccess;
+Result NPad::IsUnintendedHomeButtonInputProtectionEnabled(bool& out_is_enabled, u64 aruid,
+                                                          Core::HID::NpadIdType npad_id) const {
+    std::scoped_lock lock{mutex};
+    return npad_resource.GetHomeProtectionEnabled(out_is_enabled, aruid, npad_id);
 }
 
-Result NPad::SetUnintendedHomeButtonInputProtectionEnabled(bool is_protection_enabled,
-                                                           Core::HID::NpadIdType npad_id) {
-    if (!IsNpadIdValid(npad_id)) {
-        LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
-        return InvalidNpadId;
-    }
-    auto& controller = GetControllerFromNpadIdType(npad_id);
-    controller.unintended_home_button_input_protection = is_protection_enabled;
-    return ResultSuccess;
+Result NPad::EnableUnintendedHomeButtonInputProtection(u64 aruid, Core::HID::NpadIdType npad_id,
+                                                       bool is_enabled) {
+    std::scoped_lock lock{mutex};
+    return npad_resource.SetHomeProtectionEnabled(aruid, npad_id, is_enabled);
 }
 
-void NPad::SetAnalogStickUseCenterClamp(bool use_center_clamp) {
-    analog_stick_use_center_clamp = use_center_clamp;
+void NPad::SetNpadAnalogStickUseCenterClamp(u64 aruid, bool is_enabled) {
+    std::scoped_lock lock{mutex};
+    npad_resource.SetNpadAnalogStickUseCenterClamp(aruid, is_enabled);
 }
 
 void NPad::ClearAllConnectedControllers() {
-    for (auto& controller : controller_data) {
-        if (controller.device->IsConnected() &&
-            controller.device->GetNpadStyleIndex() != Core::HID::NpadStyleIndex::None) {
-            controller.device->Disconnect();
-            controller.device->SetNpadStyleIndex(Core::HID::NpadStyleIndex::None);
+    for (std::size_t aruid_index = 0; aruid_index < AruidIndexMax; aruid_index++) {
+        for (auto& controller : controller_data[aruid_index]) {
+            if (controller.device->IsConnected() &&
+                controller.device->GetNpadStyleIndex() != Core::HID::NpadStyleIndex::None) {
+                controller.device->Disconnect();
+                controller.device->SetNpadStyleIndex(Core::HID::NpadStyleIndex::None);
+            }
         }
     }
 }
 
 void NPad::DisconnectAllConnectedControllers() {
-    for (auto& controller : controller_data) {
-        controller.device->Disconnect();
+    for (std::size_t aruid_index = 0; aruid_index < AruidIndexMax; aruid_index++) {
+        for (auto& controller : controller_data[aruid_index]) {
+            controller.device->Disconnect();
+        }
     }
 }
 
 void NPad::ConnectAllDisconnectedControllers() {
-    for (auto& controller : controller_data) {
-        if (controller.device->GetNpadStyleIndex() != Core::HID::NpadStyleIndex::None &&
-            !controller.device->IsConnected()) {
-            controller.device->Connect();
+    for (std::size_t aruid_index = 0; aruid_index < AruidIndexMax; aruid_index++) {
+        for (auto& controller : controller_data[aruid_index]) {
+            if (controller.device->GetNpadStyleIndex() != Core::HID::NpadStyleIndex::None &&
+                !controller.device->IsConnected()) {
+                controller.device->Connect();
+            }
         }
     }
 }
 
 void NPad::ClearAllControllers() {
-    for (auto& controller : controller_data) {
-        controller.device->Disconnect();
-        controller.device->SetNpadStyleIndex(Core::HID::NpadStyleIndex::None);
+    for (std::size_t aruid_index = 0; aruid_index < AruidIndexMax; aruid_index++) {
+        for (auto& controller : controller_data[aruid_index]) {
+            controller.device->Disconnect();
+            controller.device->SetNpadStyleIndex(Core::HID::NpadStyleIndex::None);
+        }
     }
 }
 
@@ -1169,128 +1187,105 @@ Core::HID::NpadButton NPad::GetAndResetPressState() {
     return static_cast<Core::HID::NpadButton>(press_state.exchange(0));
 }
 
-void NPad::ApplyNpadSystemCommonPolicy() {
-    Core::HID::NpadStyleTag styletag{};
-    styletag.fullkey.Assign(1);
-    styletag.handheld.Assign(1);
-    styletag.joycon_dual.Assign(1);
-    styletag.system_ext.Assign(1);
-    styletag.system.Assign(1);
-    SetSupportedStyleSet(styletag);
-
-    SetNpadHandheldActivationMode(NpadHandheldActivationMode::Dual);
-
-    supported_npad_id_types.clear();
-    supported_npad_id_types.resize(10);
-    supported_npad_id_types[0] = Core::HID::NpadIdType::Player1;
-    supported_npad_id_types[1] = Core::HID::NpadIdType::Player2;
-    supported_npad_id_types[2] = Core::HID::NpadIdType::Player3;
-    supported_npad_id_types[3] = Core::HID::NpadIdType::Player4;
-    supported_npad_id_types[4] = Core::HID::NpadIdType::Player5;
-    supported_npad_id_types[5] = Core::HID::NpadIdType::Player6;
-    supported_npad_id_types[6] = Core::HID::NpadIdType::Player7;
-    supported_npad_id_types[7] = Core::HID::NpadIdType::Player8;
-    supported_npad_id_types[8] = Core::HID::NpadIdType::Other;
-    supported_npad_id_types[9] = Core::HID::NpadIdType::Handheld;
-}
-
-bool NPad::IsControllerSupported(Core::HID::NpadStyleIndex controller) const {
-    if (controller == Core::HID::NpadStyleIndex::Handheld) {
-        const bool support_handheld =
-            std::find(supported_npad_id_types.begin(), supported_npad_id_types.end(),
-                      Core::HID::NpadIdType::Handheld) != supported_npad_id_types.end();
-        // Handheld is not even a supported type, lets stop here
-        if (!support_handheld) {
-            return false;
-        }
-        // Handheld shouldn't be supported in docked mode
-        if (Settings::IsDockedMode()) {
-            return false;
-        }
+Result NPad::ApplyNpadSystemCommonPolicy(u64 aruid) {
+    std::scoped_lock lock{mutex};
+    const Result result = npad_resource.ApplyNpadSystemCommonPolicy(aruid, false);
+    if (result.IsSuccess()) {
+        OnUpdate({});
+    }
+    return result;
+}
 
-        return true;
-    }
-
-    if (std::any_of(supported_npad_id_types.begin(), supported_npad_id_types.end(),
-                    [](Core::HID::NpadIdType npad_id) {
-                        return npad_id <= Core::HID::NpadIdType::Player8;
-                    })) {
-        Core::HID::NpadStyleTag style = GetSupportedStyleSet();
-        switch (controller) {
-        case Core::HID::NpadStyleIndex::ProController:
-            return style.fullkey.As<bool>();
-        case Core::HID::NpadStyleIndex::JoyconDual:
-            return style.joycon_dual.As<bool>();
-        case Core::HID::NpadStyleIndex::JoyconLeft:
-            return style.joycon_left.As<bool>();
-        case Core::HID::NpadStyleIndex::JoyconRight:
-            return style.joycon_right.As<bool>();
-        case Core::HID::NpadStyleIndex::GameCube:
-            return style.gamecube.As<bool>();
-        case Core::HID::NpadStyleIndex::Pokeball:
-            return style.palma.As<bool>();
-        case Core::HID::NpadStyleIndex::NES:
-            return style.lark.As<bool>();
-        case Core::HID::NpadStyleIndex::SNES:
-            return style.lucia.As<bool>();
-        case Core::HID::NpadStyleIndex::N64:
-            return style.lagoon.As<bool>();
-        case Core::HID::NpadStyleIndex::SegaGenesis:
-            return style.lager.As<bool>();
-        default:
-            return false;
-        }
+Result NPad::ApplyNpadSystemCommonPolicyFull(u64 aruid) {
+    std::scoped_lock lock{mutex};
+    const Result result = npad_resource.ApplyNpadSystemCommonPolicy(aruid, true);
+    if (result.IsSuccess()) {
+        OnUpdate({});
     }
+    return result;
+}
+
+Result NPad::ClearNpadSystemCommonPolicy(u64 aruid) {
+    std::scoped_lock lock{mutex};
+    const Result result = npad_resource.ClearNpadSystemCommonPolicy(aruid);
+    if (result.IsSuccess()) {
+        OnUpdate({});
+    }
+    return result;
+}
+
+void NPad::SetRevision(u64 aruid, NpadRevision revision) {
+    npad_resource.SetNpadRevision(aruid, revision);
+}
+
+NpadRevision NPad::GetRevision(u64 aruid) {
+    return npad_resource.GetNpadRevision(aruid);
+}
+
+Result NPad::RegisterAppletResourceUserId(u64 aruid) {
+    return npad_resource.RegisterAppletResourceUserId(aruid);
+}
+
+void NPad::UnregisterAppletResourceUserId(u64 aruid) {
+    npad_resource.UnregisterAppletResourceUserId(aruid);
+}
 
-    return false;
+void NPad::SetNpadExternals(std::shared_ptr<AppletResource> resource,
+                            std::recursive_mutex* shared_mutex) {
+    applet_resource_holder.applet_resource = resource;
+    applet_resource_holder.shared_mutex = shared_mutex;
+    applet_resource_holder.shared_npad_resource = &npad_resource;
 }
 
 NPad::NpadControllerData& NPad::GetControllerFromHandle(
-    const Core::HID::VibrationDeviceHandle& device_handle) {
+    u64 aruid, const Core::HID::VibrationDeviceHandle& device_handle) {
     const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
-    return GetControllerFromNpadIdType(npad_id);
+    return GetControllerFromNpadIdType(aruid, npad_id);
 }
 
 const NPad::NpadControllerData& NPad::GetControllerFromHandle(
-    const Core::HID::VibrationDeviceHandle& device_handle) const {
+    u64 aruid, const Core::HID::VibrationDeviceHandle& device_handle) const {
     const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
-    return GetControllerFromNpadIdType(npad_id);
+    return GetControllerFromNpadIdType(aruid, npad_id);
 }
 
 NPad::NpadControllerData& NPad::GetControllerFromHandle(
-    const Core::HID::SixAxisSensorHandle& device_handle) {
+    u64 aruid, const Core::HID::SixAxisSensorHandle& device_handle) {
     const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
-    return GetControllerFromNpadIdType(npad_id);
+    return GetControllerFromNpadIdType(aruid, npad_id);
 }
 
 const NPad::NpadControllerData& NPad::GetControllerFromHandle(
-    const Core::HID::SixAxisSensorHandle& device_handle) const {
+    u64 aruid, const Core::HID::SixAxisSensorHandle& device_handle) const {
     const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
-    return GetControllerFromNpadIdType(npad_id);
+    return GetControllerFromNpadIdType(aruid, npad_id);
 }
 
-NPad::NpadControllerData& NPad::GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id) {
+NPad::NpadControllerData& NPad::GetControllerFromNpadIdType(u64 aruid,
+                                                            Core::HID::NpadIdType npad_id) {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         npad_id = Core::HID::NpadIdType::Player1;
     }
     const auto npad_index = NpadIdTypeToIndex(npad_id);
-    return controller_data[npad_index];
+    const auto aruid_index = applet_resource_holder.applet_resource->GetIndexFromAruid(aruid);
+    return controller_data[aruid_index][npad_index];
 }
 
 const NPad::NpadControllerData& NPad::GetControllerFromNpadIdType(
-    Core::HID::NpadIdType npad_id) const {
+    u64 aruid, Core::HID::NpadIdType npad_id) const {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         npad_id = Core::HID::NpadIdType::Player1;
     }
     const auto npad_index = NpadIdTypeToIndex(npad_id);
-    return controller_data[npad_index];
+    const auto aruid_index = applet_resource_holder.applet_resource->GetIndexFromAruid(aruid);
+    return controller_data[aruid_index][npad_index];
 }
 
 Core::HID::SixAxisSensorProperties& NPad::GetSixaxisProperties(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle) {
-    auto& controller = GetControllerFromHandle(sixaxis_handle);
+    u64 aruid, const Core::HID::SixAxisSensorHandle& sixaxis_handle) {
+    auto& controller = GetControllerFromHandle(aruid, sixaxis_handle);
     switch (sixaxis_handle.npad_type) {
     case Core::HID::NpadStyleIndex::ProController:
     case Core::HID::NpadStyleIndex::Pokeball:
@@ -1312,8 +1307,8 @@ Core::HID::SixAxisSensorProperties& NPad::GetSixaxisProperties(
 }
 
 const Core::HID::SixAxisSensorProperties& NPad::GetSixaxisProperties(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle) const {
-    const auto& controller = GetControllerFromHandle(sixaxis_handle);
+    u64 aruid, const Core::HID::SixAxisSensorHandle& sixaxis_handle) const {
+    const auto& controller = GetControllerFromHandle(aruid, sixaxis_handle);
     switch (sixaxis_handle.npad_type) {
     case Core::HID::NpadStyleIndex::ProController:
     case Core::HID::NpadStyleIndex::Pokeball:
@@ -1335,7 +1330,8 @@ const Core::HID::SixAxisSensorProperties& NPad::GetSixaxisProperties(
 }
 
 AppletDetailedUiType NPad::GetAppletDetailedUiType(Core::HID::NpadIdType npad_id) {
-    const auto& shared_memory = GetControllerFromNpadIdType(npad_id).shared_memory;
+    const auto aruid = applet_resource_holder.applet_resource->GetActiveAruid();
+    const auto& shared_memory = GetControllerFromNpadIdType(aruid, npad_id).shared_memory;
 
     return {
         .ui_variant = 0,
diff --git a/src/core/hle/service/hid/controllers/npad.h b/src/core/hle/service/hid/controllers/npad.h
index 80cfcb2bbbbf..8ab33306484e 100644
--- a/src/core/hle/service/hid/controllers/npad.h
+++ b/src/core/hle/service/hid/controllers/npad.h
@@ -11,6 +11,7 @@
 #include "common/common_types.h"
 #include "core/hid/hid_types.h"
 #include "core/hle/service/hid/controllers/controller_base.h"
+#include "core/hle/service/hid/controllers/npad/npad_resource.h"
 #include "core/hle/service/hid/controllers/types/npad_types.h"
 
 namespace Core::HID {
@@ -35,99 +36,116 @@ struct NpadInternalState;
 struct NpadSixAxisSensorLifo;
 struct NpadSharedMemoryFormat;
 
-class NPad final : public ControllerBase {
+class NPad final {
 public:
     explicit NPad(Core::HID::HIDCore& hid_core_, KernelHelpers::ServiceContext& service_context_);
-    ~NPad() override;
+    ~NPad();
 
-    // Called when the controller is initialized
-    void OnInit() override;
+    Result Activate();
+    Result Activate(u64 aruid);
 
-    // When the controller is released
-    void OnRelease() override;
+    Result ActivateNpadResource();
+    Result ActivateNpadResource(u64 aruid);
 
     // When the controller is requesting an update for the shared memory
-    void OnUpdate(const Core::Timing::CoreTiming& core_timing) override;
+    void OnUpdate(const Core::Timing::CoreTiming& core_timing);
 
-    void SetSupportedStyleSet(Core::HID::NpadStyleTag style_set);
-    Core::HID::NpadStyleTag GetSupportedStyleSet() const;
+    Result SetSupportedNpadStyleSet(u64 aruid, Core::HID::NpadStyleSet supported_style_set);
+    Result GetSupportedNpadStyleSet(u64 aruid,
+                                    Core::HID::NpadStyleSet& out_supported_style_set) const;
+    Result GetMaskedSupportedNpadStyleSet(u64 aruid,
+                                          Core::HID::NpadStyleSet& out_supported_style_set) const;
 
-    Result SetSupportedNpadIdTypes(std::span<const u8> data);
-    void GetSupportedNpadIdTypes(u32* data, std::size_t max_length);
-    std::size_t GetSupportedNpadIdTypesSize() const;
+    Result SetSupportedNpadIdType(u64 aruid,
+                                  std::span<const Core::HID::NpadIdType> supported_npad_list);
 
-    void SetHoldType(NpadJoyHoldType joy_hold_type);
-    NpadJoyHoldType GetHoldType() const;
+    Result SetNpadJoyHoldType(u64 aruid, NpadJoyHoldType hold_type);
+    Result GetNpadJoyHoldType(u64 aruid, NpadJoyHoldType& out_hold_type) const;
 
-    void SetNpadHandheldActivationMode(NpadHandheldActivationMode activation_mode);
-    NpadHandheldActivationMode GetNpadHandheldActivationMode() const;
+    Result SetNpadHandheldActivationMode(u64 aruid, NpadHandheldActivationMode mode);
+    Result GetNpadHandheldActivationMode(u64 aruid, NpadHandheldActivationMode& out_mode) const;
 
-    void SetNpadCommunicationMode(NpadCommunicationMode communication_mode_);
-    NpadCommunicationMode GetNpadCommunicationMode() const;
-
-    bool SetNpadMode(Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType npad_id,
+    bool SetNpadMode(u64 aruid, Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType npad_id,
                      NpadJoyDeviceType npad_device_type, NpadJoyAssignmentMode assignment_mode);
 
-    bool VibrateControllerAtIndex(Core::HID::NpadIdType npad_id, std::size_t device_index,
+    bool VibrateControllerAtIndex(u64 aruid, Core::HID::NpadIdType npad_id,
+                                  std::size_t device_index,
                                   const Core::HID::VibrationValue& vibration_value);
 
-    void VibrateController(const Core::HID::VibrationDeviceHandle& vibration_device_handle,
+    void VibrateController(u64 aruid,
+                           const Core::HID::VibrationDeviceHandle& vibration_device_handle,
                            const Core::HID::VibrationValue& vibration_value);
 
     void VibrateControllers(
-        std::span<const Core::HID::VibrationDeviceHandle> vibration_device_handles,
+        u64 aruid, std::span<const Core::HID::VibrationDeviceHandle> vibration_device_handles,
         std::span<const Core::HID::VibrationValue> vibration_values);
 
     Core::HID::VibrationValue GetLastVibration(
-        const Core::HID::VibrationDeviceHandle& vibration_device_handle) const;
+        u64 aruid, const Core::HID::VibrationDeviceHandle& vibration_device_handle) const;
 
     void InitializeVibrationDevice(const Core::HID::VibrationDeviceHandle& vibration_device_handle);
 
-    void InitializeVibrationDeviceAtIndex(Core::HID::NpadIdType npad_id, std::size_t device_index);
+    void InitializeVibrationDeviceAtIndex(u64 aruid, Core::HID::NpadIdType npad_id,
+                                          std::size_t device_index);
 
     void SetPermitVibrationSession(bool permit_vibration_session);
 
     bool IsVibrationDeviceMounted(
-        const Core::HID::VibrationDeviceHandle& vibration_device_handle) const;
+        u64 aruid, const Core::HID::VibrationDeviceHandle& vibration_device_handle) const;
 
-    Kernel::KReadableEvent& GetStyleSetChangedEvent(Core::HID::NpadIdType npad_id);
-    void SignalStyleSetChangedEvent(Core::HID::NpadIdType npad_id) const;
+    Result AcquireNpadStyleSetUpdateEventHandle(u64 aruid, Kernel::KReadableEvent** out_event,
+                                                Core::HID::NpadIdType npad_id);
 
     // Adds a new controller at an index.
-    void AddNewControllerAt(Core::HID::NpadStyleIndex controller, Core::HID::NpadIdType npad_id);
+    void AddNewControllerAt(u64 aruid, Core::HID::NpadStyleIndex controller,
+                            Core::HID::NpadIdType npad_id);
     // Adds a new controller at an index with connection status.
-    void UpdateControllerAt(Core::HID::NpadStyleIndex controller, Core::HID::NpadIdType npad_id,
-                            bool connected);
+    void UpdateControllerAt(u64 aruid, Core::HID::NpadStyleIndex controller,
+                            Core::HID::NpadIdType npad_id, bool connected);
 
-    Result DisconnectNpad(Core::HID::NpadIdType npad_id);
+    Result DisconnectNpad(u64 aruid, Core::HID::NpadIdType npad_id);
 
     Result IsFirmwareUpdateAvailableForSixAxisSensor(
-        const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_firmware_available) const;
+        u64 aruid, const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+        bool& is_firmware_available) const;
     Result ResetIsSixAxisSensorDeviceNewlyAssigned(
-        const Core::HID::SixAxisSensorHandle& sixaxis_handle);
+        u64 aruid, const Core::HID::SixAxisSensorHandle& sixaxis_handle);
 
     Result GetLedPattern(Core::HID::NpadIdType npad_id, Core::HID::LedPattern& pattern) const;
-    Result IsUnintendedHomeButtonInputProtectionEnabled(Core::HID::NpadIdType npad_id,
-                                                        bool& is_enabled) const;
-    Result SetUnintendedHomeButtonInputProtectionEnabled(bool is_protection_enabled,
-                                                         Core::HID::NpadIdType npad_id);
-    void SetAnalogStickUseCenterClamp(bool use_center_clamp);
+
+    Result IsUnintendedHomeButtonInputProtectionEnabled(bool& out_is_enabled, u64 aruid,
+                                                        Core::HID::NpadIdType npad_id) const;
+    Result EnableUnintendedHomeButtonInputProtection(u64 aruid, Core::HID::NpadIdType npad_id,
+                                                     bool is_enabled);
+
+    void SetNpadAnalogStickUseCenterClamp(u64 aruid, bool is_enabled);
     void ClearAllConnectedControllers();
     void DisconnectAllConnectedControllers();
     void ConnectAllDisconnectedControllers();
     void ClearAllControllers();
 
-    Result MergeSingleJoyAsDualJoy(Core::HID::NpadIdType npad_id_1,
+    Result MergeSingleJoyAsDualJoy(u64 aruid, Core::HID::NpadIdType npad_id_1,
                                    Core::HID::NpadIdType npad_id_2);
-    void StartLRAssignmentMode();
-    void StopLRAssignmentMode();
-    Result SwapNpadAssignment(Core::HID::NpadIdType npad_id_1, Core::HID::NpadIdType npad_id_2);
+    Result StartLrAssignmentMode(u64 aruid);
+    Result StopLrAssignmentMode(u64 aruid);
+    Result SwapNpadAssignment(u64 aruid, Core::HID::NpadIdType npad_id_1,
+                              Core::HID::NpadIdType npad_id_2);
 
     // Logical OR for all buttons presses on all controllers
     // Specifically for cheat engine and other features.
     Core::HID::NpadButton GetAndResetPressState();
 
-    void ApplyNpadSystemCommonPolicy();
+    Result ApplyNpadSystemCommonPolicy(u64 aruid);
+    Result ApplyNpadSystemCommonPolicyFull(u64 aruid);
+    Result ClearNpadSystemCommonPolicy(u64 aruid);
+
+    void SetRevision(u64 aruid, NpadRevision revision);
+    NpadRevision GetRevision(u64 aruid);
+
+    Result RegisterAppletResourceUserId(u64 aruid);
+    void UnregisterAppletResourceUserId(u64 aruid);
+    void SetNpadExternals(std::shared_ptr<AppletResource> resource,
+                          std::recursive_mutex* shared_mutex);
 
     AppletDetailedUiType GetAppletDetailedUiType(Core::HID::NpadIdType npad_id);
 
@@ -139,12 +157,10 @@ class NPad final : public ControllerBase {
     };
 
     struct NpadControllerData {
-        Kernel::KEvent* styleset_changed_event{};
         NpadInternalState* shared_memory = nullptr;
         Core::HID::EmulatedController* device = nullptr;
 
         std::array<VibrationData, 2> vibration{};
-        bool unintended_home_button_input_protection{};
         bool is_connected{};
 
         // Dual joycons can have only one side connected
@@ -159,39 +175,40 @@ class NPad final : public ControllerBase {
     };
 
     void ControllerUpdate(Core::HID::ControllerTriggerType type, std::size_t controller_idx);
-    void InitNewlyAddedController(Core::HID::NpadIdType npad_id);
-    bool IsControllerSupported(Core::HID::NpadStyleIndex controller) const;
-    void RequestPadStateUpdate(Core::HID::NpadIdType npad_id);
+    void InitNewlyAddedController(u64 aruid, Core::HID::NpadIdType npad_id);
+    void RequestPadStateUpdate(u64 aruid, Core::HID::NpadIdType npad_id);
     void WriteEmptyEntry(NpadInternalState* npad);
 
     NpadControllerData& GetControllerFromHandle(
-        const Core::HID::VibrationDeviceHandle& device_handle);
+        u64 aruid, const Core::HID::VibrationDeviceHandle& device_handle);
     const NpadControllerData& GetControllerFromHandle(
-        const Core::HID::VibrationDeviceHandle& device_handle) const;
+        u64 aruid, const Core::HID::VibrationDeviceHandle& device_handle) const;
     NpadControllerData& GetControllerFromHandle(
-        const Core::HID::SixAxisSensorHandle& device_handle);
+        u64 aruid, const Core::HID::SixAxisSensorHandle& device_handle);
     const NpadControllerData& GetControllerFromHandle(
-        const Core::HID::SixAxisSensorHandle& device_handle) const;
-    NpadControllerData& GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id);
-    const NpadControllerData& GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id) const;
+        u64 aruid, const Core::HID::SixAxisSensorHandle& device_handle) const;
+    NpadControllerData& GetControllerFromNpadIdType(u64 aruid, Core::HID::NpadIdType npad_id);
+    const NpadControllerData& GetControllerFromNpadIdType(u64 aruid,
+                                                          Core::HID::NpadIdType npad_id) const;
 
     Core::HID::SixAxisSensorProperties& GetSixaxisProperties(
-        const Core::HID::SixAxisSensorHandle& device_handle);
+        u64 aruid, const Core::HID::SixAxisSensorHandle& device_handle);
     const Core::HID::SixAxisSensorProperties& GetSixaxisProperties(
-        const Core::HID::SixAxisSensorHandle& device_handle) const;
+        u64 aruid, const Core::HID::SixAxisSensorHandle& device_handle) const;
 
-    std::atomic<u64> press_state{};
-
-    std::array<NpadControllerData, NpadCount> controller_data{};
+    Core::HID::HIDCore& hid_core;
     KernelHelpers::ServiceContext& service_context;
-    std::mutex mutex;
-    std::vector<Core::HID::NpadIdType> supported_npad_id_types{};
-    NpadJoyHoldType hold_type{NpadJoyHoldType::Vertical};
-    NpadHandheldActivationMode handheld_activation_mode{NpadHandheldActivationMode::Dual};
-    NpadCommunicationMode communication_mode{NpadCommunicationMode::Default};
-    bool permit_vibration_session_enabled{false};
-    bool analog_stick_use_center_clamp{false};
-    bool is_in_lr_assignment_mode{false};
-    bool is_controller_initialized{false};
+
+    s32 ref_counter{};
+    mutable std::mutex mutex;
+    NPadResource npad_resource;
+    AppletResourceHolder applet_resource_holder{};
+    Kernel::KEvent* input_event{nullptr};
+    std::mutex* input_mutex{nullptr};
+
+    std::atomic<u64> press_state{};
+    bool permit_vibration_session_enabled;
+    std::array<std::array<NpadControllerData, MaxSupportedNpadIdTypes>, AruidIndexMax>
+        controller_data{};
 };
 } // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/npad/npad_data.cpp b/src/core/hle/service/hid/controllers/npad/npad_data.cpp
new file mode 100644
index 000000000000..c8cfe5d0ec74
--- /dev/null
+++ b/src/core/hle/service/hid/controllers/npad/npad_data.cpp
@@ -0,0 +1,226 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "core/hle/service/hid/controllers/npad/npad_data.h"
+#include "core/hle/service/hid/hid_util.h"
+
+namespace Service::HID {
+
+NPadData::NPadData() {
+    ClearNpadSystemCommonPolicy();
+}
+
+NPadData::~NPadData() = default;
+
+NpadStatus NPadData::GetNpadStatus() const {
+    return status;
+}
+
+void NPadData::SetNpadAnalogStickUseCenterClamp(bool is_enabled) {
+    status.use_center_clamp.Assign(is_enabled);
+}
+
+bool NPadData::GetNpadAnalogStickUseCenterClamp() const {
+    return status.use_center_clamp.As<bool>();
+}
+
+void NPadData::SetNpadSystemExtStateEnabled(bool is_enabled) {
+    status.system_ext_state.Assign(is_enabled);
+}
+
+bool NPadData::GetNpadSystemExtState() const {
+    return status.system_ext_state.As<bool>();
+}
+
+Result NPadData::SetSupportedNpadIdType(std::span<const Core::HID::NpadIdType> list) {
+    // Note: Real limit is 11. But array size is 10. N's bug?
+    if (list.size() > MaxSupportedNpadIdTypes) {
+        return ResultInvalidArraySize;
+    }
+
+    supported_npad_id_types_count = list.size();
+    memcpy(supported_npad_id_types.data(), list.data(),
+           list.size() * sizeof(Core::HID::NpadIdType));
+
+    return ResultSuccess;
+}
+
+std::size_t NPadData::GetSupportedNpadIdType(std::span<Core::HID::NpadIdType> out_list) const {
+    std::size_t out_size = std::min(supported_npad_id_types_count, out_list.size());
+
+    memcpy(out_list.data(), supported_npad_id_types.data(),
+           out_size * sizeof(Core::HID::NpadIdType));
+
+    return out_size;
+}
+
+bool NPadData::IsNpadIdTypeSupported(Core::HID::NpadIdType npad_id) const {
+    for (std::size_t i = 0; i < supported_npad_id_types_count; i++) {
+        if (supported_npad_id_types[i] == npad_id) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void NPadData::SetNpadSystemCommonPolicy(bool is_full_policy) {
+    supported_npad_style_set = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::JoyDual |
+                               Core::HID::NpadStyleSet::SystemExt | Core::HID::NpadStyleSet::System;
+    handheld_activation_mode = NpadHandheldActivationMode::Dual;
+
+    status.is_supported_styleset_set.Assign(true);
+    status.is_hold_type_set.Assign(true);
+    status.lr_assignment_mode.Assign(false);
+    status.is_policy.Assign(true);
+    if (is_full_policy) {
+        status.is_full_policy.Assign(true);
+    }
+
+    supported_npad_id_types_count = 10;
+    supported_npad_id_types[0] = Core::HID::NpadIdType::Player1;
+    supported_npad_id_types[1] = Core::HID::NpadIdType::Player2;
+    supported_npad_id_types[2] = Core::HID::NpadIdType::Player3;
+    supported_npad_id_types[3] = Core::HID::NpadIdType::Player4;
+    supported_npad_id_types[4] = Core::HID::NpadIdType::Player5;
+    supported_npad_id_types[5] = Core::HID::NpadIdType::Player6;
+    supported_npad_id_types[6] = Core::HID::NpadIdType::Player7;
+    supported_npad_id_types[7] = Core::HID::NpadIdType::Player8;
+    supported_npad_id_types[8] = Core::HID::NpadIdType::Other;
+    supported_npad_id_types[9] = Core::HID::NpadIdType::Handheld;
+
+    for (auto& input_protection : is_unintended_home_button_input_protection) {
+        input_protection = true;
+    }
+}
+
+void NPadData::ClearNpadSystemCommonPolicy() {
+    status.raw = 0;
+    supported_npad_style_set = Core::HID::NpadStyleSet::All;
+    npad_hold_type = NpadJoyHoldType::Vertical;
+    handheld_activation_mode = NpadHandheldActivationMode::Dual;
+
+    for (auto& button_assignment : npad_button_assignment) {
+        button_assignment = Core::HID::NpadButton::None;
+    }
+
+    supported_npad_id_types_count = 10;
+    supported_npad_id_types[0] = Core::HID::NpadIdType::Player1;
+    supported_npad_id_types[1] = Core::HID::NpadIdType::Player2;
+    supported_npad_id_types[2] = Core::HID::NpadIdType::Player3;
+    supported_npad_id_types[3] = Core::HID::NpadIdType::Player4;
+    supported_npad_id_types[4] = Core::HID::NpadIdType::Player5;
+    supported_npad_id_types[5] = Core::HID::NpadIdType::Player6;
+    supported_npad_id_types[6] = Core::HID::NpadIdType::Player7;
+    supported_npad_id_types[7] = Core::HID::NpadIdType::Player8;
+    supported_npad_id_types[8] = Core::HID::NpadIdType::Other;
+    supported_npad_id_types[9] = Core::HID::NpadIdType::Handheld;
+
+    for (auto& input_protection : is_unintended_home_button_input_protection) {
+        input_protection = true;
+    }
+}
+
+void NPadData::SetNpadJoyHoldType(NpadJoyHoldType hold_type) {
+    npad_hold_type = hold_type;
+    status.is_hold_type_set.Assign(true);
+}
+
+NpadJoyHoldType NPadData::GetNpadJoyHoldType() const {
+    return npad_hold_type;
+}
+
+void NPadData::SetHandheldActivationMode(NpadHandheldActivationMode activation_mode) {
+    handheld_activation_mode = activation_mode;
+}
+
+NpadHandheldActivationMode NPadData::GetHandheldActivationMode() const {
+    return handheld_activation_mode;
+}
+
+void NPadData::SetSupportedNpadStyleSet(Core::HID::NpadStyleSet style_set) {
+    supported_npad_style_set = style_set;
+    status.is_supported_styleset_set.Assign(true);
+    status.is_hold_type_set.Assign(true);
+}
+
+Core::HID::NpadStyleSet NPadData::GetSupportedNpadStyleSet() const {
+    return supported_npad_style_set;
+}
+
+bool NPadData::IsNpadStyleIndexSupported(Core::HID::NpadStyleIndex style_index) const {
+    Core::HID::NpadStyleTag style = {supported_npad_style_set};
+    switch (style_index) {
+    case Core::HID::NpadStyleIndex::ProController:
+        return style.fullkey.As<bool>();
+    case Core::HID::NpadStyleIndex::JoyconDual:
+        return style.joycon_dual.As<bool>();
+    case Core::HID::NpadStyleIndex::JoyconLeft:
+        return style.joycon_left.As<bool>();
+    case Core::HID::NpadStyleIndex::JoyconRight:
+        return style.joycon_right.As<bool>();
+    case Core::HID::NpadStyleIndex::GameCube:
+        return style.gamecube.As<bool>();
+    case Core::HID::NpadStyleIndex::Pokeball:
+        return style.palma.As<bool>();
+    case Core::HID::NpadStyleIndex::NES:
+        return style.lark.As<bool>();
+    case Core::HID::NpadStyleIndex::SNES:
+        return style.lucia.As<bool>();
+    case Core::HID::NpadStyleIndex::N64:
+        return style.lagoon.As<bool>();
+    case Core::HID::NpadStyleIndex::SegaGenesis:
+        return style.lager.As<bool>();
+    default:
+        return false;
+    }
+}
+
+void NPadData::SetLrAssignmentMode(bool is_enabled) {
+    status.lr_assignment_mode.Assign(is_enabled);
+}
+
+bool NPadData::GetLrAssignmentMode() const {
+    return status.lr_assignment_mode.As<bool>();
+}
+
+void NPadData::SetAssigningSingleOnSlSrPress(bool is_enabled) {
+    status.assigning_single_on_sl_sr_press.Assign(is_enabled);
+}
+
+bool NPadData::GetAssigningSingleOnSlSrPress() const {
+    return status.assigning_single_on_sl_sr_press.As<bool>();
+}
+
+void NPadData::SetHomeProtectionEnabled(bool is_enabled, Core::HID::NpadIdType npad_id) {
+    is_unintended_home_button_input_protection[NpadIdTypeToIndex(npad_id)] = is_enabled;
+}
+
+bool NPadData::GetHomeProtectionEnabled(Core::HID::NpadIdType npad_id) const {
+    return is_unintended_home_button_input_protection[NpadIdTypeToIndex(npad_id)];
+}
+
+void NPadData::SetCaptureButtonAssignment(Core::HID::NpadButton button_assignment,
+                                          std::size_t style_index) {
+    npad_button_assignment[style_index] = button_assignment;
+}
+
+Core::HID::NpadButton NPadData::GetCaptureButtonAssignment(std::size_t style_index) const {
+    return npad_button_assignment[style_index];
+}
+
+std::size_t NPadData::GetNpadCaptureButtonAssignmentList(
+    std::span<Core::HID::NpadButton> out_list) const {
+    for (std::size_t i = 0; i < out_list.size(); i++) {
+        Core::HID::NpadStyleSet style_set = GetStylesetByIndex(i);
+        if ((style_set & supported_npad_style_set) == Core::HID::NpadStyleSet::None ||
+            npad_button_assignment[i] == Core::HID::NpadButton::None) {
+            return i;
+        }
+        out_list[i] = npad_button_assignment[i];
+    }
+
+    return out_list.size();
+}
+
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/npad/npad_data.h b/src/core/hle/service/hid/controllers/npad/npad_data.h
new file mode 100644
index 000000000000..f799a9f9c657
--- /dev/null
+++ b/src/core/hle/service/hid/controllers/npad/npad_data.h
@@ -0,0 +1,88 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#pragma once
+
+#include <array>
+#include <span>
+
+#include "common/common_types.h"
+#include "core/hid/hid_types.h"
+#include "core/hle/result.h"
+#include "core/hle/service/hid/controllers/types/npad_types.h"
+
+namespace Service::HID {
+
+struct NpadStatus {
+    union {
+        u32 raw{};
+
+        BitField<0, 1, u32> is_supported_styleset_set;
+        BitField<1, 1, u32> is_hold_type_set;
+        BitField<2, 1, u32> lr_assignment_mode;
+        BitField<3, 1, u32> assigning_single_on_sl_sr_press;
+        BitField<4, 1, u32> is_full_policy;
+        BitField<5, 1, u32> is_policy;
+        BitField<6, 1, u32> use_center_clamp;
+        BitField<7, 1, u32> system_ext_state;
+    };
+};
+static_assert(sizeof(NpadStatus) == 4, "NpadStatus is an invalid size");
+
+/// Handles Npad request from HID interfaces
+class NPadData final {
+public:
+    explicit NPadData();
+    ~NPadData();
+
+    NpadStatus GetNpadStatus() const;
+
+    void SetNpadAnalogStickUseCenterClamp(bool is_enabled);
+    bool GetNpadAnalogStickUseCenterClamp() const;
+
+    void SetNpadSystemExtStateEnabled(bool is_enabled);
+    bool GetNpadSystemExtState() const;
+
+    Result SetSupportedNpadIdType(std::span<const Core::HID::NpadIdType> list);
+    std::size_t GetSupportedNpadIdType(std::span<Core::HID::NpadIdType> out_list) const;
+    bool IsNpadIdTypeSupported(Core::HID::NpadIdType npad_id) const;
+
+    void SetNpadSystemCommonPolicy(bool is_full_policy);
+    void ClearNpadSystemCommonPolicy();
+
+    void SetNpadJoyHoldType(NpadJoyHoldType hold_type);
+    NpadJoyHoldType GetNpadJoyHoldType() const;
+
+    void SetHandheldActivationMode(NpadHandheldActivationMode activation_mode);
+    NpadHandheldActivationMode GetHandheldActivationMode() const;
+
+    void SetSupportedNpadStyleSet(Core::HID::NpadStyleSet style_set);
+    Core::HID::NpadStyleSet GetSupportedNpadStyleSet() const;
+    bool IsNpadStyleIndexSupported(Core::HID::NpadStyleIndex style_index) const;
+
+    void SetLrAssignmentMode(bool is_enabled);
+    bool GetLrAssignmentMode() const;
+
+    void SetAssigningSingleOnSlSrPress(bool is_enabled);
+    bool GetAssigningSingleOnSlSrPress() const;
+
+    void SetHomeProtectionEnabled(bool is_enabled, Core::HID::NpadIdType npad_id);
+    bool GetHomeProtectionEnabled(Core::HID::NpadIdType npad_id) const;
+
+    void SetCaptureButtonAssignment(Core::HID::NpadButton button_assignment,
+                                    std::size_t style_index);
+    Core::HID::NpadButton GetCaptureButtonAssignment(std::size_t style_index) const;
+    std::size_t GetNpadCaptureButtonAssignmentList(std::span<Core::HID::NpadButton> out_list) const;
+
+private:
+    NpadStatus status{};
+    Core::HID::NpadStyleSet supported_npad_style_set{Core::HID::NpadStyleSet::All};
+    NpadJoyHoldType npad_hold_type{NpadJoyHoldType::Vertical};
+    NpadHandheldActivationMode handheld_activation_mode{};
+    std::array<Core::HID::NpadIdType, MaxSupportedNpadIdTypes> supported_npad_id_types{};
+    std::array<Core::HID::NpadButton, StyleIndexCount> npad_button_assignment{};
+    std::size_t supported_npad_id_types_count{};
+    std::array<bool, MaxSupportedNpadIdTypes> is_unintended_home_button_input_protection{};
+};
+
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/npad/npad_resource.cpp b/src/core/hle/service/hid/controllers/npad/npad_resource.cpp
new file mode 100644
index 000000000000..0a9341a39db3
--- /dev/null
+++ b/src/core/hle/service/hid/controllers/npad/npad_resource.cpp
@@ -0,0 +1,685 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "core/hle/kernel/k_event.h"
+#include "core/hle/kernel/k_readable_event.h"
+#include "core/hle/service/hid/controllers/npad/npad_resource.h"
+#include "core/hle/service/hid/controllers/types/npad_types.h"
+#include "core/hle/service/hid/errors.h"
+#include "core/hle/service/hid/hid_util.h"
+
+namespace Service::HID {
+
+NPadResource::NPadResource(KernelHelpers::ServiceContext& context) : service_context{context} {}
+
+NPadResource::~NPadResource() = default;
+
+Result NPadResource::RegisterAppletResourceUserId(u64 aruid) {
+    const auto aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index < AruidIndexMax) {
+        return ResultAruidAlreadyRegistered;
+    }
+
+    std::size_t data_index = AruidIndexMax;
+    for (std::size_t i = 0; i < AruidIndexMax; i++) {
+        if (!state[i].flag.is_initialized) {
+            data_index = i;
+            break;
+        }
+    }
+
+    if (data_index == AruidIndexMax) {
+        return ResultAruidNoAvailableEntries;
+    }
+
+    auto& aruid_data = state[data_index];
+
+    aruid_data.aruid = aruid;
+    aruid_data.flag.is_initialized.Assign(true);
+
+    data_index = AruidIndexMax;
+    for (std::size_t i = 0; i < AruidIndexMax; i++) {
+        if (registration_list.flag[i] == RegistrationStatus::Initialized) {
+            if (registration_list.aruid[i] != aruid) {
+                continue;
+            }
+            data_index = i;
+            break;
+        }
+        if (registration_list.flag[i] == RegistrationStatus::None) {
+            data_index = i;
+            break;
+        }
+    }
+
+    if (data_index == AruidIndexMax) {
+        return ResultSuccess;
+    }
+
+    registration_list.flag[data_index] = RegistrationStatus::Initialized;
+    registration_list.aruid[data_index] = aruid;
+
+    return ResultSuccess;
+}
+
+void NPadResource::UnregisterAppletResourceUserId(u64 aruid) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+
+    DestroyStyleSetUpdateEvents(aruid);
+    if (aruid_index < AruidIndexMax) {
+        state[aruid_index] = {};
+        registration_list.flag[aruid_index] = RegistrationStatus::PendingDelete;
+    }
+}
+
+void NPadResource::DestroyStyleSetUpdateEvents(u64 aruid) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+
+    if (aruid_index >= AruidIndexMax) {
+        return;
+    }
+
+    for (auto& controller_state : state[aruid_index].controller_state) {
+        if (!controller_state.is_styleset_update_event_initialized) {
+            continue;
+        }
+        service_context.CloseEvent(controller_state.style_set_update_event);
+        controller_state.is_styleset_update_event_initialized = false;
+    }
+}
+
+Result NPadResource::Activate(u64 aruid) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+
+    if (aruid_index >= AruidIndexMax) {
+        return ResultSuccess;
+    }
+
+    auto& state_data = state[aruid_index];
+
+    if (state_data.flag.is_assigned) {
+        return ResultAruidAlreadyRegistered;
+    }
+
+    state_data.flag.is_assigned.Assign(true);
+    state_data.data.ClearNpadSystemCommonPolicy();
+    state_data.npad_revision = NpadRevision::Revision0;
+    state_data.button_config = {};
+
+    if (active_data_aruid == aruid) {
+        default_hold_type = active_data.GetNpadJoyHoldType();
+        active_data.SetNpadJoyHoldType(default_hold_type);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::Activate() {
+    if (ref_counter == std::numeric_limits<s32>::max() - 1) {
+        return ResultAppletResourceOverflow;
+    }
+    if (ref_counter == 0) {
+        RegisterAppletResourceUserId(SystemAruid);
+        Activate(SystemAruid);
+    }
+    ref_counter++;
+    return ResultSuccess;
+}
+
+Result NPadResource::Deactivate() {
+    if (ref_counter == 0) {
+        return ResultAppletResourceNotInitialized;
+    }
+
+    UnregisterAppletResourceUserId(SystemAruid);
+    ref_counter--;
+    return ResultSuccess;
+}
+
+NPadData* NPadResource::GetActiveData() {
+    return &active_data;
+}
+
+u64 NPadResource::GetActiveDataAruid() {
+    return active_data_aruid;
+}
+
+void NPadResource::SetAppletResourceUserId(u64 aruid) {
+    if (active_data_aruid == aruid) {
+        return;
+    }
+
+    active_data_aruid = aruid;
+    default_hold_type = active_data.GetNpadJoyHoldType();
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+
+    if (aruid_index >= AruidIndexMax) {
+        return;
+    }
+
+    auto& data = state[aruid_index].data;
+    if (data.GetNpadStatus().is_policy || data.GetNpadStatus().is_full_policy) {
+        data.SetNpadJoyHoldType(default_hold_type);
+    }
+
+    active_data = data;
+    if (data.GetNpadStatus().is_hold_type_set) {
+        active_data.SetNpadJoyHoldType(default_hold_type);
+    }
+}
+
+std::size_t NPadResource::GetIndexFromAruid(u64 aruid) const {
+    for (std::size_t i = 0; i < AruidIndexMax; i++) {
+        if (registration_list.flag[i] == RegistrationStatus::Initialized &&
+            registration_list.aruid[i] == aruid) {
+            return i;
+        }
+    }
+    return AruidIndexMax;
+}
+
+Result NPadResource::ApplyNpadSystemCommonPolicy(u64 aruid, bool is_full_policy) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    auto& data = state[aruid_index].data;
+    data.SetNpadSystemCommonPolicy(is_full_policy);
+    data.SetNpadJoyHoldType(default_hold_type);
+    if (active_data_aruid == aruid) {
+        active_data.SetNpadSystemCommonPolicy(is_full_policy);
+        active_data.SetNpadJoyHoldType(default_hold_type);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::ClearNpadSystemCommonPolicy(u64 aruid) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].data.ClearNpadSystemCommonPolicy();
+    if (active_data_aruid == aruid) {
+        active_data.ClearNpadSystemCommonPolicy();
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::SetSupportedNpadStyleSet(u64 aruid, Core::HID::NpadStyleSet style_set) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    auto& data = state[aruid_index].data;
+    data.SetSupportedNpadStyleSet(style_set);
+    if (active_data_aruid == aruid) {
+        active_data.SetSupportedNpadStyleSet(style_set);
+        active_data.SetNpadJoyHoldType(data.GetNpadJoyHoldType());
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::GetSupportedNpadStyleSet(Core::HID::NpadStyleSet& out_style_Set,
+                                              u64 aruid) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    auto& data = state[aruid_index].data;
+    if (!data.GetNpadStatus().is_supported_styleset_set) {
+        return ResultUndefinedStyleset;
+    }
+
+    out_style_Set = data.GetSupportedNpadStyleSet();
+    return ResultSuccess;
+}
+
+Result NPadResource::GetMaskedSupportedNpadStyleSet(Core::HID::NpadStyleSet& out_style_set,
+                                                    u64 aruid) const {
+    if (aruid == SystemAruid) {
+        out_style_set = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+                        Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+                        Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::Palma |
+                        Core::HID::NpadStyleSet::SystemExt | Core::HID::NpadStyleSet::System;
+        return ResultSuccess;
+    }
+
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    auto& data = state[aruid_index].data;
+    if (!data.GetNpadStatus().is_supported_styleset_set) {
+        return ResultUndefinedStyleset;
+    }
+
+    Core::HID::NpadStyleSet mask{Core::HID::NpadStyleSet::None};
+    out_style_set = data.GetSupportedNpadStyleSet();
+
+    switch (state[aruid_index].npad_revision) {
+    case NpadRevision::Revision1:
+        mask = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+               Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+               Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::Gc |
+               Core::HID::NpadStyleSet::Palma | Core::HID::NpadStyleSet::SystemExt |
+               Core::HID::NpadStyleSet::System;
+        break;
+    case NpadRevision::Revision2:
+        mask = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+               Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+               Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::Gc |
+               Core::HID::NpadStyleSet::Palma | Core::HID::NpadStyleSet::Lark |
+               Core::HID::NpadStyleSet::SystemExt | Core::HID::NpadStyleSet::System;
+        break;
+    case NpadRevision::Revision3:
+        mask = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+               Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+               Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::Gc |
+               Core::HID::NpadStyleSet::Palma | Core::HID::NpadStyleSet::Lark |
+               Core::HID::NpadStyleSet::HandheldLark | Core::HID::NpadStyleSet::Lucia |
+               Core::HID::NpadStyleSet::Lagoon | Core::HID::NpadStyleSet::Lager |
+               Core::HID::NpadStyleSet::SystemExt | Core::HID::NpadStyleSet::System;
+        break;
+    default:
+        mask = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+               Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+               Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::SystemExt |
+               Core::HID::NpadStyleSet::System;
+        break;
+    }
+
+    out_style_set = out_style_set & mask;
+    return ResultSuccess;
+}
+
+Result NPadResource::GetAvailableStyleset(Core::HID::NpadStyleSet& out_style_set, u64 aruid) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    auto& data = state[aruid_index].data;
+    if (!data.GetNpadStatus().is_supported_styleset_set) {
+        return ResultUndefinedStyleset;
+    }
+
+    Core::HID::NpadStyleSet mask{Core::HID::NpadStyleSet::None};
+    out_style_set = data.GetSupportedNpadStyleSet();
+
+    switch (state[aruid_index].npad_revision) {
+    case NpadRevision::Revision1:
+        mask = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+               Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+               Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::Gc |
+               Core::HID::NpadStyleSet::Palma | Core::HID::NpadStyleSet::SystemExt |
+               Core::HID::NpadStyleSet::System;
+        break;
+    case NpadRevision::Revision2:
+        mask = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+               Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+               Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::Gc |
+               Core::HID::NpadStyleSet::Palma | Core::HID::NpadStyleSet::Lark |
+               Core::HID::NpadStyleSet::SystemExt | Core::HID::NpadStyleSet::System;
+        break;
+    case NpadRevision::Revision3:
+        mask = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+               Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+               Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::Gc |
+               Core::HID::NpadStyleSet::Palma | Core::HID::NpadStyleSet::Lark |
+               Core::HID::NpadStyleSet::HandheldLark | Core::HID::NpadStyleSet::Lucia |
+               Core::HID::NpadStyleSet::Lagoon | Core::HID::NpadStyleSet::Lager |
+               Core::HID::NpadStyleSet::SystemExt | Core::HID::NpadStyleSet::System;
+        break;
+    default:
+        mask = Core::HID::NpadStyleSet::Fullkey | Core::HID::NpadStyleSet::Handheld |
+               Core::HID::NpadStyleSet::JoyDual | Core::HID::NpadStyleSet::JoyLeft |
+               Core::HID::NpadStyleSet::JoyRight | Core::HID::NpadStyleSet::SystemExt |
+               Core::HID::NpadStyleSet::System;
+        break;
+    }
+
+    out_style_set = out_style_set & mask;
+    return ResultSuccess;
+}
+
+NpadRevision NPadResource::GetNpadRevision(u64 aruid) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return NpadRevision::Revision0;
+    }
+
+    return state[aruid_index].npad_revision;
+}
+
+Result NPadResource::IsSupportedNpadStyleSet(bool& is_set, u64 aruid) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    is_set = state[aruid_index].data.GetNpadStatus().is_supported_styleset_set.Value() != 0;
+    return ResultSuccess;
+}
+
+Result NPadResource::SetNpadJoyHoldType(u64 aruid, NpadJoyHoldType hold_type) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].data.SetNpadJoyHoldType(hold_type);
+    if (active_data_aruid == aruid) {
+        active_data.SetNpadJoyHoldType(hold_type);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::GetNpadJoyHoldType(NpadJoyHoldType& hold_type, u64 aruid) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    auto& data = state[aruid_index].data;
+    if (data.GetNpadStatus().is_policy || data.GetNpadStatus().is_full_policy) {
+        hold_type = active_data.GetNpadJoyHoldType();
+        return ResultSuccess;
+    }
+    hold_type = data.GetNpadJoyHoldType();
+    return ResultSuccess;
+}
+
+Result NPadResource::SetNpadHandheldActivationMode(u64 aruid,
+                                                   NpadHandheldActivationMode activation_mode) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].data.SetHandheldActivationMode(activation_mode);
+    if (active_data_aruid == aruid) {
+        active_data.SetHandheldActivationMode(activation_mode);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::GetNpadHandheldActivationMode(NpadHandheldActivationMode& activation_mode,
+                                                   u64 aruid) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    activation_mode = state[aruid_index].data.GetHandheldActivationMode();
+    return ResultSuccess;
+}
+
+Result NPadResource::SetSupportedNpadIdType(
+    u64 aruid, std::span<const Core::HID::NpadIdType> supported_npad_list) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+    if (supported_npad_list.size() > MaxSupportedNpadIdTypes) {
+        return ResultInvalidArraySize;
+    }
+
+    Result result = state[aruid_index].data.SetSupportedNpadIdType(supported_npad_list);
+    if (result.IsSuccess() && active_data_aruid == aruid) {
+        result = active_data.SetSupportedNpadIdType(supported_npad_list);
+    }
+
+    return result;
+}
+
+bool NPadResource::IsControllerSupported(u64 aruid, Core::HID::NpadStyleIndex style_index) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return false;
+    }
+    return state[aruid_index].data.IsNpadStyleIndexSupported(style_index);
+}
+
+Result NPadResource::SetLrAssignmentMode(u64 aruid, bool is_enabled) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].data.SetLrAssignmentMode(is_enabled);
+    if (active_data_aruid == aruid) {
+        active_data.SetLrAssignmentMode(is_enabled);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::GetLrAssignmentMode(bool& is_enabled, u64 aruid) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    is_enabled = state[aruid_index].data.GetLrAssignmentMode();
+    return ResultSuccess;
+}
+
+Result NPadResource::SetAssigningSingleOnSlSrPress(u64 aruid, bool is_enabled) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].data.SetAssigningSingleOnSlSrPress(is_enabled);
+    if (active_data_aruid == aruid) {
+        active_data.SetAssigningSingleOnSlSrPress(is_enabled);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::IsAssigningSingleOnSlSrPressEnabled(bool& is_enabled, u64 aruid) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    is_enabled = state[aruid_index].data.GetAssigningSingleOnSlSrPress();
+    return ResultSuccess;
+}
+
+Result NPadResource::AcquireNpadStyleSetUpdateEventHandle(u64 aruid,
+                                                          Kernel::KReadableEvent** out_event,
+                                                          Core::HID::NpadIdType npad_id) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    auto& controller_state = state[aruid_index].controller_state[NpadIdTypeToIndex(npad_id)];
+    if (!controller_state.is_styleset_update_event_initialized) {
+        // Auto clear = true
+        controller_state.style_set_update_event =
+            service_context.CreateEvent("NpadResource:StylesetUpdateEvent");
+
+        // Assume creating the event succeeds otherwise crash the system here
+        controller_state.is_styleset_update_event_initialized = true;
+    }
+
+    *out_event = &controller_state.style_set_update_event->GetReadableEvent();
+
+    if (controller_state.is_styleset_update_event_initialized) {
+        controller_state.style_set_update_event->Signal();
+    }
+
+    return ResultSuccess;
+}
+
+Result NPadResource::SignalStyleSetUpdateEvent(u64 aruid, Core::HID::NpadIdType npad_id) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+    auto controller = state[aruid_index].controller_state[NpadIdTypeToIndex(npad_id)];
+    if (controller.is_styleset_update_event_initialized) {
+        controller.style_set_update_event->Signal();
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::GetHomeProtectionEnabled(bool& is_enabled, u64 aruid,
+                                              Core::HID::NpadIdType npad_id) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    is_enabled = state[aruid_index].data.GetHomeProtectionEnabled(npad_id);
+    return ResultSuccess;
+}
+
+Result NPadResource::SetHomeProtectionEnabled(u64 aruid, Core::HID::NpadIdType npad_id,
+                                              bool is_enabled) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].data.SetHomeProtectionEnabled(is_enabled, npad_id);
+    if (active_data_aruid == aruid) {
+        active_data.SetHomeProtectionEnabled(is_enabled, npad_id);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::SetNpadAnalogStickUseCenterClamp(u64 aruid, bool is_enabled) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].data.SetNpadAnalogStickUseCenterClamp(is_enabled);
+    if (active_data_aruid == aruid) {
+        active_data.SetNpadAnalogStickUseCenterClamp(is_enabled);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::SetButtonConfig(u64 aruid, Core::HID::NpadIdType npad_id, std::size_t index,
+                                     Core::HID::NpadButton button_config) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].button_config[NpadIdTypeToIndex(npad_id)][index] = button_config;
+    return ResultSuccess;
+}
+
+Core::HID::NpadButton NPadResource::GetButtonConfig(u64 aruid, Core::HID::NpadIdType npad_id,
+                                                    std::size_t index, Core::HID::NpadButton mask,
+                                                    bool is_enabled) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return Core::HID::NpadButton::None;
+    }
+
+    auto& button_config = state[aruid_index].button_config[NpadIdTypeToIndex(npad_id)][index];
+    if (is_enabled) {
+        button_config = button_config | mask;
+        return button_config;
+    }
+
+    button_config = Core::HID::NpadButton::None;
+    return Core::HID::NpadButton::None;
+}
+
+void NPadResource::ResetButtonConfig() {
+    for (auto& selected_state : state) {
+        selected_state.button_config = {};
+    }
+}
+
+Result NPadResource::SetNpadCaptureButtonAssignment(u64 aruid,
+                                                    Core::HID::NpadStyleSet npad_style_set,
+                                                    Core::HID::NpadButton button_assignment) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    // Must be a power of two
+    const auto raw_styleset = static_cast<u32>(npad_style_set);
+    if (raw_styleset == 0 && (raw_styleset & (raw_styleset - 1)) != 0) {
+        return ResultMultipleStyleSetSelected;
+    }
+
+    std::size_t style_index{};
+    Core::HID::NpadStyleSet style_selected{};
+    for (style_index = 0; style_index < StyleIndexCount; ++style_index) {
+        style_selected = GetStylesetByIndex(style_index);
+        if (npad_style_set == style_selected) {
+            break;
+        }
+    }
+
+    if (style_selected == Core::HID::NpadStyleSet::None) {
+        return ResultMultipleStyleSetSelected;
+    }
+
+    state[aruid_index].data.SetCaptureButtonAssignment(button_assignment, style_index);
+    if (active_data_aruid == aruid) {
+        active_data.SetCaptureButtonAssignment(button_assignment, style_index);
+    }
+    return ResultSuccess;
+}
+
+Result NPadResource::ClearNpadCaptureButtonAssignment(u64 aruid) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    for (std::size_t i = 0; i < StyleIndexCount; i++) {
+        state[aruid_index].data.SetCaptureButtonAssignment(Core::HID::NpadButton::None, i);
+        if (active_data_aruid == aruid) {
+            active_data.SetCaptureButtonAssignment(Core::HID::NpadButton::None, i);
+        }
+    }
+    return ResultSuccess;
+}
+
+std::size_t NPadResource::GetNpadCaptureButtonAssignment(std::span<Core::HID::NpadButton> out_list,
+                                                         u64 aruid) const {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return 0;
+    }
+    return state[aruid_index].data.GetNpadCaptureButtonAssignmentList(out_list);
+}
+
+void NPadResource::SetNpadRevision(u64 aruid, NpadRevision revision) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return;
+    }
+
+    state[aruid_index].npad_revision = revision;
+}
+
+Result NPadResource::SetNpadSystemExtStateEnabled(u64 aruid, bool is_enabled) {
+    const u64 aruid_index = GetIndexFromAruid(aruid);
+    if (aruid_index >= AruidIndexMax) {
+        return ResultNpadNotConnected;
+    }
+
+    state[aruid_index].data.SetNpadAnalogStickUseCenterClamp(is_enabled);
+    if (active_data_aruid == aruid) {
+        active_data.SetNpadAnalogStickUseCenterClamp(is_enabled);
+    }
+    return ResultSuccess;
+}
+
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/npad/npad_resource.h b/src/core/hle/service/hid/controllers/npad/npad_resource.h
new file mode 100644
index 000000000000..4c7e6ab0e2e9
--- /dev/null
+++ b/src/core/hle/service/hid/controllers/npad/npad_resource.h
@@ -0,0 +1,132 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#pragma once
+
+#include <array>
+#include <mutex>
+#include <span>
+
+#include "common/common_types.h"
+#include "core/hid/hid_types.h"
+#include "core/hle/result.h"
+#include "core/hle/service/hid/controllers/applet_resource.h"
+#include "core/hle/service/hid/controllers/npad/npad_data.h"
+#include "core/hle/service/hid/controllers/types/npad_types.h"
+#include "core/hle/service/kernel_helpers.h"
+
+namespace Core {
+class System;
+}
+
+namespace Kernel {
+class KReadableEvent;
+}
+
+namespace Service::HID {
+struct DataStatusFlag;
+
+struct NpadControllerState {
+    bool is_styleset_update_event_initialized{};
+    INSERT_PADDING_BYTES(0x7);
+    Kernel::KEvent* style_set_update_event{nullptr};
+    INSERT_PADDING_BYTES(0x27);
+};
+
+struct NpadState {
+    DataStatusFlag flag{};
+    u64 aruid{};
+    NPadData data{};
+    std::array<std::array<Core::HID::NpadButton, StyleIndexCount>, MaxSupportedNpadIdTypes>
+        button_config;
+    std::array<NpadControllerState, MaxSupportedNpadIdTypes> controller_state;
+    NpadRevision npad_revision;
+};
+
+/// Handles Npad request from HID interfaces
+class NPadResource final {
+public:
+    explicit NPadResource(KernelHelpers::ServiceContext& context);
+    ~NPadResource();
+
+    NPadData* GetActiveData();
+    u64 GetActiveDataAruid();
+
+    Result RegisterAppletResourceUserId(u64 aruid);
+    void UnregisterAppletResourceUserId(u64 aruid);
+
+    void DestroyStyleSetUpdateEvents(u64 aruid);
+
+    Result Activate(u64 aruid);
+    Result Activate();
+    Result Deactivate();
+
+    void SetAppletResourceUserId(u64 aruid);
+    std::size_t GetIndexFromAruid(u64 aruid) const;
+
+    Result ApplyNpadSystemCommonPolicy(u64 aruid, bool is_full_policy);
+    Result ClearNpadSystemCommonPolicy(u64 aruid);
+
+    Result SetSupportedNpadStyleSet(u64 aruid, Core::HID::NpadStyleSet style_set);
+    Result GetSupportedNpadStyleSet(Core::HID::NpadStyleSet& out_style_Set, u64 aruid) const;
+    Result GetMaskedSupportedNpadStyleSet(Core::HID::NpadStyleSet& out_style_set, u64 aruid) const;
+    Result GetAvailableStyleset(Core::HID::NpadStyleSet& out_style_set, u64 aruid) const;
+
+    NpadRevision GetNpadRevision(u64 aruid) const;
+    void SetNpadRevision(u64 aruid, NpadRevision revision);
+
+    Result IsSupportedNpadStyleSet(bool& is_set, u64 aruid);
+
+    Result SetNpadJoyHoldType(u64 aruid, NpadJoyHoldType hold_type);
+    Result GetNpadJoyHoldType(NpadJoyHoldType& hold_type, u64 aruid) const;
+
+    Result SetNpadHandheldActivationMode(u64 aruid, NpadHandheldActivationMode activation_mode);
+    Result GetNpadHandheldActivationMode(NpadHandheldActivationMode& activation_mode,
+                                         u64 aruid) const;
+
+    Result SetSupportedNpadIdType(u64 aruid,
+                                  std::span<const Core::HID::NpadIdType> supported_npad_list);
+    bool IsControllerSupported(u64 aruid, Core::HID::NpadStyleIndex style_index) const;
+
+    Result SetLrAssignmentMode(u64 aruid, bool is_enabled);
+    Result GetLrAssignmentMode(bool& is_enabled, u64 aruid) const;
+
+    Result SetAssigningSingleOnSlSrPress(u64 aruid, bool is_enabled);
+    Result IsAssigningSingleOnSlSrPressEnabled(bool& is_enabled, u64 aruid) const;
+
+    Result AcquireNpadStyleSetUpdateEventHandle(u64 aruid, Kernel::KReadableEvent** out_event,
+                                                Core::HID::NpadIdType npad_id);
+    Result SignalStyleSetUpdateEvent(u64 aruid, Core::HID::NpadIdType npad_id);
+
+    Result GetHomeProtectionEnabled(bool& is_enabled, u64 aruid,
+                                    Core::HID::NpadIdType npad_id) const;
+    Result SetHomeProtectionEnabled(u64 aruid, Core::HID::NpadIdType npad_id, bool is_enabled);
+
+    Result SetNpadAnalogStickUseCenterClamp(u64 aruid, bool is_enabled);
+
+    Result SetButtonConfig(u64 aruid, Core::HID::NpadIdType npad_id, std::size_t index,
+                           Core::HID::NpadButton button_config);
+    Core::HID::NpadButton GetButtonConfig(u64 aruid, Core::HID::NpadIdType npad_id,
+                                          std::size_t index, Core::HID::NpadButton mask,
+                                          bool is_enabled);
+    void ResetButtonConfig();
+
+    Result SetNpadCaptureButtonAssignment(u64 aruid, Core::HID::NpadStyleSet npad_style_set,
+                                          Core::HID::NpadButton button_assignment);
+    Result ClearNpadCaptureButtonAssignment(u64 aruid);
+    std::size_t GetNpadCaptureButtonAssignment(std::span<Core::HID::NpadButton> out_list,
+                                               u64 aruid) const;
+
+    Result SetNpadSystemExtStateEnabled(u64 aruid, bool is_enabled);
+
+private:
+    NPadData active_data{};
+    AruidRegisterList registration_list{};
+    std::array<NpadState, AruidIndexMax> state{};
+    u64 active_data_aruid{};
+    NpadJoyHoldType default_hold_type{};
+    s32 ref_counter{};
+
+    KernelHelpers::ServiceContext& service_context;
+};
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/six_axis.cpp b/src/core/hle/service/hid/controllers/six_axis.cpp
index a5a67dea65e0..adab60911102 100644
--- a/src/core/hle/service/hid/controllers/six_axis.cpp
+++ b/src/core/hle/service/hid/controllers/six_axis.cpp
@@ -27,10 +27,11 @@ void SixAxis::OnInit() {}
 void SixAxis::OnRelease() {}
 
 void SixAxis::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/sleep_button.cpp b/src/core/hle/service/hid/controllers/sleep_button.cpp
index 978dc4c1f369..d44b1f4cc5a1 100644
--- a/src/core/hle/service/hid/controllers/sleep_button.cpp
+++ b/src/core/hle/service/hid/controllers/sleep_button.cpp
@@ -21,10 +21,11 @@ void SleepButton::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
         return;
     }
 
+    std::scoped_lock shared_lock{*shared_mutex};
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/touchscreen.cpp b/src/core/hle/service/hid/controllers/touchscreen.cpp
index 291dc707e6f6..b585a5829dc2 100644
--- a/src/core/hle/service/hid/controllers/touchscreen.cpp
+++ b/src/core/hle/service/hid/controllers/touchscreen.cpp
@@ -30,7 +30,7 @@ void TouchScreen::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/controllers/types/npad_types.h b/src/core/hle/service/hid/controllers/types/npad_types.h
index a5ce2562bd11..419c33a8cbb7 100644
--- a/src/core/hle/service/hid/controllers/types/npad_types.h
+++ b/src/core/hle/service/hid/controllers/types/npad_types.h
@@ -9,7 +9,8 @@
 #include "core/hid/hid_types.h"
 
 namespace Service::HID {
-static constexpr std::size_t NpadCount = 10;
+static constexpr std::size_t MaxSupportedNpadIdTypes = 10;
+static constexpr std::size_t StyleIndexCount = 7;
 
 // This is nn::hid::NpadJoyHoldType
 enum class NpadJoyHoldType : u64 {
diff --git a/src/core/hle/service/hid/controllers/types/shared_memory_format.h b/src/core/hle/service/hid/controllers/types/shared_memory_format.h
index 2986c113e08b..976043b9c939 100644
--- a/src/core/hle/service/hid/controllers/types/shared_memory_format.h
+++ b/src/core/hle/service/hid/controllers/types/shared_memory_format.h
@@ -171,7 +171,7 @@ static_assert(sizeof(NpadSharedMemoryEntry) == 0x5000, "NpadSharedMemoryEntry is
 
 // This is nn::hid::detail::NpadSharedMemoryFormat
 struct NpadSharedMemoryFormat {
-    std::array<NpadSharedMemoryEntry, NpadCount> npad_entry;
+    std::array<NpadSharedMemoryEntry, MaxSupportedNpadIdTypes> npad_entry;
 };
 static_assert(sizeof(NpadSharedMemoryFormat) == 0x32000,
               "NpadSharedMemoryFormat is an invalid size");
diff --git a/src/core/hle/service/hid/controllers/unique_pad.cpp b/src/core/hle/service/hid/controllers/unique_pad.cpp
index 8230501a591f..6c543031dc35 100644
--- a/src/core/hle/service/hid/controllers/unique_pad.cpp
+++ b/src/core/hle/service/hid/controllers/unique_pad.cpp
@@ -24,7 +24,7 @@ void UniquePad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     const u64 aruid = applet_resource->GetActiveAruid();
     auto* data = applet_resource->GetAruidData(aruid);
 
-    if (data == nullptr) {
+    if (data == nullptr || !data->flag.is_assigned) {
         return;
     }
 
diff --git a/src/core/hle/service/hid/errors.h b/src/core/hle/service/hid/errors.h
index 6dc976fe1830..bb14aa61ec7f 100644
--- a/src/core/hle/service/hid/errors.h
+++ b/src/core/hle/service/hid/errors.h
@@ -10,15 +10,32 @@ namespace Service::HID {
 constexpr Result PalmaResultSuccess{ErrorModule::HID, 0};
 constexpr Result NpadInvalidHandle{ErrorModule::HID, 100};
 constexpr Result NpadDeviceIndexOutOfRange{ErrorModule::HID, 107};
-constexpr Result VibrationInvalidStyleIndex{ErrorModule::HID, 122};
-constexpr Result VibrationInvalidNpadId{ErrorModule::HID, 123};
-constexpr Result VibrationDeviceIndexOutOfRange{ErrorModule::HID, 124};
+
+constexpr Result ResultVibrationNotInitialized{ErrorModule::HID, 121};
+constexpr Result ResultVibrationInvalidStyleIndex{ErrorModule::HID, 122};
+constexpr Result ResultVibrationInvalidNpadId{ErrorModule::HID, 123};
+constexpr Result ResultVibrationDeviceIndexOutOfRange{ErrorModule::HID, 124};
+constexpr Result ResultVibrationStrenghtOutOfRange{ErrorModule::HID, 126};
+constexpr Result ResultVibrationArraySizeMismatch{ErrorModule::HID, 131};
+
 constexpr Result InvalidSixAxisFusionRange{ErrorModule::HID, 423};
+
+constexpr Result ResultNfcIsNotReady{ErrorModule::HID, 461};
+constexpr Result ResultNfcXcdHandleIsNotInitialized{ErrorModule::HID, 464};
+constexpr Result ResultIrSensorIsNotReady{ErrorModule::HID, 501};
+constexpr Result ResultMcuIsNotReady{ErrorModule::HID, 541};
+
 constexpr Result NpadIsDualJoycon{ErrorModule::HID, 601};
 constexpr Result NpadIsSameType{ErrorModule::HID, 602};
-constexpr Result InvalidNpadId{ErrorModule::HID, 709};
-constexpr Result NpadNotConnected{ErrorModule::HID, 710};
-constexpr Result InvalidArraySize{ErrorModule::HID, 715};
+constexpr Result ResultNpadIsNotProController{ErrorModule::HID, 604};
+
+constexpr Result ResultInvalidNpadId{ErrorModule::HID, 709};
+constexpr Result ResultNpadNotConnected{ErrorModule::HID, 710};
+constexpr Result ResultNpadHandlerOverflow{ErrorModule::HID, 711};
+constexpr Result ResultNpadHandlerNotInitialized{ErrorModule::HID, 712};
+constexpr Result ResultInvalidArraySize{ErrorModule::HID, 715};
+constexpr Result ResultUndefinedStyleset{ErrorModule::HID, 716};
+constexpr Result ResultMultipleStyleSetSelected{ErrorModule::HID, 717};
 
 constexpr Result ResultAppletResourceOverflow{ErrorModule::HID, 1041};
 constexpr Result ResultAppletResourceNotInitialized{ErrorModule::HID, 1042};
@@ -27,6 +44,9 @@ constexpr Result ResultAruidNoAvailableEntries{ErrorModule::HID, 1044};
 constexpr Result ResultAruidAlreadyRegistered{ErrorModule::HID, 1046};
 constexpr Result ResultAruidNotRegistered{ErrorModule::HID, 1047};
 
+constexpr Result ResultNpadResourceOverflow{ErrorModule::HID, 2001};
+constexpr Result ResultNpadResourceNotInitialized{ErrorModule::HID, 2002};
+
 constexpr Result InvalidPalmaHandle{ErrorModule::HID, 3302};
 
 } // namespace Service::HID
diff --git a/src/core/hle/service/hid/hid.cpp b/src/core/hle/service/hid/hid.cpp
index afbcb019f7c0..bd287318170a 100644
--- a/src/core/hle/service/hid/hid.cpp
+++ b/src/core/hle/service/hid/hid.cpp
@@ -25,6 +25,7 @@ void LoopProcess(Core::System& system) {
     // TODO: Remove this hack until this service is emulated properly.
     const auto process_list = system.Kernel().GetProcessList();
     if (!process_list.empty()) {
+        resouce_manager->Initialize();
         resouce_manager->RegisterAppletResourceUserId(process_list[0]->GetId(), true);
     }
 
diff --git a/src/core/hle/service/hid/hid_server.cpp b/src/core/hle/service/hid/hid_server.cpp
index 3174672afb0f..a953c92b3227 100644
--- a/src/core/hle/service/hid/hid_server.cpp
+++ b/src/core/hle/service/hid/hid_server.cpp
@@ -785,8 +785,8 @@ void IHidServer::IsFirmwareUpdateAvailableForSixAxisSensor(HLERequestContext& ct
 
     bool is_firmware_available{};
     auto controller = GetResourceManager()->GetNpad();
-    controller->IsFirmwareUpdateAvailableForSixAxisSensor(parameters.sixaxis_handle,
-                                                          is_firmware_available);
+    controller->IsFirmwareUpdateAvailableForSixAxisSensor(
+        parameters.applet_resource_user_id, parameters.sixaxis_handle, is_firmware_available);
 
     LOG_WARNING(
         Service_HID,
@@ -924,8 +924,8 @@ void IHidServer::ResetIsSixAxisSensorDeviceNewlyAssigned(HLERequestContext& ctx)
     const auto parameters{rp.PopRaw<Parameters>()};
 
     auto controller = GetResourceManager()->GetNpad();
-    const auto result =
-        controller->ResetIsSixAxisSensorDeviceNewlyAssigned(parameters.sixaxis_handle);
+    const auto result = controller->ResetIsSixAxisSensorDeviceNewlyAssigned(
+        parameters.applet_resource_user_id, parameters.sixaxis_handle);
 
     LOG_WARNING(
         Service_HID,
@@ -970,7 +970,7 @@ void IHidServer::ActivateGesture(HLERequestContext& ctx) {
 void IHidServer::SetSupportedNpadStyleSet(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     struct Parameters {
-        Core::HID::NpadStyleSet supported_styleset;
+        Core::HID::NpadStyleSet supported_style_set;
         INSERT_PADDING_WORDS_NOINIT(1);
         u64 applet_resource_user_id;
     };
@@ -978,13 +978,25 @@ void IHidServer::SetSupportedNpadStyleSet(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    GetResourceManager()->GetNpad()->SetSupportedStyleSet({parameters.supported_styleset});
+    LOG_DEBUG(Service_HID, "called, supported_style_set={}, applet_resource_user_id={}",
+              parameters.supported_style_set, parameters.applet_resource_user_id);
+
+    const auto npad = GetResourceManager()->GetNpad();
+    const Result result = npad->SetSupportedNpadStyleSet(parameters.applet_resource_user_id,
+                                                         parameters.supported_style_set);
 
-    LOG_DEBUG(Service_HID, "called, supported_styleset={}, applet_resource_user_id={}",
-              parameters.supported_styleset, parameters.applet_resource_user_id);
+    if (result.IsSuccess()) {
+        Core::HID::NpadStyleTag style_tag{parameters.supported_style_set};
+        const auto revision = npad->GetRevision(parameters.applet_resource_user_id);
+
+        if (style_tag.palma != 0 && revision < NpadRevision::Revision3) {
+            // GetResourceManager()->GetPalma()->EnableBoostMode(parameters.applet_resource_user_id,
+            //                                                   true);
+        }
+    }
 
     IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
 }
 
 void IHidServer::GetSupportedNpadStyleSet(HLERequestContext& ctx) {
@@ -993,19 +1005,31 @@ void IHidServer::GetSupportedNpadStyleSet(HLERequestContext& ctx) {
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
+    Core::HID::NpadStyleSet supported_style_set{};
+    const auto npad = GetResourceManager()->GetNpad();
+    const auto result =
+        npad->GetSupportedNpadStyleSet(applet_resource_user_id, supported_style_set);
+
     IPC::ResponseBuilder rb{ctx, 3};
-    rb.Push(ResultSuccess);
-    rb.PushEnum(GetResourceManager()->GetNpad()->GetSupportedStyleSet().raw);
+    rb.Push(result);
+    rb.PushEnum(supported_style_set);
 }
 
 void IHidServer::SetSupportedNpadIdType(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
-
-    const auto result = GetResourceManager()->GetNpad()->SetSupportedNpadIdTypes(ctx.ReadBuffer());
+    const auto buffer = ctx.ReadBuffer();
+    const std::size_t elements = ctx.GetReadBufferNumElements<Core::HID::NpadIdType>();
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
+    std::vector<Core::HID::NpadIdType> supported_npad_list(elements);
+    memcpy(supported_npad_list.data(), buffer.data(), buffer.size());
+
+    const auto npad = GetResourceManager()->GetNpad();
+    const Result result =
+        npad->SetSupportedNpadIdType(applet_resource_user_id, supported_npad_list);
+
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
 }
@@ -1018,7 +1042,7 @@ void IHidServer::ActivateNpad(HLERequestContext& ctx) {
 
     auto npad = GetResourceManager()->GetNpad();
 
-    // TODO: npad->SetRevision(applet_resource_user_id, NpadRevision::Revision0);
+    npad->SetRevision(applet_resource_user_id, NpadRevision::Revision0);
     const Result result = npad->Activate(applet_resource_user_id);
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -1052,13 +1076,13 @@ void IHidServer::AcquireNpadStyleSetUpdateEventHandle(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called, npad_id={}, applet_resource_user_id={}, unknown={}",
               parameters.npad_id, parameters.applet_resource_user_id, parameters.unknown);
 
-    // Games expect this event to be signaled after calling this function
-    GetResourceManager()->GetNpad()->SignalStyleSetChangedEvent(parameters.npad_id);
+    Kernel::KReadableEvent* style_set_update_event;
+    const auto result = GetResourceManager()->GetNpad()->AcquireNpadStyleSetUpdateEventHandle(
+        parameters.applet_resource_user_id, &style_set_update_event, parameters.npad_id);
 
     IPC::ResponseBuilder rb{ctx, 2, 1};
-    rb.Push(ResultSuccess);
-    rb.PushCopyObjects(
-        GetResourceManager()->GetNpad()->GetStyleSetChangedEvent(parameters.npad_id));
+    rb.Push(result);
+    rb.PushCopyObjects(style_set_update_event);
 }
 
 void IHidServer::DisconnectNpad(HLERequestContext& ctx) {
@@ -1073,7 +1097,7 @@ void IHidServer::DisconnectNpad(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     auto controller = GetResourceManager()->GetNpad();
-    controller->DisconnectNpad(parameters.npad_id);
+    controller->DisconnectNpad(parameters.applet_resource_user_id, parameters.npad_id);
 
     LOG_DEBUG(Service_HID, "called, npad_id={}, applet_resource_user_id={}", parameters.npad_id,
               parameters.applet_resource_user_id);
@@ -1113,7 +1137,7 @@ void IHidServer::ActivateNpadWithRevision(HLERequestContext& ctx) {
 
     auto npad = GetResourceManager()->GetNpad();
 
-    // TODO: npad->SetRevision(applet_resource_user_id, revision);
+    npad->SetRevision(parameters.applet_resource_user_id, parameters.revision);
     const auto result = npad->Activate(parameters.applet_resource_user_id);
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -1125,13 +1149,19 @@ void IHidServer::SetNpadJoyHoldType(HLERequestContext& ctx) {
     const auto applet_resource_user_id{rp.Pop<u64>()};
     const auto hold_type{rp.PopEnum<NpadJoyHoldType>()};
 
-    GetResourceManager()->GetNpad()->SetHoldType(hold_type);
-
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}, hold_type={}",
               applet_resource_user_id, hold_type);
 
+    if (hold_type != NpadJoyHoldType::Horizontal && hold_type != NpadJoyHoldType::Vertical) {
+        // This should crash console
+        ASSERT_MSG(false, "Invalid npad joy hold type");
+    }
+
+    const auto npad = GetResourceManager()->GetNpad();
+    const auto result = npad->SetNpadJoyHoldType(applet_resource_user_id, hold_type);
+
     IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
 }
 
 void IHidServer::GetNpadJoyHoldType(HLERequestContext& ctx) {
@@ -1140,9 +1170,13 @@ void IHidServer::GetNpadJoyHoldType(HLERequestContext& ctx) {
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
+    NpadJoyHoldType hold_type{};
+    const auto npad = GetResourceManager()->GetNpad();
+    const auto result = npad->GetNpadJoyHoldType(applet_resource_user_id, hold_type);
+
     IPC::ResponseBuilder rb{ctx, 4};
-    rb.Push(ResultSuccess);
-    rb.PushEnum(GetResourceManager()->GetNpad()->GetHoldType());
+    rb.Push(result);
+    rb.PushEnum(hold_type);
 }
 
 void IHidServer::SetNpadJoyAssignmentModeSingleByDefault(HLERequestContext& ctx) {
@@ -1158,8 +1192,8 @@ void IHidServer::SetNpadJoyAssignmentModeSingleByDefault(HLERequestContext& ctx)
 
     Core::HID::NpadIdType new_npad_id{};
     auto controller = GetResourceManager()->GetNpad();
-    controller->SetNpadMode(new_npad_id, parameters.npad_id, NpadJoyDeviceType::Left,
-                            NpadJoyAssignmentMode::Single);
+    controller->SetNpadMode(parameters.applet_resource_user_id, new_npad_id, parameters.npad_id,
+                            NpadJoyDeviceType::Left, NpadJoyAssignmentMode::Single);
 
     LOG_INFO(Service_HID, "called, npad_id={}, applet_resource_user_id={}", parameters.npad_id,
              parameters.applet_resource_user_id);
@@ -1182,8 +1216,8 @@ void IHidServer::SetNpadJoyAssignmentModeSingle(HLERequestContext& ctx) {
 
     Core::HID::NpadIdType new_npad_id{};
     auto controller = GetResourceManager()->GetNpad();
-    controller->SetNpadMode(new_npad_id, parameters.npad_id, parameters.npad_joy_device_type,
-                            NpadJoyAssignmentMode::Single);
+    controller->SetNpadMode(parameters.applet_resource_user_id, new_npad_id, parameters.npad_id,
+                            parameters.npad_joy_device_type, NpadJoyAssignmentMode::Single);
 
     LOG_INFO(Service_HID, "called, npad_id={}, applet_resource_user_id={}, npad_joy_device_type={}",
              parameters.npad_id, parameters.applet_resource_user_id,
@@ -1206,7 +1240,8 @@ void IHidServer::SetNpadJoyAssignmentModeDual(HLERequestContext& ctx) {
 
     Core::HID::NpadIdType new_npad_id{};
     auto controller = GetResourceManager()->GetNpad();
-    controller->SetNpadMode(new_npad_id, parameters.npad_id, {}, NpadJoyAssignmentMode::Dual);
+    controller->SetNpadMode(parameters.applet_resource_user_id, new_npad_id, parameters.npad_id, {},
+                            NpadJoyAssignmentMode::Dual);
 
     LOG_DEBUG(Service_HID, "called, npad_id={}, applet_resource_user_id={}", parameters.npad_id,
               parameters.applet_resource_user_id); // Spams a lot when controller applet is open
@@ -1222,7 +1257,8 @@ void IHidServer::MergeSingleJoyAsDualJoy(HLERequestContext& ctx) {
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
     auto controller = GetResourceManager()->GetNpad();
-    const auto result = controller->MergeSingleJoyAsDualJoy(npad_id_1, npad_id_2);
+    const auto result =
+        controller->MergeSingleJoyAsDualJoy(applet_resource_user_id, npad_id_1, npad_id_2);
 
     LOG_DEBUG(Service_HID, "called, npad_id_1={}, npad_id_2={}, applet_resource_user_id={}",
               npad_id_1, npad_id_2, applet_resource_user_id);
@@ -1235,10 +1271,10 @@ void IHidServer::StartLrAssignmentMode(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    GetResourceManager()->GetNpad()->StartLRAssignmentMode();
-
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
+    GetResourceManager()->GetNpad()->StartLrAssignmentMode(applet_resource_user_id);
+
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
 }
@@ -1247,10 +1283,10 @@ void IHidServer::StopLrAssignmentMode(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    GetResourceManager()->GetNpad()->StopLRAssignmentMode();
-
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
+    GetResourceManager()->GetNpad()->StopLrAssignmentMode(applet_resource_user_id);
+
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
 }
@@ -1260,13 +1296,23 @@ void IHidServer::SetNpadHandheldActivationMode(HLERequestContext& ctx) {
     const auto applet_resource_user_id{rp.Pop<u64>()};
     const auto activation_mode{rp.PopEnum<NpadHandheldActivationMode>()};
 
-    GetResourceManager()->GetNpad()->SetNpadHandheldActivationMode(activation_mode);
-
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}, activation_mode={}",
               applet_resource_user_id, activation_mode);
 
+    if (activation_mode >= NpadHandheldActivationMode::MaxActivationMode) {
+        // Console should crash here
+        ASSERT_MSG(false, "Activation mode should be always None, Single or Dual");
+        IPC::ResponseBuilder rb{ctx, 2};
+        rb.Push(ResultSuccess);
+        return;
+    }
+
+    const auto npad = GetResourceManager()->GetNpad();
+    const auto result =
+        npad->SetNpadHandheldActivationMode(applet_resource_user_id, activation_mode);
+
     IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
 }
 
 void IHidServer::GetNpadHandheldActivationMode(HLERequestContext& ctx) {
@@ -1275,9 +1321,14 @@ void IHidServer::GetNpadHandheldActivationMode(HLERequestContext& ctx) {
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
+    NpadHandheldActivationMode activation_mode{};
+    const auto npad = GetResourceManager()->GetNpad();
+    const auto result =
+        npad->GetNpadHandheldActivationMode(applet_resource_user_id, activation_mode);
+
     IPC::ResponseBuilder rb{ctx, 4};
-    rb.Push(ResultSuccess);
-    rb.PushEnum(GetResourceManager()->GetNpad()->GetNpadHandheldActivationMode());
+    rb.Push(result);
+    rb.PushEnum(activation_mode);
 }
 
 void IHidServer::SwapNpadAssignment(HLERequestContext& ctx) {
@@ -1286,12 +1337,12 @@ void IHidServer::SwapNpadAssignment(HLERequestContext& ctx) {
     const auto npad_id_2{rp.PopEnum<Core::HID::NpadIdType>()};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    auto controller = GetResourceManager()->GetNpad();
-    const auto result = controller->SwapNpadAssignment(npad_id_1, npad_id_2);
-
     LOG_DEBUG(Service_HID, "called, npad_id_1={}, npad_id_2={}, applet_resource_user_id={}",
               npad_id_1, npad_id_2, applet_resource_user_id);
 
+    const auto npad = GetResourceManager()->GetNpad();
+    const auto result = npad->SwapNpadAssignment(applet_resource_user_id, npad_id_1, npad_id_2);
+
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
 }
@@ -1307,13 +1358,19 @@ void IHidServer::IsUnintendedHomeButtonInputProtectionEnabled(HLERequestContext&
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    bool is_enabled = false;
-    auto controller = GetResourceManager()->GetNpad();
-    const auto result =
-        controller->IsUnintendedHomeButtonInputProtectionEnabled(parameters.npad_id, is_enabled);
+    LOG_INFO(Service_HID, "called, npad_id={}, applet_resource_user_id={}", parameters.npad_id,
+             parameters.applet_resource_user_id);
 
-    LOG_WARNING(Service_HID, "(STUBBED) called, npad_id={}, applet_resource_user_id={}",
-                parameters.npad_id, parameters.applet_resource_user_id);
+    if (!IsNpadIdValid(parameters.npad_id)) {
+        IPC::ResponseBuilder rb{ctx, 3};
+        rb.Push(ResultInvalidNpadId);
+        return;
+    }
+
+    bool is_enabled{};
+    const auto npad = GetResourceManager()->GetNpad();
+    const auto result = npad->IsUnintendedHomeButtonInputProtectionEnabled(
+        is_enabled, parameters.applet_resource_user_id, parameters.npad_id);
 
     IPC::ResponseBuilder rb{ctx, 3};
     rb.Push(result);
@@ -1332,13 +1389,18 @@ void IHidServer::EnableUnintendedHomeButtonInputProtection(HLERequestContext& ct
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto controller = GetResourceManager()->GetNpad();
-    const auto result = controller->SetUnintendedHomeButtonInputProtectionEnabled(
-        parameters.is_enabled, parameters.npad_id);
+    LOG_INFO(Service_HID, "called, is_enabled={}, npad_id={}, applet_resource_user_id={}",
+             parameters.is_enabled, parameters.npad_id, parameters.applet_resource_user_id);
 
-    LOG_DEBUG(Service_HID,
-              "(STUBBED) called, is_enabled={}, npad_id={}, applet_resource_user_id={}",
-              parameters.is_enabled, parameters.npad_id, parameters.applet_resource_user_id);
+    if (!IsNpadIdValid(parameters.npad_id)) {
+        IPC::ResponseBuilder rb{ctx, 3};
+        rb.Push(ResultInvalidNpadId);
+        return;
+    }
+
+    const auto npad = GetResourceManager()->GetNpad();
+    const auto result = npad->EnableUnintendedHomeButtonInputProtection(
+        parameters.applet_resource_user_id, parameters.npad_id, parameters.is_enabled);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -1359,8 +1421,8 @@ void IHidServer::SetNpadJoyAssignmentModeSingleWithDestination(HLERequestContext
     Core::HID::NpadIdType new_npad_id{};
     auto controller = GetResourceManager()->GetNpad();
     const auto is_reassigned =
-        controller->SetNpadMode(new_npad_id, parameters.npad_id, parameters.npad_joy_device_type,
-                                NpadJoyAssignmentMode::Single);
+        controller->SetNpadMode(parameters.applet_resource_user_id, new_npad_id, parameters.npad_id,
+                                parameters.npad_joy_device_type, NpadJoyAssignmentMode::Single);
 
     LOG_INFO(Service_HID, "called, npad_id={}, applet_resource_user_id={}, npad_joy_device_type={}",
              parameters.npad_id, parameters.applet_resource_user_id,
@@ -1375,7 +1437,7 @@ void IHidServer::SetNpadJoyAssignmentModeSingleWithDestination(HLERequestContext
 void IHidServer::SetNpadAnalogStickUseCenterClamp(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     struct Parameters {
-        bool analog_stick_use_center_clamp;
+        bool use_center_clamp;
         INSERT_PADDING_BYTES_NOINIT(7);
         u64 applet_resource_user_id;
     };
@@ -1383,12 +1445,11 @@ void IHidServer::SetNpadAnalogStickUseCenterClamp(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    GetResourceManager()->GetNpad()->SetAnalogStickUseCenterClamp(
-        parameters.analog_stick_use_center_clamp);
+    LOG_WARNING(Service_HID, "(STUBBED) called, use_center_clamp={}, applet_resource_user_id={}",
+                parameters.use_center_clamp, parameters.applet_resource_user_id);
 
-    LOG_WARNING(Service_HID,
-                "(STUBBED) called, analog_stick_use_center_clamp={}, applet_resource_user_id={}",
-                parameters.analog_stick_use_center_clamp, parameters.applet_resource_user_id);
+    GetResourceManager()->GetNpad()->SetNpadAnalogStickUseCenterClamp(
+        parameters.applet_resource_user_id, parameters.use_center_clamp);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -1496,7 +1557,8 @@ void IHidServer::SendVibrationValue(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    GetResourceManager()->GetNpad()->VibrateController(parameters.vibration_device_handle,
+    GetResourceManager()->GetNpad()->VibrateController(parameters.applet_resource_user_id,
+                                                       parameters.vibration_device_handle,
                                                        parameters.vibration_value);
 
     LOG_DEBUG(Service_HID,
@@ -1528,8 +1590,8 @@ void IHidServer::GetActualVibrationValue(HLERequestContext& ctx) {
 
     IPC::ResponseBuilder rb{ctx, 6};
     rb.Push(ResultSuccess);
-    rb.PushRaw(
-        GetResourceManager()->GetNpad()->GetLastVibration(parameters.vibration_device_handle));
+    rb.PushRaw(GetResourceManager()->GetNpad()->GetLastVibration(
+        parameters.applet_resource_user_id, parameters.vibration_device_handle));
 }
 
 void IHidServer::CreateActiveVibrationDeviceList(HLERequestContext& ctx) {
@@ -1580,7 +1642,8 @@ void IHidServer::SendVibrationValues(HLERequestContext& ctx) {
     auto vibration_values = std::span(
         reinterpret_cast<const Core::HID::VibrationValue*>(vibration_data.data()), vibration_count);
 
-    GetResourceManager()->GetNpad()->VibrateControllers(vibration_device_handles, vibration_values);
+    GetResourceManager()->GetNpad()->VibrateControllers(applet_resource_user_id,
+                                                        vibration_device_handles, vibration_values);
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
@@ -1634,8 +1697,8 @@ void IHidServer::SendVibrationGcErmCommand(HLERequestContext& ctx) {
         }
     }();
 
-    GetResourceManager()->GetNpad()->VibrateController(parameters.vibration_device_handle,
-                                                       vibration_value);
+    GetResourceManager()->GetNpad()->VibrateController(
+        parameters.applet_resource_user_id, parameters.vibration_device_handle, vibration_value);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}, "
@@ -1659,8 +1722,8 @@ void IHidServer::GetActualVibrationGcErmCommand(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    const auto last_vibration =
-        GetResourceManager()->GetNpad()->GetLastVibration(parameters.vibration_device_handle);
+    const auto last_vibration = GetResourceManager()->GetNpad()->GetLastVibration(
+        parameters.applet_resource_user_id, parameters.vibration_device_handle);
 
     const auto gc_erm_command = [last_vibration] {
         if (last_vibration.low_amplitude != 0.0f || last_vibration.high_amplitude != 0.0f) {
@@ -1732,7 +1795,7 @@ void IHidServer::IsVibrationDeviceMounted(HLERequestContext& ctx) {
     IPC::ResponseBuilder rb{ctx, 3};
     rb.Push(ResultSuccess);
     rb.Push(GetResourceManager()->GetNpad()->IsVibrationDeviceMounted(
-        parameters.vibration_device_handle));
+        parameters.applet_resource_user_id, parameters.vibration_device_handle));
 }
 
 void IHidServer::ActivateConsoleSixAxisSensor(HLERequestContext& ctx) {
@@ -2315,10 +2378,10 @@ void IHidServer::SetNpadCommunicationMode(HLERequestContext& ctx) {
     const auto applet_resource_user_id{rp.Pop<u64>()};
     const auto communication_mode{rp.PopEnum<NpadCommunicationMode>()};
 
-    GetResourceManager()->GetNpad()->SetNpadCommunicationMode(communication_mode);
+    LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}, communication_mode={}",
+              applet_resource_user_id, communication_mode);
 
-    LOG_WARNING(Service_HID, "(STUBBED) called, applet_resource_user_id={}, communication_mode={}",
-                applet_resource_user_id, communication_mode);
+    // This function has been stubbed since 2.0.0+
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2326,12 +2389,15 @@ void IHidServer::SetNpadCommunicationMode(HLERequestContext& ctx) {
 
 void IHidServer::GetNpadCommunicationMode(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
+    const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    LOG_WARNING(Service_HID, "(STUBBED) called");
+    LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
+
+    // This function has been stubbed since 2.0.0+
 
     IPC::ResponseBuilder rb{ctx, 4};
     rb.Push(ResultSuccess);
-    rb.PushEnum(GetResourceManager()->GetNpad()->GetNpadCommunicationMode());
+    rb.PushEnum(NpadCommunicationMode::Default);
 }
 
 void IHidServer::SetTouchScreenConfiguration(HLERequestContext& ctx) {
diff --git a/src/core/hle/service/hid/hid_system_server.cpp b/src/core/hle/service/hid/hid_system_server.cpp
index 5cc88c4a1742..4823de74337d 100644
--- a/src/core/hle/service/hid/hid_system_server.cpp
+++ b/src/core/hle/service/hid/hid_system_server.cpp
@@ -240,9 +240,12 @@ IHidSystemServer::~IHidSystemServer() {
 };
 
 void IHidSystemServer::ApplyNpadSystemCommonPolicy(HLERequestContext& ctx) {
-    LOG_WARNING(Service_HID, "called");
+    IPC::RequestParser rp{ctx};
+    const auto applet_resource_user_id{rp.Pop<u64>()};
+
+    LOG_INFO(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
-    GetResourceManager()->GetNpad()->ApplyNpadSystemCommonPolicy();
+    GetResourceManager()->GetNpad()->ApplyNpadSystemCommonPolicy(applet_resource_user_id);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -271,9 +274,12 @@ void IHidSystemServer::GetLastActiveNpad(HLERequestContext& ctx) {
 }
 
 void IHidSystemServer::ApplyNpadSystemCommonPolicyFull(HLERequestContext& ctx) {
-    LOG_WARNING(Service_HID, "called");
+    IPC::RequestParser rp{ctx};
+    const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    GetResourceManager()->GetNpad()->ApplyNpadSystemCommonPolicy();
+    LOG_INFO(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
+
+    GetResourceManager()->GetNpad()->ApplyNpadSystemCommonPolicyFull(applet_resource_user_id);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -298,28 +304,32 @@ void IHidSystemServer::GetNpadFullKeyGripColor(HLERequestContext& ctx) {
 
 void IHidSystemServer::GetMaskedSupportedNpadStyleSet(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
+    const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    LOG_INFO(Service_HID, "(STUBBED) called");
+    LOG_INFO(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
-    Core::HID::NpadStyleSet supported_styleset =
-        GetResourceManager()->GetNpad()->GetSupportedStyleSet().raw;
+    Core::HID::NpadStyleSet supported_styleset{};
+    const auto& npad = GetResourceManager()->GetNpad();
+    const Result result =
+        npad->GetMaskedSupportedNpadStyleSet(applet_resource_user_id, supported_styleset);
 
     IPC::ResponseBuilder rb{ctx, 3};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
     rb.PushEnum(supported_styleset);
 }
 
 void IHidSystemServer::SetSupportedNpadStyleSetAll(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
+    const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    LOG_INFO(Service_HID, "(STUBBED) called");
+    LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
-    Core::HID::NpadStyleSet supported_styleset =
-        GetResourceManager()->GetNpad()->GetSupportedStyleSet().raw;
+    const auto& npad = GetResourceManager()->GetNpad();
+    const auto result =
+        npad->SetSupportedNpadStyleSet(applet_resource_user_id, Core::HID::NpadStyleSet::All);
 
-    IPC::ResponseBuilder rb{ctx, 3};
-    rb.Push(ResultSuccess);
-    rb.PushEnum(supported_styleset);
+    IPC::ResponseBuilder rb{ctx, 2};
+    rb.Push(result);
 }
 
 void IHidSystemServer::GetAppletDetailedUiType(HLERequestContext& ctx) {
diff --git a/src/core/hle/service/hid/hid_util.h b/src/core/hle/service/hid/hid_util.h
index b87cc10e30c7..6a2ed287a187 100644
--- a/src/core/hle/service/hid/hid_util.h
+++ b/src/core/hle/service/hid/hid_util.h
@@ -31,7 +31,7 @@ constexpr Result IsSixaxisHandleValid(const Core::HID::SixAxisSensorHandle& hand
     const bool device_index = handle.device_index < Core::HID::DeviceIndex::MaxDeviceIndex;
 
     if (!npad_id) {
-        return InvalidNpadId;
+        return ResultInvalidNpadId;
     }
     if (!device_index) {
         return NpadDeviceIndexOutOfRange;
@@ -54,15 +54,15 @@ constexpr Result IsVibrationHandleValid(const Core::HID::VibrationDeviceHandle&
         // These support vibration
         break;
     default:
-        return VibrationInvalidStyleIndex;
+        return ResultVibrationInvalidStyleIndex;
     }
 
     if (!IsNpadIdValid(static_cast<Core::HID::NpadIdType>(handle.npad_id))) {
-        return VibrationInvalidNpadId;
+        return ResultVibrationInvalidNpadId;
     }
 
     if (handle.device_index >= Core::HID::DeviceIndex::MaxDeviceIndex) {
-        return VibrationDeviceIndexOutOfRange;
+        return ResultVibrationDeviceIndexOutOfRange;
     }
 
     return ResultSuccess;
diff --git a/src/core/hle/service/hid/irs.cpp b/src/core/hle/service/hid/irs.cpp
index 008debfd1aa0..05ed31273db3 100644
--- a/src/core/hle/service/hid/irs.cpp
+++ b/src/core/hle/service/hid/irs.cpp
@@ -315,7 +315,7 @@ void IRS::GetNpadIrCameraHandle(HLERequestContext& ctx) {
     if (npad_id > Core::HID::NpadIdType::Player8 && npad_id != Core::HID::NpadIdType::Invalid &&
         npad_id != Core::HID::NpadIdType::Handheld) {
         IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(Service::HID::InvalidNpadId);
+        rb.Push(Service::HID::ResultInvalidNpadId);
         return;
     }
 
diff --git a/src/core/hle/service/hid/resource_manager.cpp b/src/core/hle/service/hid/resource_manager.cpp
index 84b4be3edc7a..1f41e645dd39 100644
--- a/src/core/hle/service/hid/resource_manager.cpp
+++ b/src/core/hle/service/hid/resource_manager.cpp
@@ -129,12 +129,12 @@ std::shared_ptr<UniquePad> ResourceManager::GetUniquePad() const {
 }
 
 Result ResourceManager::CreateAppletResource(u64 aruid) {
-    if (aruid == 0) {
+    if (aruid == SystemAruid) {
         const auto result = RegisterCoreAppletResource();
         if (result.IsError()) {
             return result;
         }
-        return GetNpad()->Activate();
+        return GetNpad()->ActivateNpadResource();
     }
 
     const auto result = CreateAppletResourceImpl(aruid);
@@ -147,7 +147,7 @@ Result ResourceManager::CreateAppletResource(u64 aruid) {
     six_axis->Activate();
     touch_screen->Activate();
 
-    return GetNpad()->Activate(aruid);
+    return GetNpad()->ActivateNpadResource(aruid);
 }
 
 Result ResourceManager::CreateAppletResourceImpl(u64 aruid) {
@@ -171,31 +171,31 @@ void ResourceManager::InitializeHidCommonSampler() {
     palma = std::make_shared<Palma>(system.HIDCore(), service_context);
     six_axis = std::make_shared<SixAxis>(system.HIDCore(), npad);
 
-    debug_pad->SetAppletResource(applet_resource);
-    digitizer->SetAppletResource(applet_resource);
-    keyboard->SetAppletResource(applet_resource);
-    npad->SetAppletResource(applet_resource);
-    six_axis->SetAppletResource(applet_resource);
-    mouse->SetAppletResource(applet_resource);
-    debug_mouse->SetAppletResource(applet_resource);
-    home_button->SetAppletResource(applet_resource);
-    sleep_button->SetAppletResource(applet_resource);
-    capture_button->SetAppletResource(applet_resource);
+    debug_pad->SetAppletResource(applet_resource, &shared_mutex);
+    digitizer->SetAppletResource(applet_resource, &shared_mutex);
+    keyboard->SetAppletResource(applet_resource, &shared_mutex);
+    npad->SetNpadExternals(applet_resource, &shared_mutex);
+    six_axis->SetAppletResource(applet_resource, &shared_mutex);
+    mouse->SetAppletResource(applet_resource, &shared_mutex);
+    debug_mouse->SetAppletResource(applet_resource, &shared_mutex);
+    home_button->SetAppletResource(applet_resource, &shared_mutex);
+    sleep_button->SetAppletResource(applet_resource, &shared_mutex);
+    capture_button->SetAppletResource(applet_resource, &shared_mutex);
 }
 
 void ResourceManager::InitializeTouchScreenSampler() {
     gesture = std::make_shared<Gesture>(system.HIDCore());
     touch_screen = std::make_shared<TouchScreen>(system.HIDCore());
 
-    touch_screen->SetAppletResource(applet_resource);
-    gesture->SetAppletResource(applet_resource);
+    touch_screen->SetAppletResource(applet_resource, &shared_mutex);
+    gesture->SetAppletResource(applet_resource, &shared_mutex);
 }
 
 void ResourceManager::InitializeConsoleSixAxisSampler() {
     console_six_axis = std::make_shared<ConsoleSixAxis>(system.HIDCore());
     seven_six_axis = std::make_shared<SevenSixAxis>(system);
 
-    console_six_axis->SetAppletResource(applet_resource);
+    console_six_axis->SetAppletResource(applet_resource, &shared_mutex);
 }
 
 void ResourceManager::InitializeAHidSampler() {
@@ -214,7 +214,11 @@ Result ResourceManager::UnregisterCoreAppletResource() {
 
 Result ResourceManager::RegisterAppletResourceUserId(u64 aruid, bool bool_value) {
     std::scoped_lock lock{shared_mutex};
-    return applet_resource->RegisterAppletResourceUserId(aruid, bool_value);
+    auto result = applet_resource->RegisterAppletResourceUserId(aruid, bool_value);
+    if (result.IsSuccess()) {
+        result = npad->RegisterAppletResourceUserId(aruid);
+    }
+    return result;
 }
 
 void ResourceManager::UnregisterAppletResourceUserId(u64 aruid) {
diff --git a/src/core/hle/service/hid/resource_manager.h b/src/core/hle/service/hid/resource_manager.h
index 70d9b6550f29..7a21d8eb8a8b 100644
--- a/src/core/hle/service/hid/resource_manager.h
+++ b/src/core/hle/service/hid/resource_manager.h
@@ -93,7 +93,7 @@ class ResourceManager {
 
     bool is_initialized{false};
 
-    mutable std::mutex shared_mutex;
+    mutable std::recursive_mutex shared_mutex;
     std::shared_ptr<AppletResource> applet_resource = nullptr;
 
     std::shared_ptr<CaptureButton> capture_button = nullptr;
