diff --git a/src/android/app/src/main/jni/native.cpp b/src/android/app/src/main/jni/native.cpp
index 4ea82e2170d1..fa2300ae6b26 100644
--- a/src/android/app/src/main/jni/native.cpp
+++ b/src/android/app/src/main/jni/native.cpp
@@ -665,7 +665,7 @@ void Java_org_yuzu_yuzu_1emu_NativeLibrary_initializeEmptyUserDirectory(JNIEnv*
     ASSERT(user_id);
 
     const auto user_save_data_path = FileSys::SaveDataFactory::GetFullPath(
-        {}, vfs_nand_dir, FileSys::SaveDataSpaceId::NandUser, FileSys::SaveDataType::SaveData, 1,
+        {}, vfs_nand_dir, FileSys::SaveDataSpaceId::User, FileSys::SaveDataType::Account, 1,
         user_id->AsU128(), 0);
 
     const auto full_path = Common::FS::ConcatPathSafe(nand_dir, user_save_data_path);
@@ -833,8 +833,8 @@ jstring Java_org_yuzu_yuzu_1emu_NativeLibrary_getSavePath(JNIEnv* env, jobject j
                                                             FileSys::OpenMode::Read);
 
     const auto user_save_data_path = FileSys::SaveDataFactory::GetFullPath(
-        {}, vfsNandDir, FileSys::SaveDataSpaceId::NandUser, FileSys::SaveDataType::SaveData,
-        program_id, user_id->AsU128(), 0);
+        {}, vfsNandDir, FileSys::SaveDataSpaceId::User, FileSys::SaveDataType::Account, program_id,
+        user_id->AsU128(), 0);
     return Common::Android::ToJString(env, user_save_data_path);
 }
 
diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index 23f7174727f5..de945fa704aa 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -58,6 +58,7 @@ add_library(core STATIC
     file_sys/fs_operate_range.h
     file_sys/fs_path.h
     file_sys/fs_path_utility.h
+    file_sys/fs_save_data_types.h
     file_sys/fs_string_util.h
     file_sys/fsmitm_romfsbuild.cpp
     file_sys/fsmitm_romfsbuild.h
@@ -585,6 +586,10 @@ add_library(core STATIC
     hle/service/filesystem/fsp/fs_i_file.h
     hle/service/filesystem/fsp/fs_i_filesystem.cpp
     hle/service/filesystem/fsp/fs_i_filesystem.h
+    hle/service/filesystem/fsp/fs_i_multi_commit_manager.cpp
+    hle/service/filesystem/fsp/fs_i_multi_commit_manager.h
+    hle/service/filesystem/fsp/fs_i_save_data_info_reader.cpp
+    hle/service/filesystem/fsp/fs_i_save_data_info_reader.h
     hle/service/filesystem/fsp/fs_i_storage.cpp
     hle/service/filesystem/fsp/fs_i_storage.h
     hle/service/filesystem/fsp/fsp_ldr.cpp
@@ -593,7 +598,7 @@ add_library(core STATIC
     hle/service/filesystem/fsp/fsp_pr.h
     hle/service/filesystem/fsp/fsp_srv.cpp
     hle/service/filesystem/fsp/fsp_srv.h
-    hle/service/filesystem/fsp/fsp_util.h
+    hle/service/filesystem/fsp/fsp_types.h
     hle/service/filesystem/romfs_controller.cpp
     hle/service/filesystem/romfs_controller.h
     hle/service/filesystem/save_data_controller.cpp
diff --git a/src/core/file_sys/fs_save_data_types.h b/src/core/file_sys/fs_save_data_types.h
new file mode 100644
index 000000000000..86a83d217557
--- /dev/null
+++ b/src/core/file_sys/fs_save_data_types.h
@@ -0,0 +1,175 @@
+// SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#pragma once
+
+#include <array>
+#include <fmt/format.h>
+#include "common/common_funcs.h"
+#include "common/common_types.h"
+
+namespace FileSys {
+
+using SaveDataId = u64;
+using SystemSaveDataId = u64;
+using SystemBcatSaveDataId = SystemSaveDataId;
+using ProgramId = u64;
+
+enum class SaveDataSpaceId : u8 {
+    System = 0,
+    User = 1,
+    SdSystem = 2,
+    Temporary = 3,
+    SdUser = 4,
+
+    ProperSystem = 100,
+    SafeMode = 101,
+};
+
+enum class SaveDataType : u8 {
+    System = 0,
+    Account = 1,
+    Bcat = 2,
+    Device = 3,
+    Temporary = 4,
+    Cache = 5,
+    SystemBcat = 6,
+};
+
+enum class SaveDataRank : u8 {
+    Primary = 0,
+    Secondary = 1,
+};
+
+struct SaveDataSize {
+    u64 normal;
+    u64 journal;
+};
+static_assert(sizeof(SaveDataSize) == 0x10, "SaveDataSize has invalid size.");
+
+using UserId = u128;
+static_assert(std::is_trivially_copyable_v<UserId>, "Data type must be trivially copyable.");
+static_assert(sizeof(UserId) == 0x10, "UserId has invalid size.");
+
+constexpr inline SystemSaveDataId InvalidSystemSaveDataId = 0;
+constexpr inline UserId InvalidUserId = {};
+
+enum class SaveDataFlags : u32 {
+    None = (0 << 0),
+    KeepAfterResettingSystemSaveData = (1 << 0),
+    KeepAfterRefurbishment = (1 << 1),
+    KeepAfterResettingSystemSaveDataWithoutUserSaveData = (1 << 2),
+    NeedsSecureDelete = (1 << 3),
+};
+
+enum class SaveDataMetaType : u8 {
+    None = 0,
+    Thumbnail = 1,
+    ExtensionContext = 2,
+};
+
+struct SaveDataMetaInfo {
+    u32 size;
+    SaveDataMetaType type;
+    INSERT_PADDING_BYTES(0xB);
+};
+static_assert(std::is_trivially_copyable_v<SaveDataMetaInfo>,
+              "Data type must be trivially copyable.");
+static_assert(sizeof(SaveDataMetaInfo) == 0x10, "SaveDataMetaInfo has invalid size.");
+
+struct SaveDataCreationInfo {
+    s64 size;
+    s64 journal_size;
+    s64 block_size;
+    u64 owner_id;
+    u32 flags;
+    SaveDataSpaceId space_id;
+    bool pseudo;
+    INSERT_PADDING_BYTES(0x1A);
+};
+static_assert(std::is_trivially_copyable_v<SaveDataCreationInfo>,
+              "Data type must be trivially copyable.");
+static_assert(sizeof(SaveDataCreationInfo) == 0x40, "SaveDataCreationInfo has invalid size.");
+
+struct SaveDataAttribute {
+    ProgramId program_id;
+    UserId user_id;
+    SystemSaveDataId system_save_data_id;
+    SaveDataType type;
+    SaveDataRank rank;
+    u16 index;
+    INSERT_PADDING_BYTES(0x1C);
+
+    static constexpr SaveDataAttribute Make(ProgramId program_id, SaveDataType type, UserId user_id,
+                                            SystemSaveDataId system_save_data_id, u16 index,
+                                            SaveDataRank rank) {
+        return {
+            .program_id = program_id,
+            .user_id = user_id,
+            .system_save_data_id = system_save_data_id,
+            .type = type,
+            .rank = rank,
+            .index = index,
+        };
+    }
+
+    static constexpr SaveDataAttribute Make(ProgramId program_id, SaveDataType type, UserId user_id,
+                                            SystemSaveDataId system_save_data_id, u16 index) {
+        return Make(program_id, type, user_id, system_save_data_id, index, SaveDataRank::Primary);
+    }
+
+    static constexpr SaveDataAttribute Make(ProgramId program_id, SaveDataType type, UserId user_id,
+                                            SystemSaveDataId system_save_data_id) {
+        return Make(program_id, type, user_id, system_save_data_id, 0, SaveDataRank::Primary);
+    }
+
+    std::string DebugInfo() const {
+        return fmt::format(
+            "[title_id={:016X}, user_id={:016X}{:016X}, save_id={:016X}, type={:02X}, "
+            "rank={}, index={}]",
+            program_id, user_id[1], user_id[0], system_save_data_id, static_cast<u8>(type),
+            static_cast<u8>(rank), index);
+    }
+};
+static_assert(sizeof(SaveDataAttribute) == 0x40);
+static_assert(std::is_trivially_destructible<SaveDataAttribute>::value);
+
+constexpr inline bool operator<(const SaveDataAttribute& lhs, const SaveDataAttribute& rhs) {
+    return std::tie(lhs.program_id, lhs.user_id, lhs.system_save_data_id, lhs.index, lhs.rank) <
+           std::tie(rhs.program_id, rhs.user_id, rhs.system_save_data_id, rhs.index, rhs.rank);
+}
+
+constexpr inline bool operator==(const SaveDataAttribute& lhs, const SaveDataAttribute& rhs) {
+    return std::tie(lhs.program_id, lhs.user_id, lhs.system_save_data_id, lhs.type, lhs.rank,
+                    lhs.index) == std::tie(rhs.program_id, rhs.user_id, rhs.system_save_data_id,
+                                           rhs.type, rhs.rank, rhs.index);
+}
+
+constexpr inline bool operator!=(const SaveDataAttribute& lhs, const SaveDataAttribute& rhs) {
+    return !(lhs == rhs);
+}
+
+struct SaveDataExtraData {
+    SaveDataAttribute attr;
+    u64 owner_id;
+    s64 timestamp;
+    u32 flags;
+    INSERT_PADDING_BYTES(4);
+    s64 available_size;
+    s64 journal_size;
+    s64 commit_id;
+    INSERT_PADDING_BYTES(0x190);
+};
+static_assert(sizeof(SaveDataExtraData) == 0x200, "SaveDataExtraData has invalid size.");
+static_assert(std::is_trivially_copyable_v<SaveDataExtraData>,
+              "Data type must be trivially copyable.");
+
+struct HashSalt {
+    static constexpr size_t Size = 32;
+
+    std::array<u8, Size> value;
+};
+static_assert(std::is_trivially_copyable_v<HashSalt>, "Data type must be trivially copyable.");
+static_assert(sizeof(HashSalt) == HashSalt::Size);
+
+} // namespace FileSys
diff --git a/src/core/file_sys/savedata_factory.cpp b/src/core/file_sys/savedata_factory.cpp
index cbf411a20063..106922e04f85 100644
--- a/src/core/file_sys/savedata_factory.cpp
+++ b/src/core/file_sys/savedata_factory.cpp
@@ -14,48 +14,11 @@ namespace FileSys {
 
 namespace {
 
-void PrintSaveDataAttributeWarnings(SaveDataAttribute meta) {
-    if (meta.type == SaveDataType::SystemSaveData || meta.type == SaveDataType::SaveData) {
-        if (meta.zero_1 != 0) {
-            LOG_WARNING(Service_FS,
-                        "Possibly incorrect SaveDataAttribute, type is "
-                        "SystemSaveData||SaveData but offset 0x28 is non-zero ({:016X}).",
-                        meta.zero_1);
-        }
-        if (meta.zero_2 != 0) {
-            LOG_WARNING(Service_FS,
-                        "Possibly incorrect SaveDataAttribute, type is "
-                        "SystemSaveData||SaveData but offset 0x30 is non-zero ({:016X}).",
-                        meta.zero_2);
-        }
-        if (meta.zero_3 != 0) {
-            LOG_WARNING(Service_FS,
-                        "Possibly incorrect SaveDataAttribute, type is "
-                        "SystemSaveData||SaveData but offset 0x38 is non-zero ({:016X}).",
-                        meta.zero_3);
-        }
-    }
-
-    if (meta.type == SaveDataType::SystemSaveData && meta.title_id != 0) {
-        LOG_WARNING(Service_FS,
-                    "Possibly incorrect SaveDataAttribute, type is SystemSaveData but title_id is "
-                    "non-zero ({:016X}).",
-                    meta.title_id);
-    }
-
-    if (meta.type == SaveDataType::DeviceSaveData && meta.user_id != u128{0, 0}) {
-        LOG_WARNING(Service_FS,
-                    "Possibly incorrect SaveDataAttribute, type is DeviceSaveData but user_id is "
-                    "non-zero ({:016X}{:016X})",
-                    meta.user_id[1], meta.user_id[0]);
-    }
-}
-
 bool ShouldSaveDataBeAutomaticallyCreated(SaveDataSpaceId space, const SaveDataAttribute& attr) {
-    return attr.type == SaveDataType::CacheStorage || attr.type == SaveDataType::TemporaryStorage ||
-           (space == SaveDataSpaceId::NandUser && ///< Normal Save Data -- Current Title & User
-            (attr.type == SaveDataType::SaveData || attr.type == SaveDataType::DeviceSaveData) &&
-            attr.title_id == 0 && attr.save_id == 0);
+    return attr.type == SaveDataType::Cache || attr.type == SaveDataType::Temporary ||
+           (space == SaveDataSpaceId::User && ///< Normal Save Data -- Current Title & User
+            (attr.type == SaveDataType::Account || attr.type == SaveDataType::Device) &&
+            attr.program_id == 0 && attr.system_save_data_id == 0);
 }
 
 std::string GetFutureSaveDataPath(SaveDataSpaceId space_id, SaveDataType type, u64 title_id,
@@ -63,7 +26,7 @@ std::string GetFutureSaveDataPath(SaveDataSpaceId space_id, SaveDataType type, u
     // Only detect nand user saves.
     const auto space_id_path = [space_id]() -> std::string_view {
         switch (space_id) {
-        case SaveDataSpaceId::NandUser:
+        case SaveDataSpaceId::User:
             return "/user/save";
         default:
             return "";
@@ -79,9 +42,9 @@ std::string GetFutureSaveDataPath(SaveDataSpaceId space_id, SaveDataType type, u
 
     // Only detect account/device saves from the future location.
     switch (type) {
-    case SaveDataType::SaveData:
+    case SaveDataType::Account:
         return fmt::format("{}/account/{}/{:016X}/0", space_id_path, uuid.RawString(), title_id);
-    case SaveDataType::DeviceSaveData:
+    case SaveDataType::Device:
         return fmt::format("{}/device/{:016X}/0", space_id_path, title_id);
     default:
         return "";
@@ -90,13 +53,6 @@ std::string GetFutureSaveDataPath(SaveDataSpaceId space_id, SaveDataType type, u
 
 } // Anonymous namespace
 
-std::string SaveDataAttribute::DebugInfo() const {
-    return fmt::format("[title_id={:016X}, user_id={:016X}{:016X}, save_id={:016X}, type={:02X}, "
-                       "rank={}, index={}]",
-                       title_id, user_id[1], user_id[0], save_id, static_cast<u8>(type),
-                       static_cast<u8>(rank), index);
-}
-
 SaveDataFactory::SaveDataFactory(Core::System& system_, ProgramId program_id_,
                                  VirtualDir save_directory_)
     : system{system_}, program_id{program_id_}, dir{std::move(save_directory_)} {
@@ -108,18 +64,16 @@ SaveDataFactory::SaveDataFactory(Core::System& system_, ProgramId program_id_,
 SaveDataFactory::~SaveDataFactory() = default;
 
 VirtualDir SaveDataFactory::Create(SaveDataSpaceId space, const SaveDataAttribute& meta) const {
-    PrintSaveDataAttributeWarnings(meta);
-
-    const auto save_directory =
-        GetFullPath(program_id, dir, space, meta.type, meta.title_id, meta.user_id, meta.save_id);
+    const auto save_directory = GetFullPath(program_id, dir, space, meta.type, meta.program_id,
+                                            meta.user_id, meta.system_save_data_id);
 
     return dir->CreateDirectoryRelative(save_directory);
 }
 
 VirtualDir SaveDataFactory::Open(SaveDataSpaceId space, const SaveDataAttribute& meta) const {
 
-    const auto save_directory =
-        GetFullPath(program_id, dir, space, meta.type, meta.title_id, meta.user_id, meta.save_id);
+    const auto save_directory = GetFullPath(program_id, dir, space, meta.type, meta.program_id,
+                                            meta.user_id, meta.system_save_data_id);
 
     auto out = dir->GetDirectoryRelative(save_directory);
 
@@ -136,11 +90,11 @@ VirtualDir SaveDataFactory::GetSaveDataSpaceDirectory(SaveDataSpaceId space) con
 
 std::string SaveDataFactory::GetSaveDataSpaceIdPath(SaveDataSpaceId space) {
     switch (space) {
-    case SaveDataSpaceId::NandSystem:
+    case SaveDataSpaceId::System:
         return "/system/";
-    case SaveDataSpaceId::NandUser:
+    case SaveDataSpaceId::User:
         return "/user/";
-    case SaveDataSpaceId::TemporaryStorage:
+    case SaveDataSpaceId::Temporary:
         return "/temp/";
     default:
         ASSERT_MSG(false, "Unrecognized SaveDataSpaceId: {:02X}", static_cast<u8>(space));
@@ -153,7 +107,7 @@ std::string SaveDataFactory::GetFullPath(ProgramId program_id, VirtualDir dir,
                                          u128 user_id, u64 save_id) {
     // According to switchbrew, if a save is of type SaveData and the title id field is 0, it should
     // be interpreted as the title id of the current process.
-    if (type == SaveDataType::SaveData || type == SaveDataType::DeviceSaveData) {
+    if (type == SaveDataType::Account || type == SaveDataType::Device) {
         if (title_id == 0) {
             title_id = program_id;
         }
@@ -173,16 +127,16 @@ std::string SaveDataFactory::GetFullPath(ProgramId program_id, VirtualDir dir,
     std::string out = GetSaveDataSpaceIdPath(space);
 
     switch (type) {
-    case SaveDataType::SystemSaveData:
+    case SaveDataType::System:
         return fmt::format("{}save/{:016X}/{:016X}{:016X}", out, save_id, user_id[1], user_id[0]);
-    case SaveDataType::SaveData:
-    case SaveDataType::DeviceSaveData:
+    case SaveDataType::Account:
+    case SaveDataType::Device:
         return fmt::format("{}save/{:016X}/{:016X}{:016X}/{:016X}", out, 0, user_id[1], user_id[0],
                            title_id);
-    case SaveDataType::TemporaryStorage:
+    case SaveDataType::Temporary:
         return fmt::format("{}{:016X}/{:016X}{:016X}/{:016X}", out, 0, user_id[1], user_id[0],
                            title_id);
-    case SaveDataType::CacheStorage:
+    case SaveDataType::Cache:
         return fmt::format("{}save/cache/{:016X}", out, title_id);
     default:
         ASSERT_MSG(false, "Unrecognized SaveDataType: {:02X}", static_cast<u8>(type));
@@ -202,7 +156,7 @@ std::string SaveDataFactory::GetUserGameSaveDataRoot(u128 user_id, bool future)
 SaveDataSize SaveDataFactory::ReadSaveDataSize(SaveDataType type, u64 title_id,
                                                u128 user_id) const {
     const auto path =
-        GetFullPath(program_id, dir, SaveDataSpaceId::NandUser, type, title_id, user_id, 0);
+        GetFullPath(program_id, dir, SaveDataSpaceId::User, type, title_id, user_id, 0);
     const auto relative_dir = GetOrCreateDirectoryRelative(dir, path);
 
     const auto size_file = relative_dir->GetFile(GetSaveDataSizeFileName());
@@ -221,7 +175,7 @@ SaveDataSize SaveDataFactory::ReadSaveDataSize(SaveDataType type, u64 title_id,
 void SaveDataFactory::WriteSaveDataSize(SaveDataType type, u64 title_id, u128 user_id,
                                         SaveDataSize new_value) const {
     const auto path =
-        GetFullPath(program_id, dir, SaveDataSpaceId::NandUser, type, title_id, user_id, 0);
+        GetFullPath(program_id, dir, SaveDataSpaceId::User, type, title_id, user_id, 0);
     const auto relative_dir = GetOrCreateDirectoryRelative(dir, path);
 
     const auto size_file = relative_dir->CreateFile(GetSaveDataSizeFileName());
diff --git a/src/core/file_sys/savedata_factory.h b/src/core/file_sys/savedata_factory.h
index 5ab7e4d32049..15dd4ec7de40 100644
--- a/src/core/file_sys/savedata_factory.h
+++ b/src/core/file_sys/savedata_factory.h
@@ -7,6 +7,7 @@
 #include <string>
 #include "common/common_funcs.h"
 #include "common/common_types.h"
+#include "core/file_sys/fs_save_data_types.h"
 #include "core/file_sys/vfs/vfs.h"
 #include "core/hle/result.h"
 
@@ -16,73 +17,6 @@ class System;
 
 namespace FileSys {
 
-enum class SaveDataSpaceId : u8 {
-    NandSystem = 0,
-    NandUser = 1,
-    SdCardSystem = 2,
-    TemporaryStorage = 3,
-    SdCardUser = 4,
-    ProperSystem = 100,
-    SafeMode = 101,
-};
-
-enum class SaveDataType : u8 {
-    SystemSaveData = 0,
-    SaveData = 1,
-    BcatDeliveryCacheStorage = 2,
-    DeviceSaveData = 3,
-    TemporaryStorage = 4,
-    CacheStorage = 5,
-    SystemBcat = 6,
-};
-
-enum class SaveDataRank : u8 {
-    Primary = 0,
-    Secondary = 1,
-};
-
-enum class SaveDataFlags : u32 {
-    None = (0 << 0),
-    KeepAfterResettingSystemSaveData = (1 << 0),
-    KeepAfterRefurbishment = (1 << 1),
-    KeepAfterResettingSystemSaveDataWithoutUserSaveData = (1 << 2),
-    NeedsSecureDelete = (1 << 3),
-};
-
-struct SaveDataAttribute {
-    u64 title_id;
-    u128 user_id;
-    u64 save_id;
-    SaveDataType type;
-    SaveDataRank rank;
-    u16 index;
-    INSERT_PADDING_BYTES_NOINIT(4);
-    u64 zero_1;
-    u64 zero_2;
-    u64 zero_3;
-
-    std::string DebugInfo() const;
-};
-static_assert(sizeof(SaveDataAttribute) == 0x40, "SaveDataAttribute has incorrect size.");
-
-struct SaveDataExtraData {
-    SaveDataAttribute attr;
-    u64 owner_id;
-    s64 timestamp;
-    SaveDataFlags flags;
-    INSERT_PADDING_BYTES_NOINIT(4);
-    s64 available_size;
-    s64 journal_size;
-    s64 commit_id;
-    std::array<u8, 0x190> unused;
-};
-static_assert(sizeof(SaveDataExtraData) == 0x200, "SaveDataExtraData has incorrect size.");
-
-struct SaveDataSize {
-    u64 normal;
-    u64 journal;
-};
-
 constexpr const char* GetSaveDataSizeFileName() {
     return ".yuzu_save_size";
 }
diff --git a/src/core/hle/service/am/service/application_functions.cpp b/src/core/hle/service/am/service/application_functions.cpp
index cb53b07e05f1..bfccb6b09ff7 100644
--- a/src/core/hle/service/am/service/application_functions.cpp
+++ b/src/core/hle/service/am/service/application_functions.cpp
@@ -123,13 +123,13 @@ Result IApplicationFunctions::EnsureSaveData(Out<u64> out_size, Common::UUID use
     LOG_INFO(Service_AM, "called, uid={}", user_id.FormattedString());
 
     FileSys::SaveDataAttribute attribute{};
-    attribute.title_id = m_applet->program_id;
+    attribute.program_id = m_applet->program_id;
     attribute.user_id = user_id.AsU128();
-    attribute.type = FileSys::SaveDataType::SaveData;
+    attribute.type = FileSys::SaveDataType::Account;
 
     FileSys::VirtualDir save_data{};
     R_TRY(system.GetFileSystemController().OpenSaveDataController()->CreateSaveData(
-        &save_data, FileSys::SaveDataSpaceId::NandUser, attribute));
+        &save_data, FileSys::SaveDataSpaceId::User, attribute));
 
     *out_size = 0;
     R_SUCCEED();
diff --git a/src/core/hle/service/filesystem/fsp/fs_i_filesystem.h b/src/core/hle/service/filesystem/fsp/fs_i_filesystem.h
index b06b3ef0eb46..b1f3ab5dd253 100644
--- a/src/core/hle/service/filesystem/fsp/fs_i_filesystem.h
+++ b/src/core/hle/service/filesystem/fsp/fs_i_filesystem.h
@@ -5,7 +5,7 @@
 
 #include "core/file_sys/vfs/vfs.h"
 #include "core/hle/service/filesystem/filesystem.h"
-#include "core/hle/service/filesystem/fsp/fsp_util.h"
+#include "core/hle/service/filesystem/fsp/fsp_types.h"
 #include "core/hle/service/service.h"
 
 namespace Service::FileSystem {
diff --git a/src/core/hle/service/filesystem/fsp/fs_i_multi_commit_manager.cpp b/src/core/hle/service/filesystem/fsp/fs_i_multi_commit_manager.cpp
new file mode 100644
index 000000000000..6263282344a0
--- /dev/null
+++ b/src/core/hle/service/filesystem/fsp/fs_i_multi_commit_manager.cpp
@@ -0,0 +1,33 @@
+// SPDX-FileCopyrightText: Copyright 2018 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include "core/hle/service/cmif_serialization.h"
+#include "core/hle/service/filesystem/fsp/fs_i_filesystem.h"
+#include "core/hle/service/filesystem/fsp/fs_i_multi_commit_manager.h"
+
+namespace Service::FileSystem {
+
+IMultiCommitManager::IMultiCommitManager(Core::System& system_)
+    : ServiceFramework{system_, "IMultiCommitManager"} {
+    static const FunctionInfo functions[] = {
+        {1, D<&IMultiCommitManager::Add>, "Add"},
+        {2, D<&IMultiCommitManager::Commit>, "Commit"},
+    };
+    RegisterHandlers(functions);
+}
+
+IMultiCommitManager::~IMultiCommitManager() = default;
+
+Result IMultiCommitManager::Add(std::shared_ptr<IFileSystem> filesystem) {
+    LOG_WARNING(Service_FS, "(STUBBED) called");
+
+    R_SUCCEED();
+}
+
+Result IMultiCommitManager::Commit() {
+    LOG_WARNING(Service_FS, "(STUBBED) called");
+
+    R_SUCCEED();
+}
+
+} // namespace Service::FileSystem
diff --git a/src/core/hle/service/filesystem/fsp/fs_i_multi_commit_manager.h b/src/core/hle/service/filesystem/fsp/fs_i_multi_commit_manager.h
new file mode 100644
index 000000000000..8ebf7c7d9628
--- /dev/null
+++ b/src/core/hle/service/filesystem/fsp/fs_i_multi_commit_manager.h
@@ -0,0 +1,23 @@
+// SPDX-FileCopyrightText: Copyright 2018 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#pragma once
+
+#include "core/file_sys/vfs/vfs.h"
+#include "core/hle/service/service.h"
+
+namespace Service::FileSystem {
+
+class IMultiCommitManager final : public ServiceFramework<IMultiCommitManager> {
+public:
+    explicit IMultiCommitManager(Core::System& system_);
+    ~IMultiCommitManager() override;
+
+private:
+    Result Add(std::shared_ptr<IFileSystem> filesystem);
+    Result Commit();
+
+    FileSys::VirtualFile backend;
+};
+
+} // namespace Service::FileSystem
diff --git a/src/core/hle/service/filesystem/fsp/fs_i_save_data_info_reader.cpp b/src/core/hle/service/filesystem/fsp/fs_i_save_data_info_reader.cpp
new file mode 100644
index 000000000000..ff823586b3e1
--- /dev/null
+++ b/src/core/hle/service/filesystem/fsp/fs_i_save_data_info_reader.cpp
@@ -0,0 +1,161 @@
+// SPDX-FileCopyrightText: Copyright 2018 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include "common/hex_util.h"
+#include "core/file_sys/savedata_factory.h"
+#include "core/hle/service/cmif_serialization.h"
+#include "core/hle/service/filesystem/fsp/fs_i_save_data_info_reader.h"
+#include "core/hle/service/filesystem/save_data_controller.h"
+
+namespace Service::FileSystem {
+
+ISaveDataInfoReader::ISaveDataInfoReader(Core::System& system_,
+                                         std::shared_ptr<SaveDataController> save_data_controller_,
+                                         FileSys::SaveDataSpaceId space)
+    : ServiceFramework{system_, "ISaveDataInfoReader"}, save_data_controller{
+                                                            save_data_controller_} {
+    static const FunctionInfo functions[] = {
+        {0, D<&ISaveDataInfoReader::ReadSaveDataInfo>, "ReadSaveDataInfo"},
+    };
+    RegisterHandlers(functions);
+
+    FindAllSaves(space);
+}
+
+ISaveDataInfoReader::~ISaveDataInfoReader() = default;
+
+static u64 stoull_be(std::string_view str) {
+    if (str.size() != 16) {
+        return 0;
+    }
+
+    const auto bytes = Common::HexStringToArray<0x8>(str);
+    u64 out{};
+    std::memcpy(&out, bytes.data(), sizeof(u64));
+
+    return Common::swap64(out);
+}
+
+Result ISaveDataInfoReader::ReadSaveDataInfo(
+    Out<u64> out_count, OutArray<SaveDataInfo, BufferAttr_HipcMapAlias> out_entries) {
+    LOG_DEBUG(Service_FS, "called");
+
+    // Calculate how many entries we can fit in the output buffer
+    const u64 count_entries = out_entries.size();
+
+    // Cap at total number of entries.
+    const u64 actual_entries = std::min(count_entries, info.size() - next_entry_index);
+
+    // Determine data start and end
+    const auto* begin = reinterpret_cast<u8*>(info.data() + next_entry_index);
+    const auto* end = reinterpret_cast<u8*>(info.data() + next_entry_index + actual_entries);
+    const auto range_size = static_cast<std::size_t>(std::distance(begin, end));
+
+    next_entry_index += actual_entries;
+
+    // Write the data to memory
+    std::memcpy(out_entries.data(), begin, range_size);
+    *out_count = actual_entries;
+
+    R_SUCCEED();
+}
+
+void ISaveDataInfoReader::FindAllSaves(FileSys::SaveDataSpaceId space) {
+    FileSys::VirtualDir save_root{};
+    const auto result = save_data_controller->OpenSaveDataSpace(&save_root, space);
+
+    if (result != ResultSuccess || save_root == nullptr) {
+        LOG_ERROR(Service_FS, "The save root for the space_id={:02X} was invalid!", space);
+        return;
+    }
+
+    for (const auto& type : save_root->GetSubdirectories()) {
+        if (type->GetName() == "save") {
+            FindNormalSaves(space, type);
+        } else if (space == FileSys::SaveDataSpaceId::Temporary) {
+            FindTemporaryStorageSaves(space, type);
+        }
+    }
+}
+
+void ISaveDataInfoReader::FindNormalSaves(FileSys::SaveDataSpaceId space,
+                                          const FileSys::VirtualDir& type) {
+    for (const auto& save_id : type->GetSubdirectories()) {
+        for (const auto& user_id : save_id->GetSubdirectories()) {
+            // Skip non user id subdirectories
+            if (user_id->GetName().size() != 0x20) {
+                continue;
+            }
+
+            const auto save_id_numeric = stoull_be(save_id->GetName());
+            auto user_id_numeric = Common::HexStringToArray<0x10>(user_id->GetName());
+            std::reverse(user_id_numeric.begin(), user_id_numeric.end());
+
+            if (save_id_numeric != 0) {
+                // System Save Data
+                info.emplace_back(SaveDataInfo{
+                    0,
+                    space,
+                    FileSys::SaveDataType::System,
+                    {},
+                    user_id_numeric,
+                    save_id_numeric,
+                    0,
+                    user_id->GetSize(),
+                    {},
+                    {},
+                });
+
+                continue;
+            }
+
+            for (const auto& title_id : user_id->GetSubdirectories()) {
+                const auto device = std::all_of(user_id_numeric.begin(), user_id_numeric.end(),
+                                                [](u8 val) { return val == 0; });
+                info.emplace_back(SaveDataInfo{
+                    0,
+                    space,
+                    device ? FileSys::SaveDataType::Device : FileSys::SaveDataType::Account,
+                    {},
+                    user_id_numeric,
+                    save_id_numeric,
+                    stoull_be(title_id->GetName()),
+                    title_id->GetSize(),
+                    {},
+                    {},
+                });
+            }
+        }
+    }
+}
+
+void ISaveDataInfoReader::FindTemporaryStorageSaves(FileSys::SaveDataSpaceId space,
+                                                    const FileSys::VirtualDir& type) {
+    for (const auto& user_id : type->GetSubdirectories()) {
+        // Skip non user id subdirectories
+        if (user_id->GetName().size() != 0x20) {
+            continue;
+        }
+        for (const auto& title_id : user_id->GetSubdirectories()) {
+            if (!title_id->GetFiles().empty() || !title_id->GetSubdirectories().empty()) {
+                auto user_id_numeric = Common::HexStringToArray<0x10>(user_id->GetName());
+                std::reverse(user_id_numeric.begin(), user_id_numeric.end());
+
+                info.emplace_back(SaveDataInfo{
+                    0,
+                    space,
+                    FileSys::SaveDataType::Temporary,
+                    {},
+                    user_id_numeric,
+                    stoull_be(type->GetName()),
+                    stoull_be(title_id->GetName()),
+                    title_id->GetSize(),
+                    {},
+                    {},
+                });
+            }
+        }
+    }
+}
+
+} // namespace Service::FileSystem
diff --git a/src/core/hle/service/filesystem/fsp/fs_i_save_data_info_reader.h b/src/core/hle/service/filesystem/fsp/fs_i_save_data_info_reader.h
new file mode 100644
index 000000000000..e45ad852babf
--- /dev/null
+++ b/src/core/hle/service/filesystem/fsp/fs_i_save_data_info_reader.h
@@ -0,0 +1,50 @@
+// SPDX-FileCopyrightText: Copyright 2018 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#pragma once
+
+#include <vector>
+#include "common/common_types.h"
+#include "core/hle/service/cmif_types.h"
+#include "core/hle/service/service.h"
+
+namespace Service::FileSystem {
+
+class SaveDataController;
+
+class ISaveDataInfoReader final : public ServiceFramework<ISaveDataInfoReader> {
+public:
+    explicit ISaveDataInfoReader(Core::System& system_,
+                                 std::shared_ptr<SaveDataController> save_data_controller_,
+                                 FileSys::SaveDataSpaceId space);
+    ~ISaveDataInfoReader() override;
+
+    struct SaveDataInfo {
+        u64_le save_id_unknown;
+        FileSys::SaveDataSpaceId space;
+        FileSys::SaveDataType type;
+        INSERT_PADDING_BYTES(0x6);
+        std::array<u8, 0x10> user_id;
+        u64_le save_id;
+        u64_le title_id;
+        u64_le save_image_size;
+        u16_le index;
+        FileSys::SaveDataRank rank;
+        INSERT_PADDING_BYTES(0x25);
+    };
+    static_assert(sizeof(SaveDataInfo) == 0x60, "SaveDataInfo has incorrect size.");
+
+    Result ReadSaveDataInfo(Out<u64> out_count,
+                            OutArray<SaveDataInfo, BufferAttr_HipcMapAlias> out_entries);
+
+private:
+    void FindAllSaves(FileSys::SaveDataSpaceId space);
+    void FindNormalSaves(FileSys::SaveDataSpaceId space, const FileSys::VirtualDir& type);
+    void FindTemporaryStorageSaves(FileSys::SaveDataSpaceId space, const FileSys::VirtualDir& type);
+
+    std::shared_ptr<SaveDataController> save_data_controller;
+    std::vector<SaveDataInfo> info;
+    u64 next_entry_index = 0;
+};
+
+} // namespace Service::FileSystem
diff --git a/src/core/hle/service/filesystem/fsp/fs_i_storage.cpp b/src/core/hle/service/filesystem/fsp/fs_i_storage.cpp
index 98223c1f9dc3..213f198085a1 100644
--- a/src/core/hle/service/filesystem/fsp/fs_i_storage.cpp
+++ b/src/core/hle/service/filesystem/fsp/fs_i_storage.cpp
@@ -2,61 +2,44 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "core/file_sys/errors.h"
+#include "core/hle/service/cmif_serialization.h"
 #include "core/hle/service/filesystem/fsp/fs_i_storage.h"
-#include "core/hle/service/ipc_helpers.h"
 
 namespace Service::FileSystem {
 
 IStorage::IStorage(Core::System& system_, FileSys::VirtualFile backend_)
     : ServiceFramework{system_, "IStorage"}, backend(std::move(backend_)) {
     static const FunctionInfo functions[] = {
-        {0, &IStorage::Read, "Read"},
+        {0, D<&IStorage::Read>, "Read"},
         {1, nullptr, "Write"},
         {2, nullptr, "Flush"},
         {3, nullptr, "SetSize"},
-        {4, &IStorage::GetSize, "GetSize"},
+        {4, D<&IStorage::GetSize>, "GetSize"},
         {5, nullptr, "OperateRange"},
     };
     RegisterHandlers(functions);
 }
 
-void IStorage::Read(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-    const s64 offset = rp.Pop<s64>();
-    const s64 length = rp.Pop<s64>();
-
+Result IStorage::Read(
+    OutBuffer<BufferAttr_HipcMapAlias | BufferAttr_HipcMapTransferAllowsNonSecure> out_bytes,
+    s64 offset, s64 length) {
     LOG_DEBUG(Service_FS, "called, offset=0x{:X}, length={}", offset, length);
 
-    // Error checking
-    if (length < 0) {
-        LOG_ERROR(Service_FS, "Length is less than 0, length={}", length);
-        IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(FileSys::ResultInvalidSize);
-        return;
-    }
-    if (offset < 0) {
-        LOG_ERROR(Service_FS, "Offset is less than 0, offset={}", offset);
-        IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(FileSys::ResultInvalidOffset);
-        return;
-    }
+    R_UNLESS(length >= 0, FileSys::ResultInvalidSize);
+    R_UNLESS(offset >= 0, FileSys::ResultInvalidOffset);
 
     // Read the data from the Storage backend
-    std::vector<u8> output = backend->ReadBytes(length, offset);
-    // Write the data to memory
-    ctx.WriteBuffer(output);
+    backend->Read(out_bytes.data(), length, offset);
 
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    R_SUCCEED();
 }
 
-void IStorage::GetSize(HLERequestContext& ctx) {
-    const u64 size = backend->GetSize();
-    LOG_DEBUG(Service_FS, "called, size={}", size);
+Result IStorage::GetSize(Out<u64> out_size) {
+    *out_size = backend->GetSize();
+
+    LOG_DEBUG(Service_FS, "called, size={}", *out_size);
 
-    IPC::ResponseBuilder rb{ctx, 4};
-    rb.Push(ResultSuccess);
-    rb.Push<u64>(size);
+    R_SUCCEED();
 }
 
 } // namespace Service::FileSystem
diff --git a/src/core/hle/service/filesystem/fsp/fs_i_storage.h b/src/core/hle/service/filesystem/fsp/fs_i_storage.h
index cb5bebcc9125..74d879386f70 100644
--- a/src/core/hle/service/filesystem/fsp/fs_i_storage.h
+++ b/src/core/hle/service/filesystem/fsp/fs_i_storage.h
@@ -4,6 +4,7 @@
 #pragma once
 
 #include "core/file_sys/vfs/vfs.h"
+#include "core/hle/service/cmif_types.h"
 #include "core/hle/service/filesystem/filesystem.h"
 #include "core/hle/service/service.h"
 
@@ -16,8 +17,10 @@ class IStorage final : public ServiceFramework<IStorage> {
 private:
     FileSys::VirtualFile backend;
 
-    void Read(HLERequestContext& ctx);
-    void GetSize(HLERequestContext& ctx);
+    Result Read(
+        OutBuffer<BufferAttr_HipcMapAlias | BufferAttr_HipcMapTransferAllowsNonSecure> out_bytes,
+        s64 offset, s64 length);
+    Result GetSize(Out<u64> out_size);
 };
 
 } // namespace Service::FileSystem
diff --git a/src/core/hle/service/filesystem/fsp/fsp_srv.cpp b/src/core/hle/service/filesystem/fsp/fsp_srv.cpp
index 2d49f30c868e..fc67a4713ad1 100644
--- a/src/core/hle/service/filesystem/fsp/fsp_srv.cpp
+++ b/src/core/hle/service/filesystem/fsp/fsp_srv.cpp
@@ -27,8 +27,11 @@
 #include "core/file_sys/system_archive/system_archive.h"
 #include "core/file_sys/vfs/vfs.h"
 #include "core/hle/result.h"
+#include "core/hle/service/cmif_serialization.h"
 #include "core/hle/service/filesystem/filesystem.h"
 #include "core/hle/service/filesystem/fsp/fs_i_filesystem.h"
+#include "core/hle/service/filesystem/fsp/fs_i_multi_commit_manager.h"
+#include "core/hle/service/filesystem/fsp/fs_i_save_data_info_reader.h"
 #include "core/hle/service/filesystem/fsp/fs_i_storage.h"
 #include "core/hle/service/filesystem/fsp/fsp_srv.h"
 #include "core/hle/service/filesystem/romfs_controller.h"
@@ -39,182 +42,6 @@
 #include "core/reporter.h"
 
 namespace Service::FileSystem {
-enum class FileSystemProxyType : u8 {
-    Code = 0,
-    Rom = 1,
-    Logo = 2,
-    Control = 3,
-    Manual = 4,
-    Meta = 5,
-    Data = 6,
-    Package = 7,
-    RegisteredUpdate = 8,
-};
-
-class ISaveDataInfoReader final : public ServiceFramework<ISaveDataInfoReader> {
-public:
-    explicit ISaveDataInfoReader(Core::System& system_,
-                                 std::shared_ptr<SaveDataController> save_data_controller_,
-                                 FileSys::SaveDataSpaceId space)
-        : ServiceFramework{system_, "ISaveDataInfoReader"}, save_data_controller{
-                                                                save_data_controller_} {
-        static const FunctionInfo functions[] = {
-            {0, &ISaveDataInfoReader::ReadSaveDataInfo, "ReadSaveDataInfo"},
-        };
-        RegisterHandlers(functions);
-
-        FindAllSaves(space);
-    }
-
-    void ReadSaveDataInfo(HLERequestContext& ctx) {
-        LOG_DEBUG(Service_FS, "called");
-
-        // Calculate how many entries we can fit in the output buffer
-        const u64 count_entries = ctx.GetWriteBufferNumElements<SaveDataInfo>();
-
-        // Cap at total number of entries.
-        const u64 actual_entries = std::min(count_entries, info.size() - next_entry_index);
-
-        // Determine data start and end
-        const auto* begin = reinterpret_cast<u8*>(info.data() + next_entry_index);
-        const auto* end = reinterpret_cast<u8*>(info.data() + next_entry_index + actual_entries);
-        const auto range_size = static_cast<std::size_t>(std::distance(begin, end));
-
-        next_entry_index += actual_entries;
-
-        // Write the data to memory
-        ctx.WriteBuffer(begin, range_size);
-
-        IPC::ResponseBuilder rb{ctx, 4};
-        rb.Push(ResultSuccess);
-        rb.Push<u64>(actual_entries);
-    }
-
-private:
-    static u64 stoull_be(std::string_view str) {
-        if (str.size() != 16)
-            return 0;
-
-        const auto bytes = Common::HexStringToArray<0x8>(str);
-        u64 out{};
-        std::memcpy(&out, bytes.data(), sizeof(u64));
-
-        return Common::swap64(out);
-    }
-
-    void FindAllSaves(FileSys::SaveDataSpaceId space) {
-        FileSys::VirtualDir save_root{};
-        const auto result = save_data_controller->OpenSaveDataSpace(&save_root, space);
-
-        if (result != ResultSuccess || save_root == nullptr) {
-            LOG_ERROR(Service_FS, "The save root for the space_id={:02X} was invalid!", space);
-            return;
-        }
-
-        for (const auto& type : save_root->GetSubdirectories()) {
-            if (type->GetName() == "save") {
-                for (const auto& save_id : type->GetSubdirectories()) {
-                    for (const auto& user_id : save_id->GetSubdirectories()) {
-                        // Skip non user id subdirectories
-                        if (user_id->GetName().size() != 0x20) {
-                            continue;
-                        }
-
-                        const auto save_id_numeric = stoull_be(save_id->GetName());
-                        auto user_id_numeric = Common::HexStringToArray<0x10>(user_id->GetName());
-                        std::reverse(user_id_numeric.begin(), user_id_numeric.end());
-
-                        if (save_id_numeric != 0) {
-                            // System Save Data
-                            info.emplace_back(SaveDataInfo{
-                                0,
-                                space,
-                                FileSys::SaveDataType::SystemSaveData,
-                                {},
-                                user_id_numeric,
-                                save_id_numeric,
-                                0,
-                                user_id->GetSize(),
-                                {},
-                                {},
-                            });
-
-                            continue;
-                        }
-
-                        for (const auto& title_id : user_id->GetSubdirectories()) {
-                            const auto device =
-                                std::all_of(user_id_numeric.begin(), user_id_numeric.end(),
-                                            [](u8 val) { return val == 0; });
-                            info.emplace_back(SaveDataInfo{
-                                0,
-                                space,
-                                device ? FileSys::SaveDataType::DeviceSaveData
-                                       : FileSys::SaveDataType::SaveData,
-                                {},
-                                user_id_numeric,
-                                save_id_numeric,
-                                stoull_be(title_id->GetName()),
-                                title_id->GetSize(),
-                                {},
-                                {},
-                            });
-                        }
-                    }
-                }
-            } else if (space == FileSys::SaveDataSpaceId::TemporaryStorage) {
-                // Temporary Storage
-                for (const auto& user_id : type->GetSubdirectories()) {
-                    // Skip non user id subdirectories
-                    if (user_id->GetName().size() != 0x20) {
-                        continue;
-                    }
-                    for (const auto& title_id : user_id->GetSubdirectories()) {
-                        if (!title_id->GetFiles().empty() ||
-                            !title_id->GetSubdirectories().empty()) {
-                            auto user_id_numeric =
-                                Common::HexStringToArray<0x10>(user_id->GetName());
-                            std::reverse(user_id_numeric.begin(), user_id_numeric.end());
-
-                            info.emplace_back(SaveDataInfo{
-                                0,
-                                space,
-                                FileSys::SaveDataType::TemporaryStorage,
-                                {},
-                                user_id_numeric,
-                                stoull_be(type->GetName()),
-                                stoull_be(title_id->GetName()),
-                                title_id->GetSize(),
-                                {},
-                                {},
-                            });
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    struct SaveDataInfo {
-        u64_le save_id_unknown;
-        FileSys::SaveDataSpaceId space;
-        FileSys::SaveDataType type;
-        INSERT_PADDING_BYTES(0x6);
-        std::array<u8, 0x10> user_id;
-        u64_le save_id;
-        u64_le title_id;
-        u64_le save_image_size;
-        u16_le index;
-        FileSys::SaveDataRank rank;
-        INSERT_PADDING_BYTES(0x25);
-    };
-    static_assert(sizeof(SaveDataInfo) == 0x60, "SaveDataInfo has incorrect size.");
-
-    ProcessId process_id = 0;
-    std::shared_ptr<SaveDataController> save_data_controller;
-    std::vector<SaveDataInfo> info;
-    u64 next_entry_index = 0;
-};
 
 FSP_SRV::FSP_SRV(Core::System& system_)
     : ServiceFramework{system_, "fsp-srv"}, fsc{system.GetFileSystemController()},
@@ -222,20 +49,20 @@ FSP_SRV::FSP_SRV(Core::System& system_)
     // clang-format off
     static const FunctionInfo functions[] = {
         {0, nullptr, "OpenFileSystem"},
-        {1, &FSP_SRV::SetCurrentProcess, "SetCurrentProcess"},
+        {1, D<&FSP_SRV::SetCurrentProcess>, "SetCurrentProcess"},
         {2, nullptr, "OpenDataFileSystemByCurrentProcess"},
-        {7, &FSP_SRV::OpenFileSystemWithPatch, "OpenFileSystemWithPatch"},
+        {7, D<&FSP_SRV::OpenFileSystemWithPatch>, "OpenFileSystemWithPatch"},
         {8, nullptr, "OpenFileSystemWithId"},
         {9, nullptr, "OpenDataFileSystemByApplicationId"},
         {11, nullptr, "OpenBisFileSystem"},
         {12, nullptr, "OpenBisStorage"},
         {13, nullptr, "InvalidateBisCache"},
         {17, nullptr, "OpenHostFileSystem"},
-        {18, &FSP_SRV::OpenSdCardFileSystem, "OpenSdCardFileSystem"},
+        {18, D<&FSP_SRV::OpenSdCardFileSystem>, "OpenSdCardFileSystem"},
         {19, nullptr, "FormatSdCardFileSystem"},
         {21, nullptr, "DeleteSaveDataFileSystem"},
-        {22, &FSP_SRV::CreateSaveDataFileSystem, "CreateSaveDataFileSystem"},
-        {23, &FSP_SRV::CreateSaveDataFileSystemBySystemSaveDataId, "CreateSaveDataFileSystemBySystemSaveDataId"},
+        {22, D<&FSP_SRV::CreateSaveDataFileSystem>, "CreateSaveDataFileSystem"},
+        {23, D<&FSP_SRV::CreateSaveDataFileSystemBySystemSaveDataId>, "CreateSaveDataFileSystemBySystemSaveDataId"},
         {24, nullptr, "RegisterSaveDataFileSystemAtomicDeletion"},
         {25, nullptr, "DeleteSaveDataFileSystemBySaveDataSpaceId"},
         {26, nullptr, "FormatSdCardDryRun"},
@@ -245,26 +72,26 @@ FSP_SRV::FSP_SRV(Core::System& system_)
         {31, nullptr, "OpenGameCardFileSystem"},
         {32, nullptr, "ExtendSaveDataFileSystem"},
         {33, nullptr, "DeleteCacheStorage"},
-        {34, &FSP_SRV::GetCacheStorageSize, "GetCacheStorageSize"},
+        {34, D<&FSP_SRV::GetCacheStorageSize>, "GetCacheStorageSize"},
         {35, nullptr, "CreateSaveDataFileSystemByHashSalt"},
         {36, nullptr, "OpenHostFileSystemWithOption"},
-        {51, &FSP_SRV::OpenSaveDataFileSystem, "OpenSaveDataFileSystem"},
-        {52, &FSP_SRV::OpenSaveDataFileSystemBySystemSaveDataId, "OpenSaveDataFileSystemBySystemSaveDataId"},
-        {53, &FSP_SRV::OpenReadOnlySaveDataFileSystem, "OpenReadOnlySaveDataFileSystem"},
+        {51, D<&FSP_SRV::OpenSaveDataFileSystem>, "OpenSaveDataFileSystem"},
+        {52, D<&FSP_SRV::OpenSaveDataFileSystemBySystemSaveDataId>, "OpenSaveDataFileSystemBySystemSaveDataId"},
+        {53, D<&FSP_SRV::OpenReadOnlySaveDataFileSystem>, "OpenReadOnlySaveDataFileSystem"},
         {57, nullptr, "ReadSaveDataFileSystemExtraDataBySaveDataSpaceId"},
         {58, nullptr, "ReadSaveDataFileSystemExtraData"},
         {59, nullptr, "WriteSaveDataFileSystemExtraData"},
         {60, nullptr, "OpenSaveDataInfoReader"},
-        {61, &FSP_SRV::OpenSaveDataInfoReaderBySaveDataSpaceId, "OpenSaveDataInfoReaderBySaveDataSpaceId"},
-        {62, &FSP_SRV::OpenSaveDataInfoReaderOnlyCacheStorage, "OpenSaveDataInfoReaderOnlyCacheStorage"},
+        {61, D<&FSP_SRV::OpenSaveDataInfoReaderBySaveDataSpaceId>, "OpenSaveDataInfoReaderBySaveDataSpaceId"},
+        {62, D<&FSP_SRV::OpenSaveDataInfoReaderOnlyCacheStorage>, "OpenSaveDataInfoReaderOnlyCacheStorage"},
         {64, nullptr, "OpenSaveDataInternalStorageFileSystem"},
         {65, nullptr, "UpdateSaveDataMacForDebug"},
         {66, nullptr, "WriteSaveDataFileSystemExtraData2"},
         {67, nullptr, "FindSaveDataWithFilter"},
         {68, nullptr, "OpenSaveDataInfoReaderBySaveDataFilter"},
         {69, nullptr, "ReadSaveDataFileSystemExtraDataBySaveDataAttribute"},
-        {70, &FSP_SRV::WriteSaveDataFileSystemExtraDataBySaveDataAttribute, "WriteSaveDataFileSystemExtraDataBySaveDataAttribute"},
-        {71, &FSP_SRV::ReadSaveDataFileSystemExtraDataWithMaskBySaveDataAttribute, "ReadSaveDataFileSystemExtraDataWithMaskBySaveDataAttribute"},
+        {70, D<&FSP_SRV::WriteSaveDataFileSystemExtraDataBySaveDataAttribute>, "WriteSaveDataFileSystemExtraDataBySaveDataAttribute"},
+        {71, D<&FSP_SRV::ReadSaveDataFileSystemExtraDataWithMaskBySaveDataAttribute>, "ReadSaveDataFileSystemExtraDataWithMaskBySaveDataAttribute"},
         {80, nullptr, "OpenSaveDataMetaFile"},
         {81, nullptr, "OpenSaveDataTransferManager"},
         {82, nullptr, "OpenSaveDataTransferManagerVersion2"},
@@ -279,12 +106,12 @@ FSP_SRV::FSP_SRV(Core::System& system_)
         {110, nullptr, "OpenContentStorageFileSystem"},
         {120, nullptr, "OpenCloudBackupWorkStorageFileSystem"},
         {130, nullptr, "OpenCustomStorageFileSystem"},
-        {200, &FSP_SRV::OpenDataStorageByCurrentProcess, "OpenDataStorageByCurrentProcess"},
+        {200, D<&FSP_SRV::OpenDataStorageByCurrentProcess>, "OpenDataStorageByCurrentProcess"},
         {201, nullptr, "OpenDataStorageByProgramId"},
-        {202, &FSP_SRV::OpenDataStorageByDataId, "OpenDataStorageByDataId"},
-        {203, &FSP_SRV::OpenPatchDataStorageByCurrentProcess, "OpenPatchDataStorageByCurrentProcess"},
+        {202, D<&FSP_SRV::OpenDataStorageByDataId>, "OpenDataStorageByDataId"},
+        {203, D<&FSP_SRV::OpenPatchDataStorageByCurrentProcess>, "OpenPatchDataStorageByCurrentProcess"},
         {204, nullptr, "OpenDataFileSystemByProgramIndex"},
-        {205, &FSP_SRV::OpenDataStorageWithProgramIndex, "OpenDataStorageWithProgramIndex"},
+        {205, D<&FSP_SRV::OpenDataStorageWithProgramIndex>, "OpenDataStorageWithProgramIndex"},
         {206, nullptr, "OpenDataStorageByPath"},
         {400, nullptr, "OpenDeviceOperator"},
         {500, nullptr, "OpenSdCardDetectionEventNotifier"},
@@ -324,25 +151,25 @@ FSP_SRV::FSP_SRV(Core::System& system_)
         {1000, nullptr, "SetBisRootForHost"},
         {1001, nullptr, "SetSaveDataSize"},
         {1002, nullptr, "SetSaveDataRootPath"},
-        {1003, &FSP_SRV::DisableAutoSaveDataCreation, "DisableAutoSaveDataCreation"},
-        {1004, &FSP_SRV::SetGlobalAccessLogMode, "SetGlobalAccessLogMode"},
-        {1005, &FSP_SRV::GetGlobalAccessLogMode, "GetGlobalAccessLogMode"},
-        {1006, &FSP_SRV::OutputAccessLogToSdCard, "OutputAccessLogToSdCard"},
+        {1003, D<&FSP_SRV::DisableAutoSaveDataCreation>, "DisableAutoSaveDataCreation"},
+        {1004, D<&FSP_SRV::SetGlobalAccessLogMode>, "SetGlobalAccessLogMode"},
+        {1005, D<&FSP_SRV::GetGlobalAccessLogMode>, "GetGlobalAccessLogMode"},
+        {1006, D<&FSP_SRV::OutputAccessLogToSdCard>, "OutputAccessLogToSdCard"},
         {1007, nullptr, "RegisterUpdatePartition"},
         {1008, nullptr, "OpenRegisteredUpdatePartition"},
         {1009, nullptr, "GetAndClearMemoryReportInfo"},
         {1010, nullptr, "SetDataStorageRedirectTarget"},
-        {1011, &FSP_SRV::GetProgramIndexForAccessLog, "GetProgramIndexForAccessLog"},
+        {1011, D<&FSP_SRV::GetProgramIndexForAccessLog>, "GetProgramIndexForAccessLog"},
         {1012, nullptr, "GetFsStackUsage"},
         {1013, nullptr, "UnsetSaveDataRootPath"},
         {1014, nullptr, "OutputMultiProgramTagAccessLog"},
-        {1016, &FSP_SRV::FlushAccessLogOnSdCard, "FlushAccessLogOnSdCard"},
+        {1016, D<&FSP_SRV::FlushAccessLogOnSdCard>, "FlushAccessLogOnSdCard"},
         {1017, nullptr, "OutputApplicationInfoAccessLog"},
         {1018, nullptr, "SetDebugOption"},
         {1019, nullptr, "UnsetDebugOption"},
         {1100, nullptr, "OverrideSaveDataTransferTokenSignVerificationKey"},
         {1110, nullptr, "CorruptSaveDataFileSystemBySaveDataSpaceId2"},
-        {1200, &FSP_SRV::OpenMultiCommitManager, "OpenMultiCommitManager"},
+        {1200, D<&FSP_SRV::OpenMultiCommitManager>, "OpenMultiCommitManager"},
         {1300, nullptr, "OpenBisWiper"},
     };
     // clang-format on
@@ -355,234 +182,177 @@ FSP_SRV::FSP_SRV(Core::System& system_)
 
 FSP_SRV::~FSP_SRV() = default;
 
-void FSP_SRV::SetCurrentProcess(HLERequestContext& ctx) {
-    current_process_id = ctx.GetPID();
+Result FSP_SRV::SetCurrentProcess(ClientProcessId pid) {
+    current_process_id = *pid;
 
     LOG_DEBUG(Service_FS, "called. current_process_id=0x{:016X}", current_process_id);
 
-    const auto res =
-        fsc.OpenProcess(&program_id, &save_data_controller, &romfs_controller, current_process_id);
-
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(res);
+    R_RETURN(
+        fsc.OpenProcess(&program_id, &save_data_controller, &romfs_controller, current_process_id));
 }
 
-void FSP_SRV::OpenFileSystemWithPatch(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-
-    struct InputParameters {
-        FileSystemProxyType type;
-        u64 program_id;
-    };
-    static_assert(sizeof(InputParameters) == 0x10, "InputParameters has wrong size");
-
-    const auto params = rp.PopRaw<InputParameters>();
-    LOG_ERROR(Service_FS, "(STUBBED) called with type={}, program_id={:016X}", params.type,
-              params.program_id);
+Result FSP_SRV::OpenFileSystemWithPatch(OutInterface<IFileSystem> out_interface,
+                                        FileSystemProxyType type, u64 open_program_id) {
+    LOG_ERROR(Service_FS, "(STUBBED) called with type={}, program_id={:016X}", type,
+              open_program_id);
 
     // FIXME: many issues with this
-    ASSERT(params.type == FileSystemProxyType::Manual);
+    ASSERT(type == FileSystemProxyType::Manual);
     const auto manual_romfs = romfs_controller->OpenPatchedRomFS(
-        params.program_id, FileSys::ContentRecordType::HtmlDocument);
+        open_program_id, FileSys::ContentRecordType::HtmlDocument);
 
     ASSERT(manual_romfs != nullptr);
 
     const auto extracted_romfs = FileSys::ExtractRomFS(manual_romfs);
     ASSERT(extracted_romfs != nullptr);
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<IFileSystem>(system, extracted_romfs,
-                                     SizeGetter::FromStorageId(fsc, FileSys::StorageId::NandUser));
+    *out_interface = std::make_shared<IFileSystem>(
+        system, extracted_romfs, SizeGetter::FromStorageId(fsc, FileSys::StorageId::NandUser));
+
+    R_SUCCEED();
 }
 
-void FSP_SRV::OpenSdCardFileSystem(HLERequestContext& ctx) {
+Result FSP_SRV::OpenSdCardFileSystem(OutInterface<IFileSystem> out_interface) {
     LOG_DEBUG(Service_FS, "called");
 
     FileSys::VirtualDir sdmc_dir{};
     fsc.OpenSDMC(&sdmc_dir);
 
-    auto filesystem = std::make_shared<IFileSystem>(
+    *out_interface = std::make_shared<IFileSystem>(
         system, sdmc_dir, SizeGetter::FromStorageId(fsc, FileSys::StorageId::SdCard));
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<IFileSystem>(std::move(filesystem));
+    R_SUCCEED();
 }
 
-void FSP_SRV::CreateSaveDataFileSystem(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-
-    auto save_struct = rp.PopRaw<FileSys::SaveDataAttribute>();
-    [[maybe_unused]] auto save_create_struct = rp.PopRaw<std::array<u8, 0x40>>();
-    u128 uid = rp.PopRaw<u128>();
-
+Result FSP_SRV::CreateSaveDataFileSystem(FileSys::SaveDataCreationInfo save_create_struct,
+                                         FileSys::SaveDataAttribute save_struct, u128 uid) {
     LOG_DEBUG(Service_FS, "called save_struct = {}, uid = {:016X}{:016X}", save_struct.DebugInfo(),
               uid[1], uid[0]);
 
     FileSys::VirtualDir save_data_dir{};
-    save_data_controller->CreateSaveData(&save_data_dir, FileSys::SaveDataSpaceId::NandUser,
-                                         save_struct);
-
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    R_RETURN(save_data_controller->CreateSaveData(&save_data_dir, FileSys::SaveDataSpaceId::User,
+                                                  save_struct));
 }
 
-void FSP_SRV::CreateSaveDataFileSystemBySystemSaveDataId(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-
-    auto save_struct = rp.PopRaw<FileSys::SaveDataAttribute>();
-    [[maybe_unused]] auto save_create_struct = rp.PopRaw<std::array<u8, 0x40>>();
-
+Result FSP_SRV::CreateSaveDataFileSystemBySystemSaveDataId(
+    FileSys::SaveDataCreationInfo save_create_struct, FileSys::SaveDataAttribute save_struct) {
     LOG_DEBUG(Service_FS, "called save_struct = {}", save_struct.DebugInfo());
 
     FileSys::VirtualDir save_data_dir{};
-    save_data_controller->CreateSaveData(&save_data_dir, FileSys::SaveDataSpaceId::NandSystem,
-                                         save_struct);
-
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    R_RETURN(save_data_controller->CreateSaveData(&save_data_dir, FileSys::SaveDataSpaceId::System,
+                                                  save_struct));
 }
 
-void FSP_SRV::OpenSaveDataFileSystem(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-
-    struct Parameters {
-        FileSys::SaveDataSpaceId space_id;
-        FileSys::SaveDataAttribute attribute;
-    };
-
-    const auto parameters = rp.PopRaw<Parameters>();
-
+Result FSP_SRV::OpenSaveDataFileSystem(OutInterface<IFileSystem> out_interface,
+                                       FileSys::SaveDataSpaceId space_id,
+                                       FileSys::SaveDataAttribute attribute) {
     LOG_INFO(Service_FS, "called.");
 
     FileSys::VirtualDir dir{};
-    auto result =
-        save_data_controller->OpenSaveData(&dir, parameters.space_id, parameters.attribute);
-    if (result != ResultSuccess) {
-        IPC::ResponseBuilder rb{ctx, 2, 0, 0};
-        rb.Push(FileSys::ResultTargetNotFound);
-        return;
-    }
+    R_TRY(save_data_controller->OpenSaveData(&dir, space_id, attribute));
 
     FileSys::StorageId id{};
-    switch (parameters.space_id) {
-    case FileSys::SaveDataSpaceId::NandUser:
+    switch (space_id) {
+    case FileSys::SaveDataSpaceId::User:
         id = FileSys::StorageId::NandUser;
         break;
-    case FileSys::SaveDataSpaceId::SdCardSystem:
-    case FileSys::SaveDataSpaceId::SdCardUser:
+    case FileSys::SaveDataSpaceId::SdSystem:
+    case FileSys::SaveDataSpaceId::SdUser:
         id = FileSys::StorageId::SdCard;
         break;
-    case FileSys::SaveDataSpaceId::NandSystem:
+    case FileSys::SaveDataSpaceId::System:
         id = FileSys::StorageId::NandSystem;
         break;
-    case FileSys::SaveDataSpaceId::TemporaryStorage:
+    case FileSys::SaveDataSpaceId::Temporary:
     case FileSys::SaveDataSpaceId::ProperSystem:
     case FileSys::SaveDataSpaceId::SafeMode:
         ASSERT(false);
     }
 
-    auto filesystem =
+    *out_interface =
         std::make_shared<IFileSystem>(system, std::move(dir), SizeGetter::FromStorageId(fsc, id));
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<IFileSystem>(std::move(filesystem));
+    R_SUCCEED();
 }
 
-void FSP_SRV::OpenSaveDataFileSystemBySystemSaveDataId(HLERequestContext& ctx) {
+Result FSP_SRV::OpenSaveDataFileSystemBySystemSaveDataId(OutInterface<IFileSystem> out_interface,
+                                                         FileSys::SaveDataSpaceId space_id,
+                                                         FileSys::SaveDataAttribute attribute) {
     LOG_WARNING(Service_FS, "(STUBBED) called, delegating to 51 OpenSaveDataFilesystem");
-    OpenSaveDataFileSystem(ctx);
+    R_RETURN(OpenSaveDataFileSystem(out_interface, space_id, attribute));
 }
 
-void FSP_SRV::OpenReadOnlySaveDataFileSystem(HLERequestContext& ctx) {
+Result FSP_SRV::OpenReadOnlySaveDataFileSystem(OutInterface<IFileSystem> out_interface,
+                                               FileSys::SaveDataSpaceId space_id,
+                                               FileSys::SaveDataAttribute attribute) {
     LOG_WARNING(Service_FS, "(STUBBED) called, delegating to 51 OpenSaveDataFilesystem");
-    OpenSaveDataFileSystem(ctx);
+    R_RETURN(OpenSaveDataFileSystem(out_interface, space_id, attribute));
 }
 
-void FSP_SRV::OpenSaveDataInfoReaderBySaveDataSpaceId(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-    const auto space = rp.PopRaw<FileSys::SaveDataSpaceId>();
+Result FSP_SRV::OpenSaveDataInfoReaderBySaveDataSpaceId(
+    OutInterface<ISaveDataInfoReader> out_interface, FileSys::SaveDataSpaceId space) {
     LOG_INFO(Service_FS, "called, space={}", space);
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<ISaveDataInfoReader>(
-        std::make_shared<ISaveDataInfoReader>(system, save_data_controller, space));
+    *out_interface = std::make_shared<ISaveDataInfoReader>(system, save_data_controller, space);
+
+    R_SUCCEED();
 }
 
-void FSP_SRV::OpenSaveDataInfoReaderOnlyCacheStorage(HLERequestContext& ctx) {
+Result FSP_SRV::OpenSaveDataInfoReaderOnlyCacheStorage(
+    OutInterface<ISaveDataInfoReader> out_interface) {
     LOG_WARNING(Service_FS, "(STUBBED) called");
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<ISaveDataInfoReader>(system, save_data_controller,
-                                             FileSys::SaveDataSpaceId::TemporaryStorage);
+    *out_interface = std::make_shared<ISaveDataInfoReader>(system, save_data_controller,
+                                                           FileSys::SaveDataSpaceId::Temporary);
+
+    R_SUCCEED();
 }
 
-void FSP_SRV::WriteSaveDataFileSystemExtraDataBySaveDataAttribute(HLERequestContext& ctx) {
+Result FSP_SRV::WriteSaveDataFileSystemExtraDataBySaveDataAttribute() {
     LOG_WARNING(Service_FS, "(STUBBED) called.");
 
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    R_SUCCEED();
 }
 
-void FSP_SRV::ReadSaveDataFileSystemExtraDataWithMaskBySaveDataAttribute(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-
-    struct Parameters {
-        FileSys::SaveDataSpaceId space_id;
-        FileSys::SaveDataAttribute attribute;
-    };
-
-    const auto parameters = rp.PopRaw<Parameters>();
+Result FSP_SRV::ReadSaveDataFileSystemExtraDataWithMaskBySaveDataAttribute(
+    FileSys::SaveDataSpaceId space_id, FileSys::SaveDataAttribute attribute,
+    InBuffer<BufferAttr_HipcMapAlias> mask_buffer, OutBuffer<BufferAttr_HipcMapAlias> out_buffer) {
     // Stub this to None for now, backend needs an impl to read/write the SaveDataExtraData
-    constexpr auto flags = static_cast<u32>(FileSys::SaveDataFlags::None);
+    // In an earlier version of the code, this was returned as an out argument, but this is not
+    // correct
+    [[maybe_unused]] constexpr auto flags = static_cast<u32>(FileSys::SaveDataFlags::None);
 
     LOG_WARNING(Service_FS,
-                "(STUBBED) called, flags={}, space_id={}, attribute.title_id={:016X}\n"
+                "(STUBBED) called, flags={}, space_id={}, attribute.program_id={:016X}\n"
                 "attribute.user_id={:016X}{:016X}, attribute.save_id={:016X}\n"
                 "attribute.type={}, attribute.rank={}, attribute.index={}",
-                flags, parameters.space_id, parameters.attribute.title_id,
-                parameters.attribute.user_id[1], parameters.attribute.user_id[0],
-                parameters.attribute.save_id, parameters.attribute.type, parameters.attribute.rank,
-                parameters.attribute.index);
-
-    IPC::ResponseBuilder rb{ctx, 3};
-    rb.Push(ResultSuccess);
-    rb.Push(flags);
+                flags, space_id, attribute.program_id, attribute.user_id[1], attribute.user_id[0],
+                attribute.system_save_data_id, attribute.type, attribute.rank, attribute.index);
+
+    R_SUCCEED();
 }
 
-void FSP_SRV::OpenDataStorageByCurrentProcess(HLERequestContext& ctx) {
+Result FSP_SRV::OpenDataStorageByCurrentProcess(OutInterface<IStorage> out_interface) {
     LOG_DEBUG(Service_FS, "called");
 
     if (!romfs) {
         auto current_romfs = romfs_controller->OpenRomFSCurrentProcess();
         if (!current_romfs) {
             // TODO (bunnei): Find the right error code to use here
-            LOG_CRITICAL(Service_FS, "no file system interface available!");
-            IPC::ResponseBuilder rb{ctx, 2};
-            rb.Push(ResultUnknown);
-            return;
+            LOG_CRITICAL(Service_FS, "No file system interface available!");
+            R_RETURN(ResultUnknown);
         }
 
         romfs = current_romfs;
     }
 
-    auto storage = std::make_shared<IStorage>(system, romfs);
+    *out_interface = std::make_shared<IStorage>(system, romfs);
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<IStorage>(std::move(storage));
+    R_SUCCEED();
 }
 
-void FSP_SRV::OpenDataStorageByDataId(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-    const auto storage_id = rp.PopRaw<FileSys::StorageId>();
-    const auto unknown = rp.PopRaw<u32>();
-    const auto title_id = rp.PopRaw<u64>();
-
+Result FSP_SRV::OpenDataStorageByDataId(OutInterface<IStorage> out_interface,
+                                        FileSys::StorageId storage_id, u32 unknown, u64 title_id) {
     LOG_DEBUG(Service_FS, "called with storage_id={:02X}, unknown={:08X}, title_id={:016X}",
               storage_id, unknown, title_id);
 
@@ -592,19 +362,15 @@ void FSP_SRV::OpenDataStorageByDataId(HLERequestContext& ctx) {
         const auto archive = FileSys::SystemArchive::SynthesizeSystemArchive(title_id);
 
         if (archive != nullptr) {
-            IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-            rb.Push(ResultSuccess);
-            rb.PushIpcInterface(std::make_shared<IStorage>(system, archive));
-            return;
+            *out_interface = std::make_shared<IStorage>(system, archive);
+            R_SUCCEED();
         }
 
         // TODO(DarkLordZach): Find the right error code to use here
         LOG_ERROR(Service_FS,
-                  "could not open data storage with title_id={:016X}, storage_id={:02X}", title_id,
+                  "Could not open data storage with title_id={:016X}, storage_id={:02X}", title_id,
                   storage_id);
-        IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(ResultUnknown);
-        return;
+        R_RETURN(ResultUnknown);
     }
 
     const FileSys::PatchManager pm{title_id, fsc, content_provider};
@@ -614,28 +380,20 @@ void FSP_SRV::OpenDataStorageByDataId(HLERequestContext& ctx) {
     auto storage = std::make_shared<IStorage>(
         system, pm.PatchRomFS(base.get(), std::move(data), FileSys::ContentRecordType::Data));
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<IStorage>(std::move(storage));
+    *out_interface = std::move(storage);
+    R_SUCCEED();
 }
 
-void FSP_SRV::OpenPatchDataStorageByCurrentProcess(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-
-    const auto storage_id = rp.PopRaw<FileSys::StorageId>();
-    const auto title_id = rp.PopRaw<u64>();
+Result FSP_SRV::OpenPatchDataStorageByCurrentProcess(OutInterface<IStorage> out_interface,
+                                                     FileSys::StorageId storage_id, u64 title_id) {
+    LOG_WARNING(Service_FS, "(STUBBED) called with storage_id={:02X}, title_id={:016X}", storage_id,
+                title_id);
 
-    LOG_DEBUG(Service_FS, "called with storage_id={:02X}, title_id={:016X}", storage_id, title_id);
-
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(FileSys::ResultTargetNotFound);
+    R_RETURN(FileSys::ResultTargetNotFound);
 }
 
-void FSP_SRV::OpenDataStorageWithProgramIndex(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-
-    const auto program_index = rp.PopRaw<u8>();
-
+Result FSP_SRV::OpenDataStorageWithProgramIndex(OutInterface<IStorage> out_interface,
+                                                u8 program_index) {
     LOG_DEBUG(Service_FS, "called, program_index={}", program_index);
 
     auto patched_romfs = romfs_controller->OpenPatchedRomFSWithProgramIndex(
@@ -643,123 +401,80 @@ void FSP_SRV::OpenDataStorageWithProgramIndex(HLERequestContext& ctx) {
 
     if (!patched_romfs) {
         // TODO: Find the right error code to use here
-        LOG_ERROR(Service_FS, "could not open storage with program_index={}", program_index);
-
-        IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(ResultUnknown);
-        return;
+        LOG_ERROR(Service_FS, "Could not open storage with program_index={}", program_index);
+        R_RETURN(ResultUnknown);
     }
 
-    auto storage = std::make_shared<IStorage>(system, std::move(patched_romfs));
+    *out_interface = std::make_shared<IStorage>(system, std::move(patched_romfs));
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<IStorage>(std::move(storage));
+    R_SUCCEED();
 }
 
-void FSP_SRV::DisableAutoSaveDataCreation(HLERequestContext& ctx) {
+Result FSP_SRV::DisableAutoSaveDataCreation() {
     LOG_DEBUG(Service_FS, "called");
 
     save_data_controller->SetAutoCreate(false);
 
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    R_SUCCEED();
 }
 
-void FSP_SRV::SetGlobalAccessLogMode(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-    access_log_mode = rp.PopEnum<AccessLogMode>();
+Result FSP_SRV::SetGlobalAccessLogMode(AccessLogMode access_log_mode_) {
+    LOG_DEBUG(Service_FS, "called, access_log_mode={}", access_log_mode_);
 
-    LOG_DEBUG(Service_FS, "called, access_log_mode={}", access_log_mode);
+    access_log_mode = access_log_mode_;
 
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    R_SUCCEED();
 }
 
-void FSP_SRV::GetGlobalAccessLogMode(HLERequestContext& ctx) {
+Result FSP_SRV::GetGlobalAccessLogMode(Out<AccessLogMode> out_access_log_mode) {
     LOG_DEBUG(Service_FS, "called");
 
-    IPC::ResponseBuilder rb{ctx, 3};
-    rb.Push(ResultSuccess);
-    rb.PushEnum(access_log_mode);
-}
+    *out_access_log_mode = access_log_mode;
 
-void FSP_SRV::OutputAccessLogToSdCard(HLERequestContext& ctx) {
-    const auto raw = ctx.ReadBufferCopy();
-    auto log = Common::StringFromFixedZeroTerminatedBuffer(
-        reinterpret_cast<const char*>(raw.data()), raw.size());
+    R_SUCCEED();
+}
 
+Result FSP_SRV::OutputAccessLogToSdCard(InBuffer<BufferAttr_HipcMapAlias> log_message_buffer) {
     LOG_DEBUG(Service_FS, "called");
 
+    auto log = Common::StringFromFixedZeroTerminatedBuffer(
+        reinterpret_cast<const char*>(log_message_buffer.data()), log_message_buffer.size());
     reporter.SaveFSAccessLog(log);
 
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    R_SUCCEED();
 }
 
-void FSP_SRV::GetProgramIndexForAccessLog(HLERequestContext& ctx) {
-    LOG_DEBUG(Service_FS, "called");
+Result FSP_SRV::GetProgramIndexForAccessLog(Out<AccessLogVersion> out_access_log_version,
+                                            Out<u32> out_access_log_program_index) {
+    LOG_DEBUG(Service_FS, "(STUBBED) called");
+
+    *out_access_log_version = AccessLogVersion::Latest;
+    *out_access_log_program_index = access_log_program_index;
 
-    IPC::ResponseBuilder rb{ctx, 4};
-    rb.Push(ResultSuccess);
-    rb.PushEnum(AccessLogVersion::Latest);
-    rb.Push(access_log_program_index);
+    R_SUCCEED();
 }
 
-void FSP_SRV::FlushAccessLogOnSdCard(HLERequestContext& ctx) {
+Result FSP_SRV::FlushAccessLogOnSdCard() {
     LOG_DEBUG(Service_FS, "(STUBBED) called");
 
-    IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    R_SUCCEED();
 }
 
-void FSP_SRV::GetCacheStorageSize(HLERequestContext& ctx) {
-    IPC::RequestParser rp{ctx};
-    const auto index{rp.Pop<s32>()};
-
+Result FSP_SRV::GetCacheStorageSize(s32 index, Out<s64> out_data_size, Out<s64> out_journal_size) {
     LOG_WARNING(Service_FS, "(STUBBED) called with index={}", index);
 
-    IPC::ResponseBuilder rb{ctx, 6};
-    rb.Push(ResultSuccess);
-    rb.Push(s64{0});
-    rb.Push(s64{0});
-}
-
-class IMultiCommitManager final : public ServiceFramework<IMultiCommitManager> {
-public:
-    explicit IMultiCommitManager(Core::System& system_)
-        : ServiceFramework{system_, "IMultiCommitManager"} {
-        static const FunctionInfo functions[] = {
-            {1, &IMultiCommitManager::Add, "Add"},
-            {2, &IMultiCommitManager::Commit, "Commit"},
-        };
-        RegisterHandlers(functions);
-    }
+    *out_data_size = 0;
+    *out_journal_size = 0;
 
-private:
-    FileSys::VirtualFile backend;
-
-    void Add(HLERequestContext& ctx) {
-        LOG_WARNING(Service_FS, "(STUBBED) called");
-
-        IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(ResultSuccess);
-    }
-
-    void Commit(HLERequestContext& ctx) {
-        LOG_WARNING(Service_FS, "(STUBBED) called");
-
-        IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(ResultSuccess);
-    }
-};
+    R_SUCCEED();
+}
 
-void FSP_SRV::OpenMultiCommitManager(HLERequestContext& ctx) {
+Result FSP_SRV::OpenMultiCommitManager(OutInterface<IMultiCommitManager> out_interface) {
     LOG_DEBUG(Service_FS, "called");
 
-    IPC::ResponseBuilder rb{ctx, 2, 0, 1};
-    rb.Push(ResultSuccess);
-    rb.PushIpcInterface<IMultiCommitManager>(std::make_shared<IMultiCommitManager>(system));
+    *out_interface = std::make_shared<IMultiCommitManager>(system);
+
+    R_SUCCEED();
 }
 
 } // namespace Service::FileSystem
diff --git a/src/core/hle/service/filesystem/fsp/fsp_srv.h b/src/core/hle/service/filesystem/fsp/fsp_srv.h
index 59406e6f957e..ee67f6bc1488 100644
--- a/src/core/hle/service/filesystem/fsp/fsp_srv.h
+++ b/src/core/hle/service/filesystem/fsp/fsp_srv.h
@@ -4,6 +4,9 @@
 #pragma once
 
 #include <memory>
+#include "core/file_sys/fs_save_data_types.h"
+#include "core/hle/service/cmif_types.h"
+#include "core/hle/service/filesystem/fsp/fsp_types.h"
 #include "core/hle/service/service.h"
 
 namespace Core {
@@ -20,6 +23,11 @@ namespace Service::FileSystem {
 class RomFsController;
 class SaveDataController;
 
+class IFileSystem;
+class ISaveDataInfoReader;
+class IStorage;
+class IMultiCommitManager;
+
 enum class AccessLogVersion : u32 {
     V7_0_0 = 2,
 
@@ -38,30 +46,46 @@ class FSP_SRV final : public ServiceFramework<FSP_SRV> {
     ~FSP_SRV() override;
 
 private:
-    void SetCurrentProcess(HLERequestContext& ctx);
-    void OpenFileSystemWithPatch(HLERequestContext& ctx);
-    void OpenSdCardFileSystem(HLERequestContext& ctx);
-    void CreateSaveDataFileSystem(HLERequestContext& ctx);
-    void CreateSaveDataFileSystemBySystemSaveDataId(HLERequestContext& ctx);
-    void OpenSaveDataFileSystem(HLERequestContext& ctx);
-    void OpenSaveDataFileSystemBySystemSaveDataId(HLERequestContext& ctx);
-    void OpenReadOnlySaveDataFileSystem(HLERequestContext& ctx);
-    void OpenSaveDataInfoReaderBySaveDataSpaceId(HLERequestContext& ctx);
-    void OpenSaveDataInfoReaderOnlyCacheStorage(HLERequestContext& ctx);
-    void WriteSaveDataFileSystemExtraDataBySaveDataAttribute(HLERequestContext& ctx);
-    void ReadSaveDataFileSystemExtraDataWithMaskBySaveDataAttribute(HLERequestContext& ctx);
-    void OpenDataStorageByCurrentProcess(HLERequestContext& ctx);
-    void OpenDataStorageByDataId(HLERequestContext& ctx);
-    void OpenPatchDataStorageByCurrentProcess(HLERequestContext& ctx);
-    void OpenDataStorageWithProgramIndex(HLERequestContext& ctx);
-    void DisableAutoSaveDataCreation(HLERequestContext& ctx);
-    void SetGlobalAccessLogMode(HLERequestContext& ctx);
-    void GetGlobalAccessLogMode(HLERequestContext& ctx);
-    void OutputAccessLogToSdCard(HLERequestContext& ctx);
-    void FlushAccessLogOnSdCard(HLERequestContext& ctx);
-    void GetProgramIndexForAccessLog(HLERequestContext& ctx);
-    void OpenMultiCommitManager(HLERequestContext& ctx);
-    void GetCacheStorageSize(HLERequestContext& ctx);
+    Result SetCurrentProcess(ClientProcessId pid);
+    Result OpenFileSystemWithPatch(OutInterface<IFileSystem> out_interface,
+                                   FileSystemProxyType type, u64 open_program_id);
+    Result OpenSdCardFileSystem(OutInterface<IFileSystem> out_interface);
+    Result CreateSaveDataFileSystem(FileSys::SaveDataCreationInfo save_create_struct,
+                                    FileSys::SaveDataAttribute save_struct, u128 uid);
+    Result CreateSaveDataFileSystemBySystemSaveDataId(
+        FileSys::SaveDataCreationInfo save_create_struct, FileSys::SaveDataAttribute save_struct);
+    Result OpenSaveDataFileSystem(OutInterface<IFileSystem> out_interface,
+                                  FileSys::SaveDataSpaceId space_id,
+                                  FileSys::SaveDataAttribute attribute);
+    Result OpenSaveDataFileSystemBySystemSaveDataId(OutInterface<IFileSystem> out_interface,
+                                                    FileSys::SaveDataSpaceId space_id,
+                                                    FileSys::SaveDataAttribute attribute);
+    Result OpenReadOnlySaveDataFileSystem(OutInterface<IFileSystem> out_interface,
+                                          FileSys::SaveDataSpaceId space_id,
+                                          FileSys::SaveDataAttribute attribute);
+    Result OpenSaveDataInfoReaderBySaveDataSpaceId(OutInterface<ISaveDataInfoReader> out_interface,
+                                                   FileSys::SaveDataSpaceId space);
+    Result OpenSaveDataInfoReaderOnlyCacheStorage(OutInterface<ISaveDataInfoReader> out_interface);
+    Result WriteSaveDataFileSystemExtraDataBySaveDataAttribute();
+    Result ReadSaveDataFileSystemExtraDataWithMaskBySaveDataAttribute(
+        FileSys::SaveDataSpaceId space_id, FileSys::SaveDataAttribute attribute,
+        InBuffer<BufferAttr_HipcMapAlias> mask_buffer,
+        OutBuffer<BufferAttr_HipcMapAlias> out_buffer);
+    Result OpenDataStorageByCurrentProcess(OutInterface<IStorage> out_interface);
+    Result OpenDataStorageByDataId(OutInterface<IStorage> out_interface,
+                                   FileSys::StorageId storage_id, u32 unknown, u64 title_id);
+    Result OpenPatchDataStorageByCurrentProcess(OutInterface<IStorage> out_interface,
+                                                FileSys::StorageId storage_id, u64 title_id);
+    Result OpenDataStorageWithProgramIndex(OutInterface<IStorage> out_interface, u8 program_index);
+    Result DisableAutoSaveDataCreation();
+    Result SetGlobalAccessLogMode(AccessLogMode access_log_mode_);
+    Result GetGlobalAccessLogMode(Out<AccessLogMode> out_access_log_mode);
+    Result OutputAccessLogToSdCard(InBuffer<BufferAttr_HipcMapAlias> log_message_buffer);
+    Result FlushAccessLogOnSdCard();
+    Result GetProgramIndexForAccessLog(Out<AccessLogVersion> out_access_log_version,
+                                       Out<u32> out_access_log_program_index);
+    Result OpenMultiCommitManager(OutInterface<IMultiCommitManager> out_interface);
+    Result GetCacheStorageSize(s32 index, Out<s64> out_data_size, Out<s64> out_journal_size);
 
     FileSystemController& fsc;
     const FileSys::ContentProvider& content_provider;
diff --git a/src/core/hle/service/filesystem/fsp/fsp_util.h b/src/core/hle/service/filesystem/fsp/fsp_types.h
similarity index 76%
rename from src/core/hle/service/filesystem/fsp/fsp_util.h
rename to src/core/hle/service/filesystem/fsp/fsp_types.h
index 253f866db966..294da6a2deb2 100644
--- a/src/core/hle/service/filesystem/fsp/fsp_util.h
+++ b/src/core/hle/service/filesystem/fsp/fsp_types.h
@@ -7,6 +7,18 @@
 
 namespace Service::FileSystem {
 
+enum class FileSystemProxyType : u8 {
+    Code = 0,
+    Rom = 1,
+    Logo = 2,
+    Control = 3,
+    Manual = 4,
+    Meta = 5,
+    Data = 6,
+    Package = 7,
+    RegisteredUpdate = 8,
+};
+
 struct SizeGetter {
     std::function<u64()> get_free_size;
     std::function<u64()> get_total_size;
diff --git a/src/yuzu/main.cpp b/src/yuzu/main.cpp
index 236642fb934e..9d63b5935cf6 100644
--- a/src/yuzu/main.cpp
+++ b/src/yuzu/main.cpp
@@ -2323,15 +2323,15 @@ void GMainWindow::OnGameListOpenFolder(u64 program_id, GameListOpenTarget target
             ASSERT(user_id);
 
             const auto user_save_data_path = FileSys::SaveDataFactory::GetFullPath(
-                {}, vfs_nand_dir, FileSys::SaveDataSpaceId::NandUser,
-                FileSys::SaveDataType::SaveData, program_id, user_id->AsU128(), 0);
+                {}, vfs_nand_dir, FileSys::SaveDataSpaceId::User, FileSys::SaveDataType::Account,
+                program_id, user_id->AsU128(), 0);
 
             path = Common::FS::ConcatPathSafe(nand_dir, user_save_data_path);
         } else {
             // Device save data
             const auto device_save_data_path = FileSys::SaveDataFactory::GetFullPath(
-                {}, vfs_nand_dir, FileSys::SaveDataSpaceId::NandUser,
-                FileSys::SaveDataType::SaveData, program_id, {}, 0);
+                {}, vfs_nand_dir, FileSys::SaveDataSpaceId::User, FileSys::SaveDataType::Account,
+                program_id, {}, 0);
 
             path = Common::FS::ConcatPathSafe(nand_dir, device_save_data_path);
         }
@@ -2672,7 +2672,7 @@ void GMainWindow::RemoveCacheStorage(u64 program_id) {
         vfs->OpenDirectory(Common::FS::PathToUTF8String(nand_dir), FileSys::OpenMode::Read);
 
     const auto cache_storage_path = FileSys::SaveDataFactory::GetFullPath(
-        {}, vfs_nand_dir, FileSys::SaveDataSpaceId::NandUser, FileSys::SaveDataType::CacheStorage,
+        {}, vfs_nand_dir, FileSys::SaveDataSpaceId::User, FileSys::SaveDataType::Cache,
         0 /* program_id */, {}, 0);
 
     const auto path = Common::FS::ConcatPathSafe(nand_dir, cache_storage_path);
