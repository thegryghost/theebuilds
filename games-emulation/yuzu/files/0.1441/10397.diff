diff --git a/src/common/settings.cpp b/src/common/settings.cpp
index ba617aea1a4..ac21c2537ad 100644
--- a/src/common/settings.cpp
+++ b/src/common/settings.cpp
@@ -1,7 +1,15 @@
 // SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#if __cpp_lib_chrono >= 201907L
+#include <chrono>
+#else
+#include <ctime>
+#include <limits>
+#endif
 #include <string_view>
+#include <fmt/chrono.h>
+#include <fmt/core.h>
 
 #include "common/assert.h"
 #include "common/fs/path_util.h"
@@ -15,7 +23,7 @@ static bool configuring_global = true;
 
 std::string GetTimeZoneString() {
     static constexpr std::array timezones{
-        "auto",      "default",   "CET", "CST6CDT", "Cuba",    "EET",    "Egypt",     "Eire",
+        "GMT",       "GMT",       "CET", "CST6CDT", "Cuba",    "EET",    "Egypt",     "Eire",
         "EST",       "EST5EDT",   "GB",  "GB-Eire", "GMT",     "GMT+0",  "GMT-0",     "GMT0",
         "Greenwich", "Hongkong",  "HST", "Iceland", "Iran",    "Israel", "Jamaica",   "Japan",
         "Kwajalein", "Libya",     "MET", "MST",     "MST7MDT", "Navajo", "NZ",        "NZ-CHAT",
@@ -25,7 +33,73 @@ std::string GetTimeZoneString() {
 
     const auto time_zone_index = static_cast<std::size_t>(values.time_zone_index.GetValue());
     ASSERT(time_zone_index < timezones.size());
-    return timezones[time_zone_index];
+    std::string location_name;
+    switch (time_zone_index) {
+    case 0: { // Auto
+#if __cpp_lib_chrono >= 201907L
+        const struct std::chrono::tzdb& time_zone_data = std::chrono::get_tzdb();
+        const std::chrono::time_zone* current_zone = time_zone_data.current_zone();
+        std::string_view current_zone_name = current_zone->name();
+        location_name = current_zone_name;
+#elif defined(MINGW)
+        // MinGW has broken strftime -- https://sourceforge.net/p/mingw-w64/bugs/793/
+        // e.g. fmt::format("{:%z}") -- returns "Eastern Daylight Time" when it should be "-0400"
+        location_name = timezones[0];
+        break;
+#else
+        static constexpr std::array offsets{
+            0,     0,     3600,   -21600, -19768, 7200,   7509,  -1521,  -18000, -18000,
+            -75,   -75,   0,      0,      0,      0,      0,     27402,  -36000, -968,
+            12344, 8454,  -18430, 33539,  40160,  3164,   3600,  -25200, -25200, -25196,
+            41944, 44028, 5040,   -2205,  29143,  -28800, 29160, 30472,  24925,  6952,
+            0,     0,     0,      9017,   0,      0,
+        };
+
+        static constexpr std::array dst{
+            false, false, true,  true,  true,  true,  true,  true,  false, true,  true, true,
+            false, false, false, false, false, true,  false, false, true,  true,  true, true,
+            false, true,  true,  false, true,  true,  true,  true,  true,  true,  true, true,
+            true,  true,  true,  true,  false, false, false, true,  true,  false,
+        };
+
+        const auto now = std::time(nullptr);
+        const struct std::tm& local = *std::localtime(&now);
+        const std::string clock_offset_s = fmt::format("{:%z}", local);
+        if (clock_offset_s.empty()) {
+            location_name = timezones[0];
+            break;
+        }
+        const int hours_offset = std::stoi(clock_offset_s) / 100;
+        const int minutes_offset = std::stoi(clock_offset_s) - hours_offset * 100;
+        const int system_offset =
+            hours_offset * 3600 + minutes_offset * 60 - (local.tm_isdst ? 3600 : 0);
+
+        int min = std::numeric_limits<int>::max();
+        int min_index = -1;
+        for (u32 i = 2; i < offsets.size(); i++) {
+            // Skip if system is celebrating DST but considered time zone does not
+            if (local.tm_isdst && !dst[i]) {
+                continue;
+            }
+
+            const auto offset = offsets[i];
+            const int difference = std::abs(std::abs(offset) - std::abs(system_offset));
+            if (difference < min) {
+                min = difference;
+                min_index = i;
+            }
+        }
+
+        location_name = timezones[min_index];
+#endif
+        break;
+    }
+    default:
+        location_name = timezones[time_zone_index];
+        break;
+    }
+
+    return location_name;
 }
 
 void LogSettings() {
diff --git a/src/core/hle/service/time/time_manager.cpp b/src/core/hle/service/time/time_manager.cpp
index 28667710e94..20012afd957 100644
--- a/src/core/hle/service/time/time_manager.cpp
+++ b/src/core/hle/service/time/time_manager.cpp
@@ -22,10 +22,6 @@ s64 GetSecondsSinceEpoch() {
     return std::chrono::duration_cast<std::chrono::seconds>(time_since_epoch).count() +
            Settings::values.custom_rtc_differential;
 }
-
-s64 GetExternalRtcValue() {
-    return GetSecondsSinceEpoch() + TimeManager::GetExternalTimeZoneOffset();
-}
 } // Anonymous namespace
 
 struct TimeManager::Impl final {
@@ -43,7 +39,7 @@ struct TimeManager::Impl final {
               std::make_shared<Clock::EphemeralNetworkSystemClockContextWriter>()},
           time_zone_content_manager{system} {
 
-        const auto system_time{Clock::TimeSpanType::FromSeconds(GetExternalRtcValue())};
+        const auto system_time{Clock::TimeSpanType::FromSeconds(GetSecondsSinceEpoch())};
         SetupStandardSteadyClock(system, Common::UUID::MakeRandom(), system_time, {}, {});
         SetupStandardLocalSystemClock(system, {}, system_time.ToSeconds());
 
@@ -123,14 +119,6 @@ struct TimeManager::Impl final {
         time_zone_content_manager.GetTimeZoneManager().MarkAsInitialized();
     }
 
-    static s64 GetExternalTimeZoneOffset() {
-        // With "auto" timezone setting, we use the external system's timezone offset
-        if (Settings::GetTimeZoneString() == "auto") {
-            return Common::TimeZone::GetCurrentOffsetSeconds().count();
-        }
-        return 0;
-    }
-
     void SetupStandardSteadyClock(Core::System& system_, Common::UUID clock_source_id,
                                   Clock::TimeSpanType setup_value,
                                   Clock::TimeSpanType internal_offset, bool is_rtc_reset_detected) {
@@ -301,13 +289,4 @@ void TimeManager::SetupTimeZoneManager(std::string location_name,
     impl->SetupTimeZoneManager(location_name, time_zone_updated_time_point,
                                total_location_name_count, time_zone_rule_version, vfs_file);
 }
-
-/*static*/ s64 TimeManager::GetExternalTimeZoneOffset() {
-    // With "auto" timezone setting, we use the external system's timezone offset
-    if (Settings::GetTimeZoneString() == "auto") {
-        return Common::TimeZone::GetCurrentOffsetSeconds().count();
-    }
-    return 0;
-}
-
 } // namespace Service::Time
diff --git a/src/core/hle/service/time/time_manager.h b/src/core/hle/service/time/time_manager.h
index 4f046f2662d..3848da8bc69 100644
--- a/src/core/hle/service/time/time_manager.h
+++ b/src/core/hle/service/time/time_manager.h
@@ -64,8 +64,6 @@ class TimeManager final {
                               std::size_t total_location_name_count, u128 time_zone_rule_version,
                               FileSys::VirtualFile& vfs_file);
 
-    static s64 GetExternalTimeZoneOffset();
-
 private:
     Core::System& system;
 
diff --git a/src/core/hle/service/time/time_zone_content_manager.cpp b/src/core/hle/service/time/time_zone_content_manager.cpp
index afbfe971538..5fab7fa7b32 100644
--- a/src/core/hle/service/time/time_zone_content_manager.cpp
+++ b/src/core/hle/service/time/time_zone_content_manager.cpp
@@ -1,6 +1,7 @@
 // SPDX-FileCopyrightText: Copyright 2019 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#include <chrono>
 #include <sstream>
 
 #include "common/logging/log.h"
@@ -12,7 +13,11 @@
 #include "core/file_sys/registered_cache.h"
 #include "core/file_sys/romfs.h"
 #include "core/file_sys/system_archive/system_archive.h"
+#include "core/file_sys/vfs.h"
+#include "core/file_sys/vfs_types.h"
+#include "core/hle/result.h"
 #include "core/hle/service/filesystem/filesystem.h"
+#include "core/hle/service/time/errors.h"
 #include "core/hle/service/time/time_manager.h"
 #include "core/hle/service/time/time_zone_content_manager.h"
 
@@ -71,20 +76,14 @@ TimeZoneContentManager::TimeZoneContentManager(Core::System& system_)
     : system{system_}, location_name_cache{BuildLocationNameCache(system)} {}
 
 void TimeZoneContentManager::Initialize(TimeManager& time_manager) {
-    std::string location_name;
     const auto timezone_setting = Settings::GetTimeZoneString();
-    if (timezone_setting == "auto" || timezone_setting == "default") {
-        location_name = Common::TimeZone::GetDefaultTimeZone();
-    } else {
-        location_name = timezone_setting;
-    }
 
     if (FileSys::VirtualFile vfs_file;
-        GetTimeZoneInfoFile(location_name, vfs_file) == ResultSuccess) {
+        GetTimeZoneInfoFile(timezone_setting, vfs_file) == ResultSuccess) {
         const auto time_point{
             time_manager.GetStandardSteadyClockCore().GetCurrentTimePoint(system)};
-        time_manager.SetupTimeZoneManager(location_name, time_point, location_name_cache.size(), {},
-                                          vfs_file);
+        time_manager.SetupTimeZoneManager(timezone_setting, time_point, location_name_cache.size(),
+                                          {}, vfs_file);
     } else {
         time_zone_manager.MarkAsInitialized();
     }
diff --git a/src/yuzu/configuration/configure_system.cpp b/src/yuzu/configuration/configure_system.cpp
index 286ccc5cd8f..f1ae312c654 100644
--- a/src/yuzu/configuration/configure_system.cpp
+++ b/src/yuzu/configuration/configure_system.cpp
@@ -144,8 +144,7 @@ void ConfigureSystem::ApplyConfiguration() {
         if (ui->custom_rtc_checkbox->isChecked()) {
             Settings::values.custom_rtc = ui->custom_rtc_edit->dateTime().toSecsSinceEpoch();
             if (system.IsPoweredOn()) {
-                const s64 posix_time{*Settings::values.custom_rtc +
-                                     Service::Time::TimeManager::GetExternalTimeZoneOffset()};
+                const s64 posix_time{*Settings::values.custom_rtc};
                 system.GetTimeManager().UpdateLocalSystemClockTime(posix_time);
             }
         } else {
