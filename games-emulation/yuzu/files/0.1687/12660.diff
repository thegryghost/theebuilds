diff --git a/src/core/hle/service/hid/hid.cpp b/src/core/hle/service/hid/hid.cpp
index 4ce0a9834e26..0c0b3cd47ded 100644
--- a/src/core/hle/service/hid/hid.cpp
+++ b/src/core/hle/service/hid/hid.cpp
@@ -26,6 +26,7 @@ void LoopProcess(Core::System& system) {
     resource_manager->Initialize();
     resource_manager->RegisterAppletResourceUserId(system.ApplicationProcess()->GetProcessId(),
                                                    true);
+    resource_manager->SetAruidValidForVibration(system.ApplicationProcess()->GetProcessId(), true);
 
     server_manager->RegisterNamedService(
         "hid", std::make_shared<IHidServer>(system, resource_manager, firmware_settings));
diff --git a/src/core/hle/service/hid/hid_server.cpp b/src/core/hle/service/hid/hid_server.cpp
index 1951da33ba52..30afed812260 100644
--- a/src/core/hle/service/hid/hid_server.cpp
+++ b/src/core/hle/service/hid/hid_server.cpp
@@ -22,12 +22,16 @@
 #include "hid_core/resources/mouse/mouse.h"
 #include "hid_core/resources/npad/npad.h"
 #include "hid_core/resources/npad/npad_types.h"
+#include "hid_core/resources/npad/npad_vibration.h"
 #include "hid_core/resources/palma/palma.h"
 #include "hid_core/resources/six_axis/console_six_axis.h"
 #include "hid_core/resources/six_axis/seven_six_axis.h"
 #include "hid_core/resources/six_axis/six_axis.h"
 #include "hid_core/resources/touch_screen/gesture.h"
 #include "hid_core/resources/touch_screen/touch_screen.h"
+#include "hid_core/resources/vibration/gc_vibration_device.h"
+#include "hid_core/resources/vibration/n64_vibration_device.h"
+#include "hid_core/resources/vibration/vibration_device.h"
 
 namespace Service::HID {
 
@@ -38,7 +42,7 @@ class IActiveVibrationDeviceList final : public ServiceFramework<IActiveVibratio
         : ServiceFramework{system_, "IActiveVibrationDeviceList"}, resource_manager(resource) {
         // clang-format off
         static const FunctionInfo functions[] = {
-            {0, &IActiveVibrationDeviceList::InitializeVibrationDevice, "InitializeVibrationDevice"},
+            {0, &IActiveVibrationDeviceList::ActivateVibrationDevice, "ActivateVibrationDevice"},
         };
         // clang-format on
 
@@ -46,22 +50,49 @@ class IActiveVibrationDeviceList final : public ServiceFramework<IActiveVibratio
     }
 
 private:
-    void InitializeVibrationDevice(HLERequestContext& ctx) {
+    void ActivateVibrationDevice(HLERequestContext& ctx) {
         IPC::RequestParser rp{ctx};
         const auto vibration_device_handle{rp.PopRaw<Core::HID::VibrationDeviceHandle>()};
 
-        if (resource_manager != nullptr && resource_manager->GetNpad()) {
-            resource_manager->GetNpad()->InitializeVibrationDevice(vibration_device_handle);
-        }
-
         LOG_DEBUG(Service_HID, "called, npad_type={}, npad_id={}, device_index={}",
                   vibration_device_handle.npad_type, vibration_device_handle.npad_id,
                   vibration_device_handle.device_index);
 
+        const auto result = ActivateVibrationDeviceImpl(vibration_device_handle);
+
         IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(ResultSuccess);
+        rb.Push(result);
     }
 
+    Result ActivateVibrationDeviceImpl(const Core::HID::VibrationDeviceHandle& handle) {
+        std::scoped_lock lock{mutex};
+
+        const Result is_valid = IsVibrationHandleValid(handle);
+        if (is_valid.IsError()) {
+            return is_valid;
+        }
+
+        for (std::size_t i = 0; i < list_size; i++) {
+            if (handle.device_index == vibration_device_list[i].device_index &&
+                handle.npad_id == vibration_device_list[i].npad_id &&
+                handle.npad_type == vibration_device_list[i].npad_type) {
+                return ResultSuccess;
+            }
+        }
+        if (list_size == vibration_device_list.size()) {
+            return ResultVibrationDeviceIndexOutOfRange;
+        }
+        const Result result = resource_manager->GetVibrationDevice(handle)->Activate();
+        if (result.IsError()) {
+            return result;
+        }
+        vibration_device_list[list_size++] = handle;
+        return ResultSuccess;
+    }
+
+    mutable std::mutex mutex;
+    std::size_t list_size{};
+    std::array<Core::HID::VibrationDeviceHandle, 0x100> vibration_device_list{};
     std::shared_ptr<ResourceManager> resource_manager;
 };
 
@@ -153,7 +184,7 @@ IHidServer::IHidServer(Core::System& system_, std::shared_ptr<ResourceManager> r
         {209, &IHidServer::BeginPermitVibrationSession, "BeginPermitVibrationSession"},
         {210, &IHidServer::EndPermitVibrationSession, "EndPermitVibrationSession"},
         {211, &IHidServer::IsVibrationDeviceMounted, "IsVibrationDeviceMounted"},
-        {212, nullptr, "SendVibrationValueInBool"},
+        {212, &IHidServer::SendVibrationValueInBool, "SendVibrationValueInBool"},
         {300, &IHidServer::ActivateConsoleSixAxisSensor, "ActivateConsoleSixAxisSensor"},
         {301, &IHidServer::StartConsoleSixAxisSensor, "StartConsoleSixAxisSensor"},
         {302, &IHidServer::StopConsoleSixAxisSensor, "StopConsoleSixAxisSensor"},
@@ -1492,59 +1523,13 @@ void IHidServer::ClearNpadCaptureButtonAssignment(HLERequestContext& ctx) {
 void IHidServer::GetVibrationDeviceInfo(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto vibration_device_handle{rp.PopRaw<Core::HID::VibrationDeviceHandle>()};
-    const auto controller = GetResourceManager()->GetNpad();
-
-    Core::HID::VibrationDeviceInfo vibration_device_info;
-    bool check_device_index = false;
-
-    switch (vibration_device_handle.npad_type) {
-    case Core::HID::NpadStyleIndex::Fullkey:
-    case Core::HID::NpadStyleIndex::Handheld:
-    case Core::HID::NpadStyleIndex::JoyconDual:
-    case Core::HID::NpadStyleIndex::JoyconLeft:
-    case Core::HID::NpadStyleIndex::JoyconRight:
-        vibration_device_info.type = Core::HID::VibrationDeviceType::LinearResonantActuator;
-        check_device_index = true;
-        break;
-    case Core::HID::NpadStyleIndex::GameCube:
-        vibration_device_info.type = Core::HID::VibrationDeviceType::GcErm;
-        break;
-    case Core::HID::NpadStyleIndex::N64:
-        vibration_device_info.type = Core::HID::VibrationDeviceType::N64;
-        break;
-    default:
-        vibration_device_info.type = Core::HID::VibrationDeviceType::Unknown;
-        break;
-    }
-
-    vibration_device_info.position = Core::HID::VibrationDevicePosition::None;
-    if (check_device_index) {
-        switch (vibration_device_handle.device_index) {
-        case Core::HID::DeviceIndex::Left:
-            vibration_device_info.position = Core::HID::VibrationDevicePosition::Left;
-            break;
-        case Core::HID::DeviceIndex::Right:
-            vibration_device_info.position = Core::HID::VibrationDevicePosition::Right;
-            break;
-        case Core::HID::DeviceIndex::None:
-        default:
-            ASSERT_MSG(false, "DeviceIndex should never be None!");
-            break;
-        }
-    }
 
-    LOG_DEBUG(Service_HID, "called, vibration_device_type={}, vibration_device_position={}",
-              vibration_device_info.type, vibration_device_info.position);
-
-    const auto result = IsVibrationHandleValid(vibration_device_handle);
-    if (result.IsError()) {
-        IPC::ResponseBuilder rb{ctx, 2};
-        rb.Push(result);
-        return;
-    }
+    Core::HID::VibrationDeviceInfo vibration_device_info{};
+    const auto result = GetResourceManager()->GetVibrationDeviceInfo(vibration_device_info,
+                                                                     vibration_device_handle);
 
     IPC::ResponseBuilder rb{ctx, 4};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
     rb.PushRaw(vibration_device_info);
 }
 
@@ -1560,16 +1545,16 @@ void IHidServer::SendVibrationValue(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    GetResourceManager()->GetNpad()->VibrateController(parameters.applet_resource_user_id,
-                                                       parameters.vibration_device_handle,
-                                                       parameters.vibration_value);
-
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
               parameters.vibration_device_handle.npad_type,
               parameters.vibration_device_handle.npad_id,
               parameters.vibration_device_handle.device_index, parameters.applet_resource_user_id);
 
+    GetResourceManager()->SendVibrationValue(parameters.applet_resource_user_id,
+                                             parameters.vibration_device_handle,
+                                             parameters.vibration_value);
+
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
 }
@@ -1591,10 +1576,28 @@ void IHidServer::GetActualVibrationValue(HLERequestContext& ctx) {
               parameters.vibration_device_handle.npad_id,
               parameters.vibration_device_handle.device_index, parameters.applet_resource_user_id);
 
+    bool has_active_aruid{};
+    NpadVibrationDevice* device{nullptr};
+    Core::HID::VibrationValue vibration_value{};
+    Result result = GetResourceManager()->IsVibrationAruidActive(parameters.applet_resource_user_id,
+                                                                 has_active_aruid);
+
+    if (result.IsSuccess() && has_active_aruid) {
+        result = IsVibrationHandleValid(parameters.vibration_device_handle);
+    }
+    if (result.IsSuccess() && has_active_aruid) {
+        device = GetResourceManager()->GetNSVibrationDevice(parameters.vibration_device_handle);
+    }
+    if (device != nullptr) {
+        result = device->GetActualVibrationValue(vibration_value);
+    }
+    if (result.IsError()) {
+        vibration_value = Core::HID::DEFAULT_VIBRATION_VALUE;
+    }
+
     IPC::ResponseBuilder rb{ctx, 6};
     rb.Push(ResultSuccess);
-    rb.PushRaw(GetResourceManager()->GetNpad()->GetLastVibration(
-        parameters.applet_resource_user_id, parameters.vibration_device_handle));
+    rb.PushRaw(vibration_value);
 }
 
 void IHidServer::CreateActiveVibrationDeviceList(HLERequestContext& ctx) {
@@ -1609,25 +1612,27 @@ void IHidServer::PermitVibration(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto can_vibrate{rp.Pop<bool>()};
 
-    // nnSDK saves this value as a float. Since it can only be 1.0f or 0.0f we simplify this value
-    // by converting it to a bool
-    Settings::values.vibration_enabled.SetValue(can_vibrate);
-
     LOG_DEBUG(Service_HID, "called, can_vibrate={}", can_vibrate);
 
+    const auto result =
+        GetResourceManager()->GetNpad()->GetVibrationHandler()->SetVibrationMasterVolume(
+            can_vibrate ? 1.0f : 0.0f);
+
     IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
 }
 
 void IHidServer::IsVibrationPermitted(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called");
 
-    // nnSDK checks if a float is greater than zero. We return the bool we stored earlier
-    const auto is_enabled = Settings::values.vibration_enabled.GetValue();
+    f32 master_volume{};
+    const auto result =
+        GetResourceManager()->GetNpad()->GetVibrationHandler()->GetVibrationMasterVolume(
+            master_volume);
 
     IPC::ResponseBuilder rb{ctx, 3};
-    rb.Push(ResultSuccess);
-    rb.Push(is_enabled);
+    rb.Push(result);
+    rb.Push(master_volume > 0.0f);
 }
 
 void IHidServer::SendVibrationValues(HLERequestContext& ctx) {
@@ -1645,13 +1650,22 @@ void IHidServer::SendVibrationValues(HLERequestContext& ctx) {
     auto vibration_values = std::span(
         reinterpret_cast<const Core::HID::VibrationValue*>(vibration_data.data()), vibration_count);
 
-    GetResourceManager()->GetNpad()->VibrateControllers(applet_resource_user_id,
-                                                        vibration_device_handles, vibration_values);
-
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
+    Result result = ResultSuccess;
+    if (handle_count != vibration_count) {
+        result = ResultVibrationArraySizeMismatch;
+    }
+
+    for (std::size_t i = 0; i < handle_count; i++) {
+        if (result.IsSuccess()) {
+            result = GetResourceManager()->SendVibrationValue(
+                applet_resource_user_id, vibration_device_handles[i], vibration_values[i]);
+        }
+    }
+
     IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
 }
 
 void IHidServer::SendVibrationGcErmCommand(HLERequestContext& ctx) {
@@ -1666,43 +1680,6 @@ void IHidServer::SendVibrationGcErmCommand(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    /**
-     * Note: This uses yuzu-specific behavior such that the StopHard command produces
-     * vibrations where freq_low == 0.0f and freq_high == 0.0f, as defined below,
-     * in order to differentiate between Stop and StopHard commands.
-     * This is done to reuse the controller vibration functions made for regular controllers.
-     */
-    const auto vibration_value = [parameters] {
-        switch (parameters.gc_erm_command) {
-        case Core::HID::VibrationGcErmCommand::Stop:
-            return Core::HID::VibrationValue{
-                .low_amplitude = 0.0f,
-                .low_frequency = 160.0f,
-                .high_amplitude = 0.0f,
-                .high_frequency = 320.0f,
-            };
-        case Core::HID::VibrationGcErmCommand::Start:
-            return Core::HID::VibrationValue{
-                .low_amplitude = 1.0f,
-                .low_frequency = 160.0f,
-                .high_amplitude = 1.0f,
-                .high_frequency = 320.0f,
-            };
-        case Core::HID::VibrationGcErmCommand::StopHard:
-            return Core::HID::VibrationValue{
-                .low_amplitude = 0.0f,
-                .low_frequency = 0.0f,
-                .high_amplitude = 0.0f,
-                .high_frequency = 0.0f,
-            };
-        default:
-            return Core::HID::DEFAULT_VIBRATION_VALUE;
-        }
-    }();
-
-    GetResourceManager()->GetNpad()->VibrateController(
-        parameters.applet_resource_user_id, parameters.vibration_device_handle, vibration_value);
-
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}, "
               "gc_erm_command={}",
@@ -1711,8 +1688,23 @@ void IHidServer::SendVibrationGcErmCommand(HLERequestContext& ctx) {
               parameters.vibration_device_handle.device_index, parameters.applet_resource_user_id,
               parameters.gc_erm_command);
 
+    bool has_active_aruid{};
+    NpadGcVibrationDevice* gc_device{nullptr};
+    Result result = GetResourceManager()->IsVibrationAruidActive(parameters.applet_resource_user_id,
+                                                                 has_active_aruid);
+
+    if (result.IsSuccess() && has_active_aruid) {
+        result = IsVibrationHandleValid(parameters.vibration_device_handle);
+    }
+    if (result.IsSuccess() && has_active_aruid) {
+        gc_device = GetResourceManager()->GetGcVibrationDevice(parameters.vibration_device_handle);
+    }
+    if (gc_device != nullptr) {
+        result = gc_device->SendVibrationGcErmCommand(parameters.gc_erm_command);
+    }
+
     IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
 }
 
 void IHidServer::GetActualVibrationGcErmCommand(HLERequestContext& ctx) {
@@ -1725,33 +1717,31 @@ void IHidServer::GetActualVibrationGcErmCommand(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    const auto last_vibration = GetResourceManager()->GetNpad()->GetLastVibration(
-        parameters.applet_resource_user_id, parameters.vibration_device_handle);
-
-    const auto gc_erm_command = [last_vibration] {
-        if (last_vibration.low_amplitude != 0.0f || last_vibration.high_amplitude != 0.0f) {
-            return Core::HID::VibrationGcErmCommand::Start;
-        }
-
-        /**
-         * Note: This uses yuzu-specific behavior such that the StopHard command produces
-         * vibrations where freq_low == 0.0f and freq_high == 0.0f, as defined in the HID function
-         * SendVibrationGcErmCommand, in order to differentiate between Stop and StopHard commands.
-         * This is done to reuse the controller vibration functions made for regular controllers.
-         */
-        if (last_vibration.low_frequency == 0.0f && last_vibration.high_frequency == 0.0f) {
-            return Core::HID::VibrationGcErmCommand::StopHard;
-        }
-
-        return Core::HID::VibrationGcErmCommand::Stop;
-    }();
-
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
               parameters.vibration_device_handle.npad_type,
               parameters.vibration_device_handle.npad_id,
               parameters.vibration_device_handle.device_index, parameters.applet_resource_user_id);
 
+    bool has_active_aruid{};
+    NpadGcVibrationDevice* gc_device{nullptr};
+    Core::HID::VibrationGcErmCommand gc_erm_command{};
+    Result result = GetResourceManager()->IsVibrationAruidActive(parameters.applet_resource_user_id,
+                                                                 has_active_aruid);
+
+    if (result.IsSuccess() && has_active_aruid) {
+        result = IsVibrationHandleValid(parameters.vibration_device_handle);
+    }
+    if (result.IsSuccess() && has_active_aruid) {
+        gc_device = GetResourceManager()->GetGcVibrationDevice(parameters.vibration_device_handle);
+    }
+    if (gc_device != nullptr) {
+        result = gc_device->GetActualVibrationGcErmCommand(gc_erm_command);
+    }
+    if (result.IsError()) {
+        gc_erm_command = Core::HID::VibrationGcErmCommand::Stop;
+    }
+
     IPC::ResponseBuilder rb{ctx, 4};
     rb.Push(ResultSuccess);
     rb.PushEnum(gc_erm_command);
@@ -1761,21 +1751,24 @@ void IHidServer::BeginPermitVibrationSession(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    GetResourceManager()->GetNpad()->SetPermitVibrationSession(true);
-
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
+    const auto result =
+        GetResourceManager()->GetNpad()->GetVibrationHandler()->BeginPermitVibrationSession(
+            applet_resource_user_id);
+
     IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
 }
 
 void IHidServer::EndPermitVibrationSession(HLERequestContext& ctx) {
-    GetResourceManager()->GetNpad()->SetPermitVibrationSession(false);
-
     LOG_DEBUG(Service_HID, "called");
 
+    const auto result =
+        GetResourceManager()->GetNpad()->GetVibrationHandler()->EndPermitVibrationSession();
+
     IPC::ResponseBuilder rb{ctx, 2};
-    rb.Push(ResultSuccess);
+    rb.Push(result);
 }
 
 void IHidServer::IsVibrationDeviceMounted(HLERequestContext& ctx) {
@@ -1795,10 +1788,61 @@ void IHidServer::IsVibrationDeviceMounted(HLERequestContext& ctx) {
               parameters.vibration_device_handle.npad_id,
               parameters.vibration_device_handle.device_index, parameters.applet_resource_user_id);
 
+    bool is_mounted{};
+    NpadVibrationBase* device{nullptr};
+    Result result = IsVibrationHandleValid(parameters.vibration_device_handle);
+
+    if (result.IsSuccess()) {
+        device = GetResourceManager()->GetVibrationDevice(parameters.vibration_device_handle);
+    }
+
+    if (device != nullptr) {
+        is_mounted = device->IsVibrationMounted();
+    }
+
     IPC::ResponseBuilder rb{ctx, 3};
-    rb.Push(ResultSuccess);
-    rb.Push(GetResourceManager()->GetNpad()->IsVibrationDeviceMounted(
-        parameters.applet_resource_user_id, parameters.vibration_device_handle));
+    rb.Push(result);
+    rb.Push(is_mounted);
+}
+
+void IHidServer::SendVibrationValueInBool(HLERequestContext& ctx) {
+    IPC::RequestParser rp{ctx};
+    struct Parameters {
+        Core::HID::VibrationDeviceHandle vibration_device_handle;
+        INSERT_PADDING_WORDS_NOINIT(1);
+        u64 applet_resource_user_id;
+        bool is_vibrating;
+    };
+    static_assert(sizeof(Parameters) == 0x18, "Parameters has incorrect size.");
+
+    const auto parameters{rp.PopRaw<Parameters>()};
+
+    LOG_DEBUG(Service_HID,
+              "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}, "
+              "is_vibrating={}",
+              parameters.vibration_device_handle.npad_type,
+              parameters.vibration_device_handle.npad_id,
+              parameters.vibration_device_handle.device_index, parameters.applet_resource_user_id,
+              parameters.is_vibrating);
+
+    bool has_active_aruid{};
+    NpadN64VibrationDevice* n64_device{nullptr};
+    Result result = GetResourceManager()->IsVibrationAruidActive(parameters.applet_resource_user_id,
+                                                                 has_active_aruid);
+
+    if (result.IsSuccess() && has_active_aruid) {
+        result = IsVibrationHandleValid(parameters.vibration_device_handle);
+    }
+    if (result.IsSuccess() && has_active_aruid) {
+        n64_device =
+            GetResourceManager()->GetN64VibrationDevice(parameters.vibration_device_handle);
+    }
+    if (n64_device != nullptr) {
+        result = n64_device->SendValueInBool(parameters.is_vibrating);
+    }
+
+    IPC::ResponseBuilder rb{ctx, 2};
+    rb.Push(result);
 }
 
 void IHidServer::ActivateConsoleSixAxisSensor(HLERequestContext& ctx) {
diff --git a/src/core/hle/service/hid/hid_server.h b/src/core/hle/service/hid/hid_server.h
index cc7c4ebdd199..3a2e0a2301a2 100644
--- a/src/core/hle/service/hid/hid_server.h
+++ b/src/core/hle/service/hid/hid_server.h
@@ -97,6 +97,7 @@ class IHidServer final : public ServiceFramework<IHidServer> {
     void BeginPermitVibrationSession(HLERequestContext& ctx);
     void EndPermitVibrationSession(HLERequestContext& ctx);
     void IsVibrationDeviceMounted(HLERequestContext& ctx);
+    void SendVibrationValueInBool(HLERequestContext& ctx);
     void ActivateConsoleSixAxisSensor(HLERequestContext& ctx);
     void StartConsoleSixAxisSensor(HLERequestContext& ctx);
     void StopConsoleSixAxisSensor(HLERequestContext& ctx);
diff --git a/src/core/hle/service/hid/hid_system_server.cpp b/src/core/hle/service/hid/hid_system_server.cpp
index 3a0cb3cb1dd8..4466a189b37c 100644
--- a/src/core/hle/service/hid/hid_system_server.cpp
+++ b/src/core/hle/service/hid/hid_system_server.cpp
@@ -7,6 +7,7 @@
 #include "hid_core/resource_manager.h"
 #include "hid_core/resources/npad/npad.h"
 #include "hid_core/resources/npad/npad_types.h"
+#include "hid_core/resources/npad/npad_vibration.h"
 #include "hid_core/resources/palma/palma.h"
 #include "hid_core/resources/touch_screen/touch_screen.h"
 
@@ -67,14 +68,14 @@ IHidSystemServer::IHidSystemServer(Core::System& system_, std::shared_ptr<Resour
         {501, &IHidSystemServer::RegisterAppletResourceUserId, "RegisterAppletResourceUserId"},
         {502, &IHidSystemServer::UnregisterAppletResourceUserId, "UnregisterAppletResourceUserId"},
         {503, &IHidSystemServer::EnableAppletToGetInput, "EnableAppletToGetInput"},
-        {504, nullptr, "SetAruidValidForVibration"},
+        {504, &IHidSystemServer::SetAruidValidForVibration, "SetAruidValidForVibration"},
         {505, &IHidSystemServer::EnableAppletToGetSixAxisSensor, "EnableAppletToGetSixAxisSensor"},
         {506, &IHidSystemServer::EnableAppletToGetPadInput, "EnableAppletToGetPadInput"},
         {507, &IHidSystemServer::EnableAppletToGetTouchScreen, "EnableAppletToGetTouchScreen"},
-        {510, nullptr, "SetVibrationMasterVolume"},
-        {511, nullptr, "GetVibrationMasterVolume"},
-        {512, nullptr, "BeginPermitVibrationSession"},
-        {513, nullptr, "EndPermitVibrationSession"},
+        {510, &IHidSystemServer::SetVibrationMasterVolume, "SetVibrationMasterVolume"},
+        {511, &IHidSystemServer::GetVibrationMasterVolume, "GetVibrationMasterVolume"},
+        {512, &IHidSystemServer::BeginPermitVibrationSession, "BeginPermitVibrationSession"},
+        {513, &IHidSystemServer::EndPermitVibrationSession, "EndPermitVibrationSession"},
         {514, nullptr, "Unknown514"},
         {520, nullptr, "EnableHandheldHids"},
         {521, nullptr, "DisableHandheldHids"},
@@ -156,7 +157,7 @@ IHidSystemServer::IHidSystemServer(Core::System& system_, std::shared_ptr<Resour
         {1152, nullptr, "SetTouchScreenDefaultConfiguration"},
         {1153, &IHidSystemServer::GetTouchScreenDefaultConfiguration, "GetTouchScreenDefaultConfiguration"},
         {1154, nullptr, "IsFirmwareAvailableForNotification"},
-        {1155, nullptr, "SetForceHandheldStyleVibration"},
+        {1155, &IHidSystemServer::SetForceHandheldStyleVibration, "SetForceHandheldStyleVibration"},
         {1156, nullptr, "SendConnectionTriggerWithoutTimeoutEvent"},
         {1157, nullptr, "CancelConnectionTrigger"},
         {1200, nullptr, "IsButtonConfigSupported"},
@@ -538,6 +539,27 @@ void IHidSystemServer::EnableAppletToGetInput(HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
+void IHidSystemServer::SetAruidValidForVibration(HLERequestContext& ctx) {
+    IPC::RequestParser rp{ctx};
+    struct Parameters {
+        bool is_enabled;
+        INSERT_PADDING_WORDS_NOINIT(1);
+        u64 applet_resource_user_id;
+    };
+    static_assert(sizeof(Parameters) == 0x10, "Parameters has incorrect size.");
+
+    const auto parameters{rp.PopRaw<Parameters>()};
+
+    LOG_INFO(Service_HID, "called, is_enabled={}, applet_resource_user_id={}",
+             parameters.is_enabled, parameters.applet_resource_user_id);
+
+    GetResourceManager()->SetAruidValidForVibration(parameters.applet_resource_user_id,
+                                                    parameters.is_enabled);
+
+    IPC::ResponseBuilder rb{ctx, 2};
+    rb.Push(ResultSuccess);
+}
+
 void IHidSystemServer::EnableAppletToGetSixAxisSensor(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     struct Parameters {
@@ -601,6 +623,57 @@ void IHidSystemServer::EnableAppletToGetTouchScreen(HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
+void IHidSystemServer::SetVibrationMasterVolume(HLERequestContext& ctx) {
+    IPC::RequestParser rp{ctx};
+    const auto master_volume{rp.Pop<f32>()};
+
+    LOG_INFO(Service_HID, "called, volume={}", master_volume);
+
+    const auto result =
+        GetResourceManager()->GetNpad()->GetVibrationHandler()->SetVibrationMasterVolume(
+            master_volume);
+
+    IPC::ResponseBuilder rb{ctx, 2};
+    rb.Push(result);
+}
+
+void IHidSystemServer::GetVibrationMasterVolume(HLERequestContext& ctx) {
+    f32 master_volume{};
+    const auto result =
+        GetResourceManager()->GetNpad()->GetVibrationHandler()->GetVibrationMasterVolume(
+            master_volume);
+
+    LOG_INFO(Service_HID, "called, volume={}", master_volume);
+
+    IPC::ResponseBuilder rb{ctx, 3};
+    rb.Push(result);
+    rb.Push(master_volume);
+}
+
+void IHidSystemServer::BeginPermitVibrationSession(HLERequestContext& ctx) {
+    IPC::RequestParser rp{ctx};
+    const auto applet_resource_user_id{rp.Pop<u64>()};
+
+    LOG_INFO(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
+
+    const auto result =
+        GetResourceManager()->GetNpad()->GetVibrationHandler()->BeginPermitVibrationSession(
+            applet_resource_user_id);
+
+    IPC::ResponseBuilder rb{ctx, 2};
+    rb.Push(result);
+}
+
+void IHidSystemServer::EndPermitVibrationSession(HLERequestContext& ctx) {
+    LOG_INFO(Service_HID, "called");
+
+    const auto result =
+        GetResourceManager()->GetNpad()->GetVibrationHandler()->EndPermitVibrationSession();
+
+    IPC::ResponseBuilder rb{ctx, 2};
+    rb.Push(result);
+}
+
 void IHidSystemServer::IsJoyConAttachedOnAllRail(HLERequestContext& ctx) {
     const bool is_attached = true;
 
@@ -749,6 +822,19 @@ void IHidSystemServer::GetTouchScreenDefaultConfiguration(HLERequestContext& ctx
     rb.PushRaw(touchscreen_config);
 }
 
+void IHidSystemServer::SetForceHandheldStyleVibration(HLERequestContext& ctx) {
+    IPC::RequestParser rp{ctx};
+    const auto is_forced{rp.Pop<bool>()};
+
+    LOG_INFO(Service_HID, "called, is_forced={}", is_forced);
+
+    GetResourceManager()->SetForceHandheldStyleVibration(is_forced);
+    GetResourceManager()->GetNpad()->UpdateHandheldAbstractState();
+
+    IPC::ResponseBuilder rb{ctx, 2};
+    rb.Push(ResultSuccess);
+}
+
 void IHidSystemServer::IsUsingCustomButtonConfig(HLERequestContext& ctx) {
     const bool is_enabled = false;
 
diff --git a/src/core/hle/service/hid/hid_system_server.h b/src/core/hle/service/hid/hid_system_server.h
index 0c2634e3f102..90a719f026f5 100644
--- a/src/core/hle/service/hid/hid_system_server.h
+++ b/src/core/hle/service/hid/hid_system_server.h
@@ -42,9 +42,14 @@ class IHidSystemServer final : public ServiceFramework<IHidSystemServer> {
     void RegisterAppletResourceUserId(HLERequestContext& ctx);
     void UnregisterAppletResourceUserId(HLERequestContext& ctx);
     void EnableAppletToGetInput(HLERequestContext& ctx);
+    void SetAruidValidForVibration(HLERequestContext& ctx);
     void EnableAppletToGetSixAxisSensor(HLERequestContext& ctx);
     void EnableAppletToGetPadInput(HLERequestContext& ctx);
     void EnableAppletToGetTouchScreen(HLERequestContext& ctx);
+    void SetVibrationMasterVolume(HLERequestContext& ctx);
+    void GetVibrationMasterVolume(HLERequestContext& ctx);
+    void BeginPermitVibrationSession(HLERequestContext& ctx);
+    void EndPermitVibrationSession(HLERequestContext& ctx);
     void IsJoyConAttachedOnAllRail(HLERequestContext& ctx);
     void AcquireConnectionTriggerTimeoutEvent(HLERequestContext& ctx);
     void AcquireDeviceRegisteredEventForControllerSupport(HLERequestContext& ctx);
@@ -61,6 +66,7 @@ class IHidSystemServer final : public ServiceFramework<IHidSystemServer> {
     void FinalizeUsbFirmwareUpdate(HLERequestContext& ctx);
     void InitializeUsbFirmwareUpdateWithoutMemory(HLERequestContext& ctx);
     void GetTouchScreenDefaultConfiguration(HLERequestContext& ctx);
+    void SetForceHandheldStyleVibration(HLERequestContext& ctx);
     void IsUsingCustomButtonConfig(HLERequestContext& ctx);
 
     std::shared_ptr<ResourceManager> GetResourceManager();
diff --git a/src/hid_core/frontend/emulated_controller.cpp b/src/hid_core/frontend/emulated_controller.cpp
index 2ab93402d71e..b6c48aba8521 100644
--- a/src/hid_core/frontend/emulated_controller.cpp
+++ b/src/hid_core/frontend/emulated_controller.cpp
@@ -144,8 +144,8 @@ void EmulatedController::ReloadColorsFromSettings() {
 
 void EmulatedController::LoadDevices() {
     // TODO(german77): Use more buttons to detect the correct device
-    const auto left_joycon = button_params[Settings::NativeButton::DRight];
-    const auto right_joycon = button_params[Settings::NativeButton::A];
+    const auto& left_joycon = button_params[Settings::NativeButton::DRight];
+    const auto& right_joycon = button_params[Settings::NativeButton::A];
 
     // Triggers for GC controllers
     trigger_params[LeftIndex] = button_params[Settings::NativeButton::ZL];
@@ -1208,20 +1208,43 @@ void EmulatedController::SetNfc(const Common::Input::CallbackStatus& callback) {
     controller.nfc_state = controller.nfc_values;
 }
 
-bool EmulatedController::SetVibration(std::size_t device_index, VibrationValue vibration) {
+bool EmulatedController::SetVibration(bool should_vibrate) {
+    VibrationValue vibration_value = DEFAULT_VIBRATION_VALUE;
+    if (should_vibrate) {
+        vibration_value.high_amplitude = 1.0f;
+        vibration_value.low_amplitude = 1.0f;
+    }
+
+    return SetVibration(DeviceIndex::Left, vibration_value);
+}
+
+bool EmulatedController::SetVibration(u32 slot, Core::HID::VibrationGcErmCommand erm_command) {
+    VibrationValue vibration_value = DEFAULT_VIBRATION_VALUE;
+    if (erm_command == Core::HID::VibrationGcErmCommand::Start) {
+        vibration_value.high_amplitude = 1.0f;
+        vibration_value.low_amplitude = 1.0f;
+    }
+
+    return SetVibration(DeviceIndex::Left, vibration_value);
+}
+
+bool EmulatedController::SetVibration(DeviceIndex device_index, const VibrationValue& vibration) {
     if (!is_initialized) {
         return false;
     }
-    if (device_index >= output_devices.size()) {
+    if (device_index >= DeviceIndex::MaxDeviceIndex) {
         return false;
     }
-    if (!output_devices[device_index]) {
+    const std::size_t index = static_cast<std::size_t>(device_index);
+    if (!output_devices[index]) {
         return false;
     }
     const auto player_index = Service::HID::NpadIdTypeToIndex(npad_id_type);
     const auto& player = Settings::values.players.GetValue()[player_index];
     const f32 strength = static_cast<f32>(player.vibration_strength) / 100.0f;
 
+    last_vibration_value = vibration;
+
     if (!player.vibration_enabled) {
         return false;
     }
@@ -1239,8 +1262,11 @@ bool EmulatedController::SetVibration(std::size_t device_index, VibrationValue v
         .high_frequency = vibration.high_frequency,
         .type = type,
     };
-    return output_devices[device_index]->SetVibration(status) ==
-           Common::Input::DriverResult::Success;
+    return output_devices[index]->SetVibration(status) == Common::Input::DriverResult::Success;
+}
+
+VibrationValue EmulatedController::GetActualVibrationValue(DeviceIndex device_index) const {
+    return last_vibration_value;
 }
 
 bool EmulatedController::IsVibrationEnabled(std::size_t device_index) {
diff --git a/src/hid_core/frontend/emulated_controller.h b/src/hid_core/frontend/emulated_controller.h
index 90e536e072a6..168abe089dfb 100644
--- a/src/hid_core/frontend/emulated_controller.h
+++ b/src/hid_core/frontend/emulated_controller.h
@@ -355,11 +355,28 @@ class EmulatedController {
     /// Returns the latest ntag status from the controller
     const NfcState& GetNfc() const;
 
+    /**
+     * Sends an on/off vibration to the left device
+     * @return true if vibration had no errors
+     */
+    bool SetVibration(bool should_vibrate);
+
+    /**
+     * Sends an GC vibration to the left device
+     * @return true if vibration had no errors
+     */
+    bool SetVibration(u32 slot, Core::HID::VibrationGcErmCommand erm_command);
+
     /**
      * Sends a specific vibration to the output device
      * @return true if vibration had no errors
      */
-    bool SetVibration(std::size_t device_index, VibrationValue vibration);
+    bool SetVibration(DeviceIndex device_index, const VibrationValue& vibration);
+
+    /**
+     * @return The last sent vibration
+     */
+    VibrationValue GetActualVibrationValue(DeviceIndex device_index) const;
 
     /**
      * Sends a small vibration to the output device
@@ -564,6 +581,7 @@ class EmulatedController {
     f32 motion_sensitivity{Core::HID::MotionInput::IsAtRestStandard};
     u32 turbo_button_state{0};
     std::size_t nfc_handles{0};
+    VibrationValue last_vibration_value{DEFAULT_VIBRATION_VALUE};
 
     // Temporary values to avoid doing changes while the controller is in configuring mode
     NpadStyleIndex tmp_npad_type{NpadStyleIndex::None};
diff --git a/src/hid_core/resource_manager.cpp b/src/hid_core/resource_manager.cpp
index 2c5fe6d512ad..ca824b4a32ce 100644
--- a/src/hid_core/resource_manager.cpp
+++ b/src/hid_core/resource_manager.cpp
@@ -7,6 +7,7 @@
 #include "core/hle/kernel/k_shared_memory.h"
 #include "core/hle/service/ipc_helpers.h"
 #include "hid_core/hid_core.h"
+#include "hid_core/hid_util.h"
 #include "hid_core/resource_manager.h"
 
 #include "hid_core/resources/applet_resource.h"
@@ -27,6 +28,10 @@
 #include "hid_core/resources/touch_screen/gesture.h"
 #include "hid_core/resources/touch_screen/touch_screen.h"
 #include "hid_core/resources/unique_pad/unique_pad.h"
+#include "hid_core/resources/vibration/gc_vibration_device.h"
+#include "hid_core/resources/vibration/n64_vibration_device.h"
+#include "hid_core/resources/vibration/vibration_base.h"
+#include "hid_core/resources/vibration/vibration_device.h"
 
 namespace Service::HID {
 
@@ -52,6 +57,7 @@ void ResourceManager::Initialize() {
 
     system.HIDCore().ReloadInputDevices();
 
+    handheld_config = std::make_shared<HandheldConfig>();
     InitializeHidCommonSampler();
     InitializeTouchScreenSampler();
     InitializeConsoleSixAxisSampler();
@@ -174,7 +180,7 @@ void ResourceManager::InitializeHidCommonSampler() {
     debug_pad->SetAppletResource(applet_resource, &shared_mutex);
     digitizer->SetAppletResource(applet_resource, &shared_mutex);
     keyboard->SetAppletResource(applet_resource, &shared_mutex);
-    npad->SetNpadExternals(applet_resource, &shared_mutex);
+    npad->SetNpadExternals(applet_resource, &shared_mutex, handheld_config);
     six_axis->SetAppletResource(applet_resource, &shared_mutex);
     mouse->SetAppletResource(applet_resource, &shared_mutex);
     debug_mouse->SetAppletResource(applet_resource, &shared_mutex);
@@ -257,6 +263,121 @@ void ResourceManager::EnableTouchScreen(u64 aruid, bool is_enabled) {
     applet_resource->EnableTouchScreen(aruid, is_enabled);
 }
 
+NpadVibrationBase* ResourceManager::GetVibrationDevice(
+    const Core::HID::VibrationDeviceHandle& handle) {
+    return npad->GetVibrationDevice(handle);
+}
+
+NpadN64VibrationDevice* ResourceManager::GetN64VibrationDevice(
+    const Core::HID::VibrationDeviceHandle& handle) {
+    return npad->GetN64VibrationDevice(handle);
+}
+
+NpadVibrationDevice* ResourceManager::GetNSVibrationDevice(
+    const Core::HID::VibrationDeviceHandle& handle) {
+    return npad->GetNSVibrationDevice(handle);
+}
+
+NpadGcVibrationDevice* ResourceManager::GetGcVibrationDevice(
+    const Core::HID::VibrationDeviceHandle& handle) {
+    return npad->GetGcVibrationDevice(handle);
+}
+
+Result ResourceManager::SetAruidValidForVibration(u64 aruid, bool is_enabled) {
+    std::scoped_lock lock{shared_mutex};
+    const bool has_changed = applet_resource->SetAruidValidForVibration(aruid, is_enabled);
+
+    if (has_changed) {
+        auto devices = npad->GetAllVibrationDevices();
+        for ([[maybe_unused]] auto* device : devices) {
+            // TODO
+        }
+    }
+
+    auto* vibration_handler = npad->GetVibrationHandler();
+    if (aruid != vibration_handler->GetSessionAruid()) {
+        vibration_handler->EndPermitVibrationSession();
+    }
+
+    return ResultSuccess;
+}
+
+void ResourceManager::SetForceHandheldStyleVibration(bool is_forced) {
+    handheld_config->is_force_handheld_style_vibration = is_forced;
+}
+
+Result ResourceManager::IsVibrationAruidActive(u64 aruid, bool& is_active) const {
+    std::scoped_lock lock{shared_mutex};
+    is_active = applet_resource->IsVibrationAruidActive(aruid);
+    return ResultSuccess;
+}
+
+Result ResourceManager::GetVibrationDeviceInfo(Core::HID::VibrationDeviceInfo& device_info,
+                                               const Core::HID::VibrationDeviceHandle& handle) {
+    bool check_device_index = false;
+
+    const Result is_valid = IsVibrationHandleValid(handle);
+    if (is_valid.IsError()) {
+        return is_valid;
+    }
+
+    switch (handle.npad_type) {
+    case Core::HID::NpadStyleIndex::Fullkey:
+    case Core::HID::NpadStyleIndex::Handheld:
+    case Core::HID::NpadStyleIndex::JoyconDual:
+    case Core::HID::NpadStyleIndex::JoyconLeft:
+    case Core::HID::NpadStyleIndex::JoyconRight:
+        device_info.type = Core::HID::VibrationDeviceType::LinearResonantActuator;
+        check_device_index = true;
+        break;
+    case Core::HID::NpadStyleIndex::GameCube:
+        device_info.type = Core::HID::VibrationDeviceType::GcErm;
+        break;
+    case Core::HID::NpadStyleIndex::N64:
+        device_info.type = Core::HID::VibrationDeviceType::N64;
+        break;
+    default:
+        device_info.type = Core::HID::VibrationDeviceType::Unknown;
+        break;
+    }
+
+    device_info.position = Core::HID::VibrationDevicePosition::None;
+    if (check_device_index) {
+        switch (handle.device_index) {
+        case Core::HID::DeviceIndex::Left:
+            device_info.position = Core::HID::VibrationDevicePosition::Left;
+            break;
+        case Core::HID::DeviceIndex::Right:
+            device_info.position = Core::HID::VibrationDevicePosition::Right;
+            break;
+        case Core::HID::DeviceIndex::None:
+        default:
+            ASSERT_MSG(false, "DeviceIndex should never be None!");
+            break;
+        }
+    }
+    return ResultSuccess;
+}
+
+Result ResourceManager::SendVibrationValue(u64 aruid,
+                                           const Core::HID::VibrationDeviceHandle& handle,
+                                           const Core::HID::VibrationValue& value) {
+    bool has_active_aruid{};
+    NpadVibrationDevice* device{nullptr};
+    Result result = IsVibrationAruidActive(aruid, has_active_aruid);
+
+    if (result.IsSuccess() && has_active_aruid) {
+        result = IsVibrationHandleValid(handle);
+    }
+    if (result.IsSuccess() && has_active_aruid) {
+        device = GetNSVibrationDevice(handle);
+    }
+    if (device != nullptr) {
+        result = device->SendVibrationValue(value);
+    }
+    return result;
+}
+
 void ResourceManager::UpdateControllers(std::chrono::nanoseconds ns_late) {
     auto& core_timing = system.CoreTiming();
     debug_pad->OnUpdate(core_timing);
diff --git a/src/hid_core/resource_manager.h b/src/hid_core/resource_manager.h
index 7a21d8eb8a8b..128e001252c9 100644
--- a/src/hid_core/resource_manager.h
+++ b/src/hid_core/resource_manager.h
@@ -10,6 +10,12 @@ namespace Core {
 class System;
 }
 
+namespace Core::HID {
+struct VibrationDeviceHandle;
+struct VibrationValue;
+struct VibrationDeviceInfo;
+} // namespace Core::HID
+
 namespace Core::Timing {
 struct EventType;
 }
@@ -37,6 +43,11 @@ class SixAxis;
 class SleepButton;
 class TouchScreen;
 class UniquePad;
+class NpadVibrationBase;
+class NpadN64VibrationDevice;
+class NpadGcVibrationDevice;
+class NpadVibrationDevice;
+struct HandheldConfig;
 
 class ResourceManager {
 
@@ -79,6 +90,18 @@ class ResourceManager {
     void EnablePadInput(u64 aruid, bool is_enabled);
     void EnableTouchScreen(u64 aruid, bool is_enabled);
 
+    NpadVibrationBase* GetVibrationDevice(const Core::HID::VibrationDeviceHandle& handle);
+    NpadN64VibrationDevice* GetN64VibrationDevice(const Core::HID::VibrationDeviceHandle& handle);
+    NpadVibrationDevice* GetNSVibrationDevice(const Core::HID::VibrationDeviceHandle& handle);
+    NpadGcVibrationDevice* GetGcVibrationDevice(const Core::HID::VibrationDeviceHandle& handle);
+    Result SetAruidValidForVibration(u64 aruid, bool is_enabled);
+    void SetForceHandheldStyleVibration(bool is_forced);
+    Result IsVibrationAruidActive(u64 aruid, bool& is_active) const;
+    Result GetVibrationDeviceInfo(Core::HID::VibrationDeviceInfo& device_info,
+                                  const Core::HID::VibrationDeviceHandle& handle);
+    Result SendVibrationValue(u64 aruid, const Core::HID::VibrationDeviceHandle& handle,
+                              const Core::HID::VibrationValue& value);
+
     void UpdateControllers(std::chrono::nanoseconds ns_late);
     void UpdateNpad(std::chrono::nanoseconds ns_late);
     void UpdateMouseKeyboard(std::chrono::nanoseconds ns_late);
@@ -113,6 +136,8 @@ class ResourceManager {
     std::shared_ptr<TouchScreen> touch_screen = nullptr;
     std::shared_ptr<UniquePad> unique_pad = nullptr;
 
+    std::shared_ptr<HandheldConfig> handheld_config = nullptr;
+
     // TODO: Create these resources
     // std::shared_ptr<AudioControl> audio_control = nullptr;
     // std::shared_ptr<ButtonConfig> button_config = nullptr;
diff --git a/src/hid_core/resources/abstracted_pad/abstract_ir_sensor_handler.cpp b/src/hid_core/resources/abstracted_pad/abstract_ir_sensor_handler.cpp
index d4e4181bfa0a..e399edfd706b 100644
--- a/src/hid_core/resources/abstracted_pad/abstract_ir_sensor_handler.cpp
+++ b/src/hid_core/resources/abstracted_pad/abstract_ir_sensor_handler.cpp
@@ -115,7 +115,7 @@ Result NpadAbstractIrSensorHandler::GetXcdHandleForNpadWithIrSensor(u64& handle)
     if (sensor_state < NpadIrSensorState::Available) {
         return ResultIrSensorIsNotReady;
     }
-    handle = xcd_handle;
+    // handle = xcd_handle;
     return ResultSuccess;
 }
 
diff --git a/src/hid_core/resources/abstracted_pad/abstract_ir_sensor_handler.h b/src/hid_core/resources/abstracted_pad/abstract_ir_sensor_handler.h
index fe8e005af67f..997811511673 100644
--- a/src/hid_core/resources/abstracted_pad/abstract_ir_sensor_handler.h
+++ b/src/hid_core/resources/abstracted_pad/abstract_ir_sensor_handler.h
@@ -7,6 +7,10 @@
 #include "core/hle/result.h"
 #include "hid_core/hid_types.h"
 
+namespace Core::HID {
+class EmulatedController;
+}
+
 namespace Kernel {
 class KEvent;
 class KReadableEvent;
@@ -50,7 +54,7 @@ class NpadAbstractIrSensorHandler final {
 
     s32 ref_counter{};
     Kernel::KEvent* ir_sensor_event{nullptr};
-    u64 xcd_handle{};
+    Core::HID::EmulatedController* xcd_handle{};
     NpadIrSensorState sensor_state{};
 };
 } // namespace Service::HID
diff --git a/src/hid_core/resources/abstracted_pad/abstract_pad.cpp b/src/hid_core/resources/abstracted_pad/abstract_pad.cpp
index 2c7691d7cc98..435b095f0250 100644
--- a/src/hid_core/resources/abstracted_pad/abstract_pad.cpp
+++ b/src/hid_core/resources/abstracted_pad/abstract_pad.cpp
@@ -1,6 +1,7 @@
 // SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-3.0-or-later
 
+#include "hid_core/hid_core.h"
 #include "hid_core/hid_result.h"
 #include "hid_core/resources/abstracted_pad/abstract_pad.h"
 #include "hid_core/resources/applet_resource.h"
@@ -16,7 +17,7 @@ void AbstractPad::SetExternals(AppletResourceHolder* applet_resource,
                                CaptureButtonResource* capture_button_resource,
                                HomeButtonResource* home_button_resource,
                                SixAxisResource* sixaxis_resource, PalmaResource* palma_resource,
-                               VibrationHandler* vibration) {
+                               NpadVibration* vibration, Core::HID::HIDCore* core) {
     applet_resource_holder = applet_resource;
 
     properties_handler.SetAppletResource(applet_resource_holder);
@@ -35,13 +36,14 @@ void AbstractPad::SetExternals(AppletResourceHolder* applet_resource,
     mcu_handler.SetAbstractPadHolder(&abstract_pad_holder);
     mcu_handler.SetPropertiesHandler(&properties_handler);
 
-    std::array<NpadVibrationDevice*, 2> vibration_devices{&vibration_left, &vibration_right};
     vibration_handler.SetAppletResource(applet_resource_holder);
     vibration_handler.SetAbstractPadHolder(&abstract_pad_holder);
     vibration_handler.SetPropertiesHandler(&properties_handler);
     vibration_handler.SetN64Vibration(&vibration_n64);
-    vibration_handler.SetVibration(vibration_devices);
+    vibration_handler.SetVibration(&vibration_left, &vibration_right);
     vibration_handler.SetGcVibration(&vibration_gc);
+    vibration_handler.SetVibrationHandler(vibration);
+    vibration_handler.SetHidCore(core);
 
     sixaxis_handler.SetAppletResource(applet_resource_holder);
     sixaxis_handler.SetAbstractPadHolder(&abstract_pad_holder);
@@ -239,11 +241,6 @@ NpadVibrationDevice* AbstractPad::GetVibrationDevice(Core::HID::DeviceIndex devi
     return &vibration_left;
 }
 
-void AbstractPad::GetLeftRightVibrationDevice(std::vector<NpadVibrationDevice*> list) {
-    list.emplace_back(&vibration_left);
-    list.emplace_back(&vibration_right);
-}
-
 NpadGcVibrationDevice* AbstractPad::GetGCVibrationDevice() {
     return &vibration_gc;
 }
diff --git a/src/hid_core/resources/abstracted_pad/abstract_pad.h b/src/hid_core/resources/abstracted_pad/abstract_pad.h
index cbdf84af731e..329792457442 100644
--- a/src/hid_core/resources/abstracted_pad/abstract_pad.h
+++ b/src/hid_core/resources/abstracted_pad/abstract_pad.h
@@ -32,7 +32,6 @@ class AppletResource;
 class SixAxisResource;
 class PalmaResource;
 class NPadResource;
-class AbstractPad;
 class NpadLastActiveHandler;
 class NpadIrNfcHandler;
 class UniquePads;
@@ -44,7 +43,6 @@ class NpadGcVibration;
 
 class CaptureButtonResource;
 class HomeButtonResource;
-class VibrationHandler;
 
 struct HandheldConfig;
 
@@ -57,7 +55,8 @@ class AbstractPad final {
     void SetExternals(AppletResourceHolder* applet_resource,
                       CaptureButtonResource* capture_button_resource,
                       HomeButtonResource* home_button_resource, SixAxisResource* sixaxis_resource,
-                      PalmaResource* palma_resource, VibrationHandler* vibration);
+                      PalmaResource* palma_resource, NpadVibration* vibration,
+                      Core::HID::HIDCore* core);
     void SetNpadId(Core::HID::NpadIdType npad_id);
 
     Result Activate();
@@ -78,7 +77,6 @@ class AbstractPad final {
 
     NpadN64VibrationDevice* GetN64VibrationDevice();
     NpadVibrationDevice* GetVibrationDevice(Core::HID::DeviceIndex device_index);
-    void GetLeftRightVibrationDevice(std::vector<NpadVibrationDevice*> list);
     NpadGcVibrationDevice* GetGCVibrationDevice();
 
     Core::HID::NpadIdType GetLastActiveNpad();
diff --git a/src/hid_core/resources/abstracted_pad/abstract_vibration_handler.cpp b/src/hid_core/resources/abstracted_pad/abstract_vibration_handler.cpp
index a00d6c9de1f4..ca64b0a437cb 100644
--- a/src/hid_core/resources/abstracted_pad/abstract_vibration_handler.cpp
+++ b/src/hid_core/resources/abstracted_pad/abstract_vibration_handler.cpp
@@ -1,6 +1,8 @@
 // SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-3.0-or-later
 
+#include "hid_core/frontend/emulated_controller.h"
+#include "hid_core/hid_core.h"
 #include "hid_core/hid_result.h"
 #include "hid_core/hid_util.h"
 #include "hid_core/resources/abstracted_pad/abstract_pad_holder.h"
@@ -30,14 +32,22 @@ void NpadAbstractVibrationHandler::SetPropertiesHandler(NpadAbstractPropertiesHa
     properties_handler = handler;
 }
 
+void NpadAbstractVibrationHandler::SetVibrationHandler(NpadVibration* handler) {
+    vibration_handler = handler;
+}
+
+void NpadAbstractVibrationHandler::SetHidCore(Core::HID::HIDCore* core) {
+    hid_core = core;
+}
+
 void NpadAbstractVibrationHandler::SetN64Vibration(NpadN64VibrationDevice* n64_device) {
     n64_vibration_device = n64_device;
 }
 
-void NpadAbstractVibrationHandler::SetVibration(std::span<NpadVibrationDevice*> device) {
-    for (std::size_t i = 0; i < device.size() && i < vibration_device.size(); i++) {
-        vibration_device[i] = device[i];
-    }
+void NpadAbstractVibrationHandler::SetVibration(NpadVibrationDevice* left_device,
+                                                NpadVibrationDevice* right_device) {
+    left_vibration_device = left_device;
+    right_vibration_device = right_device;
 }
 
 void NpadAbstractVibrationHandler::SetGcVibration(NpadGcVibrationDevice* gc_device) {
@@ -69,5 +79,29 @@ void NpadAbstractVibrationHandler::UpdateVibrationState() {
     if (!is_handheld_hid_enabled && is_force_handheld_style_vibration) {
         // TODO
     }
+
+    // TODO: This function isn't accurate. It's supposed to get 5 abstracted pads from the
+    // NpadAbstractPropertiesHandler but this handler isn't fully implemented yet
+    IAbstractedPad abstracted_pad{};
+    const auto npad_id = properties_handler->GetNpadId();
+    abstracted_pad.xcd_handle = hid_core->GetEmulatedController(npad_id);
+    abstracted_pad.internal_flags.is_connected.Assign(abstracted_pad.xcd_handle->IsConnected());
+
+    if (abstracted_pad.internal_flags.is_connected) {
+        left_vibration_device->Mount(abstracted_pad, Core::HID::DeviceIndex::Left,
+                                     vibration_handler);
+        right_vibration_device->Mount(abstracted_pad, Core::HID::DeviceIndex::Right,
+                                      vibration_handler);
+        gc_vibration_device->Mount(abstracted_pad, 0, vibration_handler);
+        gc_vibration_device->Mount(abstracted_pad, 0, vibration_handler);
+        n64_vibration_device->Mount(abstracted_pad, vibration_handler);
+        return;
+    }
+
+    left_vibration_device->Unmount();
+    right_vibration_device->Unmount();
+    gc_vibration_device->Unmount();
+    gc_vibration_device->Unmount();
+    n64_vibration_device->Unmount();
 }
 } // namespace Service::HID
diff --git a/src/hid_core/resources/abstracted_pad/abstract_vibration_handler.h b/src/hid_core/resources/abstracted_pad/abstract_vibration_handler.h
index aeb07ce86814..8bc8129c243c 100644
--- a/src/hid_core/resources/abstracted_pad/abstract_vibration_handler.h
+++ b/src/hid_core/resources/abstracted_pad/abstract_vibration_handler.h
@@ -9,6 +9,10 @@
 #include "core/hle/result.h"
 #include "hid_core/hid_types.h"
 
+namespace Core::HID {
+class HIDCore;
+}
+
 namespace Service::HID {
 struct AppletResourceHolder;
 class NpadAbstractedPadHolder;
@@ -27,9 +31,11 @@ class NpadAbstractVibrationHandler final {
     void SetAbstractPadHolder(NpadAbstractedPadHolder* holder);
     void SetAppletResource(AppletResourceHolder* applet_resource);
     void SetPropertiesHandler(NpadAbstractPropertiesHandler* handler);
+    void SetVibrationHandler(NpadVibration* handler);
+    void SetHidCore(Core::HID::HIDCore* core);
 
     void SetN64Vibration(NpadN64VibrationDevice* n64_device);
-    void SetVibration(std::span<NpadVibrationDevice*> device);
+    void SetVibration(NpadVibrationDevice* left_device, NpadVibrationDevice* right_device);
     void SetGcVibration(NpadGcVibrationDevice* gc_device);
 
     Result IncrementRefCounter();
@@ -41,9 +47,11 @@ class NpadAbstractVibrationHandler final {
     AppletResourceHolder* applet_resource_holder{nullptr};
     NpadAbstractedPadHolder* abstract_pad_holder{nullptr};
     NpadAbstractPropertiesHandler* properties_handler{nullptr};
+    Core::HID::HIDCore* hid_core{nullptr};
 
     NpadN64VibrationDevice* n64_vibration_device{nullptr};
-    std::array<NpadVibrationDevice*, 2> vibration_device{};
+    NpadVibrationDevice* left_vibration_device{};
+    NpadVibrationDevice* right_vibration_device{};
     NpadGcVibrationDevice* gc_vibration_device{nullptr};
     NpadVibration* vibration_handler{nullptr};
     s32 ref_counter{};
diff --git a/src/hid_core/resources/applet_resource.cpp b/src/hid_core/resources/applet_resource.cpp
index a84826050adb..db4134037d17 100644
--- a/src/hid_core/resources/applet_resource.cpp
+++ b/src/hid_core/resources/applet_resource.cpp
@@ -200,6 +200,25 @@ void AppletResource::EnableInput(u64 aruid, bool is_enabled) {
     data[index].flag.enable_touchscreen.Assign(is_enabled);
 }
 
+bool AppletResource::SetAruidValidForVibration(u64 aruid, bool is_enabled) {
+    const u64 index = GetIndexFromAruid(aruid);
+    if (index >= AruidIndexMax) {
+        return false;
+    }
+
+    if (!is_enabled && aruid == active_vibration_aruid) {
+        active_vibration_aruid = SystemAruid;
+        return true;
+    }
+
+    if (is_enabled && aruid != active_vibration_aruid) {
+        active_vibration_aruid = aruid;
+        return true;
+    }
+
+    return false;
+}
+
 void AppletResource::EnableSixAxisSensor(u64 aruid, bool is_enabled) {
     const u64 index = GetIndexFromAruid(aruid);
     if (index >= AruidIndexMax) {
diff --git a/src/hid_core/resources/applet_resource.h b/src/hid_core/resources/applet_resource.h
index f3f32bac16f1..e9710d306384 100644
--- a/src/hid_core/resources/applet_resource.h
+++ b/src/hid_core/resources/applet_resource.h
@@ -101,6 +101,7 @@ class AppletResource {
     Result DestroySevenSixAxisTransferMemory();
 
     void EnableInput(u64 aruid, bool is_enabled);
+    bool SetAruidValidForVibration(u64 aruid, bool is_enabled);
     void EnableSixAxisSensor(u64 aruid, bool is_enabled);
     void EnablePadInput(u64 aruid, bool is_enabled);
     void EnableTouchScreen(u64 aruid, bool is_enabled);
diff --git a/src/hid_core/resources/npad/npad.cpp b/src/hid_core/resources/npad/npad.cpp
index 97537a2e26ee..310fa8ba7416 100644
--- a/src/hid_core/resources/npad/npad.cpp
+++ b/src/hid_core/resources/npad/npad.cpp
@@ -21,6 +21,7 @@
 #include "hid_core/hid_util.h"
 #include "hid_core/resources/applet_resource.h"
 #include "hid_core/resources/npad/npad.h"
+#include "hid_core/resources/npad/npad_vibration.h"
 #include "hid_core/resources/shared_memory_format.h"
 
 namespace Service::HID {
@@ -31,10 +32,6 @@ NPad::NPad(Core::HID::HIDCore& hid_core_, KernelHelpers::ServiceContext& service
         for (std::size_t i = 0; i < controller_data[aruid_index].size(); ++i) {
             auto& controller = controller_data[aruid_index][i];
             controller.device = hid_core.GetEmulatedControllerByIndex(i);
-            controller.vibration[Core::HID::EmulatedDeviceIndex::LeftIndex].latest_vibration_value =
-                Core::HID::DEFAULT_VIBRATION_VALUE;
-            controller.vibration[Core::HID::EmulatedDeviceIndex::RightIndex]
-                .latest_vibration_value = Core::HID::DEFAULT_VIBRATION_VALUE;
             Core::HID::ControllerUpdateCallback engine_callback{
                 .on_change =
                     [this, i](Core::HID::ControllerTriggerType type) { ControllerUpdate(type, i); },
@@ -43,6 +40,10 @@ NPad::NPad(Core::HID::HIDCore& hid_core_, KernelHelpers::ServiceContext& service
             controller.callback_key = controller.device->SetCallback(engine_callback);
         }
     }
+    for (std::size_t i = 0; i < abstracted_pads.size(); ++i) {
+        abstracted_pads[i] = AbstractPad{};
+        abstracted_pads[i].SetNpadId(IndexToNpadIdType(i));
+    }
 }
 
 NPad::~NPad() {
@@ -359,6 +360,7 @@ void NPad::InitNewlyAddedController(u64 aruid, Core::HID::NpadIdType npad_id) {
     npad_resource.SignalStyleSetUpdateEvent(aruid, npad_id);
     WriteEmptyEntry(controller.shared_memory);
     hid_core.SetLastActiveController(npad_id);
+    abstracted_pads[NpadIdTypeToIndex(npad_id)].Update();
 }
 
 void NPad::WriteEmptyEntry(NpadInternalState* npad) {
@@ -740,171 +742,6 @@ bool NPad::SetNpadMode(u64 aruid, Core::HID::NpadIdType& new_npad_id, Core::HID:
     return true;
 }
 
-bool NPad::VibrateControllerAtIndex(u64 aruid, Core::HID::NpadIdType npad_id,
-                                    std::size_t device_index,
-                                    const Core::HID::VibrationValue& vibration_value) {
-    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
-    if (!controller.device->IsConnected()) {
-        return false;
-    }
-
-    if (!controller.device->IsVibrationEnabled(device_index)) {
-        if (controller.vibration[device_index].latest_vibration_value.low_amplitude != 0.0f ||
-            controller.vibration[device_index].latest_vibration_value.high_amplitude != 0.0f) {
-            // Send an empty vibration to stop any vibrations.
-            Core::HID::VibrationValue vibration{0.0f, 160.0f, 0.0f, 320.0f};
-            controller.device->SetVibration(device_index, vibration);
-            // Then reset the vibration value to its default value.
-            controller.vibration[device_index].latest_vibration_value =
-                Core::HID::DEFAULT_VIBRATION_VALUE;
-        }
-
-        return false;
-    }
-
-    if (!Settings::values.enable_accurate_vibrations.GetValue()) {
-        using std::chrono::duration_cast;
-        using std::chrono::milliseconds;
-        using std::chrono::steady_clock;
-
-        const auto now = steady_clock::now();
-
-        // Filter out non-zero vibrations that are within 15ms of each other.
-        if ((vibration_value.low_amplitude != 0.0f || vibration_value.high_amplitude != 0.0f) &&
-            duration_cast<milliseconds>(
-                now - controller.vibration[device_index].last_vibration_timepoint) <
-                milliseconds(15)) {
-            return false;
-        }
-
-        controller.vibration[device_index].last_vibration_timepoint = now;
-    }
-
-    Core::HID::VibrationValue vibration{
-        vibration_value.low_amplitude, vibration_value.low_frequency,
-        vibration_value.high_amplitude, vibration_value.high_frequency};
-    return controller.device->SetVibration(device_index, vibration);
-}
-
-void NPad::VibrateController(u64 aruid,
-                             const Core::HID::VibrationDeviceHandle& vibration_device_handle,
-                             const Core::HID::VibrationValue& vibration_value) {
-    if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
-        return;
-    }
-
-    if (!Settings::values.vibration_enabled.GetValue() && !permit_vibration_session_enabled) {
-        return;
-    }
-
-    auto& controller = GetControllerFromHandle(aruid, vibration_device_handle);
-    const auto device_index = static_cast<std::size_t>(vibration_device_handle.device_index);
-
-    if (!controller.vibration[device_index].device_mounted || !controller.device->IsConnected()) {
-        return;
-    }
-
-    if (vibration_device_handle.device_index == Core::HID::DeviceIndex::None) {
-        ASSERT_MSG(false, "DeviceIndex should never be None!");
-        return;
-    }
-
-    // Some games try to send mismatched parameters in the device handle, block these.
-    if ((controller.device->GetNpadStyleIndex() == Core::HID::NpadStyleIndex::JoyconLeft &&
-         (vibration_device_handle.npad_type == Core::HID::NpadStyleIndex::JoyconRight ||
-          vibration_device_handle.device_index == Core::HID::DeviceIndex::Right)) ||
-        (controller.device->GetNpadStyleIndex() == Core::HID::NpadStyleIndex::JoyconRight &&
-         (vibration_device_handle.npad_type == Core::HID::NpadStyleIndex::JoyconLeft ||
-          vibration_device_handle.device_index == Core::HID::DeviceIndex::Left))) {
-        return;
-    }
-
-    // Filter out vibrations with equivalent values to reduce unnecessary state changes.
-    if (vibration_value.low_amplitude ==
-            controller.vibration[device_index].latest_vibration_value.low_amplitude &&
-        vibration_value.high_amplitude ==
-            controller.vibration[device_index].latest_vibration_value.high_amplitude) {
-        return;
-    }
-
-    if (VibrateControllerAtIndex(aruid, controller.device->GetNpadIdType(), device_index,
-                                 vibration_value)) {
-        controller.vibration[device_index].latest_vibration_value = vibration_value;
-    }
-}
-
-void NPad::VibrateControllers(
-    u64 aruid, std::span<const Core::HID::VibrationDeviceHandle> vibration_device_handles,
-    std::span<const Core::HID::VibrationValue> vibration_values) {
-    if (!Settings::values.vibration_enabled.GetValue() && !permit_vibration_session_enabled) {
-        return;
-    }
-
-    ASSERT_OR_EXECUTE_MSG(
-        vibration_device_handles.size() == vibration_values.size(), { return; },
-        "The amount of device handles does not match with the amount of vibration values,"
-        "this is undefined behavior!");
-
-    for (std::size_t i = 0; i < vibration_device_handles.size(); ++i) {
-        VibrateController(aruid, vibration_device_handles[i], vibration_values[i]);
-    }
-}
-
-Core::HID::VibrationValue NPad::GetLastVibration(
-    u64 aruid, const Core::HID::VibrationDeviceHandle& vibration_device_handle) const {
-    if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
-        return {};
-    }
-
-    const auto& controller = GetControllerFromHandle(aruid, vibration_device_handle);
-    const auto device_index = static_cast<std::size_t>(vibration_device_handle.device_index);
-    return controller.vibration[device_index].latest_vibration_value;
-}
-
-void NPad::InitializeVibrationDevice(
-    const Core::HID::VibrationDeviceHandle& vibration_device_handle) {
-    if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
-        return;
-    }
-
-    const auto aruid = applet_resource_holder.applet_resource->GetActiveAruid();
-    const auto npad_index = static_cast<Core::HID::NpadIdType>(vibration_device_handle.npad_id);
-    const auto device_index = static_cast<std::size_t>(vibration_device_handle.device_index);
-
-    if (aruid == 0) {
-        return;
-    }
-
-    InitializeVibrationDeviceAtIndex(aruid, npad_index, device_index);
-}
-
-void NPad::InitializeVibrationDeviceAtIndex(u64 aruid, Core::HID::NpadIdType npad_id,
-                                            std::size_t device_index) {
-    auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
-    if (!Settings::values.vibration_enabled.GetValue()) {
-        controller.vibration[device_index].device_mounted = false;
-        return;
-    }
-
-    controller.vibration[device_index].device_mounted =
-        controller.device->IsVibrationEnabled(device_index);
-}
-
-void NPad::SetPermitVibrationSession(bool permit_vibration_session) {
-    permit_vibration_session_enabled = permit_vibration_session;
-}
-
-bool NPad::IsVibrationDeviceMounted(
-    u64 aruid, const Core::HID::VibrationDeviceHandle& vibration_device_handle) const {
-    if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
-        return false;
-    }
-
-    const auto& controller = GetControllerFromHandle(aruid, vibration_device_handle);
-    const auto device_index = static_cast<std::size_t>(vibration_device_handle.device_index);
-    return controller.vibration[device_index].device_mounted;
-}
-
 Result NPad::AcquireNpadStyleSetUpdateEventHandle(u64 aruid, Kernel::KReadableEvent** out_event,
                                                   Core::HID::NpadIdType npad_id) {
     std::scoped_lock lock{mutex};
@@ -936,11 +773,6 @@ Result NPad::DisconnectNpad(u64 aruid, Core::HID::NpadIdType npad_id) {
 
     LOG_DEBUG(Service_HID, "Npad disconnected {}", npad_id);
     auto& controller = GetControllerFromNpadIdType(aruid, npad_id);
-    for (std::size_t device_idx = 0; device_idx < controller.vibration.size(); ++device_idx) {
-        // Send an empty vibration to stop any vibrations.
-        VibrateControllerAtIndex(aruid, npad_id, device_idx, {});
-        controller.vibration[device_idx].device_mounted = false;
-    }
 
     auto* shared_memory = controller.shared_memory;
     // Don't reset shared_memory->assignment_mode this value is persistent
@@ -1236,22 +1068,17 @@ void NPad::UnregisterAppletResourceUserId(u64 aruid) {
 }
 
 void NPad::SetNpadExternals(std::shared_ptr<AppletResource> resource,
-                            std::recursive_mutex* shared_mutex) {
+                            std::recursive_mutex* shared_mutex,
+                            std::shared_ptr<HandheldConfig> handheld_config) {
     applet_resource_holder.applet_resource = resource;
     applet_resource_holder.shared_mutex = shared_mutex;
     applet_resource_holder.shared_npad_resource = &npad_resource;
-}
+    applet_resource_holder.handheld_config = handheld_config;
 
-NPad::NpadControllerData& NPad::GetControllerFromHandle(
-    u64 aruid, const Core::HID::VibrationDeviceHandle& device_handle) {
-    const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
-    return GetControllerFromNpadIdType(aruid, npad_id);
-}
-
-const NPad::NpadControllerData& NPad::GetControllerFromHandle(
-    u64 aruid, const Core::HID::VibrationDeviceHandle& device_handle) const {
-    const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
-    return GetControllerFromNpadIdType(aruid, npad_id);
+    for (auto& abstract_pad : abstracted_pads) {
+        abstract_pad.SetExternals(&applet_resource_holder, nullptr, nullptr, nullptr, nullptr,
+                                  &vibration_handler, &hid_core);
+    }
 }
 
 NPad::NpadControllerData& NPad::GetControllerFromHandle(
@@ -1389,4 +1216,97 @@ Result NPad::GetLastActiveNpad(Core::HID::NpadIdType& out_npad_id) const {
     return ResultSuccess;
 }
 
+NpadVibration* NPad::GetVibrationHandler() {
+    return &vibration_handler;
+}
+
+std::vector<NpadVibrationBase*> NPad::GetAllVibrationDevices() {
+    std::vector<NpadVibrationBase*> vibration_devices;
+
+    for (auto& abstract_pad : abstracted_pads) {
+        auto* left_device = abstract_pad.GetVibrationDevice(Core::HID::DeviceIndex::Left);
+        auto* right_device = abstract_pad.GetVibrationDevice(Core::HID::DeviceIndex::Right);
+        auto* n64_device = abstract_pad.GetGCVibrationDevice();
+        auto* gc_device = abstract_pad.GetGCVibrationDevice();
+
+        if (left_device != nullptr) {
+            vibration_devices.emplace_back(left_device);
+        }
+        if (right_device != nullptr) {
+            vibration_devices.emplace_back(right_device);
+        }
+        if (n64_device != nullptr) {
+            vibration_devices.emplace_back(n64_device);
+        }
+        if (gc_device != nullptr) {
+            vibration_devices.emplace_back(gc_device);
+        }
+    }
+
+    return vibration_devices;
+}
+
+NpadVibrationBase* NPad::GetVibrationDevice(const Core::HID::VibrationDeviceHandle& handle) {
+    if (IsVibrationHandleValid(handle).IsError()) {
+        return nullptr;
+    }
+
+    const auto npad_index = NpadIdTypeToIndex(static_cast<Core::HID::NpadIdType>(handle.npad_id));
+    const auto style_inde = static_cast<Core::HID::NpadStyleIndex>(handle.npad_type);
+    if (style_inde == Core::HID::NpadStyleIndex::GameCube) {
+        return abstracted_pads[npad_index].GetGCVibrationDevice();
+    }
+    if (style_inde == Core::HID::NpadStyleIndex::N64) {
+        return abstracted_pads[npad_index].GetN64VibrationDevice();
+    }
+    return abstracted_pads[npad_index].GetVibrationDevice(handle.device_index);
+}
+
+NpadN64VibrationDevice* NPad::GetN64VibrationDevice(
+    const Core::HID::VibrationDeviceHandle& handle) {
+    if (IsVibrationHandleValid(handle).IsError()) {
+        return nullptr;
+    }
+
+    const auto npad_index = NpadIdTypeToIndex(static_cast<Core::HID::NpadIdType>(handle.npad_id));
+    const auto style_inde = static_cast<Core::HID::NpadStyleIndex>(handle.npad_type);
+    if (style_inde != Core::HID::NpadStyleIndex::N64) {
+        return nullptr;
+    }
+    return abstracted_pads[npad_index].GetN64VibrationDevice();
+}
+
+NpadVibrationDevice* NPad::GetNSVibrationDevice(const Core::HID::VibrationDeviceHandle& handle) {
+    if (IsVibrationHandleValid(handle).IsError()) {
+        return nullptr;
+    }
+
+    const auto npad_index = NpadIdTypeToIndex(static_cast<Core::HID::NpadIdType>(handle.npad_id));
+    const auto style_inde = static_cast<Core::HID::NpadStyleIndex>(handle.npad_type);
+    if (style_inde == Core::HID::NpadStyleIndex::GameCube ||
+        style_inde == Core::HID::NpadStyleIndex::N64) {
+        return nullptr;
+    }
+
+    return abstracted_pads[npad_index].GetVibrationDevice(handle.device_index);
+}
+
+NpadGcVibrationDevice* NPad::GetGcVibrationDevice(const Core::HID::VibrationDeviceHandle& handle) {
+    if (IsVibrationHandleValid(handle).IsError()) {
+        return nullptr;
+    }
+
+    const auto npad_index = NpadIdTypeToIndex(static_cast<Core::HID::NpadIdType>(handle.npad_id));
+    const auto style_inde = static_cast<Core::HID::NpadStyleIndex>(handle.npad_type);
+    if (style_inde != Core::HID::NpadStyleIndex::GameCube) {
+        return nullptr;
+    }
+    return abstracted_pads[npad_index].GetGCVibrationDevice();
+}
+
+void NPad::UpdateHandheldAbstractState() {
+    std::scoped_lock lock{mutex};
+    abstracted_pads[NpadIdTypeToIndex(Core::HID::NpadIdType::Handheld)].Update();
+}
+
 } // namespace Service::HID
diff --git a/src/hid_core/resources/npad/npad.h b/src/hid_core/resources/npad/npad.h
index 01f3dabb1582..18b25c688e94 100644
--- a/src/hid_core/resources/npad/npad.h
+++ b/src/hid_core/resources/npad/npad.h
@@ -10,9 +10,15 @@
 
 #include "common/common_types.h"
 #include "hid_core/hid_types.h"
+#include "hid_core/resources/abstracted_pad/abstract_pad.h"
 #include "hid_core/resources/controller_base.h"
 #include "hid_core/resources/npad/npad_resource.h"
 #include "hid_core/resources/npad/npad_types.h"
+#include "hid_core/resources/npad/npad_vibration.h"
+#include "hid_core/resources/vibration/gc_vibration_device.h"
+#include "hid_core/resources/vibration/n64_vibration_device.h"
+#include "hid_core/resources/vibration/vibration_base.h"
+#include "hid_core/resources/vibration/vibration_device.h"
 
 namespace Core::HID {
 class EmulatedController;
@@ -32,6 +38,7 @@ union Result;
 
 namespace Service::HID {
 class AppletResource;
+struct HandheldConfig;
 struct NpadInternalState;
 struct NpadSixAxisSensorLifo;
 struct NpadSharedMemoryFormat;
@@ -68,31 +75,6 @@ class NPad final {
     bool SetNpadMode(u64 aruid, Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType npad_id,
                      NpadJoyDeviceType npad_device_type, NpadJoyAssignmentMode assignment_mode);
 
-    bool VibrateControllerAtIndex(u64 aruid, Core::HID::NpadIdType npad_id,
-                                  std::size_t device_index,
-                                  const Core::HID::VibrationValue& vibration_value);
-
-    void VibrateController(u64 aruid,
-                           const Core::HID::VibrationDeviceHandle& vibration_device_handle,
-                           const Core::HID::VibrationValue& vibration_value);
-
-    void VibrateControllers(
-        u64 aruid, std::span<const Core::HID::VibrationDeviceHandle> vibration_device_handles,
-        std::span<const Core::HID::VibrationValue> vibration_values);
-
-    Core::HID::VibrationValue GetLastVibration(
-        u64 aruid, const Core::HID::VibrationDeviceHandle& vibration_device_handle) const;
-
-    void InitializeVibrationDevice(const Core::HID::VibrationDeviceHandle& vibration_device_handle);
-
-    void InitializeVibrationDeviceAtIndex(u64 aruid, Core::HID::NpadIdType npad_id,
-                                          std::size_t device_index);
-
-    void SetPermitVibrationSession(bool permit_vibration_session);
-
-    bool IsVibrationDeviceMounted(
-        u64 aruid, const Core::HID::VibrationDeviceHandle& vibration_device_handle) const;
-
     Result AcquireNpadStyleSetUpdateEventHandle(u64 aruid, Kernel::KReadableEvent** out_event,
                                                 Core::HID::NpadIdType npad_id);
 
@@ -145,7 +127,8 @@ class NPad final {
     Result RegisterAppletResourceUserId(u64 aruid);
     void UnregisterAppletResourceUserId(u64 aruid);
     void SetNpadExternals(std::shared_ptr<AppletResource> resource,
-                          std::recursive_mutex* shared_mutex);
+                          std::recursive_mutex* shared_mutex,
+                          std::shared_ptr<HandheldConfig> handheld_config);
 
     AppletDetailedUiType GetAppletDetailedUiType(Core::HID::NpadIdType npad_id);
 
@@ -161,18 +144,20 @@ class NPad final {
 
     Result GetLastActiveNpad(Core::HID::NpadIdType& out_npad_id) const;
 
-private:
-    struct VibrationData {
-        bool device_mounted{};
-        Core::HID::VibrationValue latest_vibration_value{};
-        std::chrono::steady_clock::time_point last_vibration_timepoint{};
-    };
+    NpadVibration* GetVibrationHandler();
+    std::vector<NpadVibrationBase*> GetAllVibrationDevices();
+    NpadVibrationBase* GetVibrationDevice(const Core::HID::VibrationDeviceHandle& handle);
+    NpadN64VibrationDevice* GetN64VibrationDevice(const Core::HID::VibrationDeviceHandle& handle);
+    NpadVibrationDevice* GetNSVibrationDevice(const Core::HID::VibrationDeviceHandle& handle);
+    NpadGcVibrationDevice* GetGcVibrationDevice(const Core::HID::VibrationDeviceHandle& handle);
 
+    void UpdateHandheldAbstractState();
+
+private:
     struct NpadControllerData {
         NpadInternalState* shared_memory = nullptr;
         Core::HID::EmulatedController* device = nullptr;
 
-        std::array<VibrationData, 2> vibration{};
         bool is_connected{};
 
         // Dual joycons can have only one side connected
@@ -191,10 +176,6 @@ class NPad final {
     void RequestPadStateUpdate(u64 aruid, Core::HID::NpadIdType npad_id);
     void WriteEmptyEntry(NpadInternalState* npad);
 
-    NpadControllerData& GetControllerFromHandle(
-        u64 aruid, const Core::HID::VibrationDeviceHandle& device_handle);
-    const NpadControllerData& GetControllerFromHandle(
-        u64 aruid, const Core::HID::VibrationDeviceHandle& device_handle) const;
     NpadControllerData& GetControllerFromHandle(
         u64 aruid, const Core::HID::SixAxisSensorHandle& device_handle);
     const NpadControllerData& GetControllerFromHandle(
@@ -215,11 +196,13 @@ class NPad final {
     mutable std::mutex mutex;
     NPadResource npad_resource;
     AppletResourceHolder applet_resource_holder{};
+    std::array<AbstractPad, MaxSupportedNpadIdTypes> abstracted_pads;
+    NpadVibration vibration_handler{};
+
     Kernel::KEvent* input_event{nullptr};
     std::mutex* input_mutex{nullptr};
 
     std::atomic<u64> press_state{};
-    bool permit_vibration_session_enabled;
     std::array<std::array<NpadControllerData, MaxSupportedNpadIdTypes>, AruidIndexMax>
         controller_data{};
 };
diff --git a/src/hid_core/resources/npad/npad_types.h b/src/hid_core/resources/npad/npad_types.h
index fd86c8e40366..92700d69a657 100644
--- a/src/hid_core/resources/npad/npad_types.h
+++ b/src/hid_core/resources/npad/npad_types.h
@@ -8,6 +8,10 @@
 #include "common/common_types.h"
 #include "hid_core/hid_types.h"
 
+namespace Core::HID {
+class EmulatedController;
+}
+
 namespace Service::HID {
 static constexpr std::size_t MaxSupportedNpadIdTypes = 10;
 static constexpr std::size_t StyleIndexCount = 7;
@@ -348,7 +352,7 @@ struct IAbstractedPad {
     u8 indicator;
     std::vector<f32> virtual_six_axis_sensor_acceleration;
     std::vector<f32> virtual_six_axis_sensor_angle;
-    u64 xcd_handle;
+    Core::HID::EmulatedController* xcd_handle;
     u64 color;
 };
 } // namespace Service::HID
diff --git a/src/hid_core/resources/npad/npad_vibration.cpp b/src/hid_core/resources/npad/npad_vibration.cpp
index 7056e8eab707..05aad4c54f5b 100644
--- a/src/hid_core/resources/npad/npad_vibration.cpp
+++ b/src/hid_core/resources/npad/npad_vibration.cpp
@@ -77,4 +77,8 @@ Result NpadVibration::EndPermitVibrationSession() {
     return ResultSuccess;
 }
 
+u64 NpadVibration::GetSessionAruid() const {
+    return session_aruid;
+}
+
 } // namespace Service::HID
diff --git a/src/hid_core/resources/npad/npad_vibration.h b/src/hid_core/resources/npad/npad_vibration.h
index 0748aeffc1a0..d5a95f2a09f8 100644
--- a/src/hid_core/resources/npad/npad_vibration.h
+++ b/src/hid_core/resources/npad/npad_vibration.h
@@ -25,6 +25,8 @@ class NpadVibration final {
     Result BeginPermitVibrationSession(u64 aruid);
     Result EndPermitVibrationSession();
 
+    u64 GetSessionAruid() const;
+
 private:
     f32 volume{};
     u64 session_aruid{};
diff --git a/src/hid_core/resources/vibration/gc_vibration_device.cpp b/src/hid_core/resources/vibration/gc_vibration_device.cpp
index f01f81b9a3d6..ad42b9d660b6 100644
--- a/src/hid_core/resources/vibration/gc_vibration_device.cpp
+++ b/src/hid_core/resources/vibration/gc_vibration_device.cpp
@@ -1,6 +1,7 @@
 // SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-3.0-or-later
 
+#include "hid_core/frontend/emulated_controller.h"
 #include "hid_core/hid_result.h"
 #include "hid_core/resources/npad/npad_types.h"
 #include "hid_core/resources/npad/npad_vibration.h"
@@ -10,24 +11,25 @@ namespace Service::HID {
 
 NpadGcVibrationDevice::NpadGcVibrationDevice() {}
 
-Result NpadGcVibrationDevice::IncrementRefCounter() {
+Result NpadGcVibrationDevice::Activate() {
     if (ref_counter == 0 && is_mounted) {
         f32 volume = 1.0f;
         const auto result = vibration_handler->GetVibrationVolume(volume);
         if (result.IsSuccess()) {
-            // TODO: SendVibrationGcErmCommand
+            xcd_handle->SetVibration(adapter_slot, Core::HID::VibrationGcErmCommand::Stop);
         }
     }
+
     ref_counter++;
     return ResultSuccess;
 }
 
-Result NpadGcVibrationDevice::DecrementRefCounter() {
-    if (ref_counter == 1 && !is_mounted) {
+Result NpadGcVibrationDevice::Deactivate() {
+    if (ref_counter == 1 && is_mounted) {
         f32 volume = 1.0f;
         const auto result = vibration_handler->GetVibrationVolume(volume);
         if (result.IsSuccess()) {
-            // TODO: SendVibrationGcErmCommand
+            xcd_handle->SetVibration(adapter_slot, Core::HID::VibrationGcErmCommand::Stop);
         }
     }
 
@@ -38,6 +40,48 @@ Result NpadGcVibrationDevice::DecrementRefCounter() {
     return ResultSuccess;
 }
 
+Result NpadGcVibrationDevice::Mount(IAbstractedPad& abstracted_pad, u32 slot,
+                                    NpadVibration* handler) {
+    if (!abstracted_pad.internal_flags.is_connected) {
+        return ResultSuccess;
+    }
+
+    // TODO: This device doesn't use a xcd handle instead has an GC adapter handle. This is just to
+    // keep compatibility with the front end.
+    xcd_handle = abstracted_pad.xcd_handle;
+    adapter_slot = slot;
+    vibration_handler = handler;
+    is_mounted = true;
+
+    if (ref_counter == 0) {
+        return ResultSuccess;
+    }
+
+    f32 volume{1.0f};
+    const auto result = vibration_handler->GetVibrationVolume(volume);
+    if (result.IsSuccess()) {
+        xcd_handle->SetVibration(adapter_slot, Core::HID::VibrationGcErmCommand::Stop);
+    }
+
+    return ResultSuccess;
+}
+
+Result NpadGcVibrationDevice::Unmount() {
+    if (ref_counter == 0 || !is_mounted) {
+        is_mounted = false;
+        return ResultSuccess;
+    }
+
+    f32 volume{1.0f};
+    const auto result = vibration_handler->GetVibrationVolume(volume);
+    if (result.IsSuccess()) {
+        xcd_handle->SetVibration(adapter_slot, Core::HID::VibrationGcErmCommand::Stop);
+    }
+
+    is_mounted = false;
+    return ResultSuccess;
+}
+
 Result NpadGcVibrationDevice::SendVibrationGcErmCommand(Core::HID::VibrationGcErmCommand command) {
     if (!is_mounted) {
         return ResultSuccess;
@@ -55,7 +99,7 @@ Result NpadGcVibrationDevice::SendVibrationGcErmCommand(Core::HID::VibrationGcEr
             return ResultSuccess;
         }
     }
-    // TODO: SendVibrationGcErmCommand
+    xcd_handle->SetVibration(adapter_slot, command);
     return ResultSuccess;
 }
 
diff --git a/src/hid_core/resources/vibration/gc_vibration_device.h b/src/hid_core/resources/vibration/gc_vibration_device.h
index 87abca57dcce..c624cbb28fdf 100644
--- a/src/hid_core/resources/vibration/gc_vibration_device.h
+++ b/src/hid_core/resources/vibration/gc_vibration_device.h
@@ -20,12 +20,18 @@ class NpadGcVibrationDevice final : public NpadVibrationBase {
 public:
     explicit NpadGcVibrationDevice();
 
-    Result IncrementRefCounter() override;
-    Result DecrementRefCounter() override;
+    Result Activate() override;
+    Result Deactivate() override;
+
+    Result Mount(IAbstractedPad& abstracted_pad, u32 slot, NpadVibration* handler);
+    Result Unmount();
 
     Result SendVibrationGcErmCommand(Core::HID::VibrationGcErmCommand command);
 
     Result GetActualVibrationGcErmCommand(Core::HID::VibrationGcErmCommand& out_command);
     Result SendVibrationNotificationPattern(Core::HID::VibrationGcErmCommand command);
+
+private:
+    u32 adapter_slot;
 };
 } // namespace Service::HID
diff --git a/src/hid_core/resources/vibration/n64_vibration_device.cpp b/src/hid_core/resources/vibration/n64_vibration_device.cpp
index 639f87abf3b0..94ad37c8f751 100644
--- a/src/hid_core/resources/vibration/n64_vibration_device.cpp
+++ b/src/hid_core/resources/vibration/n64_vibration_device.cpp
@@ -1,6 +1,7 @@
 // SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-3.0-or-later
 
+#include "hid_core/frontend/emulated_controller.h"
 #include "hid_core/hid_result.h"
 #include "hid_core/resources/npad/npad_types.h"
 #include "hid_core/resources/npad/npad_vibration.h"
@@ -10,12 +11,12 @@ namespace Service::HID {
 
 NpadN64VibrationDevice::NpadN64VibrationDevice() {}
 
-Result NpadN64VibrationDevice::IncrementRefCounter() {
+Result NpadN64VibrationDevice::Activate() {
     if (ref_counter == 0 && is_mounted) {
         f32 volume = 1.0f;
         const auto result = vibration_handler->GetVibrationVolume(volume);
         if (result.IsSuccess()) {
-            // TODO: SendVibrationInBool
+            xcd_handle->SetVibration(false);
         }
     }
 
@@ -23,19 +24,12 @@ Result NpadN64VibrationDevice::IncrementRefCounter() {
     return ResultSuccess;
 }
 
-Result NpadN64VibrationDevice::DecrementRefCounter() {
-    if (ref_counter == 1) {
-        if (!is_mounted) {
-            ref_counter = 0;
-            if (is_mounted != false) {
-                // TODO: SendVibrationInBool
-            }
-            return ResultSuccess;
-        }
+Result NpadN64VibrationDevice::Deactivate() {
+    if (ref_counter == 1 && is_mounted) {
         f32 volume = 1.0f;
         const auto result = vibration_handler->GetVibrationVolume(volume);
         if (result.IsSuccess()) {
-            // TODO
+            xcd_handle->SetVibration(false);
         }
     }
 
@@ -46,6 +40,43 @@ Result NpadN64VibrationDevice::DecrementRefCounter() {
     return ResultSuccess;
 }
 
+Result NpadN64VibrationDevice::Mount(IAbstractedPad& abstracted_pad, NpadVibration* handler) {
+    if (!abstracted_pad.internal_flags.is_connected) {
+        return ResultSuccess;
+    }
+    xcd_handle = abstracted_pad.xcd_handle;
+    vibration_handler = handler;
+    is_mounted = true;
+
+    if (ref_counter == 0) {
+        return ResultSuccess;
+    }
+
+    f32 volume{1.0f};
+    const auto result = vibration_handler->GetVibrationVolume(volume);
+    if (result.IsSuccess()) {
+        xcd_handle->SetVibration(false);
+    }
+
+    return ResultSuccess;
+}
+
+Result NpadN64VibrationDevice::Unmount() {
+    if (ref_counter == 0 || !is_mounted) {
+        is_mounted = false;
+        return ResultSuccess;
+    }
+
+    f32 volume{1.0f};
+    const auto result = vibration_handler->GetVibrationVolume(volume);
+    if (result.IsSuccess()) {
+        xcd_handle->SetVibration(false);
+    }
+
+    is_mounted = false;
+    return ResultSuccess;
+}
+
 Result NpadN64VibrationDevice::SendValueInBool(bool is_vibrating) {
     if (ref_counter < 1) {
         return ResultVibrationNotInitialized;
@@ -56,7 +87,7 @@ Result NpadN64VibrationDevice::SendValueInBool(bool is_vibrating) {
         if (result.IsError()) {
             return result;
         }
-        // TODO: SendVibrationInBool
+        xcd_handle->SetVibration(false);
     }
     return ResultSuccess;
 }
diff --git a/src/hid_core/resources/vibration/n64_vibration_device.h b/src/hid_core/resources/vibration/n64_vibration_device.h
index 54e6efc1ae9b..09de7701cb98 100644
--- a/src/hid_core/resources/vibration/n64_vibration_device.h
+++ b/src/hid_core/resources/vibration/n64_vibration_device.h
@@ -14,14 +14,18 @@
 
 namespace Service::HID {
 class NpadVibration;
+struct IAbstractedPad;
 
 /// Handles Npad request from HID interfaces
 class NpadN64VibrationDevice final : public NpadVibrationBase {
 public:
     explicit NpadN64VibrationDevice();
 
-    Result IncrementRefCounter() override;
-    Result DecrementRefCounter() override;
+    Result Activate() override;
+    Result Deactivate() override;
+
+    Result Mount(IAbstractedPad& abstracted_pad, NpadVibration* handler);
+    Result Unmount();
 
     Result SendValueInBool(bool is_vibrating);
     Result SendVibrationNotificationPattern(u32 pattern);
diff --git a/src/hid_core/resources/vibration/vibration_base.cpp b/src/hid_core/resources/vibration/vibration_base.cpp
index 350f349c227c..f28d30406037 100644
--- a/src/hid_core/resources/vibration/vibration_base.cpp
+++ b/src/hid_core/resources/vibration/vibration_base.cpp
@@ -10,12 +10,12 @@ namespace Service::HID {
 
 NpadVibrationBase::NpadVibrationBase() {}
 
-Result NpadVibrationBase::IncrementRefCounter() {
+Result NpadVibrationBase::Activate() {
     ref_counter++;
     return ResultSuccess;
 }
 
-Result NpadVibrationBase::DecrementRefCounter() {
+Result NpadVibrationBase::Deactivate() {
     if (ref_counter > 0) {
         ref_counter--;
     }
diff --git a/src/hid_core/resources/vibration/vibration_base.h b/src/hid_core/resources/vibration/vibration_base.h
index c6c5fc4d94c7..69c26e669021 100644
--- a/src/hid_core/resources/vibration/vibration_base.h
+++ b/src/hid_core/resources/vibration/vibration_base.h
@@ -6,6 +6,10 @@
 #include "common/common_types.h"
 #include "core/hle/result.h"
 
+namespace Core::HID {
+class EmulatedController;
+}
+
 namespace Service::HID {
 class NpadVibration;
 
@@ -14,13 +18,13 @@ class NpadVibrationBase {
 public:
     explicit NpadVibrationBase();
 
-    virtual Result IncrementRefCounter();
-    virtual Result DecrementRefCounter();
+    virtual Result Activate();
+    virtual Result Deactivate();
 
     bool IsVibrationMounted() const;
 
 protected:
-    u64 xcd_handle{};
+    Core::HID::EmulatedController* xcd_handle{nullptr};
     s32 ref_counter{};
     bool is_mounted{};
     NpadVibration* vibration_handler{nullptr};
diff --git a/src/hid_core/resources/vibration/vibration_device.cpp b/src/hid_core/resources/vibration/vibration_device.cpp
index 888c3a7ed65f..08b14591f9f3 100644
--- a/src/hid_core/resources/vibration/vibration_device.cpp
+++ b/src/hid_core/resources/vibration/vibration_device.cpp
@@ -1,6 +1,7 @@
 // SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project
 // SPDX-License-Identifier: GPL-3.0-or-later
 
+#include "hid_core/frontend/emulated_controller.h"
 #include "hid_core/hid_result.h"
 #include "hid_core/resources/npad/npad_types.h"
 #include "hid_core/resources/npad/npad_vibration.h"
@@ -10,12 +11,30 @@ namespace Service::HID {
 
 NpadVibrationDevice::NpadVibrationDevice() {}
 
-Result NpadVibrationDevice::IncrementRefCounter() {
+Result NpadVibrationDevice::Activate() {
+    if (ref_counter == 0 && is_mounted) {
+        f32 volume = 1.0f;
+        const auto result = vibration_handler->GetVibrationVolume(volume);
+        if (result.IsSuccess()) {
+            xcd_handle->SetVibration(device_index, Core::HID::DEFAULT_VIBRATION_VALUE);
+            // TODO: SendNotificationPattern;
+        }
+    }
+
     ref_counter++;
     return ResultSuccess;
 }
 
-Result NpadVibrationDevice::DecrementRefCounter() {
+Result NpadVibrationDevice::Deactivate() {
+    if (ref_counter == 1 && is_mounted) {
+        f32 volume = 1.0f;
+        const auto result = vibration_handler->GetVibrationVolume(volume);
+        if (result.IsSuccess()) {
+            xcd_handle->SetVibration(device_index, Core::HID::DEFAULT_VIBRATION_VALUE);
+            // TODO: SendNotificationPattern;
+        }
+    }
+
     if (ref_counter > 0) {
         ref_counter--;
     }
@@ -23,6 +42,45 @@ Result NpadVibrationDevice::DecrementRefCounter() {
     return ResultSuccess;
 }
 
+Result NpadVibrationDevice::Mount(IAbstractedPad& abstracted_pad, Core::HID::DeviceIndex index,
+                                  NpadVibration* handler) {
+    if (!abstracted_pad.internal_flags.is_connected) {
+        return ResultSuccess;
+    }
+    xcd_handle = abstracted_pad.xcd_handle;
+    device_index = index;
+    vibration_handler = handler;
+    is_mounted = true;
+
+    if (ref_counter == 0) {
+        return ResultSuccess;
+    }
+
+    f32 volume{1.0f};
+    const auto result = vibration_handler->GetVibrationVolume(volume);
+    if (result.IsSuccess()) {
+        xcd_handle->SetVibration(false);
+    }
+
+    return ResultSuccess;
+}
+
+Result NpadVibrationDevice::Unmount() {
+    if (ref_counter == 0 || !is_mounted) {
+        is_mounted = false;
+        return ResultSuccess;
+    }
+
+    f32 volume{1.0f};
+    const auto result = vibration_handler->GetVibrationVolume(volume);
+    if (result.IsSuccess()) {
+        xcd_handle->SetVibration(device_index, Core::HID::DEFAULT_VIBRATION_VALUE);
+    }
+
+    is_mounted = false;
+    return ResultSuccess;
+}
+
 Result NpadVibrationDevice::SendVibrationValue(const Core::HID::VibrationValue& value) {
     if (ref_counter == 0) {
         return ResultVibrationNotInitialized;
@@ -37,7 +95,7 @@ Result NpadVibrationDevice::SendVibrationValue(const Core::HID::VibrationValue&
         return result;
     }
     if (volume <= 0.0f) {
-        // TODO: SendVibrationValue
+        xcd_handle->SetVibration(device_index, Core::HID::DEFAULT_VIBRATION_VALUE);
         return ResultSuccess;
     }
 
@@ -45,7 +103,7 @@ Result NpadVibrationDevice::SendVibrationValue(const Core::HID::VibrationValue&
     vibration_value.high_amplitude *= volume;
     vibration_value.low_amplitude *= volume;
 
-    // TODO: SendVibrationValue
+    xcd_handle->SetVibration(device_index, vibration_value);
     return ResultSuccess;
 }
 
@@ -63,11 +121,11 @@ Result NpadVibrationDevice::SendVibrationNotificationPattern([[maybe_unused]] u3
         pattern = 0;
     }
 
-    // return xcd_handle->SendVibrationNotificationPattern(pattern);
+    // TODO: SendVibrationNotificationPattern;
     return ResultSuccess;
 }
 
-Result NpadVibrationDevice::GetActualVibrationValue(Core::HID::VibrationValue& out_value) {
+Result NpadVibrationDevice::GetActualVibrationValue(Core::HID::VibrationValue& out_value) const {
     if (ref_counter < 1) {
         return ResultVibrationNotInitialized;
     }
@@ -77,7 +135,7 @@ Result NpadVibrationDevice::GetActualVibrationValue(Core::HID::VibrationValue& o
         return ResultSuccess;
     }
 
-    // TODO: SendVibrationValue
+    out_value = xcd_handle->GetActualVibrationValue(device_index);
     return ResultSuccess;
 }
 
diff --git a/src/hid_core/resources/vibration/vibration_device.h b/src/hid_core/resources/vibration/vibration_device.h
index 3574ad60b795..c2f9891d3a12 100644
--- a/src/hid_core/resources/vibration/vibration_device.h
+++ b/src/hid_core/resources/vibration/vibration_device.h
@@ -12,6 +12,10 @@
 #include "hid_core/resources/npad/npad_types.h"
 #include "hid_core/resources/vibration/vibration_base.h"
 
+namespace Core::HID {
+enum class DeviceIndex : u8;
+}
+
 namespace Service::HID {
 class NpadVibration;
 
@@ -20,16 +24,20 @@ class NpadVibrationDevice final : public NpadVibrationBase {
 public:
     explicit NpadVibrationDevice();
 
-    Result IncrementRefCounter();
-    Result DecrementRefCounter();
+    Result Activate();
+    Result Deactivate();
+
+    Result Mount(IAbstractedPad& abstracted_pad, Core::HID::DeviceIndex index,
+                 NpadVibration* handler);
+    Result Unmount();
 
     Result SendVibrationValue(const Core::HID::VibrationValue& value);
     Result SendVibrationNotificationPattern(u32 pattern);
 
-    Result GetActualVibrationValue(Core::HID::VibrationValue& out_value);
+    Result GetActualVibrationValue(Core::HID::VibrationValue& out_value) const;
 
 private:
-    u32 device_index{};
+    Core::HID::DeviceIndex device_index{};
 };
 
 } // namespace Service::HID
diff --git a/src/yuzu/configuration/configure_vibration.cpp b/src/yuzu/configuration/configure_vibration.cpp
index d898d8accf8a..6b1f4527b849 100644
--- a/src/yuzu/configuration/configure_vibration.cpp
+++ b/src/yuzu/configuration/configure_vibration.cpp
@@ -116,8 +116,8 @@ void ConfigureVibration::VibrateController(Core::HID::ControllerTriggerType type
         .high_amplitude = 1.0f,
         .high_frequency = 320.0f,
     };
-    controller->SetVibration(0, vibration);
-    controller->SetVibration(1, vibration);
+    controller->SetVibration(Core::HID::DeviceIndex::Left, vibration);
+    controller->SetVibration(Core::HID::DeviceIndex::Right, vibration);
 
     // Restore previous values
     player.vibration_enabled = old_vibration_enabled;
@@ -127,7 +127,7 @@ void ConfigureVibration::VibrateController(Core::HID::ControllerTriggerType type
 void ConfigureVibration::StopVibrations() {
     for (std::size_t i = 0; i < NUM_PLAYERS; ++i) {
         auto controller = hid_core.GetEmulatedControllerByIndex(i);
-        controller->SetVibration(0, Core::HID::DEFAULT_VIBRATION_VALUE);
-        controller->SetVibration(1, Core::HID::DEFAULT_VIBRATION_VALUE);
+        controller->SetVibration(Core::HID::DeviceIndex::Left, Core::HID::DEFAULT_VIBRATION_VALUE);
+        controller->SetVibration(Core::HID::DeviceIndex::Right, Core::HID::DEFAULT_VIBRATION_VALUE);
     }
 }
