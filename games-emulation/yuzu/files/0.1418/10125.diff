diff --git a/src/common/settings.cpp b/src/common/settings.cpp
index 77ff21128347..92794f4a2773 100644
--- a/src/common/settings.cpp
+++ b/src/common/settings.cpp
@@ -60,7 +60,7 @@ void LogSettings() {
     log_setting("Renderer_NvdecEmulation", values.nvdec_emulation.GetValue());
     log_setting("Renderer_AccelerateASTC", values.accelerate_astc.GetValue());
     log_setting("Renderer_AsyncASTC", values.async_astc.GetValue());
-    log_setting("Renderer_UseVsync", values.use_vsync.GetValue());
+    log_setting("Renderer_UseVsync", values.vsync_mode.GetValue());
     log_setting("Renderer_ShaderBackend", values.shader_backend.GetValue());
     log_setting("Renderer_UseAsynchronousShaders", values.use_asynchronous_shaders.GetValue());
     log_setting("Renderer_AnisotropicFilteringLevel", values.max_anisotropy.GetValue());
@@ -222,7 +222,6 @@ void RestoreGlobalState(bool is_powered_on) {
     values.nvdec_emulation.SetGlobal(true);
     values.accelerate_astc.SetGlobal(true);
     values.async_astc.SetGlobal(true);
-    values.use_vsync.SetGlobal(true);
     values.shader_backend.SetGlobal(true);
     values.use_asynchronous_shaders.SetGlobal(true);
     values.use_fast_gpu_time.SetGlobal(true);
diff --git a/src/common/settings.h b/src/common/settings.h
index 5379d0dd526a..c0faa74068e9 100644
--- a/src/common/settings.h
+++ b/src/common/settings.h
@@ -16,6 +16,13 @@
 
 namespace Settings {
 
+enum class VSyncMode : u32 {
+    Immediate = 0,
+    Mailbox = 1,
+    FIFO = 2,
+    FIFORelaxed = 3,
+};
+
 enum class RendererBackend : u32 {
     OpenGL = 0,
     Vulkan = 1,
@@ -455,7 +462,8 @@ struct Values {
     SwitchableSetting<NvdecEmulation> nvdec_emulation{NvdecEmulation::GPU, "nvdec_emulation"};
     SwitchableSetting<bool> accelerate_astc{true, "accelerate_astc"};
     SwitchableSetting<bool> async_astc{false, "async_astc"};
-    SwitchableSetting<bool> use_vsync{true, "use_vsync"};
+    Setting<VSyncMode, true> vsync_mode{VSyncMode::FIFO, VSyncMode::Immediate,
+                                        VSyncMode::FIFORelaxed, "use_vsync"};
     SwitchableSetting<ShaderBackend, true> shader_backend{ShaderBackend::GLSL, ShaderBackend::GLSL,
                                                           ShaderBackend::SPIRV, "shader_backend"};
     SwitchableSetting<bool> use_asynchronous_shaders{false, "use_asynchronous_shaders"};
diff --git a/src/core/telemetry_session.cpp b/src/core/telemetry_session.cpp
index 9178b00ca629..7a2f3c90aff2 100644
--- a/src/core/telemetry_session.cpp
+++ b/src/core/telemetry_session.cpp
@@ -85,6 +85,20 @@ static const char* TranslateNvdecEmulation(Settings::NvdecEmulation backend) {
     return "Unknown";
 }
 
+static constexpr const char* TranslateVSyncMode(Settings::VSyncMode mode) {
+    switch (mode) {
+    case Settings::VSyncMode::Immediate:
+        return "Immediate";
+    case Settings::VSyncMode::Mailbox:
+        return "Mailbox";
+    case Settings::VSyncMode::FIFO:
+        return "FIFO";
+    case Settings::VSyncMode::FIFORelaxed:
+        return "FIFO Relaxed";
+    }
+    return "Unknown";
+}
+
 u64 GetTelemetryId() {
     u64 telemetry_id{};
     const auto filename = Common::FS::GetYuzuPath(Common::FS::YuzuPath::ConfigDir) / "telemetry_id";
@@ -241,7 +255,8 @@ void TelemetrySession::AddInitialInfo(Loader::AppLoader& app_loader,
     AddField(field_type, "Renderer_NvdecEmulation",
              TranslateNvdecEmulation(Settings::values.nvdec_emulation.GetValue()));
     AddField(field_type, "Renderer_AccelerateASTC", Settings::values.accelerate_astc.GetValue());
-    AddField(field_type, "Renderer_UseVsync", Settings::values.use_vsync.GetValue());
+    AddField(field_type, "Renderer_UseVsync",
+             TranslateVSyncMode(Settings::values.vsync_mode.GetValue()));
     AddField(field_type, "Renderer_ShaderBackend",
              static_cast<u32>(Settings::values.shader_backend.GetValue()));
     AddField(field_type, "Renderer_UseAsynchronousShaders",
diff --git a/src/video_core/renderer_vulkan/renderer_vulkan.cpp b/src/video_core/renderer_vulkan/renderer_vulkan.cpp
index 69dc76180d6c..94ae2a2f86ca 100644
--- a/src/video_core/renderer_vulkan/renderer_vulkan.cpp
+++ b/src/video_core/renderer_vulkan/renderer_vulkan.cpp
@@ -88,7 +88,7 @@ RendererVulkan::RendererVulkan(Core::TelemetrySession& telemetry_session_,
       instance(CreateInstance(library, dld, VK_API_VERSION_1_1, render_window.GetWindowInfo().type,
                               Settings::values.renderer_debug.GetValue())),
       debug_callback(Settings::values.renderer_debug ? CreateDebugCallback(instance) : nullptr),
-      surface(CreateSurface(instance, render_window)),
+      surface(CreateSurface(instance, render_window.GetWindowInfo())),
       device(CreateDevice(instance, dld, *surface)), memory_allocator(device, false),
       state_tracker(), scheduler(device, state_tracker),
       swapchain(*surface, device, scheduler, render_window.GetFramebufferLayout().width,
diff --git a/src/video_core/renderer_vulkan/vk_swapchain.cpp b/src/video_core/renderer_vulkan/vk_swapchain.cpp
index 23bbea7f10d9..1e80ce46396c 100644
--- a/src/video_core/renderer_vulkan/vk_swapchain.cpp
+++ b/src/video_core/renderer_vulkan/vk_swapchain.cpp
@@ -14,6 +14,7 @@
 #include "video_core/renderer_vulkan/vk_swapchain.h"
 #include "video_core/vulkan_common/vulkan_device.h"
 #include "video_core/vulkan_common/vulkan_wrapper.h"
+#include "vulkan/vulkan_core.h"
 
 namespace Vulkan {
 
@@ -33,23 +34,47 @@ VkSurfaceFormatKHR ChooseSwapSurfaceFormat(vk::Span<VkSurfaceFormatKHR> formats)
     return found != formats.end() ? *found : formats[0];
 }
 
-VkPresentModeKHR ChooseSwapPresentMode(vk::Span<VkPresentModeKHR> modes) {
-    // Mailbox (triple buffering) doesn't lock the application like fifo (vsync),
-    // prefer it if vsync option is not selected
-    const auto found_mailbox = std::find(modes.begin(), modes.end(), VK_PRESENT_MODE_MAILBOX_KHR);
-    if (Settings::values.fullscreen_mode.GetValue() == Settings::FullscreenMode::Borderless &&
-        found_mailbox != modes.end() && !Settings::values.use_vsync.GetValue()) {
-        return VK_PRESENT_MODE_MAILBOX_KHR;
-    }
-    if (!Settings::values.use_speed_limit.GetValue()) {
-        // FIFO present mode locks the framerate to the monitor's refresh rate,
-        // Find an alternative to surpass this limitation if FPS is unlocked.
-        const auto found_imm = std::find(modes.begin(), modes.end(), VK_PRESENT_MODE_IMMEDIATE_KHR);
-        if (found_imm != modes.end()) {
-            return VK_PRESENT_MODE_IMMEDIATE_KHR;
+static constexpr VkPresentModeKHR ChooseSwapPresentMode(bool has_imm, bool has_mailbox,
+                                                        bool has_fifo_relaxed) {
+    // Mailbox doesn't lock the application like FIFO (vsync)
+    // FIFO present mode locks the framerate to the monitor's refresh rate
+    Settings::VSyncMode setting = [has_imm, has_mailbox]() {
+        // Choose Mailbox or Immediate if unlocked and those modes are supported
+        const auto mode = Settings::values.vsync_mode.GetValue();
+        if (Settings::values.use_speed_limit.GetValue()) {
+            return mode;
+        }
+        switch (mode) {
+        case Settings::VSyncMode::FIFO:
+        case Settings::VSyncMode::FIFORelaxed:
+            if (has_mailbox) {
+                return Settings::VSyncMode::Mailbox;
+            } else if (has_imm) {
+                return Settings::VSyncMode::Immediate;
+            }
+            [[fallthrough]];
+        default:
+            return mode;
         }
+    }();
+    if ((setting == Settings::VSyncMode::Mailbox && !has_mailbox) ||
+        (setting == Settings::VSyncMode::Immediate && !has_imm) ||
+        (setting == Settings::VSyncMode::FIFORelaxed && !has_fifo_relaxed)) {
+        setting = Settings::VSyncMode::FIFO;
+    }
+
+    switch (setting) {
+    case Settings::VSyncMode::Immediate:
+        return VK_PRESENT_MODE_IMMEDIATE_KHR;
+    case Settings::VSyncMode::Mailbox:
+        return VK_PRESENT_MODE_MAILBOX_KHR;
+    case Settings::VSyncMode::FIFO:
+        return VK_PRESENT_MODE_FIFO_KHR;
+    case Settings::VSyncMode::FIFORelaxed:
+        return VK_PRESENT_MODE_FIFO_RELAXED_KHR;
+    default:
+        return VK_PRESENT_MODE_FIFO_KHR;
     }
-    return VK_PRESENT_MODE_FIFO_KHR;
 }
 
 VkExtent2D ChooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities, u32 width, u32 height) {
@@ -167,11 +192,17 @@ void Swapchain::Present(VkSemaphore render_semaphore) {
 void Swapchain::CreateSwapchain(const VkSurfaceCapabilitiesKHR& capabilities, bool srgb) {
     const auto physical_device{device.GetPhysical()};
     const auto formats{physical_device.GetSurfaceFormatsKHR(surface)};
-    const auto present_modes{physical_device.GetSurfacePresentModesKHR(surface)};
+    const auto present_modes = physical_device.GetSurfacePresentModesKHR(surface);
+    has_mailbox = std::find(present_modes.begin(), present_modes.end(),
+                            VK_PRESENT_MODE_MAILBOX_KHR) != present_modes.end();
+    has_imm = std::find(present_modes.begin(), present_modes.end(),
+                        VK_PRESENT_MODE_IMMEDIATE_KHR) != present_modes.end();
+    has_fifo_relaxed = std::find(present_modes.begin(), present_modes.end(),
+                                 VK_PRESENT_MODE_FIFO_RELAXED_KHR) != present_modes.end();
 
     const VkCompositeAlphaFlagBitsKHR alpha_flags{ChooseAlphaFlags(capabilities)};
     surface_format = ChooseSwapSurfaceFormat(formats);
-    present_mode = ChooseSwapPresentMode(present_modes);
+    present_mode = ChooseSwapPresentMode(has_imm, has_mailbox, has_fifo_relaxed);
 
     u32 requested_image_count{capabilities.minImageCount + 1};
     // Ensure Triple buffering if possible.
@@ -232,7 +263,6 @@ void Swapchain::CreateSwapchain(const VkSurfaceCapabilitiesKHR& capabilities, bo
 
     extent = swapchain_ci.imageExtent;
     current_srgb = srgb;
-    current_fps_unlocked = !Settings::values.use_speed_limit.GetValue();
 
     images = swapchain.GetImages();
     image_count = static_cast<u32>(images.size());
@@ -254,14 +284,9 @@ void Swapchain::Destroy() {
     swapchain.reset();
 }
 
-bool Swapchain::HasFpsUnlockChanged() const {
-    return current_fps_unlocked != !Settings::values.use_speed_limit.GetValue();
-}
-
 bool Swapchain::NeedsPresentModeUpdate() const {
-    // Mailbox present mode is the ideal for all scenarios. If it is not available,
-    // A different present mode is needed to support unlocked FPS above the monitor's refresh rate.
-    return present_mode != VK_PRESENT_MODE_MAILBOX_KHR && HasFpsUnlockChanged();
+    const auto requested_mode = ChooseSwapPresentMode(has_imm, has_mailbox, has_fifo_relaxed);
+    return present_mode != requested_mode;
 }
 
 } // namespace Vulkan
diff --git a/src/video_core/renderer_vulkan/vk_swapchain.h b/src/video_core/renderer_vulkan/vk_swapchain.h
index 41974258678b..bf1ea7254c30 100644
--- a/src/video_core/renderer_vulkan/vk_swapchain.h
+++ b/src/video_core/renderer_vulkan/vk_swapchain.h
@@ -116,8 +116,6 @@ class Swapchain {
 
     void Destroy();
 
-    bool HasFpsUnlockChanged() const;
-
     bool NeedsPresentModeUpdate() const;
 
     const VkSurfaceKHR surface;
@@ -142,9 +140,11 @@ class Swapchain {
     VkExtent2D extent{};
     VkPresentModeKHR present_mode{};
     VkSurfaceFormatKHR surface_format{};
+    bool has_imm{false};
+    bool has_mailbox{false};
+    bool has_fifo_relaxed{false};
 
     bool current_srgb{};
-    bool current_fps_unlocked{};
     bool is_outdated{};
     bool is_suboptimal{};
 };
diff --git a/src/video_core/vulkan_common/vulkan_surface.cpp b/src/video_core/vulkan_common/vulkan_surface.cpp
index fa9bafa206f7..c34599365fe1 100644
--- a/src/video_core/vulkan_common/vulkan_surface.cpp
+++ b/src/video_core/vulkan_common/vulkan_surface.cpp
@@ -23,10 +23,10 @@
 
 namespace Vulkan {
 
-vk::SurfaceKHR CreateSurface(const vk::Instance& instance,
-                             const Core::Frontend::EmuWindow& emu_window) {
+vk::SurfaceKHR CreateSurface(
+    const vk::Instance& instance,
+    [[maybe_unused]] const Core::Frontend::EmuWindow::WindowSystemInfo& window_info) {
     [[maybe_unused]] const vk::InstanceDispatch& dld = instance.Dispatch();
-    [[maybe_unused]] const auto& window_info = emu_window.GetWindowInfo();
     VkSurfaceKHR unsafe_surface = nullptr;
 
 #ifdef _WIN32
diff --git a/src/video_core/vulkan_common/vulkan_surface.h b/src/video_core/vulkan_common/vulkan_surface.h
index 5725143e652c..5e18c06c4de0 100644
--- a/src/video_core/vulkan_common/vulkan_surface.h
+++ b/src/video_core/vulkan_common/vulkan_surface.h
@@ -3,15 +3,12 @@
 
 #pragma once
 
+#include "core/frontend/emu_window.h"
 #include "video_core/vulkan_common/vulkan_wrapper.h"
 
-namespace Core::Frontend {
-class EmuWindow;
-}
-
 namespace Vulkan {
 
-[[nodiscard]] vk::SurfaceKHR CreateSurface(const vk::Instance& instance,
-                                           const Core::Frontend::EmuWindow& emu_window);
+[[nodiscard]] vk::SurfaceKHR CreateSurface(
+    const vk::Instance& instance, const Core::Frontend::EmuWindow::WindowSystemInfo& window_info);
 
 } // namespace Vulkan
diff --git a/src/yuzu/CMakeLists.txt b/src/yuzu/CMakeLists.txt
index 0f8c1e6a68f5..2d7b9ab65f6c 100644
--- a/src/yuzu/CMakeLists.txt
+++ b/src/yuzu/CMakeLists.txt
@@ -189,6 +189,8 @@ add_executable(yuzu
     multiplayer/state.h
     multiplayer/validation.h
     precompiled_headers.h
+    qt_common.cpp
+    qt_common.h
     startup_checks.cpp
     startup_checks.h
     uisettings.cpp
diff --git a/src/yuzu/bootmanager.cpp b/src/yuzu/bootmanager.cpp
index 4c7bf28d805b..d0c72b8207a6 100644
--- a/src/yuzu/bootmanager.cpp
+++ b/src/yuzu/bootmanager.cpp
@@ -1,36 +1,48 @@
 // SPDX-FileCopyrightText: 2014 Citra Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#include <algorithm>
+#include <array>
+#include <cmath>
+#include <cstring>
+#include <string>
+#include <tuple>
+#include <type_traits>
 #include <glad/glad.h>
 
-#include <QApplication>
+#include <QtCore/qglobal.h>
 #if (QT_VERSION < QT_VERSION_CHECK(6, 0, 0)) && YUZU_USE_QT_MULTIMEDIA
+#include <QCamera>
 #include <QCameraImageCapture>
 #include <QCameraInfo>
 #endif
+#include <QCursor>
+#include <QEvent>
+#include <QGuiApplication>
 #include <QHBoxLayout>
+#include <QKeyEvent>
+#include <QLayout>
+#include <QList>
 #include <QMessageBox>
-#include <QPainter>
 #include <QScreen>
-#include <QString>
-#include <QStringList>
+#include <QSize>
+#include <QStringLiteral>
+#include <QSurfaceFormat>
+#include <QTimer>
 #include <QWindow>
+#include <QtCore/qobjectdefs.h>
 
 #ifdef HAS_OPENGL
 #include <QOffscreenSurface>
 #include <QOpenGLContext>
 #endif
 
-#if !defined(WIN32)
-#include <qpa/qplatformnativeinterface.h>
-#endif
-
-#include <fmt/format.h>
-
-#include "common/assert.h"
 #include "common/microprofile.h"
+#include "common/polyfill_thread.h"
 #include "common/scm_rev.h"
 #include "common/settings.h"
+#include "common/settings_input.h"
+#include "common/thread.h"
 #include "core/core.h"
 #include "core/cpu_manager.h"
 #include "core/frontend/framebuffer_layout.h"
@@ -40,11 +52,16 @@
 #include "input_common/drivers/tas_input.h"
 #include "input_common/drivers/touch_screen.h"
 #include "input_common/main.h"
+#include "video_core/gpu.h"
+#include "video_core/rasterizer_interface.h"
 #include "video_core/renderer_base.h"
 #include "yuzu/bootmanager.h"
 #include "yuzu/main.h"
+#include "yuzu/qt_common.h"
 
-static Core::Frontend::WindowSystemType GetWindowSystemType();
+class QObject;
+class QPaintEngine;
+class QSurface;
 
 EmuThread::EmuThread(Core::System& system) : m_system{system} {}
 
@@ -154,7 +171,10 @@ class OpenGLSharedContext : public Core::Frontend::GraphicsContext {
 
         // disable vsync for any shared contexts
         auto format = share_context->format();
-        format.setSwapInterval(main_surface ? Settings::values.use_vsync.GetValue() : 0);
+        const int swap_interval =
+            Settings::values.vsync_mode.GetValue() == Settings::VSyncMode::Immediate ? 0 : 1;
+
+        format.setSwapInterval(main_surface ? swap_interval : 0);
 
         context = std::make_unique<QOpenGLContext>();
         context->setShareContext(share_context);
@@ -221,7 +241,7 @@ class RenderWidget : public QWidget {
     explicit RenderWidget(GRenderWindow* parent) : QWidget(parent), render_window(parent) {
         setAttribute(Qt::WA_NativeWindow);
         setAttribute(Qt::WA_PaintOnScreen);
-        if (GetWindowSystemType() == Core::Frontend::WindowSystemType::Wayland) {
+        if (YuzuQtCommon::GetWindowSystemType() == Core::Frontend::WindowSystemType::Wayland) {
             setAttribute(Qt::WA_DontCreateNativeAncestors);
         }
     }
@@ -259,46 +279,6 @@ struct NullRenderWidget : public RenderWidget {
     explicit NullRenderWidget(GRenderWindow* parent) : RenderWidget(parent) {}
 };
 
-static Core::Frontend::WindowSystemType GetWindowSystemType() {
-    // Determine WSI type based on Qt platform.
-    QString platform_name = QGuiApplication::platformName();
-    if (platform_name == QStringLiteral("windows"))
-        return Core::Frontend::WindowSystemType::Windows;
-    else if (platform_name == QStringLiteral("xcb"))
-        return Core::Frontend::WindowSystemType::X11;
-    else if (platform_name == QStringLiteral("wayland"))
-        return Core::Frontend::WindowSystemType::Wayland;
-    else if (platform_name == QStringLiteral("wayland-egl"))
-        return Core::Frontend::WindowSystemType::Wayland;
-    else if (platform_name == QStringLiteral("cocoa"))
-        return Core::Frontend::WindowSystemType::Cocoa;
-    else if (platform_name == QStringLiteral("android"))
-        return Core::Frontend::WindowSystemType::Android;
-
-    LOG_CRITICAL(Frontend, "Unknown Qt platform {}!", platform_name.toStdString());
-    return Core::Frontend::WindowSystemType::Windows;
-}
-
-static Core::Frontend::EmuWindow::WindowSystemInfo GetWindowSystemInfo(QWindow* window) {
-    Core::Frontend::EmuWindow::WindowSystemInfo wsi;
-    wsi.type = GetWindowSystemType();
-
-    // Our Win32 Qt external doesn't have the private API.
-#if defined(WIN32) || defined(__APPLE__)
-    wsi.render_surface = window ? reinterpret_cast<void*>(window->winId()) : nullptr;
-#else
-    QPlatformNativeInterface* pni = QGuiApplication::platformNativeInterface();
-    wsi.display_connection = pni->nativeResourceForWindow("display", window);
-    if (wsi.type == Core::Frontend::WindowSystemType::Wayland)
-        wsi.render_surface = window ? pni->nativeResourceForWindow("surface", window) : nullptr;
-    else
-        wsi.render_surface = window ? reinterpret_cast<void*>(window->winId()) : nullptr;
-#endif
-    wsi.render_surface_scale = window ? static_cast<float>(window->devicePixelRatio()) : 1.0f;
-
-    return wsi;
-}
-
 GRenderWindow::GRenderWindow(GMainWindow* parent, EmuThread* emu_thread_,
                              std::shared_ptr<InputCommon::InputSubsystem> input_subsystem_,
                              Core::System& system_)
@@ -904,7 +884,7 @@ bool GRenderWindow::InitRenderTarget() {
     }
 
     // Update the Window System information with the new render target
-    window_info = GetWindowSystemInfo(child_widget->windowHandle());
+    window_info = YuzuQtCommon::GetWindowSystemInfo(child_widget->windowHandle());
 
     child_widget->resize(Layout::ScreenUndocked::Width, Layout::ScreenUndocked::Height);
     layout()->addWidget(child_widget);
diff --git a/src/yuzu/bootmanager.h b/src/yuzu/bootmanager.h
index bb4eca07f48e..4276be82b5b8 100644
--- a/src/yuzu/bootmanager.h
+++ b/src/yuzu/bootmanager.h
@@ -5,27 +5,46 @@
 
 #include <atomic>
 #include <condition_variable>
+#include <cstddef>
 #include <memory>
 #include <mutex>
+#include <stop_token>
+#include <utility>
+#include <vector>
 
+#include <QByteArray>
 #include <QImage>
+#include <QObject>
+#include <QPoint>
+#include <QString>
 #include <QStringList>
 #include <QThread>
-#include <QTouchEvent>
 #include <QWidget>
+#include <qglobal.h>
+#include <qnamespace.h>
+#include <qobjectdefs.h>
 
+#include "common/common_types.h"
+#include "common/logging/log.h"
 #include "common/polyfill_thread.h"
 #include "common/thread.h"
 #include "core/frontend/emu_window.h"
 
-class GRenderWindow;
 class GMainWindow;
 class QCamera;
 class QCameraImageCapture;
+class QCloseEvent;
+class QFocusEvent;
 class QKeyEvent;
+class QMouseEvent;
+class QObject;
+class QResizeEvent;
+class QShowEvent;
+class QTimer;
+class QTouchEvent;
+class QWheelEvent;
 
 namespace Core {
-enum class SystemResultStatus : u32;
 class System;
 } // namespace Core
 
@@ -40,7 +59,6 @@ enum class TasState;
 
 namespace VideoCore {
 enum class LoadCallbackStage;
-class RendererBase;
 } // namespace VideoCore
 
 class EmuThread final : public QThread {
diff --git a/src/yuzu/configuration/config.cpp b/src/yuzu/configuration/config.cpp
index 305891d18f15..4a8436e5c119 100644
--- a/src/yuzu/configuration/config.cpp
+++ b/src/yuzu/configuration/config.cpp
@@ -6,6 +6,7 @@
 #include <QSettings>
 #include "common/fs/fs.h"
 #include "common/fs/path_util.h"
+#include "common/settings.h"
 #include "core/core.h"
 #include "core/hle/service/acc/profile_manager.h"
 #include "core/hle/service/hid/controllers/npad.h"
@@ -709,7 +710,6 @@ void Config::ReadRendererValues() {
     ReadGlobalSetting(Settings::values.nvdec_emulation);
     ReadGlobalSetting(Settings::values.accelerate_astc);
     ReadGlobalSetting(Settings::values.async_astc);
-    ReadGlobalSetting(Settings::values.use_vsync);
     ReadGlobalSetting(Settings::values.shader_backend);
     ReadGlobalSetting(Settings::values.use_asynchronous_shaders);
     ReadGlobalSetting(Settings::values.use_fast_gpu_time);
@@ -720,6 +720,10 @@ void Config::ReadRendererValues() {
     ReadGlobalSetting(Settings::values.bg_blue);
 
     if (global) {
+        Settings::values.vsync_mode.SetValue(static_cast<Settings::VSyncMode>(
+            ReadSetting(QString::fromStdString(Settings::values.vsync_mode.GetLabel()),
+                        static_cast<u32>(Settings::values.vsync_mode.GetDefault()))
+                .value<u32>()));
         ReadBasicSetting(Settings::values.renderer_debug);
         ReadBasicSetting(Settings::values.renderer_shader_feedback);
         ReadBasicSetting(Settings::values.enable_nsight_aftermath);
@@ -1352,7 +1356,6 @@ void Config::SaveRendererValues() {
                  Settings::values.nvdec_emulation.UsingGlobal());
     WriteGlobalSetting(Settings::values.accelerate_astc);
     WriteGlobalSetting(Settings::values.async_astc);
-    WriteGlobalSetting(Settings::values.use_vsync);
     WriteSetting(QString::fromStdString(Settings::values.shader_backend.GetLabel()),
                  static_cast<u32>(Settings::values.shader_backend.GetValue(global)),
                  static_cast<u32>(Settings::values.shader_backend.GetDefault()),
@@ -1366,6 +1369,9 @@ void Config::SaveRendererValues() {
     WriteGlobalSetting(Settings::values.bg_blue);
 
     if (global) {
+        WriteSetting(QString::fromStdString(Settings::values.vsync_mode.GetLabel()),
+                     static_cast<u32>(Settings::values.vsync_mode.GetValue()),
+                     static_cast<u32>(Settings::values.vsync_mode.GetDefault()));
         WriteBasicSetting(Settings::values.renderer_debug);
         WriteBasicSetting(Settings::values.renderer_shader_feedback);
         WriteBasicSetting(Settings::values.enable_nsight_aftermath);
diff --git a/src/yuzu/configuration/configure_graphics.cpp b/src/yuzu/configuration/configure_graphics.cpp
index e9388daadbf5..6f5bc8d90bc3 100644
--- a/src/yuzu/configuration/configure_graphics.cpp
+++ b/src/yuzu/configuration/configure_graphics.cpp
@@ -4,20 +4,76 @@
 // Include this early to include Vulkan headers how we want to
 #include "video_core/vulkan_common/vulkan_wrapper.h"
 
+#include <algorithm>
+#include <iosfwd>
+#include <iterator>
+#include <string>
+#include <tuple>
+#include <utility>
+#include <vector>
+#include <QBoxLayout>
+#include <QCheckBox>
 #include <QColorDialog>
-#include <QVulkanInstance>
+#include <QComboBox>
+#include <QIcon>
+#include <QLabel>
+#include <QPixmap>
+#include <QPushButton>
+#include <QSlider>
+#include <QStringLiteral>
+#include <QtCore/qobjectdefs.h>
+#include <qcoreevent.h>
+#include <qglobal.h>
+#include <vulkan/vulkan_core.h>
 
 #include "common/common_types.h"
+#include "common/dynamic_library.h"
 #include "common/logging/log.h"
 #include "common/settings.h"
 #include "core/core.h"
 #include "ui_configure_graphics.h"
 #include "video_core/vulkan_common/vulkan_instance.h"
 #include "video_core/vulkan_common/vulkan_library.h"
+#include "video_core/vulkan_common/vulkan_surface.h"
 #include "yuzu/configuration/configuration_shared.h"
 #include "yuzu/configuration/configure_graphics.h"
+#include "yuzu/qt_common.h"
 #include "yuzu/uisettings.h"
 
+static const std::vector<VkPresentModeKHR> default_present_modes{VK_PRESENT_MODE_IMMEDIATE_KHR,
+                                                                 VK_PRESENT_MODE_FIFO_KHR};
+
+// Converts a setting to a present mode (or vice versa)
+static constexpr VkPresentModeKHR VSyncSettingToMode(Settings::VSyncMode mode) {
+    switch (mode) {
+    case Settings::VSyncMode::Immediate:
+        return VK_PRESENT_MODE_IMMEDIATE_KHR;
+    case Settings::VSyncMode::Mailbox:
+        return VK_PRESENT_MODE_MAILBOX_KHR;
+    case Settings::VSyncMode::FIFO:
+        return VK_PRESENT_MODE_FIFO_KHR;
+    case Settings::VSyncMode::FIFORelaxed:
+        return VK_PRESENT_MODE_FIFO_RELAXED_KHR;
+    default:
+        return VK_PRESENT_MODE_FIFO_KHR;
+    }
+}
+
+static constexpr Settings::VSyncMode PresentModeToSetting(VkPresentModeKHR mode) {
+    switch (mode) {
+    case VK_PRESENT_MODE_IMMEDIATE_KHR:
+        return Settings::VSyncMode::Immediate;
+    case VK_PRESENT_MODE_MAILBOX_KHR:
+        return Settings::VSyncMode::Mailbox;
+    case VK_PRESENT_MODE_FIFO_KHR:
+        return Settings::VSyncMode::FIFO;
+    case VK_PRESENT_MODE_FIFO_RELAXED_KHR:
+        return Settings::VSyncMode::FIFORelaxed;
+    default:
+        return Settings::VSyncMode::FIFO;
+    }
+}
+
 ConfigureGraphics::ConfigureGraphics(const Core::System& system_, QWidget* parent)
     : QWidget(parent), ui{std::make_unique<Ui::ConfigureGraphics>()}, system{system_} {
     vulkan_device = Settings::values.vulkan_device.GetValue();
@@ -39,13 +95,16 @@ ConfigureGraphics::ConfigureGraphics(const Core::System& system_, QWidget* paren
 
     connect(ui->api, qOverload<int>(&QComboBox::currentIndexChanged), this, [this] {
         UpdateAPILayout();
+        PopulateVSyncModeSelection();
         if (!Settings::IsConfiguringGlobal()) {
             ConfigurationShared::SetHighlight(
                 ui->api_widget, ui->api->currentIndex() != ConfigurationShared::USE_GLOBAL_INDEX);
         }
     });
-    connect(ui->device, qOverload<int>(&QComboBox::activated), this,
-            [this](int device) { UpdateDeviceSelection(device); });
+    connect(ui->device, qOverload<int>(&QComboBox::activated), this, [this](int device) {
+        UpdateDeviceSelection(device);
+        PopulateVSyncModeSelection();
+    });
     connect(ui->backend, qOverload<int>(&QComboBox::activated), this,
             [this](int backend) { UpdateShaderBackendSelection(backend); });
 
@@ -70,6 +129,43 @@ ConfigureGraphics::ConfigureGraphics(const Core::System& system_, QWidget* paren
     ui->fsr_sharpening_label->setVisible(Settings::IsConfiguringGlobal());
 }
 
+void ConfigureGraphics::PopulateVSyncModeSelection() {
+    const Settings::RendererBackend backend{GetCurrentGraphicsBackend()};
+    if (backend == Settings::RendererBackend::Null) {
+        ui->vsync_mode_combobox->setEnabled(false);
+        return;
+    }
+    ui->vsync_mode_combobox->setEnabled(true);
+
+    const int current_index = //< current selected vsync mode from combobox
+        ui->vsync_mode_combobox->currentIndex();
+    const auto current_mode = //< current selected vsync mode as a VkPresentModeKHR
+        current_index == -1 ? VSyncSettingToMode(Settings::values.vsync_mode.GetValue())
+                            : vsync_mode_combobox_enum_map[current_index];
+    int index{};
+    const int device{ui->device->currentIndex()}; //< current selected Vulkan device
+    const auto& present_modes = //< relevant vector of present modes for the selected device or API
+        backend == Settings::RendererBackend::Vulkan ? device_present_modes[device]
+                                                     : default_present_modes;
+
+    ui->vsync_mode_combobox->clear();
+    vsync_mode_combobox_enum_map.clear();
+    vsync_mode_combobox_enum_map.reserve(present_modes.size());
+    for (const auto present_mode : present_modes) {
+        const auto mode_name = TranslateVSyncMode(present_mode, backend);
+        if (mode_name.isEmpty()) {
+            continue;
+        }
+
+        ui->vsync_mode_combobox->insertItem(index, mode_name);
+        vsync_mode_combobox_enum_map.push_back(present_mode);
+        if (present_mode == current_mode) {
+            ui->vsync_mode_combobox->setCurrentIndex(index);
+        }
+        index++;
+    }
+}
+
 void ConfigureGraphics::UpdateDeviceSelection(int device) {
     if (device == -1) {
         return;
@@ -99,6 +195,9 @@ void ConfigureGraphics::SetConfiguration() {
     ui->nvdec_emulation_widget->setEnabled(runtime_lock);
     ui->resolution_combobox->setEnabled(runtime_lock);
     ui->accelerate_astc->setEnabled(runtime_lock);
+    ui->vsync_mode_layout->setEnabled(runtime_lock ||
+                                      Settings::values.renderer_backend.GetValue() ==
+                                          Settings::RendererBackend::Vulkan);
     ui->use_disk_shader_cache->setChecked(Settings::values.use_disk_shader_cache.GetValue());
     ui->use_asynchronous_gpu_emulation->setChecked(
         Settings::values.use_asynchronous_gpu_emulation.GetValue());
@@ -170,7 +269,24 @@ void ConfigureGraphics::SetConfiguration() {
                                                 Settings::values.bg_green.GetValue(),
                                                 Settings::values.bg_blue.GetValue()));
     UpdateAPILayout();
+    PopulateVSyncModeSelection(); //< must happen after UpdateAPILayout
     SetFSRIndicatorText(ui->fsr_sharpening_slider->sliderPosition());
+
+    // VSync setting needs to be determined after populating the VSync combobox
+    if (Settings::IsConfiguringGlobal()) {
+        const auto vsync_mode_setting = Settings::values.vsync_mode.GetValue();
+        const auto vsync_mode = VSyncSettingToMode(vsync_mode_setting);
+        int index{};
+        for (const auto mode : vsync_mode_combobox_enum_map) {
+            if (mode == vsync_mode) {
+                break;
+            }
+            index++;
+        }
+        if (static_cast<unsigned long>(index) < vsync_mode_combobox_enum_map.size()) {
+            ui->vsync_mode_combobox->setCurrentIndex(index);
+        }
+    }
 }
 
 void ConfigureGraphics::SetFSRIndicatorText(int percentage) {
@@ -178,6 +294,27 @@ void ConfigureGraphics::SetFSRIndicatorText(int percentage) {
         tr("%1%", "FSR sharpening percentage (e.g. 50%)").arg(100 - (percentage / 2)));
 }
 
+const QString ConfigureGraphics::TranslateVSyncMode(VkPresentModeKHR mode,
+                                                    Settings::RendererBackend backend) const {
+    switch (mode) {
+    case VK_PRESENT_MODE_IMMEDIATE_KHR:
+        return backend == Settings::RendererBackend::OpenGL
+                   ? tr("Off")
+                   : QStringLiteral("Immediate (%1)").arg(tr("VSync Off"));
+    case VK_PRESENT_MODE_MAILBOX_KHR:
+        return QStringLiteral("Mailbox (%1)").arg(tr("Recommended"));
+    case VK_PRESENT_MODE_FIFO_KHR:
+        return backend == Settings::RendererBackend::OpenGL
+                   ? tr("On")
+                   : QStringLiteral("FIFO (%1)").arg(tr("VSync On"));
+    case VK_PRESENT_MODE_FIFO_RELAXED_KHR:
+        return QStringLiteral("FIFO Relaxed");
+    default:
+        return {};
+        break;
+    }
+}
+
 void ConfigureGraphics::ApplyConfiguration() {
     const auto resolution_setup = static_cast<Settings::ResolutionSetup>(
         ui->resolution_combobox->currentIndex() -
@@ -232,6 +369,10 @@ void ConfigureGraphics::ApplyConfiguration() {
             Settings::values.anti_aliasing.SetValue(anti_aliasing);
         }
         Settings::values.fsr_sharpening_slider.SetValue(ui->fsr_sharpening_slider->value());
+
+        const auto mode = vsync_mode_combobox_enum_map[ui->vsync_mode_combobox->currentIndex()];
+        const auto vsync_mode = PresentModeToSetting(mode);
+        Settings::values.vsync_mode.SetValue(vsync_mode);
     } else {
         if (ui->resolution_combobox->currentIndex() == ConfigurationShared::USE_GLOBAL_INDEX) {
             Settings::values.resolution_setup.SetGlobal(true);
@@ -345,7 +486,9 @@ void ConfigureGraphics::UpdateAPILayout() {
         ui->backend_widget->setVisible(true);
         break;
     case Settings::RendererBackend::Vulkan:
-        ui->device->setCurrentIndex(vulkan_device);
+        if (static_cast<int>(vulkan_device) < ui->device->count()) {
+            ui->device->setCurrentIndex(vulkan_device);
+        }
         ui->device_widget->setVisible(true);
         ui->backend_widget->setVisible(false);
         break;
@@ -363,16 +506,27 @@ void ConfigureGraphics::RetrieveVulkanDevices() try {
 
     using namespace Vulkan;
 
+    auto* window = this->window()->windowHandle();
+    auto wsi = YuzuQtCommon::GetWindowSystemInfo(window);
+
     vk::InstanceDispatch dld;
     const Common::DynamicLibrary library = OpenLibrary();
-    const vk::Instance instance = CreateInstance(library, dld, VK_API_VERSION_1_1);
+    const vk::Instance instance = CreateInstance(library, dld, VK_API_VERSION_1_1, wsi.type);
     const std::vector<VkPhysicalDevice> physical_devices = instance.EnumeratePhysicalDevices();
+    vk::SurfaceKHR surface = //< needed to view present modes for a device
+        CreateSurface(instance, wsi);
 
     vulkan_devices.clear();
     vulkan_devices.reserve(physical_devices.size());
+    device_present_modes.clear();
+    device_present_modes.reserve(physical_devices.size());
     for (const VkPhysicalDevice device : physical_devices) {
-        const std::string name = vk::PhysicalDevice(device, dld).GetProperties().deviceName;
+        const auto physical_device = vk::PhysicalDevice(device, dld);
+        const std::string name = physical_device.GetProperties().deviceName;
+        const std::vector<VkPresentModeKHR> present_modes =
+            physical_device.GetSurfacePresentModesKHR(*surface);
         vulkan_devices.push_back(QString::fromStdString(name));
+        device_present_modes.push_back(present_modes);
     }
 } catch (const Vulkan::vk::Exception& exception) {
     LOG_ERROR(Frontend, "Failed to enumerate devices with error: {}", exception.what());
@@ -465,4 +619,6 @@ void ConfigureGraphics::SetupPerGameUI() {
         ui->api, static_cast<int>(Settings::values.renderer_backend.GetValue(true)));
     ConfigurationShared::InsertGlobalItem(
         ui->nvdec_emulation, static_cast<int>(Settings::values.nvdec_emulation.GetValue(true)));
+
+    ui->vsync_mode_layout->setVisible(false);
 }
diff --git a/src/yuzu/configuration/configure_graphics.h b/src/yuzu/configuration/configure_graphics.h
index d98d6624e2ee..901f604a597c 100644
--- a/src/yuzu/configuration/configure_graphics.h
+++ b/src/yuzu/configuration/configure_graphics.h
@@ -5,9 +5,21 @@
 
 #include <memory>
 #include <vector>
+#include <QColor>
 #include <QString>
 #include <QWidget>
-#include "common/settings.h"
+#include <qobjectdefs.h>
+#include <vulkan/vulkan_core.h>
+#include "common/common_types.h"
+
+class QEvent;
+class QObject;
+
+namespace Settings {
+enum class NvdecEmulation : u32;
+enum class RendererBackend : u32;
+enum class ShaderBackend : u32;
+} // namespace Settings
 
 namespace Core {
 class System;
@@ -35,6 +47,7 @@ class ConfigureGraphics : public QWidget {
     void changeEvent(QEvent* event) override;
     void RetranslateUI();
 
+    void PopulateVSyncModeSelection();
     void UpdateBackgroundColorButton(QColor color);
     void UpdateAPILayout();
     void UpdateDeviceSelection(int device);
@@ -43,6 +56,10 @@ class ConfigureGraphics : public QWidget {
     void RetrieveVulkanDevices();
 
     void SetFSRIndicatorText(int percentage);
+    /* Turns a Vulkan present mode into a textual string for a UI
+     * (and eventually for a human to read) */
+    const QString TranslateVSyncMode(VkPresentModeKHR mode,
+                                     Settings::RendererBackend backend) const;
 
     void SetupPerGameUI();
 
@@ -58,6 +75,10 @@ class ConfigureGraphics : public QWidget {
     ConfigurationShared::CheckState use_asynchronous_gpu_emulation;
 
     std::vector<QString> vulkan_devices;
+    std::vector<std::vector<VkPresentModeKHR>> device_present_modes;
+    std::vector<VkPresentModeKHR>
+        vsync_mode_combobox_enum_map; //< Keeps track of which present mode corresponds to which
+                                      // selection in the combobox
     u32 vulkan_device{};
     Settings::ShaderBackend shader_backend{};
 
diff --git a/src/yuzu/configuration/configure_graphics.ui b/src/yuzu/configuration/configure_graphics.ui
index a45ec69ecfa4..39f70e406fcc 100644
--- a/src/yuzu/configuration/configure_graphics.ui
+++ b/src/yuzu/configuration/configure_graphics.ui
@@ -188,6 +188,44 @@
           </property>
          </widget>
         </item>
+        <item>
+         <widget class="QWidget" name="vsync_mode_layout" native="true">
+          <layout class="QHBoxLayout" name="horizontalLayout_4">
+           <property name="leftMargin">
+            <number>0</number>
+           </property>
+           <property name="topMargin">
+            <number>0</number>
+           </property>
+           <property name="rightMargin">
+            <number>0</number>
+           </property>
+           <property name="bottomMargin">
+            <number>0</number>
+           </property>
+           <item>
+            <widget class="QLabel" name="vsync_mode_label">
+             <property name="text">
+              <string>VSync Mode:</string>
+             </property>
+            </widget>
+           </item>
+           <item>
+            <widget class="QComboBox" name="vsync_mode_combobox">
+             <property name="toolTip">
+              <string>FIFO (VSync) does not drop frames or exhibit tearing but is limited by the screen refresh rate.
+FIFO Relaxed is similar to FIFO but allows tearing as it recovers from a slow down.
+Mailbox can have lower latency than FIFO and does not tear but may drop frames.
+Immediate (no synchronization) just presents whatever is available and can exhibit tearing.</string>
+             </property>
+             <property name="currentText">
+              <string/>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </widget>
+        </item>
         <item>
          <widget class="QWidget" name="nvdec_emulation_widget" native="true">
           <layout class="QHBoxLayout" name="nvdec_emulation_layout">
@@ -366,7 +404,7 @@
              </item>
              <item>
               <property name="text">
-                  <string>1.5X (1080p/1620p) [EXPERIMENTAL]</string>
+               <string>1.5X (1080p/1620p) [EXPERIMENTAL]</string>
               </property>
              </item>
              <item>
diff --git a/src/yuzu/configuration/configure_graphics_advanced.cpp b/src/yuzu/configuration/configure_graphics_advanced.cpp
index 7f7bf0e4d060..4072ce145a53 100644
--- a/src/yuzu/configuration/configure_graphics_advanced.cpp
+++ b/src/yuzu/configuration/configure_graphics_advanced.cpp
@@ -21,7 +21,6 @@ ConfigureGraphicsAdvanced::~ConfigureGraphicsAdvanced() = default;
 
 void ConfigureGraphicsAdvanced::SetConfiguration() {
     const bool runtime_lock = !system.IsPoweredOn();
-    ui->use_vsync->setEnabled(runtime_lock);
     ui->async_present->setEnabled(runtime_lock);
     ui->renderer_force_max_clock->setEnabled(runtime_lock);
     ui->async_astc->setEnabled(runtime_lock);
@@ -30,7 +29,6 @@ void ConfigureGraphicsAdvanced::SetConfiguration() {
 
     ui->async_present->setChecked(Settings::values.async_presentation.GetValue());
     ui->renderer_force_max_clock->setChecked(Settings::values.renderer_force_max_clock.GetValue());
-    ui->use_vsync->setChecked(Settings::values.use_vsync.GetValue());
     ui->async_astc->setChecked(Settings::values.async_astc.GetValue());
     ui->use_asynchronous_shaders->setChecked(Settings::values.use_asynchronous_shaders.GetValue());
     ui->use_fast_gpu_time->setChecked(Settings::values.use_fast_gpu_time.GetValue());
@@ -63,7 +61,6 @@ void ConfigureGraphicsAdvanced::ApplyConfiguration() {
                                              renderer_force_max_clock);
     ConfigurationShared::ApplyPerGameSetting(&Settings::values.max_anisotropy,
                                              ui->anisotropic_filtering_combobox);
-    ConfigurationShared::ApplyPerGameSetting(&Settings::values.use_vsync, ui->use_vsync, use_vsync);
     ConfigurationShared::ApplyPerGameSetting(&Settings::values.async_astc, ui->async_astc,
                                              async_astc);
     ConfigurationShared::ApplyPerGameSetting(&Settings::values.use_asynchronous_shaders,
@@ -97,7 +94,6 @@ void ConfigureGraphicsAdvanced::SetupPerGameUI() {
         ui->async_present->setEnabled(Settings::values.async_presentation.UsingGlobal());
         ui->renderer_force_max_clock->setEnabled(
             Settings::values.renderer_force_max_clock.UsingGlobal());
-        ui->use_vsync->setEnabled(Settings::values.use_vsync.UsingGlobal());
         ui->async_astc->setEnabled(Settings::values.async_astc.UsingGlobal());
         ui->use_asynchronous_shaders->setEnabled(
             Settings::values.use_asynchronous_shaders.UsingGlobal());
@@ -117,7 +113,6 @@ void ConfigureGraphicsAdvanced::SetupPerGameUI() {
     ConfigurationShared::SetColoredTristate(ui->renderer_force_max_clock,
                                             Settings::values.renderer_force_max_clock,
                                             renderer_force_max_clock);
-    ConfigurationShared::SetColoredTristate(ui->use_vsync, Settings::values.use_vsync, use_vsync);
     ConfigurationShared::SetColoredTristate(ui->async_astc, Settings::values.async_astc,
                                             async_astc);
     ConfigurationShared::SetColoredTristate(ui->use_asynchronous_shaders,
diff --git a/src/yuzu/configuration/configure_graphics_advanced.ui b/src/yuzu/configuration/configure_graphics_advanced.ui
index d7ec189395b6..134023032e1a 100644
--- a/src/yuzu/configuration/configure_graphics_advanced.ui
+++ b/src/yuzu/configuration/configure_graphics_advanced.ui
@@ -86,16 +86,6 @@
           </property>
          </widget>
         </item>
-        <item>
-         <widget class="QCheckBox" name="use_vsync">
-          <property name="toolTip">
-           <string>VSync prevents the screen from tearing, but some graphics cards have lower performance with VSync enabled. Keep it enabled if you don't notice a performance difference.</string>
-          </property>
-          <property name="text">
-           <string>Use VSync</string>
-          </property>
-         </widget>
-        </item>
         <item>
          <widget class="QCheckBox" name="async_astc">
           <property name="toolTip">
diff --git a/src/yuzu/configuration/configure_input_player.cpp b/src/yuzu/configuration/configure_input_player.cpp
index 50b62293eb28..a21a3eaa944e 100644
--- a/src/yuzu/configuration/configure_input_player.cpp
+++ b/src/yuzu/configuration/configure_input_player.cpp
@@ -8,6 +8,7 @@
 #include <QInputDialog>
 #include <QMenu>
 #include <QMessageBox>
+#include <QMouseEvent>
 #include <QTimer>
 #include "common/assert.h"
 #include "common/param_package.h"
diff --git a/src/yuzu/qt_common.cpp b/src/yuzu/qt_common.cpp
new file mode 100644
index 000000000000..1b533ee402b3
--- /dev/null
+++ b/src/yuzu/qt_common.cpp
@@ -0,0 +1,55 @@
+// SPDX-FileCopyrightText: 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <QGuiApplication>
+#include <QStringLiteral>
+#include <QWindow>
+#include "common/logging/log.h"
+#include "core/frontend/emu_window.h"
+#include "yuzu/qt_common.h"
+
+#ifdef __linux__
+#include <qpa/qplatformnativeinterface.h>
+#endif
+
+namespace YuzuQtCommon {
+Core::Frontend::WindowSystemType GetWindowSystemType() {
+    // Determine WSI type based on Qt platform.
+    QString platform_name = QGuiApplication::platformName();
+    if (platform_name == QStringLiteral("windows"))
+        return Core::Frontend::WindowSystemType::Windows;
+    else if (platform_name == QStringLiteral("xcb"))
+        return Core::Frontend::WindowSystemType::X11;
+    else if (platform_name == QStringLiteral("wayland"))
+        return Core::Frontend::WindowSystemType::Wayland;
+    else if (platform_name == QStringLiteral("wayland-egl"))
+        return Core::Frontend::WindowSystemType::Wayland;
+    else if (platform_name == QStringLiteral("cocoa"))
+        return Core::Frontend::WindowSystemType::Cocoa;
+    else if (platform_name == QStringLiteral("android"))
+        return Core::Frontend::WindowSystemType::Android;
+
+    LOG_CRITICAL(Frontend, "Unknown Qt platform {}!", platform_name.toStdString());
+    return Core::Frontend::WindowSystemType::Windows;
+} // namespace Core::Frontend::WindowSystemType
+
+Core::Frontend::EmuWindow::WindowSystemInfo GetWindowSystemInfo(QWindow* window) {
+    Core::Frontend::EmuWindow::WindowSystemInfo wsi;
+    wsi.type = GetWindowSystemType();
+
+    // Our Win32 Qt external doesn't have the private API.
+#if defined(WIN32) || defined(__APPLE__)
+    wsi.render_surface = window ? reinterpret_cast<void*>(window->winId()) : nullptr;
+#else
+    QPlatformNativeInterface* pni = QGuiApplication::platformNativeInterface();
+    wsi.display_connection = pni->nativeResourceForWindow("display", window);
+    if (wsi.type == Core::Frontend::WindowSystemType::Wayland)
+        wsi.render_surface = window ? pni->nativeResourceForWindow("surface", window) : nullptr;
+    else
+        wsi.render_surface = window ? reinterpret_cast<void*>(window->winId()) : nullptr;
+#endif
+    wsi.render_surface_scale = window ? static_cast<float>(window->devicePixelRatio()) : 1.0f;
+
+    return wsi;
+}
+} // namespace YuzuQtCommon
diff --git a/src/yuzu/qt_common.h b/src/yuzu/qt_common.h
new file mode 100644
index 000000000000..b366adee698c
--- /dev/null
+++ b/src/yuzu/qt_common.h
@@ -0,0 +1,15 @@
+// SPDX-FileCopyrightText: 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#pragma once
+
+#include <QWindow>
+#include "core/frontend/emu_window.h"
+
+namespace YuzuQtCommon {
+
+Core::Frontend::WindowSystemType GetWindowSystemType();
+
+Core::Frontend::EmuWindow::WindowSystemInfo GetWindowSystemInfo(QWindow* window);
+
+} // namespace YuzuQtCommon
diff --git a/src/yuzu_cmd/config.cpp b/src/yuzu_cmd/config.cpp
index fa347fb8cb55..a692ef809dbd 100644
--- a/src/yuzu_cmd/config.cpp
+++ b/src/yuzu_cmd/config.cpp
@@ -320,7 +320,7 @@ void Config::ReadValues() {
     ReadSetting("Renderer", Settings::values.use_disk_shader_cache);
     ReadSetting("Renderer", Settings::values.gpu_accuracy);
     ReadSetting("Renderer", Settings::values.use_asynchronous_gpu_emulation);
-    ReadSetting("Renderer", Settings::values.use_vsync);
+    ReadSetting("Renderer", Settings::values.vsync_mode);
     ReadSetting("Renderer", Settings::values.shader_backend);
     ReadSetting("Renderer", Settings::values.use_asynchronous_shaders);
     ReadSetting("Renderer", Settings::values.nvdec_emulation);
diff --git a/src/yuzu_cmd/default_ini.h b/src/yuzu_cmd/default_ini.h
index c0c89fbb9b5a..1990c0707c88 100644
--- a/src/yuzu_cmd/default_ini.h
+++ b/src/yuzu_cmd/default_ini.h
@@ -325,8 +325,14 @@ aspect_ratio =
 # 0: Default, 1: 2x, 2: 4x, 3: 8x, 4: 16x
 max_anisotropy =
 
-# Whether to enable V-Sync (caps the framerate at 60FPS) or not.
-# 0 (default): Off, 1: On
+# Whether to enable VSync or not.
+# OpenGL: Values other than 0 enable VSync
+# Vulkan: FIFO is selected if the requested mode is not supported by the driver.
+# FIFO (VSync) does not drop frames or exhibit tearing but is limited by the screen refresh rate.
+# FIFO Relaxed is similar to FIFO but allows tearing as it recovers from a slow down.
+# Mailbox can have lower latency than FIFO and does not tear but may drop frames.
+# Immediate (no synchronization) just presents whatever is available and can exhibit tearing.
+# 0: Immediate (Off), 1: Mailbox, 2 (Default): FIFO (On), 3: FIFO Relaxed
 use_vsync =
 
 # Selects the OpenGL shader backend. NV_gpu_program5 is required for GLASM. If NV_gpu_program5 is
