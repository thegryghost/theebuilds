diff -Naur stream.org/etp/bitstream.c stream/etp/bitstream.c
--- stream.org/etp/bitstream.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/bitstream.c	2013-09-02 01:18:17.905198136 -0400
@@ -0,0 +1,201 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <math.h>
+#include <memory.h>
+
+#include "utils.h"
+#include "bitstream.h"
+
+
+#define BIT_GET_FILTER				0x80
+#define BIT_PUT_FILTER				0x01
+
+// ***********************
+// ***********************
+//
+// Bitstream functions
+//
+// ***********************
+// ***********************
+BITSTREAM * bits_create(uint8_t * stream, uint32_t len)
+{
+	BITSTREAM * b = calloc(1, sizeof(BITSTREAM));
+
+	b->stream = stream;
+	b->len = len;
+	b->bit_offset = 0;
+
+	return b;
+}
+
+BITSTREAM * bits_create_put(uint8_t * stream, uint32_t len)
+{
+	BITSTREAM * b = bits_create(stream, len);
+	memset(stream, 0, len);
+	return b;
+}
+
+int8_t bits_reset(BITSTREAM * b)
+{
+	int8_t r = 0;
+	if (b)
+		b->bit_offset = 0;
+	else
+		r = -1;
+	return r;
+}
+
+
+int8_t bits_peek_next_bit(BITSTREAM * b)
+{
+	int8_t r = bits_get_next_bit(b);
+
+	b->bit_offset--;
+
+	return r;
+}
+
+int8_t bits_get_next_bit(BITSTREAM * b)
+{
+	int8_t ret = -1;
+
+	if (b && b->stream && (b->bit_offset < (b->len*BYTE_SIZE)))
+	{
+		uint32_t _off = b->bit_offset - ((b->bit_offset / BYTE_SIZE) * BYTE_SIZE);
+		ret = ((b->stream[b->bit_offset++/BYTE_SIZE] & (BIT_GET_FILTER >> _off) ) >> (7 - _off));
+	}
+	return ret;
+}
+
+uint64_t bits_peek_bit_count(BITSTREAM * b, uint32_t num_of_bits, int8_t *rc)
+{
+	uint64_t r = bits_get_bit_count(b, num_of_bits, rc);
+
+	if (*rc >= 0)
+		b->bit_offset -= num_of_bits;
+	return r;
+}
+
+uint64_t bits_get_bit_count(BITSTREAM * b, uint32_t num_of_bits, int8_t *rc)
+{
+	int8_t i;
+	uint64_t ret = 0;
+
+	for (i = (num_of_bits - 1); i >= 0; i--)
+	{
+		if ((*rc = bits_get_next_bit(b)) < 0)
+			break;
+		ret |= (*rc << i);
+	}
+	return ret;
+}
+
+uint64_t bits_get_ue_golomb(BITSTREAM * b, int8_t *rc)
+{
+	uint32_t zero_count = 0;
+	uint64_t ret = 0;
+
+	while ((*rc = bits_get_next_bit(b)) == 0)
+		zero_count++;
+
+	if (zero_count && *rc >= 1)
+	{
+		uint32_t i;
+		ret = (1 << zero_count);
+
+		for (i = zero_count; i > 0; i--)
+		{
+			if ((*rc = bits_get_next_bit(b)) != -1)
+				ret |= (*rc << (i - 1));
+			else
+				break;
+		}
+		ret--;
+	}
+	return ret;
+}
+
+int64_t bits_get_se_golomb(BITSTREAM * b, int8_t *rc)
+{
+	int64_t ret = 0;
+	uint64_t tmp = 0;
+
+	tmp = bits_get_ue_golomb(b, rc);
+
+	if (*rc >= 0)
+		ret = pow(-1.0, (double)tmp + 1.0) * ceil((double)tmp / 2.0);
+
+	return ret;
+}
+
+
+uint16_t bits_get_be16(BITSTREAM * b, int8_t *rc)
+{
+	uint16_t val;
+	uint16_t tmp[2];
+
+	tmp[0] = (uint16_t) bits_get_bit_count(b, 8, rc);
+	tmp[1] = (uint16_t) bits_get_bit_count(b, 8, rc);
+	val = (tmp[0] << 8) | tmp[1];
+	return val;
+}
+
+
+uint32_t bits_get_be24(BITSTREAM * b, int8_t *rc)
+{
+	uint32_t val;
+	uint32_t tmp[2];
+
+	tmp[0] = bits_get_be16(b, rc);
+	tmp[1] = (uint16_t) bits_get_bit_count(b, 8, rc);
+	val = (tmp[0] << 16) | tmp[1];
+	return val;
+}
+
+uint32_t bits_get_be32(BITSTREAM * b, int8_t *rc)
+{
+	uint32_t val;
+	uint32_t tmp[2];
+
+	tmp[0] = (uint32_t) bits_get_be16(b, rc);
+	tmp[1] = (uint32_t) bits_get_be16(b, rc);
+	val = (tmp[0] << 16) | tmp[1];
+	return val;
+}
+
+void bits_align_8(BITSTREAM * b, int8_t *rc)
+{
+	if (b->bit_offset % 8)
+		bits_get_bit_count(b, (((b->bit_offset / 8 ) + 1) * 8) - b->bit_offset, rc);
+}
+
+
+
+uint8_t bits_invert_byte(uint8_t b)
+{
+	uint8_t c = 0;
+	c |= (0x80 & b) >> 7;
+	c |= (0x40 & b) >> 5;
+	c |= (0x20 & b) >> 3;
+	c |= (0x10 & b) >> 1;
+
+	c |= (0x8 & b) << 1;
+	c |= (0x4 & b) << 3;
+	c |= (0x2 & b) << 5;
+	c |= (0x1 & b) << 7;
+
+	return c;
+
+}
+
+
+#ifdef _MAIN_
+
+int main(int argc, char *argv[])
+{
+	return 0;
+}
+#endif
+
diff -Naur stream.org/etp/bitstream.h stream/etp/bitstream.h
--- stream.org/etp/bitstream.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/bitstream.h	2013-09-02 01:18:17.905198136 -0400
@@ -0,0 +1,38 @@
+#ifndef __BITSTREAM_STUFF
+#define __BITSTREAM_STUFF
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+#include <stdint.h>
+
+struct bitstream_Struct
+{
+	uint32_t len;
+	uint8_t * stream;
+	uint32_t bit_offset;
+};
+typedef struct bitstream_Struct BITSTREAM;
+
+BITSTREAM * bits_create(uint8_t *, uint32_t);
+int8_t bits_reset(BITSTREAM *);
+int8_t bits_get_next_bit(BITSTREAM *);
+uint64_t bits_get_bit_count(BITSTREAM *, uint32_t, int8_t *);
+int8_t bits_peek_next_bit(BITSTREAM *);
+uint64_t bits_peek_bit_count(BITSTREAM *, uint32_t, int8_t *);
+uint64_t bits_get_ue_golomb(BITSTREAM *, int8_t *);
+int64_t bits_get_se_golomb(BITSTREAM *, int8_t *);
+void bits_align_8(BITSTREAM *, int8_t *);
+uint8_t bits_invert_byte(uint8_t);
+uint32_t bits_get_be32(BITSTREAM *, int8_t *);
+uint32_t bits_get_be24(BITSTREAM *, int8_t *);
+uint16_t bits_get_be16(BITSTREAM *, int8_t *);
+BITSTREAM * bits_create_put(uint8_t *, uint32_t);
+
+#ifdef __cplusplus
+    }
+#endif
+
+
+#endif
diff -Naur stream.org/etp/mpegts.c stream/etp/mpegts.c
--- stream.org/etp/mpegts.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/mpegts.c	2013-09-02 01:18:17.905198136 -0400
@@ -0,0 +1,1422 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <math.h>
+#include <memory.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <time.h>
+#include <stdarg.h>
+
+#include "mpegts.h"
+//#include "mpegts_io.h"
+#include "bitstream.h"
+#include "utils.h"
+//#include "fastmemcpy.h"
+
+#define MPEGTS_SECTION_LEN_PLUS_CRC		9
+#define MPEGTS_SECTION_LEN_MAX			1023 // Maximum a 10 bit value can be
+
+int mpegts_verbose_mode = 0;
+
+
+//***************/
+
+int8_t _mpegts_output_write_section(MPEGTS_SECTION *, uint8_t *, uint8_t *, uint8_t);
+uint16_t _mpegts_pmt_add_program(MPEGTS_MAP_ES *, uint8_t *, uint16_t);
+int8_t mpegts_write_pat(MPEGTS_NEWPAT_STRUCT *);
+int8_t mpegts_write_pmt(MPEGTS_NEWPMT_STRUCT *);
+void mpegts_output_writepts(uint8_t *, uint64_t, uint8_t);
+void (*mpegts_printf_redir)(void *, const char *format, va_list ap);
+
+
+//***************/
+
+void mpegts_debug_printf(void * extra, const char *format, ...)
+{
+	if (mpegts_printf_redir)
+	{
+		va_list ap;
+		va_start(ap, format);
+		(*mpegts_printf_redir)(extra, format, ap);
+		va_end(ap);
+	}
+}
+
+MPEGTS_PACKET * mpegts_parse_packet(BITSTREAM *bitstream)
+{
+	MPEGTS_PACKET * ret = calloc(1, sizeof(MPEGTS_PACKET));
+
+	if (ret)
+	{
+		int8_t rc = 0;
+		ret->type = -1;
+		ret->sync_byte = bits_get_bit_count(bitstream, 8, &rc);
+		if (ret->sync_byte != TS_SYNC_BYTE)
+		{
+			mpegts_debug_printf(NULL, "[MPEGTS] No Sync Byte, invalid MPEG-TS\n");
+			free(ret);
+			return NULL;
+		}
+
+		ret->ts_error = bits_get_next_bit(bitstream);
+		if (ret->ts_error)
+		{
+			if (mpegts_verbose_mode >= 2)
+				mpegts_debug_printf(NULL, "[MPEGTS] TS_ERROR is set, bad packet\n");
+			free(ret);
+			return NULL;
+		}
+
+		ret->payload_start = bits_get_next_bit(bitstream);
+		ret->ts_priority = bits_get_next_bit(bitstream);
+		ret->pid = (uint16_t) bits_get_bit_count(bitstream, 13, &rc);
+		ret->ts_scrambling = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+		ret->adapt_field_control = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+		ret->cont_counter = (uint8_t) bits_get_bit_count(bitstream, 4, &rc);
+
+
+		ret->packet_data = bitstream->stream;
+		ret->packet_data_size = bitstream->len;
+
+		if (mpegts_verbose_mode >= 1)
+		{
+			mpegts_debug_printf(NULL, "[MPEGTS] PID: %d (%x)\n", ret->pid, ret->pid);
+			mpegts_debug_printf(NULL, "[MPEGTS] payload_start: %d, cont_count: %d\n", ret->payload_start, ret->cont_counter);
+		}
+	}
+	return ret;
+}
+
+MPEGTS_PACKET * mpegts_parse_packet2(BITSTREAM *bitstream, uint16_t pmt_pid)
+{
+	MPEGTS_PACKET *packet = mpegts_parse_packet(bitstream);
+
+	if (packet)
+	{
+		if (packet->adapt_field_control ==  ADAPT_FIELD_ONLY_NO_PAYLOAD || packet->adapt_field_control ==  ADAPT_FIELD_AND_PAYLOAD )
+		{
+//			mpegts_debug_printf(NULL, "parsing af...\n");
+			packet->adaptation_field = mpegts_parse_adaptation_field(bitstream);
+		}
+
+		if (packet->payload_start)
+		{
+//			mpegts_debug_printf(NULL, "HMM: 0x%x 0x%x 0x%x 0x%x\n", bitstream->stream[(bitstream->bit_offset/8)], bitstream->stream[(bitstream->bit_offset/8)+1], bitstream->stream[(bitstream->bit_offset/8)+2], bitstream->stream[(bitstream->bit_offset/8)+3]);
+			if (bitstream->stream[bitstream->bit_offset/8] == 0x00)
+			{
+				if (packet->pid == 0)
+				{
+					packet->type = TID_PAT;
+					packet->pat = mpegts_parse_pat(bitstream);
+				}
+				if (pmt_pid && packet->pid == pmt_pid)
+				{
+					packet->type = TID_PMT;
+					packet->pmt = mpegts_parse_pmt(bitstream, packet->payload_start);
+				}
+				else if (bitstream->stream[(bitstream->bit_offset/8)+1] == 0x00 && bitstream->stream[(bitstream->bit_offset/8)+2] == 0x01)
+				{
+					uint32_t i = 0;
+					int8_t type = bitstream->stream[(bitstream->bit_offset/8)+3] & 0xFF;
+
+					packet->payload_start_struct = mpegts_parse_payload_start(bitstream);
+				}
+				else if (bitstream->stream[(bitstream->bit_offset/8)+1] == TID_PMT)
+				{
+					packet->type = TID_PMT;
+				}
+				else
+				{
+				}
+			}
+		}
+	}
+//	else
+//		mpegts_debug_printf(NULL, "mpegts_parse_packet2 failed\n");
+
+	return packet;
+}
+
+
+void mpegts_print_adaptation_field(MPEGTS_ADAPTATION_FIELD *af)
+{
+	if (af)
+	{
+		mpegts_debug_printf(NULL, "[MPEGTS] Printing Adaptation Field, Len: %d\n", af->adaptation_field_length);
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->discontinuity: %d\n", af->discontinuity);
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->random_access: %d\n", af->random_access);
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->es_prio: %d\n", af->es_prio);
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->pcr_flag: %d\n", af->pcr_flag);
+		if (af->pcr_flag)
+		{
+			mpegts_debug_printf(NULL, "[MPEGTS]     ->pcr_base: %" PRId64 "\n", af->pcr_base);
+			mpegts_debug_printf(NULL, "[MPEGTS]     ->pcr_reserved: %d\n", af->pcr_reserved);
+			mpegts_debug_printf(NULL, "[MPEGTS]     ->pcr_ext: %d\n", af->pcr_ext);
+		}
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->opcr_flag: %d\n", af->opcr_flag);
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->splice_flag: %d\n", af->splice_flag);
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->ts_private_flag: %d\n", af->ts_private_flag);
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->field_ext_flag: %d\n", af->field_ext_flag);
+		mpegts_debug_printf(NULL, "[MPEGTS]  ->random_access: %d\n", af->random_access);
+
+	}
+}
+
+MPEGTS_ADAPTATION_FIELD * mpegts_parse_adaptation_field(BITSTREAM *bitstream)
+{
+	MPEGTS_ADAPTATION_FIELD *tmp = NULL;
+
+	if (bitstream)
+	{
+		tmp = calloc(1, sizeof(MPEGTS_ADAPTATION_FIELD));
+		if (tmp)
+		{
+			int8_t rc = 0;
+
+//			memset(tmp, 0, sizeof(MPEGTS_ADAPTATION_FIELD));
+
+			tmp->adaptation_field_length = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+//			mpegts_debug_printf(NULL, "----- AF LEN: %d\n", tmp->adaptation_field_length);
+			if (tmp->adaptation_field_length > 0)
+			{
+				uint32_t start = bitstream->bit_offset;
+
+				tmp->discontinuity = bits_get_next_bit(bitstream);
+				tmp->random_access = bits_get_next_bit(bitstream);
+				tmp->es_prio = bits_get_next_bit(bitstream);
+				tmp->pcr_flag = bits_get_next_bit(bitstream);
+				tmp->opcr_flag = bits_get_next_bit(bitstream);
+				tmp->splice_flag = bits_get_next_bit(bitstream);
+				tmp->ts_private_flag = bits_get_next_bit(bitstream);
+				tmp->field_ext_flag = bits_get_next_bit(bitstream);
+
+				if (tmp->random_access && mpegts_verbose_mode >= 1)
+					mpegts_debug_printf(NULL, "GOP\n");
+
+				if (tmp->pcr_flag)
+				{
+					tmp->pcr_base = (uint64_t) bits_get_bit_count(bitstream, 33, &rc);
+					tmp->pcr_reserved = (uint8_t) bits_get_bit_count(bitstream, 6, &rc);
+					tmp->pcr_ext = (uint16_t) bits_get_bit_count(bitstream, 9, &rc);
+				}
+
+				if (tmp->opcr_flag)
+				{
+					tmp->opcr_base = (uint64_t) bits_get_bit_count(bitstream, 33, &rc);
+					tmp->opcr_reserved = (uint8_t) bits_get_bit_count(bitstream, 6, &rc);
+					tmp->opcr_ext = (uint16_t) bits_get_bit_count(bitstream, 9, &rc);
+				}
+
+				if (tmp->splice_flag)
+					bits_get_bit_count(bitstream, 8, &rc);
+
+				if (tmp->ts_private_flag)
+				{
+					tmp->transport_private_data_length = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+
+					if (tmp->transport_private_data_length > 0)
+					{
+						bits_get_bit_count(bitstream, BYTE_SIZE * tmp->transport_private_data_length, &rc);
+					}
+				}
+
+				if (tmp->field_ext_flag )
+				{
+					mpegts_debug_printf(NULL, "[MPEGTS] ERROR! We don't implement the adaptation field ext parsing, this is broke\n");
+				}
+				if ((bitstream->bit_offset - start) % BYTE_SIZE != 0)
+				{
+					mpegts_debug_printf(NULL, "[MPEGTS] BIG PROBLEMS!\n");
+					return NULL;
+				}
+				else
+				{
+					tmp->stuffing_bytes = tmp->adaptation_field_length - ((bitstream->bit_offset - start) / 8);
+
+					if (tmp->stuffing_bytes)
+					{
+						int q;
+						uint8_t skip;
+
+						for (q = 0; q < tmp->stuffing_bytes; q++)
+						{
+							skip = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+							if (skip != MPEGTS_STUFF_BYTE)
+							{
+//								mpegts_debug_printf(NULL, "[MPEGTS] Error skipping stuffing byte: %x\n", skip);
+								//return NULL;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	return tmp;
+}
+
+void mpegts_print_pat(MPEGTS_PAT *pat)
+{
+	if (pat)
+	{
+		MPEGTS_PAT_PROGRAM_STRUCT *t =  pat->first_program;
+		uint8_t program_count = 1;
+		mpegts_debug_printf(NULL, "[MPEGTS] Printing PAT..\n");
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->table_id: %d\n", pat->table_id);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->section_syntax_indicator: %d\n", pat->section_syntax_indicator);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->zero: %d\n", pat->zero);
+//        mpegts_debug_printf(NULL, "[MPEGTS]   ->reserved1 (should be 3): %d\n", pat->reserved1);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->section_length: %d\n", pat->section_length);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->transport_stream_id: %d\n", pat->transport_stream_id);
+//        mpegts_debug_printf(NULL, "[MPEGTS]   ->reserved2 (should be 3): %d\n", pat->reserved2);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->version_number: %d\n", pat->version_number);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->current_next_indicator: %d\n", pat->current_next_indicator);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->section_number: %d\n", pat->section_number);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->last_section_number: %d\n", pat->last_section_number);
+		mpegts_debug_printf(NULL, "[MPEGTS]   There are %d program(s) in the PAT\n", pat->program_count);
+
+		while (t)
+		{
+			mpegts_debug_printf(NULL, "[MPEGTS]   (%d) ->program_number/service_id: %d\n", program_count, t->program_number);
+//            mpegts_debug_printf(NULL, "[MPEGTS]   (%d) ->reserved: %d\n", program_count, t->reserved);
+			if (t->program_number)
+				mpegts_debug_printf(NULL, "[MPEGTS]   (%d) ->pid: %d (0x%X) -- PMT PID\n", program_count, t->pid, t->pid);
+			else
+				mpegts_debug_printf(NULL, "[MPEGTS]   (%d) ->pid: %d (0x%X) -- NIT PID\n", program_count, t->pid, t->pid);
+
+			t = t->next;
+			program_count++;
+		}
+	}
+}
+
+MPEGTS_PAT * mpegts_parse_pat(BITSTREAM *bitstream)
+{
+	MPEGTS_PAT * ret = NULL;
+	if (bitstream)
+	{
+		int8_t rc = 0;
+		uint8_t pointer = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+		if (pointer != 0)
+			mpegts_debug_printf(NULL, "POINTER: %d\n", pointer);
+		if (pointer == 0)
+		{
+			int i;
+			ret = calloc(1, sizeof(MPEGTS_PAT));
+
+			if (ret)
+			{
+//				memset((void*)ret, 0, sizeof(MPEGTS_PAT));
+
+				ret->table_id = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+				ret->section_syntax_indicator = bits_get_next_bit(bitstream);
+				ret->zero = bits_get_next_bit(bitstream);
+				ret->reserved1 =  (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+				ret->section_length =  (uint16_t) bits_get_bit_count(bitstream, 12, &rc);
+				ret->transport_stream_id =  (uint16_t) bits_get_bit_count(bitstream, 16, &rc);
+				ret->reserved2 = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+				ret->version_number = (uint8_t) bits_get_bit_count(bitstream, 5, &rc);
+				ret->current_next_indicator = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+				ret->section_number = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+				ret->last_section_number = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+
+//				mpegts_debug_printf(NULL, "pat, sec_len: %d - %d\n", ret->section_length, PAT_BYTES_AFTER_SECTION_LEN);
+				for (i = 0; i < (ret->section_length - PAT_BYTES_AFTER_SECTION_LEN - CRC_LENGTH) / PAT_PROGRAM_LENGTH; i++)
+				{
+					MPEGTS_PAT_PROGRAM_STRUCT *t = calloc(1, sizeof(MPEGTS_PAT_PROGRAM_STRUCT));
+//					memset((void*)t, 0, sizeof(MPEGTS_PAT_PROGRAM_STRUCT));
+
+					t->program_number = (uint16_t) bits_get_bit_count(bitstream, 16, &rc);
+					t->reserved = (uint8_t) bits_get_bit_count(bitstream, 3, &rc);
+
+					t->pid = (uint16_t) bits_get_bit_count(bitstream, 13, &rc);
+
+					if (!ret->first_program)
+					{
+						ret->first_program = ret->current_program = t;
+					}
+					else
+					{
+						ret->current_program->next = t;
+						ret->current_program = ret->current_program->next;
+					}
+					ret->program_count++;
+//					mpegts_debug_printf(NULL, "[MPEGTS] PAT, Adding Program/Network PID: %d (0x%X) -- Count: %d\n",t->pid, t->pid, ret->program_count);
+				}
+			}
+		}
+		else
+			mpegts_debug_printf(NULL, "[MPEGTS] We encountered a PAT PID, but the pointer field is non-zero.. it's bad\n");
+	}
+	return ret;
+}
+
+int8_t _mpegts_output_write_section(MPEGTS_SECTION *sec, uint8_t *data, uint8_t *ts_header, uint8_t ts_header_len)
+{
+	if (sec && sec->section_data)
+	{
+		uint16_t section_len = MPEGTS_SECTION_LEN_PLUS_CRC + sec->section_len;
+		uint8_t packet[MPEGTS_SECTION_LEN_MAX + section_len + 12];
+		uint32_t i = 0, j, crc = 0;
+
+		if (section_len > MPEGTS_SECTION_LEN_MAX)
+		{
+			mpegts_debug_printf(NULL, "[MPEGTS] Section Length is too big: %d, Max: %d\n", section_len, MPEGTS_SECTION_LEN_MAX);
+			return -1;
+		}
+
+		packet[i++] = sec->table_id;
+		packet[i++] = 0xB0 | (section_len >> 8); // 0xB0 = 1 0 11 00 00 in binary
+		packet[i++] = section_len & 0xFF;        // Rest of the section length
+		packet[i++] = sec->ts_id >> 8;           // PID: PAT = 0, PMT = Variable
+		packet[i++] = sec->ts_id & 0xFF;
+
+//		tmp = sec->version_number << 1;
+//		tmp1 = 0xC1 | tmp;
+		packet[i++] = 0xC1 | (sec->version_number << 1);                      // 0xC1 = 11 00000 1 in binary
+//		mpegts_debug_printf(NULL, "HMM: %x\n",  packet[i-1]);
+		packet[i++] = 0;                         // section  number
+		packet[i++] = 0;                         // last section number
+
+		for (j = 0; j < sec->section_len; j++)
+			packet[i++] = sec->section_data[j];
+
+		crc = crc32(packet, i);
+
+		packet[i++] = (crc >> 24) & 0xFF;
+		packet[i++] = (crc >> 16) & 0xFF;
+		packet[i++] = (crc >> 8) & 0xFF;
+		packet[i++] = crc & 0xFF;
+
+		if (data)
+		{
+			int j = 0;
+			memset(data, 0xFF, TS_PACKET_SIZE);
+			if (ts_header && ts_header_len)
+				memcpy(data, ts_header, ts_header_len);
+			memcpy(data + ts_header_len, packet, i);
+		}
+//		mpegts_output_packetize(program, packet, i, 1, 0, 0, 0);
+	}
+	return 0;
+}
+
+uint16_t _mpegts_pmt_add_program(MPEGTS_MAP_ES * program, uint8_t *packet, uint16_t i)
+{
+	int k;
+
+	packet[i++] = program->stream_type;
+
+	packet[i++] = 0xE0 | ((program->pid >> 8) & 0x1F);
+	packet[i++] = (program->pid & 0xFF);
+
+	packet[i++] = 0xF0 | (program->info_len >> 8);
+	packet[i++] = program->info_len & 0xFF;
+	for (k = 0; k < program->info_len; k++)
+	{
+		packet[i++] = program->descriptor[k];
+	}
+	return i;
+}
+
+int8_t mpegts_write_pmt(MPEGTS_NEWPMT_STRUCT *pmt)
+{
+	int8_t ret = 1;
+	if (pmt)
+	{
+		uint8_t packet[MPEGTS_SECTION_LEN_MAX + TS_PACKET_SIZE] = {0};
+		uint16_t i = 0, j = 0;
+		MPEGTS_SECTION section = {0};
+		MPEGTS_MAP_ES * tmp_es = pmt->desc_es;
+
+		section.table_id = TID_PMT;
+		section.ts_id = pmt->program_number;
+//		mpegts_debug_printf(NULL, "PMT Program Num: %d\n", pmt->program_number);
+		//PCR
+		packet[i++] = 0xE0 | ((pmt->pcr_pid >> 8) & 0x1F);
+		packet[i++] = pmt->pcr_pid & 0xFF;
+
+		//PMT Descriptor, there shouldn't be one (len = 0)
+		packet[i++] = 0xF0 | (pmt->program_descriptor_len >> 8);
+		packet[i++] = pmt->program_descriptor_len & 0xFF;
+//		mpegts_debug_printf(NULL, "desc len: %d\n", pmt->program_descriptor_len);
+		if (pmt->program_descriptor_len)
+		{
+			for (j = 0; j < pmt->program_descriptor_len; j++)
+				packet[i++] =pmt->program_descriptor[j];
+		}
+
+		while (tmp_es)
+		{
+//			mpegts_debug_printf(NULL, "Adding, PID: %d\n", tmp_es->pid);
+			i = _mpegts_pmt_add_program(tmp_es, packet, i);
+			tmp_es = tmp_es->next;
+		}
+
+		section.section_data = packet;
+		section.section_len = i;
+
+		_mpegts_output_write_section(&section, pmt->new_pmt_data, pmt->ts_header, pmt->ts_header_len);
+
+		ret = 0;
+	}
+	return ret;
+}
+
+int8_t mpegts_write_pat(MPEGTS_NEWPAT_STRUCT *pat)
+{
+	int8_t ret = 1;
+
+	if (pat)
+	{
+		uint8_t packet[4] = {0};
+		uint16_t i = 0;
+		MPEGTS_SECTION section = {0};
+
+		section.table_id = TID_PAT;
+		section.ts_id = pat->ts_id;
+		section.version_number = pat->version;
+
+//		mpegts_debug_printf(NULL, "Program Num: %d, PMT_PID: %d\n", pat->program_num, pat->pmt_pid);
+		packet[i++] = pat->program_num >> 8;
+ 		packet[i++] = pat->program_num & 0xFF;
+
+		packet[i++] = 0xE0 | ((pat->pmt_pid >> 8) & 0x1F);
+		packet[i++] = pat->pmt_pid & 0xFF;
+
+		section.section_data = packet;
+		section.section_len = i;
+
+		_mpegts_output_write_section(&section, pat->new_pat_data, pat->ts_header, pat->ts_header_len);
+
+		ret = 0;
+	}
+	return ret;
+}
+
+void mpegts_free_packet(MPEGTS_PACKET *p)
+{
+	if (p)
+	{
+		if (p->adaptation_field)
+			free(p->adaptation_field);
+
+		if (p->payload_start_struct)
+			free(p->payload_start_struct);
+
+		if (p->pat)
+			mpegts_free_pat(p->pat);
+
+		if (p->pmt)
+			mpegts_free_pmt(p->pmt);
+
+		free(p);
+	}
+}
+
+
+MPEGTS_PAT *mpegts_dup_pat(MPEGTS_PAT *pat)
+{
+	MPEGTS_PAT * ret = NULL;
+	if (pat)
+	{
+		ret = calloc(1, sizeof(MPEGTS_PAT));
+		if (ret)
+		{
+			MPEGTS_PAT_PROGRAM_STRUCT *t = pat->first_program;
+			while (t)
+			{
+				MPEGTS_PAT_PROGRAM_STRUCT * pat_pgm = calloc(1, sizeof(MPEGTS_PAT_PROGRAM_STRUCT));
+				if (pat_pgm)
+				{
+					memcpy(pat_pgm, t, sizeof(MPEGTS_PAT_PROGRAM_STRUCT));
+
+					if (!ret->first_program)
+					{
+						ret->first_program = ret->current_program = pat_pgm;
+					}
+					else
+					{
+						ret->current_program->next = pat_pgm;
+						ret->current_program = pat_pgm;
+					}
+				}
+
+				t = t->next;
+			}
+		}
+	}
+
+	return ret;
+}
+void mpegts_free_pat(MPEGTS_PAT *pat)
+{
+	if (pat)
+	{
+		MPEGTS_PAT_PROGRAM_STRUCT *t = pat->first_program;
+		MPEGTS_PAT_PROGRAM_STRUCT *del = NULL;
+		while (t)
+		{
+			del = t;
+			t = t->next;
+			free(del);
+		}
+		free(pat);
+	}
+}
+
+void mpegts_free_pmt(MPEGTS_PMT * pmt)
+{
+	if (pmt)
+	{
+		MPEGTS_MAP_ES * t = pmt->first_es;
+		MPEGTS_MAP_ES * del = NULL;
+
+		while (t)
+		{
+			del = t;
+			t = t->next;
+			free(del);
+		}
+
+		free(pmt);
+	}
+
+	return;
+}
+
+void mpegts_print_pmt(MPEGTS_PMT *pmt)
+{
+	if (pmt)
+	{
+		int i;
+		MPEGTS_MAP_ES * t = pmt->first_es;
+		uint8_t program_count = 1;
+
+		mpegts_debug_printf(NULL, "[MPEGTS] Printing PMT..\n");
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->table_id: %d\n", pmt->table_id);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->section_syntax_indicator: %d\n", pmt->section_syntax_indicator);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->zero: %d\n", pmt->zero);
+
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->section_length: %d\n", pmt->section_length);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->program_number: %d\n", pmt->program_number);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->version_number: %d\n", pmt->version_number);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->current_next_indicator: %d\n", pmt->current_next_indicator);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->section_number: %d\n", pmt->section_number);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->last_section_number: %d\n", pmt->last_section_number);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->pcr_pid: %d\n", pmt->pcr_pid);
+		mpegts_debug_printf(NULL, "[MPEGTS]   ->program_info_length: %d\n", pmt->program_info_length);
+		mpegts_debug_printf(NULL, "[MPEGTS]   There are %d program(s) in the PMT\n", pmt->es_count);
+
+		while (t)
+		{
+			mpegts_debug_printf(NULL, "[MPEGTS]   (%d) ->stream_type: %d (0x%X)\n", program_count, t->stream_type, t->stream_type);
+			mpegts_debug_printf(NULL, "[MPEGTS]   (%d) ->pid: %d (0x%X)\n", program_count, t->pid, t->pid);
+			mpegts_debug_printf(NULL, "[MPEGTS]   (%d) ->info_len: %d\n", program_count, t->info_len);
+			for(i=0; i < t->info_len; i++)
+				if (isprint(t->descriptor[i]))
+					mpegts_debug_printf(NULL, "%c", t->descriptor[i]);
+				else
+					mpegts_debug_printf(NULL, ".");
+			mpegts_debug_printf(NULL, "\n");
+			t = t->next;
+			program_count++;
+		}
+
+	}
+}
+
+MPEGTS_PMT * mpegts_parse_pmt(BITSTREAM *bitstream, uint8_t payload_start)
+{
+	MPEGTS_PMT * pmt = NULL;
+
+	if (bitstream)
+	{
+		int8_t rc = 0;
+		uint8_t pointer = 0;
+
+		if (payload_start)
+		{
+			pointer = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+//            mpegts_debug_printf(NULL, "Pointer Field: %d\n", pointer);
+			if (pointer)
+				bits_get_bit_count(bitstream, pointer * 8, &rc);
+		}
+
+//        if (packet->pointer_field == 0)
+		{
+			int32_t tmp_len = 0;
+
+			pmt = calloc(1, sizeof(MPEGTS_PMT));
+
+			if (pmt)
+			{
+				int k;
+
+				pmt->table_id = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+
+				if (pmt->table_id != TID_PMT)
+				{
+					if (mpegts_verbose_mode >= 1)
+						mpegts_debug_printf(NULL, "[TS] PMT, TableID, 0x%x != 0x%x\n", pmt->table_id, TID_PMT);
+					free(pmt);
+					return NULL;
+				}
+				else if (mpegts_verbose_mode >= 1)
+				{
+					mpegts_debug_printf(NULL, "[TS] PMT, TableID is good (0x%x)\n", pmt->table_id);
+				}
+
+				pmt->section_syntax_indicator = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);;
+				pmt->zero = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+				pmt->reserved1 = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+				tmp_len = pmt->section_length = (uint16_t) bits_get_bit_count(bitstream, 12, &rc);
+				pmt->program_number = (uint16_t) bits_get_bit_count(bitstream, 16, &rc);
+				pmt->reserved2 = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+				pmt->version_number = (uint8_t) bits_get_bit_count(bitstream, 5, &rc);
+
+
+				pmt->current_next_indicator = bits_get_next_bit(bitstream);
+				pmt->section_number = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+				pmt->last_section_number = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+				pmt->reserved3 = (uint8_t) bits_get_bit_count(bitstream, 3, &rc);
+				pmt->pcr_pid = (uint16_t) bits_get_bit_count(bitstream, 13, &rc);
+				pmt->reserved4 = (uint8_t) bits_get_bit_count(bitstream, 4, &rc);
+				pmt->program_info_length = (uint16_t) bits_get_bit_count(bitstream, 12, &rc);
+
+				if (mpegts_verbose_mode >= 1)
+					mpegts_debug_printf(NULL, "[TS] PMT, PCR PID: %d\n", pmt->pcr_pid);
+
+				if (pmt->program_info_length)
+				{
+					pmt->program_info_data = calloc(1, pmt->program_info_length);
+					for (k = 0; k < pmt->program_info_length; k++)
+					{
+						pmt->program_info_data[k] = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+					}
+				}
+
+				tmp_len -= (pmt->program_info_length + CRC_LENGTH + PMT_BYTES_AFTER_SECTION_LEN); // Bytes left to process which are es_info's
+
+//                mpegts_debug_printf(NULL, "PMT, tmp_len2: %d (%d)\n", tmp_len, PMT_CONST_LENGTH);
+				while (tmp_len > 0)
+				{
+					MPEGTS_MAP_ES * es_info = calloc(1, sizeof(MPEGTS_MAP_ES));
+//	                mpegts_debug_printf(NULL, "PMT, tmp_len1: %d\n", tmp_len);
+
+					es_info->stream_type = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+					es_info->reserved1 =  (uint8_t) bits_get_bit_count(bitstream, 3, &rc);
+					es_info->pid = (uint16_t) bits_get_bit_count(bitstream, 13, &rc);
+					es_info->reserved1 = (uint8_t) bits_get_bit_count(bitstream, 4, &rc);
+					es_info->info_len = (uint16_t) bits_get_bit_count(bitstream, 12, &rc);
+
+//	                mpegts_debug_printf(NULL, "PMT, stream_type: 0x%x (%d), pid: 0x%x (%d), info_len: %d\n",  es_info->stream_type, es_info->stream_type, es_info->pid, es_info->pid, es_info->info_len);
+					if (es_info->info_len)
+					{
+						int i;
+						if (es_info->info_len > tmp_len)
+						{
+							mpegts_debug_printf(NULL, "BIG FREAKING ERROR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+							free(es_info);
+							break;
+						}
+						es_info->descriptor = (uint8_t*) calloc(1, es_info->info_len);
+						for (i = 0; i < es_info->info_len; i++)
+							es_info->descriptor[i] = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+					}
+
+					tmp_len -= (PMT_PROGRAM_LENGTH + es_info->info_len);
+//	                mpegts_debug_printf(NULL, "PMT, tmp_len1: %d\n", tmp_len);
+
+					if (pmt->first_es == NULL)
+					{
+						pmt->current_es = pmt->first_es = es_info;
+					}
+					else
+					{
+						pmt->current_es->next = es_info;
+						pmt->current_es = pmt->current_es->next;
+					}
+					pmt->es_count++;
+				}
+			}
+		}
+	}
+	return pmt;
+}
+
+uint64_t mpegts_parse_pts(BITSTREAM *bitstream)
+{
+    uint64_t pts_tmp = 0;
+    uint64_t ret = 0;
+    int8_t rc = 0;
+
+    pts_tmp = (uint64_t) bits_get_bit_count(bitstream, 3, &rc);
+
+    if (bits_get_next_bit(bitstream) != 1)
+        mpegts_debug_printf(NULL, "[TS] PTS or DTS ERROR! First Marker is not 1\n");
+
+    ret = (pts_tmp << 30);
+
+    pts_tmp = (uint64_t) bits_get_bit_count(bitstream, 15, &rc);
+
+    if (bits_get_next_bit(bitstream) != 1)
+        mpegts_debug_printf(NULL, "[TS] PTS_ONLY ERROR! Second Marker is not 1\n");
+
+    ret |= (pts_tmp << 15);
+
+    pts_tmp = (uint64_t) bits_get_bit_count(bitstream, 15, &rc);
+
+    if (bits_get_next_bit(bitstream) != 1)
+        mpegts_debug_printf(NULL, "[TS] PTS_ONLY ERROR! Third Marker is not 1\n");
+
+    ret |= (pts_tmp);
+
+    return ret;
+}
+
+MPEGTS_PAYLOAD_START * mpegts_parse_payload_start(BITSTREAM *bitstream)
+{
+    MPEGTS_PAYLOAD_START *p = NULL;
+    if (bitstream)
+    {
+        p = calloc(1, sizeof(MPEGTS_PAYLOAD_START));
+        if (p)
+        {
+            int8_t rc = 0;
+            uint8_t start = 0;
+//			memset(p, 0, sizeof(MPEGTS_PAYLOAD_START));
+/*
+			mpegts_debug_printf(NULL, "[0x%x 0x%x 0x%x 0x%x]\n", bitstream->stream[bitstream->bit_offset/8],
+												bitstream->stream[(bitstream->bit_offset/8)+1],
+												bitstream->stream[(bitstream->bit_offset/8)+2],
+												bitstream->stream[(bitstream->bit_offset/8)+3]);
+*/
+            p->start_code = (uint32_t) bits_get_bit_count(bitstream, 24, &rc);
+            if (p->start_code != 0x1)
+            {
+                free(p);
+//                if (mpegts_verbose_mode >= 1)
+//				mpegts_debug_printf(NULL, "[TS] Payload Start was indicated but start code does not match, broken TS\n");
+//				mpegts_debug_printf(NULL, "[0x%x 0x%x 0x%x 0x%x]\n", bitstream->stream[0], bitstream->stream[1], bitstream->stream[2], bitstream->stream[3]);
+//				mpegts_debug_printf(NULL, "[0x%x 0x%x 0x%x 0x%x]\n", bitstream->stream[4], bitstream->stream[5], bitstream->stream[6], bitstream->stream[7]);
+//				mpegts_debug_printf(NULL, "[0x%x 0x%x 0x%x 0x%x]\n", bitstream->stream[8], bitstream->stream[9], bitstream->stream[10], bitstream->stream[11]);
+                return NULL;
+            }
+
+            p->stream_id = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+            p->len = (uint16_t) bits_get_bit_count(bitstream, 16, &rc);
+            p->one_zero = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+            p->pes_scrambling = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+            p->pes_priority = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->data_alignment = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->copyright = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->original = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->pts_dts_flag = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+            p->escr_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->es_rate_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->dsm_trick_mode_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->additional_copy_info_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->pes_crc_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->pes_extension_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->pes_header_data_len = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+
+//            mpegts_debug_printf(NULL, "pes_len: %d, pes_header_len: %d\n", p->len, p->pes_header_data_len);
+
+            start  = bitstream->bit_offset / BYTE_SIZE;
+
+            switch (p->pts_dts_flag)
+            {
+                case PTS_ONLY :
+                    // '10', next 4 bits should be '0010'
+                    if (bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 1 && bits_get_next_bit(bitstream) == 0 )
+                        p->pts = mpegts_parse_pts(bitstream);
+                    else
+                        mpegts_debug_printf(NULL, "[TS] PTS_ONLY - ERROR - PTS header not correct\n");
+                    break;
+
+                case PTS_AND_DTS :
+                    // '11', next 4 bits should be '0011'
+                    if (bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 1 && bits_get_next_bit(bitstream) == 1 )
+                        p->pts = mpegts_parse_pts(bitstream);
+                    else
+                        mpegts_debug_printf(NULL, "[TS] PTS_AND_DTS - ERROR - PTS header not correct\n");
+
+                    //  next 4 bits should be '0001'
+                    if (bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 1 )
+                        p->dts = mpegts_parse_pts(bitstream);
+                    else
+                        mpegts_debug_printf(NULL, "[TS] PTS_AND_DTS - ERROR - DTS header not correct\n");
+
+
+                    break;
+
+                case NO_PTS : // '00'
+                default:
+//                    mpegts_debug_printf(NULL, "[TS] NO PTS or DTS\n");
+                    break;
+            }
+
+            if (p->escr_flag)
+            {
+                mpegts_debug_printf(NULL, "PES_escr_flag\n");
+                bits_get_bit_count(bitstream, 2 + 3 + 1 + 15 + 1 + 15 + 1 + 9 + 1, &rc);
+            }
+
+            if (p->es_rate_flag)
+            {
+                mpegts_debug_printf(NULL, "PES_es_rate_flag\n");
+                bits_get_bit_count(bitstream, 1 + 22 + 1, &rc);
+            }
+
+            if (p->dsm_trick_mode_flag)
+            {
+                mpegts_debug_printf(NULL, "TRICK MODE -- BROKEN!!!!\n");
+            }
+
+            if (p->additional_copy_info_flag)
+            {
+                mpegts_debug_printf(NULL, "PES_additional copy_info\n");
+
+                bits_get_bit_count(bitstream, 8, &rc);
+            }
+
+            if (p->pes_crc_flag)
+            {
+                mpegts_debug_printf(NULL, "PES_crc\n");
+                bits_get_bit_count(bitstream, 16, &rc);
+            }
+
+            if (p->pes_extension_flag)
+            {
+                mpegts_debug_printf(NULL, "PES_EXT -- BROKEN!!!!\n");
+            }
+
+            if (p->pes_header_data_len)
+            {
+                uint16_t diff = p->pes_header_data_len - (bitstream->bit_offset / BYTE_SIZE - start);
+
+                if (diff)
+                {
+                    uint8_t skip;
+                    int q;
+
+                    for (q = 0; q < diff; q++)
+                    {
+                        skip = (uint8_t) bits_get_bit_count(bitstream, BYTE_SIZE, &rc);
+                        if (skip != MPEGTS_STUFF_BYTE)
+                        {
+                            mpegts_debug_printf(NULL, "[TS] Error skipping stuffing byte in PES header: %x\n", skip);
+                            return NULL;
+                        }
+                    }
+                }
+            }
+
+        }
+    }
+    return p;
+}
+
+void mpegts_output_writepts(uint8_t *data, uint64_t ipts, uint8_t flags)
+{
+	uint32_t i = 0;
+	uint64_t p;
+	ipts = ipts & 0xfffffffffLL; // clip to 36 bits 33 bits *8 before clipping
+	data[i++] = (flags << 4) | (((ipts >> 30) & 0x07) << 1) | 1;
+	p = (((ipts >> 15) & 0x7fff) << 1) | 1;
+	data[i++] = p >> 8;
+	data[i++] = p & 0xff;
+	p = (((ipts) & 0x7fff) << 1) | 1;
+	data[i++] = p >> 8;
+	data[i++] = p & 0xff;
+}
+
+uint8_t mpegts_fix_pat(uint8_t *data, uint32_t len, uint16_t pmt_pid, uint16_t pgm_num)
+{
+	uint8_t ret = 0;
+	if (data && len && pmt_pid && pgm_num)
+	{
+		uint8_t pid = ((data[1] & 0x1F) << 8) | data[2];
+//		uint8_t ps = (data[1] & 0x40) >> 6;
+        uint8_t adapt = (data[3] & 0x30) >> 4;
+
+		if (pid == PAT_PID && data[4] == 0 && (!(adapt == ADAPT_FIELD_ONLY_NO_PAYLOAD || adapt == ADAPT_FIELD_AND_PAYLOAD)))
+		{
+			MPEGTS_NEWPAT_STRUCT *new_pat = NULL;
+			new_pat = calloc(1, sizeof(MPEGTS_NEWPAT_STRUCT));
+
+			if (new_pat)
+			{
+//				mpegts_debug_printf(NULL, "Fixing PAT, cont_count: %d, pgm: %d\n", cc, tuner->org_pmt->program_number);
+				new_pat->ts_header = data;
+				new_pat->ts_header_len = 5;
+				new_pat->program_num = pgm_num;
+				new_pat->pmt_pid = pmt_pid;
+				new_pat->version = (data[10] & 0x3E) >> 1;
+				new_pat->ts_id = (data[8] << 8) | data[9];
+				mpegts_write_pat(new_pat);
+
+				if (new_pat->new_pat_data)
+				{
+//					mpegts_debug_printf(NULL, "HERE1\n");
+					memcpy(data, new_pat->new_pat_data, TS_PACKET_SIZE);
+				}
+
+				free(new_pat);
+			}
+		}
+		else
+		{
+			ret = 1;
+		}
+	}
+	return ret;
+}
+
+
+uint8_t mpegts_fix_pmt(uint8_t *data, uint32_t len,  uint16_t pcr_pid, uint16_t pgm_num, MPEGTS_MAP_ES *desc_es)
+{
+	uint8_t ret = 0;
+
+	if (data && len && desc_es)
+	{
+		MPEGTS_NEWPMT_STRUCT *new_pmt = NULL;
+
+		new_pmt = calloc(1, sizeof(MPEGTS_NEWPMT_STRUCT));
+
+		if (new_pmt)
+		{
+			MPEGTS_MAP_ES *tmp_es = NULL, *del_es = NULL;
+			new_pmt->program_number = pgm_num;
+			new_pmt->pcr_pid = pcr_pid;
+//			mpegts_debug_printf(NULL, "pgm: %d, pcr: %d\n", new_pmt->program_number, new_pmt->pcr_pid);
+//			mpegts_debug_printf(NULL, ".. Start -- PMT\n");
+			while (desc_es)
+			{
+//				mpegts_debug_printf(NULL, "..PID: %d (0x%x) -- %d (0x%x)\n", desc_es->pid, desc_es->pid, desc_es->stream_type, desc_es->stream_type);
+				switch (desc_es->stream_type)
+				{
+					case MPEGTS_STREAM_TYPE_SOMETHING:
+					case MPEGTS_STREAM_TYPE_ISO13818_V: // MPEG2 Video
+					case MPEGTS_STREAM_TYPE_ISO14496_10: // H264 Video
+					case MPEGTS_STREAM_TYPE_ISO13818_3: // MP2 Audio
+					case MPEGTS_STREAM_TYPE_USER_DATA: // AC3 Audio (usually)
+						tmp_es = desc_es;
+					break;
+
+					default:
+						tmp_es = NULL;
+					break;
+				}
+
+				if (tmp_es)
+				{
+					MPEGTS_MAP_ES * newes = calloc(1, sizeof(MPEGTS_MAP_ES));
+//					mpegts_debug_printf(NULL, "BLAH: %d (0x%x)\n", tmp_es->pid, tmp_es->pid);
+
+					if (newes)
+					{
+//						mpegts_debug_printf(NULL, "Adding to PMT, PID: %d, Type: 0x%x (i_len: %d)\n", tmp_es->pid, tmp_es->stream_type, tmp_es->info_len);
+						memcpy(newes, tmp_es, sizeof(MPEGTS_MAP_ES));
+						newes->descriptor = NULL;
+						newes->next = NULL;
+
+						if (tmp_es->info_len)
+						{
+							newes->descriptor = calloc(1, tmp_es->info_len);
+							memcpy(newes->descriptor, tmp_es->descriptor, tmp_es->info_len);
+						}
+
+//						mpegts_debug_printf(NULL, "Adding... %d\n", newes->pid);
+						if (!new_pmt->desc_es)
+						{
+							new_pmt->desc_es = newes;
+//							mpegts_debug_printf(NULL, "HI: %d %d\n", new_pmt->desc_es->pid, new_pmt->desc_es->stream_type);
+						}
+						else
+						{
+							tmp_es = new_pmt->desc_es;
+							while(tmp_es->next)
+								tmp_es = tmp_es->next;
+							tmp_es->next = newes;
+						}
+					}
+				}
+				desc_es = desc_es->next;
+			}
+//			mpegts_debug_printf(NULL, ".. DONE -- PMT\n");
+
+			new_pmt->ts_header = data;
+			new_pmt->ts_header_len = 5;
+
+			mpegts_write_pmt(new_pmt);
+
+			if (new_pmt->new_pmt_data)
+			{
+//					mpegts_debug_printf(NULL, "HERE2\n");
+				memcpy(data, new_pmt->new_pmt_data, TS_PACKET_SIZE);
+			}
+
+			tmp_es = new_pmt->desc_es;
+
+			while (tmp_es)
+			{
+				del_es = tmp_es;
+//				mpegts_debug_printf(NULL, "HERE: %d 0x%x -- len: %d\n", tmp_es->pid, tmp_es->stream_type, tmp_es->info_len);
+				tmp_es = tmp_es->next;
+
+				if (del_es->descriptor)
+					free(del_es->descriptor);
+
+				free(del_es);
+			}
+
+			free(new_pmt);
+		}
+	}
+	return ret;
+}
+
+MPEGTS_PTS_DTS_RESTAMP * mpegts_offset_pts_dts(uint8_t *data, uint32_t len, uint64_t offset, uint16_t pmt_pid)
+{
+	MPEGTS_PTS_DTS_RESTAMP *ret = NULL;
+
+	if (data && len && offset && pmt_pid)
+	{
+		BITSTREAM *bitstream = bits_create(data, len);
+		if (bitstream)
+		{
+			MPEGTS_PACKET * packet = mpegts_parse_packet(bitstream);
+
+			if (packet)
+			{
+				if (packet->adapt_field_control ==  ADAPT_FIELD_ONLY_NO_PAYLOAD || packet->adapt_field_control == ADAPT_FIELD_AND_PAYLOAD)
+					packet->adaptation_field = mpegts_parse_adaptation_field(bitstream);
+
+				if (packet->adapt_field_control == ADAPT_FIELD_AND_PAYLOAD || packet->adapt_field_control == ADAPT_NO_FIELD_ONLY_PAYLOAD)
+				{
+					if (!(packet->pid == PAT_PID || packet->pid == pmt_pid))
+					{
+						uint32_t write_offset = (bitstream->bit_offset/8) + 9;
+						packet->payload_start_struct = mpegts_parse_payload_start(bitstream);
+
+						if (packet->payload_start_struct)
+						{
+							MPEGTS_PAYLOAD_START *pusi = packet->payload_start_struct;
+							uint64_t new_pts = 0, new_dts = 0;
+							uint8_t tmpbits = 0, pts_dts_flags = PTS_ONLY, check_bits = PTS_ONLY;
+
+							if (pusi->pts_dts_flag == PTS_AND_DTS)
+							{
+								check_bits = 0x03;
+								pts_dts_flags = PTS_AND_DTS;
+							}
+
+							tmpbits = (data[write_offset] & 0xF0) >> 4;
+
+							if (tmpbits == check_bits)
+							{
+								uint8_t _tmp1 = 0;
+								ret = calloc(1, sizeof(MPEGTS_PTS_DTS_RESTAMP));
+								ret->org_pts = new_pts = pusi->pts;
+								ret->org_dts = new_dts = pusi->dts;
+
+								if (offset > new_pts)
+								{
+									_tmp1 = 1;
+									new_pts += MAX_33BITS;
+								}
+								new_pts -= offset;
+
+								if (new_dts)
+								{
+									if (offset > new_dts)
+										new_dts += MAX_33BITS;
+									new_dts -= offset;
+								}
+								if (new_pts > offset)
+								{
+									ret->stamp_failed = 1;
+									mpegts_debug_printf(NULL, "[%d] BAD PTS!!!!!!!!!!!!, org: %" PRId64" -- new: %" PRId64" -- off: %" PRId64" (%" PRId64")\n", _tmp1, pusi->pts, new_pts, offset, offset - pusi->pts);
+								}
+
+								if (new_dts && new_dts > offset)
+								{
+									mpegts_debug_printf(NULL, "BAD DTS!!!!!!!!!!!!\n");
+									ret->stamp_failed = 1;
+								}
+
+								if (ret && !ret->stamp_failed)
+								{
+									ret->pts = new_pts;
+									ret->dts = new_dts;
+
+//									mpegts_debug_printf(NULL, "Restamp (pts: %" PRId64", dts: %" PRId64") Off: %" PRId64" (pts: %" PRId64", dts: %" PRId64") \n", pusi->pts, pusi->dts, offset, new_pts, new_dts);
+
+									mpegts_output_writepts(data + write_offset, new_pts, pts_dts_flags);
+
+									if (pts_dts_flags == PTS_AND_DTS)
+										data[write_offset] |= 0x10;
+
+									write_offset += 5;
+
+									if (pts_dts_flags == PTS_AND_DTS)
+									{
+										pts_dts_flags = 0x01;
+										mpegts_output_writepts(data + write_offset, new_dts, pts_dts_flags);
+										write_offset += 5;
+									}
+								}
+
+							}
+						}
+					}
+				}
+				mpegts_free_packet(packet);
+			}
+			free(bitstream);
+		}
+	}
+	else
+	{
+		if (!offset)
+			mpegts_debug_printf(NULL, "[MPEGTS] restamp: offset is 0\n");
+
+		if (!pmt_pid)
+			mpegts_debug_printf(NULL, "[MPEGTS] restamp: but pmt_pid is 0\n");
+	}
+	return ret;
+}
+
+
+uint8_t mpegts_streamtype_valid(uint8_t id)
+{
+	if (id >= MPEGTS_VIDEO_STREAM_START && id <= MPEGTS_VIDEO_STREAM_END)
+		return MPEGTS_TYPE_VIDEO;
+
+	if ((id >= MPEGTS_AUDIO_STREAM_START && id <= MPEGTS_AUDIO_STREAM_END) || (id == MPEGTS_PRIVATE_STREAM1))
+		return MPEGTS_TYPE_AUDIO;
+
+	mpegts_debug_printf(NULL, "HUH?\n");
+	return MPEGTS_TYPE_UNHANDLED;
+}
+
+uint8_t mpegts_is_valid(char *v)
+{
+	uint8_t tmp_buf[1] = {0};
+
+	int mpegts_file_handle = open(v, O_RDONLY);
+
+	if (mpegts_file_handle)
+	{
+		int temp;
+		temp = read(mpegts_file_handle, tmp_buf, sizeof(tmp_buf));
+		close(mpegts_file_handle);
+
+		if (tmp_buf[0] != TS_SYNC_BYTE)
+			return 0;
+//        else
+//            mpegts_debug_printf(NULL, "[TS] First byte is valid\n");
+	}
+	return 1;
+}
+
+/*
+int mpegts_get_ts_packets(int handle, uint8_t *data, uint32_t data_sz, uint32_t packet_count)
+{
+	if (handle && data && data_sz && packet_count)
+	{
+		if (data_sz >= packet_count * TS_PACKET_SIZE)
+		{
+			
+		}
+		else
+		{
+			return -1;
+		}
+	}
+	return -2;
+}
+*/
+//int get_bytes_from_handle(int handle, uint8_t * data, int len, long int s, long int us, uint32_t block)
+
+/*
+int32_t mpegts_need_sync(uint8_t *data, uint32_t data_sz)
+{
+	if (data && data_sz)
+	{
+		int i;
+		for(i=0; i < data_sz; i+= TS_PACKET_SIZE)
+		{
+			if (data[i] != TS_SYNC_BYTE)
+			{
+				int j;
+				for(j=i+1; j < data_sz - TS_PACKET_SIZE; j++)
+				{
+					
+				}
+				return 1;
+			}
+		}
+		return 0;
+	}
+	return -1;
+}
+*/
+
+/*
+int8_t mpegts_get_frametype(uint8_t *data, uin32_t data_size)
+{
+	if (data)
+	{
+		int i;
+		for (i = 0; i < TS_PACKET_SIZE - 5; i++)
+		{
+			if (data[i] == 0x00 && data[i+1] == 0x00 && data[i+2] == 0x01)
+			{
+//					mpegts_debug_printf(NULL, "es_type: 0x%x (%d)\n", tuner->video_es_type, tuner->video_es_type);
+					if (tuner->video_es_type == MPEGTS_STREAM_TYPE_ISO13818_V || tuner->video_es_type == MPEGTS_STREAM_TYPE_SOMETHING)
+//					if (tuner->video_es_type == MPEGTS_STREAM_TYPE_ISO13818_V)
+					{
+//							mpegts_debug_printf(NULL, "MPEG2 Video: 0x%x 0x%x 0x%x 0x%x\n", data[i], data[i+1], data[i+2], data[i+3]);
+							if (data[i+3] == 0xB3)
+							{
+//								mpegts_debug_printf(NULL, "MPEG2 SEQ\n");
+								ret = packet->frame_type = 1;
+								break;
+							}
+							else if (data[i+3] == 0x00)
+							{
+								t_seq = (uint16_t)(data[i+4] << 2) | (data[i+5] >> 6);
+								fr_type = (uint8_t)(data[i+5] & 0x38) >> 3;
+
+//								mpegts_debug_printf(NULL, "MPEG2 FRAME: %s\n", MPEG2_PIC_TYPE[fr_type]);
+								if (fr_type == 1)
+								{
+									ret = packet->frame_type = 1;
+									break;
+								}
+							}
+						}
+						else if (tuner->video_es_type == MPEGTS_STREAM_TYPE_ISO14496_10)
+						{
+							mpegts_debug_printf(NULL, "H264 Video\n");
+						}
+					}
+				}
+
+*/
+#ifdef _MAIN_
+
+
+
+/*
+                            uint16_t _t = MPEGTS_IO_IDX_HEADER;
+                             _mpegts_do_fwrite(fileunit->idx_fhandle, (uint8_t*)&_t, sizeof(_t));
+                             _mpegts_do_fwrite(fileunit->idx_fhandle, (uint8_t*)&_idx->packet_number, sizeof(_idx->packet_number));
+                             _mpegts_do_fwrite(fileunit->idx_fhandle, (uint8_t*)&_idx->pts, sizeof(_idx->pts));
+                             _mpegts_do_fwrite(fileunit->idx_fhandle, (uint8_t*)&_idx->dts, sizeof(_idx->dts));
+*/
+
+
+#define		IDX_BLOCK_SIZE		(TS_PACKET_SIZE * 500)
+
+
+
+
+int main(int argc, char *argv[])
+{
+	if (argc > 1)
+	{
+		char *filename = argv[1];
+		if (mpegts_is_valid(filename))
+		{
+			int fh = open(filename, O_RDONLY);
+
+			mpegts_debug_printf(NULL, "TS is good and valid\n");
+
+			if (fh > 2)
+			{
+				uint8_t *data = malloc(IDX_BLOCK_SIZE);
+				off_t filesize = get_file_size(filename);
+				off_t i, ret;
+				int j;
+
+				uint16_t pid;
+				uint8_t start;
+				uint64_t packet_no = 0, last_pts = 0, p_count = 0;
+
+				mpegts_debug_printf(NULL, "Generate index for file: %s\n", filename);
+
+				for(i = 0; i < filesize; i+= IDX_BLOCK_SIZE)
+				{
+					ret =  read(fh, data, IDX_BLOCK_SIZE);
+					if (ret != IDX_BLOCK_SIZE)
+						mpegts_debug_printf(NULL, "POOP\n");
+
+					for(j=0; j < ret; j+= TS_PACKET_SIZE)
+					{
+						if (data[j] == TS_SYNC_BYTE)
+						{
+							pid = ((data[j+1] & 0x1F) << 8) | data[j+2];
+							start = (data[j+1] & 0x40) >> 6;
+
+							p_count++;
+
+							if (start)
+							{
+								BITSTREAM *bitstream = bits_create(&data[j], TS_PACKET_SIZE);
+								if (bitstream)
+								{
+									MPEGTS_PACKET *packet = mpegts_parse_packet2(bitstream, 0);
+									if (packet)
+									{
+
+										if (packet->payload_start_struct)
+										{
+											if (packet->payload_start_struct->stream_id >= MPEGTS_VIDEO_STREAM_START &&
+												packet->payload_start_struct->stream_id <= MPEGTS_VIDEO_STREAM_END)
+											{
+												if (packet->payload_start_struct->dts == 0)
+												{
+													if (packet->payload_start_struct->pts - last_pts > 90000)
+													{
+														packet_no = p_count;
+														mpegts_debug_printf(NULL, "Video Start [%" PRId64"], PTS: %" PRId64" (%0.2f)\n", packet_no, packet->payload_start_struct->pts, packet->payload_start_struct->pts/90000.0);
+														last_pts = packet->payload_start_struct->pts;
+													}
+												}
+											}
+										}
+										mpegts_free_packet(packet);
+									}
+									free(bitstream);
+								}
+
+							}
+						}
+					}
+				}
+
+				close(fh);
+				free(data);
+			}
+		}
+		else
+		{
+			mpegts_debug_printf(NULL, "TS is NOT good and valid\n");
+		}
+	}
+	return 0;
+}
+#endif
+
diff -Naur stream.org/etp/mpegts.h stream/etp/mpegts.h
--- stream.org/etp/mpegts.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/mpegts.h	2013-09-02 01:18:17.905198136 -0400
@@ -0,0 +1,427 @@
+#ifndef __MPEGTS_STUFF
+#define __MPEGTS_STUFF
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+#include <stdint.h>
+#include "bitstream.h"
+//#include "utils2.h"
+
+#define CLOCK_90K                       90000.0
+#define CLOCK_27M                       27000000.0
+#define CLOCK_CONV                      (double)(CLOCK_27M/CLOCK_90K)
+
+#define MPEGTS_VIDEO_STREAM_START       0xE0
+#define MPEGTS_VIDEO_STREAM_END         0xEF
+#define MPEGTS_AUDIO_STREAM_START       0xC0
+#define MPEGTS_AUDIO_STREAM_END         0xDF
+#define MPEGTS_PROGRAM_END              0xB9
+#define MPEGTS_PACK_HEADER              0xBA
+#define MPEGTS_SYSTEM_HEADER            0xBB
+#define MPEGTS_PROGRAM_STREAM           0xBC
+#define MPEGTS_PRIVATE_STREAM1          0xBD
+#define MPEGTS_PADDING_STREAM           0xBE
+#define MPEGTS_PRIVATE_STREAM2          0xBF
+#define MPEGTS_ECM_STREAM               0xF0
+#define MPEGTS_EMM_STREAM               0xF1
+
+#define TS_SYNC_BYTE                    0x47
+#define TS_UNIT_START                   0x40
+#define TS_UNIT_PAYLOAD_ONLY            0x10
+#define TS_UNIT_PAYLOAD_AF              0x30
+
+#define TS_PACKET_SIZE                  188
+#define TS_HEADER_LEN                   4
+
+#define PAT_PID                         0x00
+#define CA_PID                          0x01
+#define DST_PID                         0x02
+#define IPMP_PID                        0x03
+#define PMT_PID                         0x1E0
+#define NULL_PID                        0x1FFF
+#define EIT_PID                         0x12
+
+#define TID_PAT                         0x00
+#define TID_CA                          0x01
+#define TID_PMT                         0x02
+#define TID_DES                         0x03
+#define TID_14496_SDC                   0x04
+#define TID_14496_ODC                   0x05
+#define TID_META                        0x06
+#define TID_IPMP                        0x07
+#define TID_RESERVED_START              0x08
+#define TID_RESERVED_END                0x3F
+#define TID_USER_START                  0x40
+#define TID_USER_END                    0xFE
+#define TID_FORBIDDEN                   0xFF
+
+#define ADAPT_RESERVED                  0x00
+#define ADAPT_NO_FIELD_ONLY_PAYLOAD     0x01
+#define ADAPT_FIELD_ONLY_NO_PAYLOAD     0x02
+#define ADAPT_FIELD_AND_PAYLOAD         0x03
+
+#define NO_PTS                          0x00
+#define PTS_ONLY                        0x02
+#define PTS_AND_DTS                     0x03
+
+#define AF_DISCONTINUITY                0x80
+#define AF_RANDOM_ACCESS                0x50
+#define AF_PCR                          0x10
+#define AF_ES_PRI                       0x20
+
+#define MPEGTS_STUFF_BYTE               0xFF
+
+#define CRC_LENGTH                      4  //CRC = 4 bytes
+
+#define PAT_PROGRAM_LENGTH              4  // program_number = 2 bytes
+                                           // reserved(3bit)+ [program_map_id or network_id](13bits) = 2 bytes
+
+#define PAT_BYTES_AFTER_SECTION_LEN     5  // ts_id = 2 bytes
+                                           // resevred(2bit)+version(5bit)+current_next_indicator(1bit) = 1 byte
+                                           // section number = 1 byte
+                                           // last section number = 1 byte
+
+#define PMT_BYTES_AFTER_SECTION_LEN     9  // program_number = 2 bytes
+                                           // resevred(2bit)+version(5bit)+current_next_indicator(1bit) = 1 byte
+                                           // section number = 1 byte
+                                           // last section number = 1 byte
+                                           // reserved(3bits) + PCR PID(13) = 2 bytes
+                                           // reserved(4bits) + program_info_length(12) = 2 bytes
+
+#define PMT_PROGRAM_LENGTH              5  // stream_type =  1 byte
+                                           // reserved(3bit) + elementary_pid(13bits) = 2 bytes
+                                           // reserved(4bit) + es_info_length(12bits) = 2 bytes
+
+
+#define PAT_CONST_LENGTH					(3+PAT_BYTES_AFTER_SECTION_LEN)
+#define PMT_CONST_LENGTH					(3+PMT_BYTES_AFTER_SECTION_LEN)
+
+/*
+
+#define MPEGTS_STREAM_TYPE_ISO13818_V		0x02  // VIDEO
+#define MPEGTS_STREAM_TYPE_ISO11172_A		0x03  // AUDIO
+#define MPEGTS_STREAM_TYPE_ISO13818_3		0x04  // AUDIO
+#define MPEGTS_STREAM_TYPE_ISO14496_10		0x1B
+#define MPEGTS_STREAM_TYPE_USER_DATA		0x81
+#define MPEGTS_STREAM_TYPE_SCTE35			0x86
+*/
+#define MPEGTS_STREAM_TYPE_RESERVED             0x00  // Reserved
+#define MPEGTS_STREAM_TYPE_ISO11172_V           0x01  // ISO/IEC 11172 Video
+#define MPEGTS_STREAM_TYPE_ISO13818_V           0x02  // VIDEO
+#define MPEGTS_STREAM_TYPE_ISO11172_A           0x03  // AUDIO
+#define MPEGTS_STREAM_TYPE_ISO13818_3           0x04  // AUDIO
+#define MPEGTS_STREAM_TYPE_ISO13818_1_P_SECT    0x05
+#define MPEGTS_STREAM_TYPE_ISO13818_1_PES       0x06
+#define MPEGTS_STREAM_TYPE_ISO13522             0x07
+#define MPEGTS_STREAM_TYPE_ISO13818_DSM_CC      0x08
+#define MPEGTS_STREAM_TYPE_ITU_H222_1           0x09
+#define MPEGTS_STREAM_TYPE_ISO13818_6_A         0x0A
+#define MPEGTS_STREAM_TYPE_ISO13818_6_B         0x0B
+#define MPEGTS_STREAM_TYPE_ISO13818_6_C         0x0C
+#define MPEGTS_STREAM_TYPE_ISO13818_6_D         0x0D
+#define MPEGTS_STREAM_TYPE_ISO13818_1_AUX       0x0E
+#define MPEGTS_STREAM_TYPE_ISO13818_7           0x0F
+#define MPEGTS_STREAM_TYPE_ISO14492_2           0x10
+#define MPEGTS_STREAM_TYPE_ISO14492_3           0x11
+#define MPEGTS_STREAM_TYPE_ISO14492_1_PES       0x12
+#define MPEGTS_STREAM_TYPE_ISO14492_1_SEC       0x13
+#define MPEGTS_STREAM_TYPE_ISO13818_6_SYNC      0x14
+#define MPEGTS_STREAM_TYPE_META_IN_PES          0x15
+#define MPEGTS_STREAM_TYPE_META_IN_SEC          0x16
+#define MPEGTS_STREAM_TYPE_ISO13818_META_IN_DC  0x17
+#define MPEGTS_STREAM_TYPE_ISO13818_META_IN_OC  0x18
+#define MPEGTS_STREAM_TYPE_ISO13818_META_SYNC   0x19
+#define MPEGTS_STREAM_TYPE_IPMP                 0x1A
+#define MPEGTS_STREAM_TYPE_ISO14496_10          0x1B
+#define MPEGTS_STREAM_TYPE_SOMETHING			0x80
+#define MPEGTS_STREAM_TYPE_USER_DATA            0x81
+
+
+#define MPEGTS_TYPE_UNHANDLED           0
+#define MPEGTS_TYPE_VIDEO               1
+#define MPEGTS_TYPE_AUDIO               2
+#define MPEGTS_TYPE_PAT                 3
+#define MPEGTS_TYPE_PMT                 4
+#define MPEGTS_TYPE_INVALID             -1
+
+
+static const uint8_t TS_NULL_PACKET[188] =
+{
+	0x47, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+/*
+static const char *MPEG2_PIC_TYPE[5]=
+{
+	"Undefined",
+	"I-Frame",
+	"P-Frame",
+	"B-Frame",
+	"D-Frame",
+};
+*/
+struct mpegts_pat_program_struct
+{
+	uint16_t program_number;
+	uint8_t reserved;
+	uint16_t pid;
+//        uint16_t network_pid;
+//        uint16_t program_pid;
+	struct mpegts_pat_program_struct *next;
+};
+typedef struct mpegts_pat_program_struct MPEGTS_PAT_PROGRAM_STRUCT;
+
+struct mpegts_pat_struct
+{
+	uint8_t table_id;
+	uint8_t section_syntax_indicator;
+	uint8_t zero;
+	uint8_t reserved1;
+	uint16_t section_length;
+	uint16_t transport_stream_id;
+	uint8_t reserved2;
+	uint8_t version_number;
+	uint8_t current_next_indicator;
+	uint8_t section_number;
+	uint8_t last_section_number;
+	uint32_t crc;
+
+	uint16_t program_count;
+	MPEGTS_PAT_PROGRAM_STRUCT * first_program;
+	MPEGTS_PAT_PROGRAM_STRUCT * current_program;
+	uint16_t program_num_filter;
+};
+typedef struct mpegts_pat_struct MPEGTS_PAT;
+
+struct mpegts_map_es_struct
+{
+	uint8_t stream_type; //8
+	uint8_t reserved1; //3
+	uint16_t pid; //13
+	uint8_t reserved2; //4
+	uint16_t info_len; //12
+	uint8_t * descriptor;
+	struct mpegts_map_es_struct *next;
+};
+typedef struct mpegts_map_es_struct MPEGTS_MAP_ES;
+
+struct mpegts_pmt_struct
+{
+	uint8_t table_id;  // 8 bits
+	uint8_t section_syntax_indicator; //1
+	uint8_t zero; //1
+	uint8_t reserved1; //2
+	uint16_t section_length; //12
+	uint16_t program_number; //16
+	uint8_t reserved2; //2
+	uint8_t version_number; //5
+	uint8_t current_next_indicator; //1
+	uint8_t section_number; //8
+	uint8_t last_section_number; //8
+	uint8_t reserved3; //3
+	uint16_t pcr_pid; //13
+	uint8_t reserved4;  //4
+	uint16_t program_info_length; //12
+	uint8_t *program_info_data;
+
+
+	uint16_t es_count;
+	MPEGTS_MAP_ES * first_es;
+	MPEGTS_MAP_ES * current_es;
+	uint32_t crc; //32
+};
+typedef struct mpegts_pmt_struct MPEGTS_PMT;
+
+struct mpegts_payload_start_struct
+{
+//	uint8_t  start;  // Where in the packet does the payload start?
+//	uint32_t packet_num;
+
+	uint32_t start_code;
+	uint8_t stream_id;
+	uint16_t len;
+	uint8_t one_zero;
+	uint8_t pes_scrambling;
+	uint8_t pes_priority;
+	uint8_t data_alignment;
+	uint8_t copyright;
+	uint8_t original;  //1 = org, 0 = copy
+	uint8_t pts_dts_flag;
+	uint8_t escr_flag;
+	uint8_t es_rate_flag;
+	uint8_t dsm_trick_mode_flag;
+	uint8_t additional_copy_info_flag;
+	uint8_t pes_crc_flag;
+	uint8_t pes_extension_flag;
+	uint8_t pes_header_data_len;
+	uint64_t pts;
+	uint64_t dts;
+
+	uint64_t new_pts;
+	uint64_t new_dts;
+	uint8_t * extra_data;
+};
+typedef struct mpegts_payload_start_struct MPEGTS_PAYLOAD_START;
+
+struct mpegts_section
+{
+	uint8_t table_id;
+	uint8_t section_syntax_indicator;
+	uint16_t ts_id;
+	uint8_t version_number;
+	uint8_t current_next_indicator;
+	uint8_t section_number;
+	uint8_t last_section_number;
+
+	uint8_t *section_data;
+	uint16_t section_len;
+
+	void * extra_data;
+};
+typedef struct mpegts_section MPEGTS_SECTION;
+
+struct mpegts_adaptfield_struct
+{
+	uint8_t adaptation_field_length;
+	uint8_t discontinuity;
+	uint8_t random_access;
+	uint8_t es_prio;
+	uint8_t pcr_flag;
+	uint8_t opcr_flag;
+	uint8_t splice_flag;
+	uint8_t ts_private_flag;
+	uint8_t field_ext_flag;
+	uint64_t pcr_baseH;
+	uint64_t pcr_base;
+	uint8_t pcr_reserved;
+	uint16_t pcr_ext;
+
+	uint8_t stuffing_bytes;
+	uint64_t pcr_27khz;
+
+	uint64_t opcr_base;
+	uint8_t opcr_reserved;
+	uint16_t opcr_ext;
+
+	uint8_t transport_private_data_length;
+	uint8_t * transport_private_data;
+
+	/* add other adapatation field flags */
+};
+typedef struct mpegts_adaptfield_struct MPEGTS_ADAPTATION_FIELD;
+
+struct mpegts_struct
+{
+	uint8_t sync_byte;
+	uint8_t ts_error;               // 1
+	uint8_t payload_start;  // 1
+	uint8_t ts_priority;    // 1
+	uint16_t pid;           // 13
+	uint8_t ts_scrambling;  // 2
+	uint8_t adapt_field_control;    // 2
+	uint8_t cont_counter;   // 4
+	uint8_t pointer_field;
+	uint8_t transport_private_data_length;
+	uint8_t splice_countdown;
+	void * extra_data;
+
+	MPEGTS_ADAPTATION_FIELD * adaptation_field;
+	MPEGTS_PAYLOAD_START * payload_start_struct;
+
+	BITSTREAM *bitstream;
+
+	uint8_t * packet_data;
+	uint8_t packet_data_size;
+
+	int8_t type;
+	uint8_t frame_type;
+	uint8_t pmt_descriptor;
+	MPEGTS_PAT *pat;
+	MPEGTS_PMT *pmt;
+};
+typedef struct mpegts_struct MPEGTS_PACKET;
+
+
+
+struct mpegts_newpat_struct
+{
+	uint16_t program_num;
+	uint16_t pmt_pid;
+	uint16_t ts_id;
+	uint8_t version;
+	uint8_t counter;
+	uint8_t new_pat_data[TS_PACKET_SIZE];
+	uint8_t *ts_header;
+	uint8_t ts_header_len;
+};
+typedef struct mpegts_newpat_struct MPEGTS_NEWPAT_STRUCT;
+
+struct mpegts_newpmt_struct
+{
+	uint16_t program_number;
+	uint16_t pcr_pid;
+	uint8_t *program_descriptor;
+	uint16_t program_descriptor_len;
+	uint8_t counter;
+	uint8_t new_pmt_data[TS_PACKET_SIZE];
+	uint8_t *ts_header;
+	uint8_t ts_header_len;
+	MPEGTS_MAP_ES * desc_es;
+
+};
+typedef struct mpegts_newpmt_struct MPEGTS_NEWPMT_STRUCT;
+
+struct mpegts_pts_dts_restamp
+{
+	uint8_t stamp_failed;
+	uint64_t org_pts;
+	uint64_t org_dts;
+	uint64_t pts;
+	uint64_t dts;
+};
+typedef struct mpegts_pts_dts_restamp MPEGTS_PTS_DTS_RESTAMP;
+
+// -----------------------------------------------------------
+
+void mpegts_print_adaptation_field(MPEGTS_ADAPTATION_FIELD *);
+void mpegts_print_pat(MPEGTS_PAT *);
+void mpegts_print_pmt(MPEGTS_PMT *);
+
+MPEGTS_PACKET * mpegts_parse_packet(BITSTREAM *);
+MPEGTS_PACKET * mpegts_parse_packet2(BITSTREAM *, uint16_t);
+MPEGTS_PAYLOAD_START * mpegts_parse_payload_start(BITSTREAM *);
+MPEGTS_ADAPTATION_FIELD * mpegts_parse_adaptation_field(BITSTREAM *);
+MPEGTS_PAT * mpegts_parse_pat(BITSTREAM *);
+MPEGTS_PAT *mpegts_dup_pat(MPEGTS_PAT *);
+MPEGTS_PMT * mpegts_parse_pmt(BITSTREAM *, uint8_t);
+
+void mpegts_free_pat(MPEGTS_PAT *);
+void mpegts_free_pmt(MPEGTS_PMT *);
+void mpegts_free_packet(MPEGTS_PACKET *);
+
+uint64_t mpegts_parse_pts(BITSTREAM *);
+uint8_t mpegts_fix_pat(uint8_t *, uint32_t, uint16_t, uint16_t);
+uint8_t mpegts_fix_pmt(uint8_t *data, uint32_t len,  uint16_t, uint16_t, MPEGTS_MAP_ES *);
+MPEGTS_PTS_DTS_RESTAMP * mpegts_offset_pts_dts(uint8_t *, uint32_t, uint64_t, uint16_t);
+
+uint8_t mpegts_streamtype_valid(uint8_t);
+//int32_t mpegts_need_sync(uint8_t *, uint32_t);
+
+
+#ifdef __cplusplus
+    }
+#endif
+
+#endif
diff -Naur stream.org/etp/protocol.c stream/etp/protocol.c
--- stream.org/etp/protocol.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/protocol.c	2013-09-02 01:18:17.905198136 -0400
@@ -0,0 +1,1445 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <memory.h>
+#include <getopt.h>
+#include <pthread.h>
+#include <errno.h>
+#include <signal.h>
+#include <ctype.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include "protocol.h"
+#include "utils.h"
+//#include "timers.h"
+//#include "device.h"
+
+
+size_t _protocol_send_cmd(int, PROTOCOL_CMD_STRUCT *);
+int _protocol_do_connect(char *, uint16_t, int timeout);
+
+size_t _protocol_send_8(int, uint8_t);
+size_t _protocol_send_16(int, uint16_t);
+size_t _protocol_send_32(int, uint32_t);
+size_t _protocol_send_64(int, uint64_t);
+
+size_t _protocol_get_8(int, uint8_t*);
+size_t _protocol_get_16(int, uint16_t*);
+size_t _protocol_get_32(int, uint32_t*);
+size_t _protocol_get_64(int, uint64_t*);
+
+// --------------------------
+
+// ---------- SENDs
+size_t _protocol_send_64(int handle, uint64_t p)
+{
+//	printf("[PROTO] SEND64: %" PRId64" -- 0x%lx\n", p, p);
+	if (handle)
+		return write(handle, &p, sizeof(uint64_t));
+	return -1;
+}
+
+size_t _protocol_send_32(int handle, uint32_t p)
+{
+	if (handle)
+		return write(handle, &p, sizeof(uint16_t));
+	return -1;
+}
+
+size_t _protocol_send_16(int handle, uint16_t p)
+{
+	if (handle)
+		return write(handle, &p, sizeof(uint16_t));
+	return -1;
+}
+
+size_t _protocol_send_8(int handle, uint8_t p)
+{
+	if (handle)
+		return write(handle, &p, sizeof(uint8_t));
+	return -1;
+}
+
+//  ------------ GETSs
+size_t _protocol_get_64(int handle, uint64_t *p)
+{
+	if (handle)
+		return get_bytes_from_socket(handle, (uint8_t *)&p, sizeof(uint64_t), 2, 0, 0);
+	return -1;
+}
+size_t _protocol_get_32(int handle, uint32_t *p)
+{
+	if (handle)
+		return get_bytes_from_socket(handle, (uint8_t *)&p, sizeof(uint16_t), 2, 0, 0);
+	return -1;
+}
+
+size_t _protocol_get_16(int handle, uint16_t *p)
+{
+	if (handle)
+		return get_bytes_from_socket(handle, (uint8_t *)&p, sizeof(uint16_t), 2, 0, 0);
+	return -1;
+}
+
+size_t _protocol_get_8(int handle, uint8_t *p)
+{
+	if (handle)
+		return get_bytes_from_socket(handle, (uint8_t *)&p, sizeof(uint8_t), 2, 0, 0);
+	return -1;
+}
+
+
+// -----------------------------=
+size_t protocol_send_tuner_pos(int handle, uint64_t pos)
+{
+//	printf("protocol_send_tuner_pos: %" PRId64" -- 0x%lx\n", pos, pos);
+	if (handle)
+		return _protocol_send_64(handle, pos);
+	return -1;
+}
+
+size_t protocol_send_tuner_init_status(int handle, uint8_t stat)
+{
+	if (handle && stat)
+		return _protocol_send_8(handle, stat);
+	return -1;
+}
+
+size_t protocol_send_tuner_id(int handle, uint8_t id)
+{
+	if (handle && id)
+		return _protocol_send_8(handle, id);
+	return -1;
+}
+
+
+int protocol_alive(char *ip, uint16_t port, int timeout)
+{
+	int handle = _protocol_do_connect(ip, port, timeout);
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		pstruct.cmd = PROTO_INIT_CONNECTION;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		if (_protocol_send_cmd(handle, &pstruct) == 1)
+		{
+			uint8_t resp = 0;
+			int sz = get_bytes_from_socket(handle, &resp, sizeof(resp), 5, 0, 0);
+			close(handle);
+
+			if (sz == sizeof(resp) && resp == PROTOCOL_INIT_GOOD)
+			{
+				return 1;
+			}
+
+			return 0;
+		}
+	}
+	return -1;
+}
+int _protocol_do_connect(char *ip, uint16_t port, int timeout)
+{
+	int sock = 0, sz = 0;
+	char req[1024] = {0};
+	uint8_t moo=0xFF;
+
+	sock = doconnect(ip, port, 0);
+
+	if (sock ==  -1)
+		printf("NOOOOO\n");
+
+	sprintf(req, "eTUNER V001 \n\n");
+	sz = write_bytes_to_socket(sock, (uint8_t*)req, strlen(req), 10, 0);
+
+	if (sz ==  -1)
+	{
+		printf("[CeTUNE] Error sending GET req\n");
+		close(sock);
+		return -1;
+	}
+
+	memset(&req, 0, 1024);
+	sz = get_bytes_from_socket(sock, &moo, 1, 5, 0, 0);
+
+	if (sz == -1)
+	{
+		close(sock);
+		return -1;
+	}
+
+	if (moo == PROTOCOL_INIT_GOOD)
+		return sock;
+
+	return -1;
+
+}
+
+size_t protocol_get_tuner_count(char *ip, uint16_t port, int * h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		memcpy(h1, &handle, sizeof(int));
+		pstruct.cmd = PROTO_QUERY_TUNER_COUNT;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_channel_epg(char *ip, uint16_t port, int *h1, char *id)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		memcpy(h1, &handle, sizeof(int));
+		pstruct.cmd = PROTO_GET_CHAN_EPG;
+		pstruct.dataptr = (uint8_t*)id;
+		pstruct.dataptr_size = strlen(id) + 1;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_channel_count(char *ip, uint16_t port, int *h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		memcpy(h1, &handle, sizeof(int));
+		pstruct.cmd = PROTO_QUERY_CHANNEL_COUNT;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_rec_count(char *ip, uint16_t port, int *h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		memcpy(h1, &handle, sizeof(int));
+		pstruct.cmd = PROTO_QUERY_REC_COUNT;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_timer_count(char *ip, uint16_t port, int *h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		memcpy(h1, &handle, sizeof(int));
+		pstruct.cmd = PROTO_QUERY_TIMER_COUNT;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_stream_info(char *ip, uint16_t port, int *h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		memcpy(h1, &handle, sizeof(int));
+
+		pstruct.cmd = PROTO_QUERY_STREAM_INFO;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_stream_info2(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		pstruct.cmd = PROTO_QUERY_STREAM_INFO;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_channel_list(char *ip, uint16_t port, int *h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		memcpy(h1, &handle, sizeof(int));
+
+		pstruct.cmd = PROTO_QUERY_CHANNEL_LIST;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_rec_list(char *ip, uint16_t port, int *h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		memcpy(h1, &handle, sizeof(int));
+
+		pstruct.cmd = PROTO_QUERY_REC_LIST;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_tuner_time_pos(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_POS;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_tuner_id(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_ID;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+uint64_t protocol_get_tuner_time_endpos(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_END_POS;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+uint64_t protocol_get_tuner_time_startpos(int handle)
+{
+	uint64_t ret = 0;
+	if (handle)
+	{
+		size_t tmp;
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_START_POS;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+uint64_t protocol_get_tuner_time_startpos2(int handle)
+{
+	uint64_t ret = 0;
+	if (handle)
+	{
+		size_t tmp;
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_START_POS2;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+
+uint64_t protocol_get_tuner_size_endpos(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_SZ_END_POS;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+uint64_t protocol_get_tuner_size_startpos(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_SZ_START_POS;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return 0;
+}
+
+size_t protocol_get_tuner_size_pos(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_SZ_POS;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_set_tuner_size_pos(int handle, uint64_t pos)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_SET_STREAM_SZ_POS;
+		pstruct.dataptr_size = sizeof(pos);
+		pstruct.dataptr = (uint8_t*)&pos;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+
+//-----------------------------------------
+
+size_t protocol_get_timer_list(char *ip, uint16_t port, int *h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+	if (handle && h1)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		memcpy(h1, &handle, sizeof(int));
+
+		pstruct.cmd = PROTO_QUERY_TIMER_LIST;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+/*
+size_t protocol_get_timer_list(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_QUERY_TIMER_LIST;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+*/
+size_t protocol_add_timer(char *ip, uint16_t port, uint8_t *data, uint32_t data_sz, int *h1)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+
+	if (handle && h1 && data && data_sz)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		memcpy(h1, &handle, sizeof(int));
+
+		pstruct.cmd = PROTO_TIMER_ADD;
+//		printf("hh: %d\n", data_sz);
+		pstruct.dataptr_size = data_sz;
+		pstruct.dataptr = data;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+
+size_t protocol_del_timer(int handle, uint32_t id)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_TIMER_DEL;
+		pstruct.dataptr = (uint8_t*)&id;
+		pstruct.dataptr_size = sizeof(id);
+		printf("MMM: %d -- %d\n", pstruct.dataptr_size, *((uint32_t*)pstruct.dataptr));
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_del_timer2(char *ip, uint16_t port, uint32_t id, int *h1)
+{
+
+	int handle = _protocol_do_connect(ip, port, 0);
+
+	if (handle && h1)
+	{
+		memcpy(h1, &handle, sizeof(int));
+		return protocol_del_timer(handle, id);
+	}
+	return 0;
+}
+
+/*
+size_t protocol_stop_timer(int handle, uint32_t id)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_TIMER_STOP;
+		pstruct.dataptr_size = sizeof(id);
+		pstruct.dataptr = (uint8_t*)&id;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+*/
+
+size_t protocol_set_tuner_channel(int handle, uint32_t channel)
+{
+	if (handle && channel)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_TUNE_AND_STREAM;
+		pstruct.dataptr_size = sizeof(channel);
+		pstruct.dataptr = (uint8_t*)&channel;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_send_keepalive(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd =  PROTO_KEEP_ALIVE;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_set_tuner_time_pos(int handle, uint64_t pos)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_SET_STREAM_POS;
+		pstruct.dataptr_size = sizeof(pos);
+		pstruct.dataptr = (uint8_t*)&pos;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+/*
+size_t protocol_play_rec_id2(char *ip, uint16_t port, int * h1, uint32_t id)
+{
+	int handle = _protocol_do_connect(ip, port, 0);
+
+	if (handle && h1)
+	{
+		memcpy(h1, &handle, sizeof(int));
+		return protocol_play_rec_id(handle, id);
+	}
+	return -1;
+}
+*/
+size_t protocol_play_rec_id(int handle, uint32_t id)
+{
+	if (handle && id)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_REC_PLAY;
+		pstruct.dataptr_size = sizeof(id);
+		pstruct.dataptr = (uint8_t*)&id;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_del_rec_id(int handle, uint32_t id)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_REC_DEL;
+		pstruct.dataptr_size = sizeof(id);
+		pstruct.dataptr = (uint8_t*)&id;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_del_rec_id2(char *ip, uint16_t port, uint32_t id, int *h1)
+{
+
+	int handle = _protocol_do_connect(ip, port, 0);
+
+	if (handle && h1)
+	{
+/*
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+		memcpy(h1, &handle, sizeof(int));
+
+		pstruct.cmd = PROTO_REC_DEL;
+//		printf("hh: %d\n", data_sz);
+		pstruct.dataptr_size = sizeof(id);
+		pstruct.dataptr = (uint8_t*)&id;
+
+		return _protocol_send_cmd(handle, &pstruct);
+*/
+		memcpy(h1, &handle, sizeof(int));
+		return protocol_del_rec_id(handle, id);
+	}
+	return 0;
+}
+/*
+size_t protocol_stop_rec_id(int handle, uint32_t id)
+{
+	if (handle && id)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_REC_STOP;
+		pstruct.dataptr_size = sizeof(id);
+		pstruct.dataptr = (uint8_t*)&id;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+*/
+void protocol_free_cmd_struct(PROTOCOL_CMD_STRUCT * p)
+{
+	if (p)
+	{
+		if (p->dataptr)
+			free(p->dataptr);
+		free(p);
+	}
+}
+
+
+PROTOCOL_CMD_STRUCT *protocol_get_cmd(int handle)
+{
+	PROTOCOL_CMD_STRUCT *ret = calloc(1, sizeof(PROTOCOL_CMD_STRUCT));
+;
+	if (handle)
+	{
+		uint32_t _input = 0;
+//		size_t _rc = 0;
+
+		while(ret->rc == 0)
+		{
+			ret->rc = get_bytes_from_socket(handle, (uint8_t*)&_input, sizeof(uint32_t), 5, 0, 0);
+			if (ret->rc < 0)
+			{
+//				printf("protocol_get_cmd 1: %d (%s)\n",errno, strerror(errno));
+				return ret;
+			}
+			else if (ret->rc == 0)
+			{
+				usleep(1000*250);
+			}
+		}
+
+		if (!((_input & PROTO_CMD_MASK) == PROTO_CMD_START))
+		{
+//			printf("protocol_get_cmd 2\n");
+			ret->rc = -5;
+			return ret;
+		}
+
+//		if (!ret)
+//			ret = calloc(1, sizeof(PROTOCOL_CMD_STRUCT));
+
+		ret->cmd  = _input & 0x000000FF;
+//		_cmd = _input & 0x000000FF;
+//		printf("CMD: 0x%x\n", ret->cmd);
+		switch(ret->cmd)
+		{
+			case PROTO_GET_CHAN_EPG:
+			case PROTO_TIMER_DEL:
+			case PROTO_TIMER_ADD:
+			case PROTO_SET_STREAM_POS:
+			case PROTO_SET_STREAM_SZ_POS:
+			case PROTO_TUNE_AND_STREAM:
+			case PROTO_REC_PLAY:
+			case PROTO_REC_DEL:
+//			case PROTO_INIT_CONNECTION:
+			{
+				uint32_t data_sz = 0;
+				ret->rc = get_bytes_from_socket(handle, (uint8_t*)&data_sz, sizeof(data_sz), 5, 0, 0);
+
+				if (ret->rc > 0)
+				{
+					ret->dataptr_size = data_sz;
+					ret->dataptr = calloc(1, ret->dataptr_size);
+					ret->rc = get_bytes_from_socket(handle, ret->dataptr, ret->dataptr_size, 5, 0, 0);
+				}
+				else
+				{
+					printf("[PROTO] !!!! protocol_get_cmd error: %d (%s)\n", ret->rc, strerror(errno));
+				}
+			}
+			break;
+
+//			break;
+/*
+			case PROTO_TIMER_LIST:
+			case PROTO_GET_STREAM_END_POS:
+			case PROTO_GET_STREAM_POS:
+			case PROTO_GET_STREAM_ID:
+*/
+			default:
+			break;
+		}
+	}
+	return ret;
+}
+
+
+size_t _protocol_send_cmd(int handle, PROTOCOL_CMD_STRUCT *protocol)
+{
+	size_t _rc = -1;
+	if (handle && protocol)
+	{
+		uint32_t _send = (PROTO_CMD_START | protocol->cmd);
+//		printf("send: %d\n", (int32_t)_send);
+
+
+		_rc = write(handle, &_send, sizeof(_send));
+		if (_rc <= 0)
+			return -1;
+
+//		printf("send1: %d\n", protocol->dataptr_size);
+		if (protocol->dataptr_size)
+		{
+			_rc = write(handle, &protocol->dataptr_size, sizeof(protocol->dataptr_size));
+			if (_rc <= 0)
+				return -1;
+
+
+			_rc = write(handle, protocol->dataptr, protocol->dataptr_size);
+			if (_rc <= 0)
+				return -1;
+		}
+		_rc = 1;
+
+	}
+	return _rc;
+}
+
+//-------------------------
+#ifdef _MAIN_
+
+
+
+#define EPG_EVENT_CONTENTMASK_UNDEFINED                0x00
+#define EPG_EVENT_CONTENTMASK_MOVIEDRAMA               0x10
+#define EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS       0x20
+#define EPG_EVENT_CONTENTMASK_SHOW                     0x30
+#define EPG_EVENT_CONTENTMASK_SPORTS                   0x40
+#define EPG_EVENT_CONTENTMASK_CHILDRENYOUTH            0x50
+#define EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE         0x60
+#define EPG_EVENT_CONTENTMASK_ARTSCULTURE              0x70
+#define EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS 0x80
+#define EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE       0x90
+#define EPG_EVENT_CONTENTMASK_LEISUREHOBBIES           0xA0
+#define EPG_EVENT_CONTENTMASK_SPECIAL                  0xB0
+#define EPG_EVENT_CONTENTMASK_USERDEFINED              0xF0
+
+UTILS_HOSTPORT_STRUCT *hostport = NULL;
+
+
+
+#define PROTO_MAIN_LIST_REC			1
+#define PROTO_MAIN_LIST_CHAN		2
+#define PROTO_MAIN_LIST_TIMER		3
+#define PROTO_MAIN_SET_TIMER		4
+#define PROTO_MAIN_DEL_REC			5
+#define PROTO_MAIN_LIST_DEL			6
+#define PROTO_MAIN_LIST_CHAN_COUNT	7
+#define PROTO_MAIN_GET_EPG			8
+#define PROTO_MAIN_STREAM_INFO		9
+
+#define PROTO_MAIN_LIST_REC_COUNT	10
+#define PROTO_MAIN_LIST_TIMER_COUNT	11
+
+
+char *remote_ip = NULL;
+char *dd_progid = NULL;
+uint8_t proto_cmd = 0;
+uint32_t prog_id = 0;
+
+void display_usage(char *exe)
+{
+	fprintf(stderr,"bleah\n");
+}
+
+#define GENRE_MAIN_COUNT		22
+#define GENRE_SUB_COUNT			43
+
+static const char *GENRE_SUB[GENRE_SUB_COUNT] =
+{
+	"Baseball",
+	"Basketball",
+	"Golf",
+	"Football",
+	"Hockey",
+	"Soccer",
+	"Boxing",
+	"Action and Adventure",
+	"Science Fiction",
+	"Horror",
+	"Fantasy",
+	"Drama",
+	"Mystery",
+	"Suspense",
+	"Drama",
+	"Musical",
+	"Music",
+	"Western",
+	"Romance",
+	"Awards/Event",
+	"Business",
+	"Cooking",
+	"Home",
+	"Interview",
+	"Racing",
+	"How-to",
+	"Science",
+	"Tennis",
+	"Travel",
+	"Weather",
+	"Home and Garden",
+	"Game",
+	"Racing",
+	"Outdoor",
+	"Episodic",
+	"Documentary",
+	"Comedy",
+	"Reality",
+	"Religious",
+	"Public Affairs",
+	"Current Events",
+	"Special",
+	"Other",
+};
+
+static const char *GENRE_MAIN[GENRE_MAIN_COUNT] =
+{
+	"News",
+	"Sports",
+	"Paid Programming",
+	"Movie",
+	"Comedy",
+	"Action/Adventure",
+	"Talk Show",
+	"Game Show",
+	"Soap Opera",
+	"Miniseries",
+	"Drama",
+	"Music",
+	"Reality",
+	"Lifestyle",
+	"Children",
+	"Cooking",
+	"Adventure",
+	"Special",
+	"Educational",
+	"Travel",
+	"How-to",
+	"Other",
+};
+
+
+static const char *optString = "a:c:i:d:?h";
+
+static const struct option longOpts[] =
+{
+	{ "help", no_argument, NULL, 'h' },
+	{ NULL, no_argument, NULL, 0 }
+};
+
+uint8_t get_opts(int argc, char *const argv[])
+{
+	int index = 0;
+	int opt = getopt_long( argc, argv, optString, longOpts, &index );
+
+	if (opt == -1 )
+	{
+		display_usage(argv[0]);
+		return 1;
+	}
+
+
+	while ( opt != -1 )
+	{
+		switch ( opt )
+		{
+			case 'a':
+				remote_ip = optarg;
+				break;
+
+			case 'd':
+				dd_progid = optarg;
+				break;
+
+			case 'c':
+				proto_cmd = atoi(optarg);
+				break;
+
+			case 'i':
+				prog_id = atoi(optarg);
+				break;
+
+			case 'h':
+			case '?':
+				display_usage(argv[0]);
+				break;
+
+			default:
+				break;
+		}
+		opt = getopt_long( argc, argv, optString, longOpts, &index );
+	}
+	return 0;
+}
+
+void sigint_handler()
+{
+	exit(0);
+}
+
+void sigpipe_handler()
+{
+//   printf("SIGPIPE caught\n");
+}
+
+
+int _proto_main_get_epg(UTILS_HOSTPORT_STRUCT * hostp, char *id)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0;
+		protocol_get_channel_epg(hostp->hostname, hostp->port, &sock, id);
+		if (sock > 0)
+		{
+			int i, j;
+			uint64_t count = 0;
+			char *genre = NULL, *subgenre=NULL;
+			TIMER_STRUCT timer = {0};
+			TIMER_STRUCT_EXTRA extra = {0};
+			sz = get_bytes_from_socket(sock, (uint8_t*)&count, sizeof(count), 5, 0, 0);
+	//		printf("Count: %" PRId64"\n", count);
+
+			while(count && timer.is_last == 0)
+			{
+				sz = get_bytes_from_socket(sock, (uint8_t*)&timer, sizeof(TIMER_STRUCT), 5, 0, 0);
+				sz = get_bytes_from_socket(sock, (uint8_t*)&extra, sizeof(TIMER_STRUCT_EXTRA), 5, 0, 0);
+				printf("Title: %s\n", timer.title);
+				printf("display-name: %s\n", timer.channel_name);
+//				for(i=0; i < extra.category_count; i++)
+//					printf("\t [%d] [%d] MOO1: %s\n", extra.category_count, i, extra.category[i]);
+
+
+				for(j=0; j < GENRE_MAIN_COUNT; j++)
+				{
+					for(i=0; i < extra.category_count; i++)
+					{
+//						printf("H: %s -- %s\n", GENRE_MAIN[j], extra.category[i]);
+						if (strcmp(extra.category[i],  GENRE_MAIN[j]) == 0)
+						{
+							genre = strdup(extra.category[i]);
+							memset(extra.category[i], 0, TIEMR_STRUCT_MAX_STRLEN);
+							break;
+						}
+					}
+
+					if (genre)
+						break;
+				}
+
+/*
+*/
+				if (genre)
+				{
+					for(j=0; j < GENRE_SUB_COUNT; j++)
+					{
+						for(i=0; i < extra.category_count; i++)
+						{
+							if (extra.category[i][0] == 0)
+								continue;
+
+							if (strcmp(extra.category[i], GENRE_SUB[j]) == 0)
+							{
+								subgenre = strdup(extra.category[i]);
+//								printf("MEEP: %s\n", subgenre);
+//								extra.category[i][0] = '\0';
+								break;
+							}
+//							else
+//								printf("\t[%d] %s -- %s\n",j, extra.category[i], GENRE_SUB[j]);
+						}
+
+						if (subgenre)
+							break;
+					}
+
+					if (!subgenre && strcmp(genre, "Paid Programming") != 0)
+					{
+						for(i=0; i < extra.category_count; i++)
+						{
+							if (strlen(extra.category[i]))
+								printf("\t [%d] [%d] MOO: %s (%s)\n", extra.category_count, i, extra.category[i], genre);
+						}
+					}
+//					printf("Found!: %s -- %s\n", genre, subgenre);
+				}
+				else
+				{
+					if (extra.category_count)
+					{
+						printf("No Main: %s -- cat count: %d, o_air: %" PRId64"\n", timer.title, extra.category_count, extra.org_air_date);
+						for(i=0; i < extra.category_count; i++)
+							printf("\t%s\n", extra.category[i]);
+					}
+				}
+				if (genre)
+					free(genre);
+				if (subgenre)
+					free(subgenre);
+				genre = subgenre = NULL;
+//					printf("Found Main: %s\n", genre);
+
+			}
+
+			close(sock);
+		}
+	}
+	return -1;
+}
+int _proto_main_get_timer_list(UTILS_HOSTPORT_STRUCT * hostp)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0;
+		protocol_get_timer_list(hostp->hostname, hostp->port, &sock);
+		if (sock > 0)
+		{
+			TIMER_STRUCT timer = {0};
+			uint32_t count = 0;
+			sz = get_bytes_from_socket(sock, (uint8_t*)&count, sizeof(count), 5, 0, 0);
+//			printf("count: %d\n", count);
+
+			while(count && timer.is_last == 0)
+			{
+				sz = get_bytes_from_socket(sock, (uint8_t*)&timer, sizeof(TIMER_STRUCT), 5, 0, 0);
+				timer_print_timer2(&timer);
+			}
+			close(sock);
+			return 0;
+		}
+	}
+	return -1;
+}
+
+int _proto_main_del_rec(UTILS_HOSTPORT_STRUCT * hostp, uint32_t id)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0;
+		printf("Removing recording num: %d\n", id);
+		protocol_del_rec_id2(hostp->hostname, hostp->port, id, &sock);
+		if (sock > 0)
+		{
+			uint8_t rc = 0;
+			printf("del_rc, sock good\n");
+			sz = get_bytes_from_socket(sock, (uint8_t*)&rc, sizeof(rc), 5, 0, 0);
+			if (rc == PROTOCOL_INIT_GOOD)
+				printf("Deleted ID: %d\n", id);
+			else
+				printf("NOT Deleted ID: %d (%d)\n", id, rc);
+
+			close(sock);
+			return 0;
+		}
+		else
+			printf("del_rc, sock bad\n");
+
+	}
+	return -1;
+}
+
+int _proto_main_del_list(UTILS_HOSTPORT_STRUCT * hostp, uint32_t id)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0;
+		printf("Removing list num: %d\n", id);
+		protocol_del_timer2(hostp->hostname, hostp->port, id, &sock);
+		if (sock > 0)
+		{
+			uint8_t rc = 0;
+			printf("del_rc, sock good\n");
+			sz = get_bytes_from_socket(sock, (uint8_t*)&rc, sizeof(rc), 5, 0, 0);
+			if (rc == PROTOCOL_INIT_GOOD)
+				printf("Deleted Timer ID: %d\n", id);
+			else
+				printf("NOT Deleted Timer ID: %d (%d)\n", id, rc);
+
+			close(sock);
+			return 0;
+		}
+		else
+			printf("del_rc, sock bad\n");
+
+	}
+	return -1;
+}
+
+int _proto_main_get_rec_list(UTILS_HOSTPORT_STRUCT * hostp)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0;
+		protocol_get_rec_list(hostp->hostname, hostp->port, &sock);
+		if (sock > 0)
+		{
+			TIMER_STRUCT timer = {0};
+			uint32_t count = 0, _count = 0;
+			sz = get_bytes_from_socket(sock, (uint8_t*)&count, sizeof(count), 5, 0, 0);
+//			printf("count: %d\n", count);
+//			while(count && timer.is_last == 0)
+			while(_count < count)
+			{
+				sz = get_bytes_from_socket(sock, (uint8_t*)&timer, sizeof(TIMER_STRUCT), 5, 0, 0);
+				printf("[%" PRId64"],[%d],[%" PRId64"],[%" PRId64"],[%s],[%s],[%s],[%s],[%s],[%s]\n", timer.channel_num, timer.id, timer.start_epoch, timer.end_epoch, timer.channel_name, timer.title, timer.plot_outline, timer.plot, timer.genre, timer.sub_genre);
+//				timer_print_timer(&timer);
+				_count++;
+			}
+			close(sock);
+			return 0;
+		}
+	}
+	return -1;
+}
+
+
+int _proto_main_get_chan_count(UTILS_HOSTPORT_STRUCT * hostp)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0, f = 0, count=0;
+		protocol_get_channel_count(hostp->hostname, hostp->port, &sock);
+		if (sock > 0)
+		{
+			sz = get_bytes_from_socket(sock, (uint8_t*)&count, sizeof(count), 5, 0, 0);
+			close(sock);
+		}
+		sock = 0;
+		printf("Count %d\n", count);
+		return count;
+	}
+	return -1;
+}
+
+int _proto_main_get_rec_count(UTILS_HOSTPORT_STRUCT * hostp)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0, f = 0, count=0;
+		protocol_get_rec_count(hostp->hostname, hostp->port, &sock);
+		if (sock > 0)
+		{
+			sz = get_bytes_from_socket(sock, (uint8_t*)&count, sizeof(count), 5, 0, 0);
+			close(sock);
+		}
+		sock = 0;
+		printf("Rec Count %d\n", count);
+		return count;
+	}
+	return -1;
+}
+
+int _proto_main_get_timer_count(UTILS_HOSTPORT_STRUCT * hostp)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0, f = 0, count=0;
+		protocol_get_timer_count(hostp->hostname, hostp->port, &sock);
+		if (sock > 0)
+		{
+			sz = get_bytes_from_socket(sock, (uint8_t*)&count, sizeof(count), 5, 0, 0);
+			close(sock);
+		}
+		sock = 0;
+		printf("Timer Count %d\n", count);
+		return count;
+	}
+	return -1;
+}
+
+int _proto_main_get_chan_list(UTILS_HOSTPORT_STRUCT * hostp)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0, f = 0;
+		protocol_get_channel_list(hostp->hostname, hostp->port, &sock);
+		if (sock > 0)
+		{
+			PROTOCOL_CHANNEL_STRUCT p_channel= {0};
+			while(p_channel.is_last == 0)
+			{
+				sz = get_bytes_from_socket(sock, (uint8_t*)&p_channel, sizeof(PROTOCOL_CHANNEL_STRUCT), 5, 0, 0);
+				printf("[%d] Channel %d, Name: %s, xmltv_id: %s, i_url: %s (%d)\n", f, p_channel.num, p_channel.name, p_channel.xmltv_id, p_channel.icon_path,  p_channel.is_last);
+				f++;
+			}
+			close(sock);
+			return 0;
+		}
+	}
+	return -1;
+}
+
+int _proto_main_get_stream_info(UTILS_HOSTPORT_STRUCT * hostp)
+{
+	if (hostp)
+	{
+		int sock = 0, sz, rc =0, f = 0;
+		protocol_get_stream_info(hostp->hostname, hostp->port, &sock);
+		if (sock > 0)
+		{
+/*
+			PROTOCOL_STREAM_STRUCT stream = {0};
+			while(stream.is_last == 0)
+			{
+				sz = get_bytes_from_socket(sock, (uint8_t*)&stream, sizeof(stream), 5, 0, 0);
+				printf("Stream info, pid: %d -- type: %d (%d)\n", stream.pid, stream.type, stream.is_last);
+				f++;
+			}
+*/
+/*
+			PROTOCOL_CHANNEL_STRUCT p_channel= {0};
+			while(p_channel.is_last == 0)
+			{
+				sz = get_bytes_from_socket(sock, (uint8_t*)&p_channel, sizeof(PROTOCOL_CHANNEL_STRUCT), 5, 0, 0);
+				printf("[%d] Channel %d, Name: %s (%d)\n", f, p_channel.num, p_channel.name, p_channel.is_last);
+				f++;
+			}
+*/
+			close(sock);
+			return 0;
+		}
+	}
+	return -1;
+}
+
+int _proto_main_set_timer(UTILS_HOSTPORT_STRUCT * hostp, uint64_t chan, char *progid)
+{
+	if (hostp)
+	{
+		int sock;
+		TIMER_STRUCT timer = {0};
+
+		if (progid)
+		{
+			timer.id = TIMER_USE_DD_PROGID;
+			strncpy(timer.title, progid, TIEMR_STRUCT_MAX_STRLEN);
+//			printf("Sending prod_id: %s\n", timer.title);
+			//return 0;
+		}
+		else
+		{
+			timer.id = 5;
+			timer.status = 4;
+			timer.channel_num = chan;
+			strncpy(timer.channel_name,"ED1", TIEMR_STRUCT_MAX_STRLEN);
+			strncpy(timer.title,"Fake Title", TIEMR_STRUCT_MAX_STRLEN);
+			strncpy(timer.plot,"Faake Plot", TIEMR_STRUCT_MAX_STRLEN);
+			strncpy(timer.plot_outline,"Plot Lines", TIEMR_STRUCT_MAX_STRLEN);
+			strncpy(timer.genre,"Fake Genere1", TIEMR_STRUCT_MAX_STRLEN);
+			strncpy(timer.sub_genre,"Fake SebGenere1", TIEMR_STRUCT_MAX_STRLEN);
+
+			timer.start_epoch = time(NULL) + 2;
+			timer.end_epoch = timer.start_epoch + 13;
+		}
+		protocol_add_timer(hostp->hostname, hostp->port, (void*)&timer, sizeof(TIMER_STRUCT), &sock);
+
+		return 0;
+	}
+	return -1;
+}
+
+int main(int argc, char *argv[])
+{
+	signal(SIGPIPE,sigpipe_handler);
+	signal(SIGINT,sigint_handler);
+
+    get_opts(argc, argv);
+	if (remote_ip && proto_cmd > 0)
+	{
+		hostport = utils_split_host(remote_ip);
+//		printf("cmd: %d, ip: %s, port: %d\n", proto_cmd, hostport->hostname, hostport->port);
+
+		switch(proto_cmd)
+		{
+			case PROTO_MAIN_LIST_REC :
+//				printf("Getting Recordings List\n");
+				_proto_main_get_rec_list(hostport);
+			break;
+
+			case PROTO_MAIN_LIST_DEL :
+				
+				_proto_main_del_list(hostport, prog_id);
+			break;
+
+			case PROTO_MAIN_DEL_REC :
+				_proto_main_del_rec(hostport, prog_id);
+			break;
+
+			case PROTO_MAIN_LIST_CHAN :
+//				printf("Getting Channel List\n");
+				_proto_main_get_chan_list(hostport);
+			break;
+
+			case PROTO_MAIN_LIST_TIMER :
+//				printf("Getting Timer List\n");
+				_proto_main_get_timer_list(hostport);
+			break;
+
+			case PROTO_MAIN_SET_TIMER :
+//				printf("Setting Timer\n");
+				_proto_main_set_timer(hostport, 802, dd_progid);
+			break;
+
+			case PROTO_MAIN_LIST_CHAN_COUNT :
+//				printf("Setting Timer\n");
+				_proto_main_get_chan_count(hostport);
+			break;
+
+			case PROTO_MAIN_LIST_REC_COUNT :
+//				printf("Setting Timer\n");
+				_proto_main_get_rec_count(hostport);
+			break;
+
+			case PROTO_MAIN_LIST_TIMER_COUNT :
+//				printf("Setting Timer\n");
+				_proto_main_get_timer_count(hostport);
+			break;
+
+			case PROTO_MAIN_STREAM_INFO :
+
+//				printf("Setting Timer\n");
+				_proto_main_get_stream_info(hostport);
+			break;
+
+			case PROTO_MAIN_GET_EPG :
+			{
+				if (prog_id)
+				{
+					char tmp[255] = {0};
+					sprintf(tmp, "I%d.labs.zap2it.com", prog_id);
+					printf("Get EPG: %s\n", tmp);
+					_proto_main_get_epg(hostport, tmp);
+				}
+			}
+			break;
+		}
+	}
+//	_doconnect(argv[1], atoi(argv[2]), atoi(argv[3]), atoi(argv[4]), atoi(argv[5]) );
+//	usleep(1000 *1000 * 10);
+//	get_opts(argc, argv);
+//	printf("BYE!\n");
+	return 0;
+}
+#endif
+
diff -Naur stream.org/etp/protocol.h stream/etp/protocol.h
--- stream.org/etp/protocol.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/protocol.h	2013-09-02 01:18:17.906198136 -0400
@@ -0,0 +1,156 @@
+#ifndef __TUNER_PROTOCOL_STUFF
+#define __TUNER_PROTOCOL_STUFF
+
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+//#include "timers.h"
+
+#define PROTOCOL_INIT_STR				"eTUNER INIT"
+
+#define PROTOCOL_INIT_BAD				0xD0
+#define PROTOCOL_INIT_GOOD				0xD1
+
+#define PROTO_CMD_START					0xEDEDED00
+#define PROTO_CMD_FILTER				0x000000FF
+#define PROTO_CMD_MASK					0xFFFFFF00
+
+#define PROTO_INIT_CONNECTION			1
+#define PROTO_TUNE_AND_STREAM			2
+#define PROTO_SET_STREAM_POS			3
+#define PROTO_GET_STREAM_END_POS		4
+#define PROTO_GET_STREAM_POS			5
+#define PROTO_GET_STREAM_ID				6
+#define PROTO_QUERY_CHANNEL_COUNT		7
+#define PROTO_QUERY_CHANNEL_LIST		8
+#define PROTO_QUERY_TUNER_COUNT			9
+#define PROTO_TIMER_ADD					10
+#define PROTO_TIMER_DEL					11
+#define PROTO_QUERY_TIMER_LIST			12
+#define PROTO_QUERY_REC_LIST			13
+#define PROTO_QUERY_REC_COUNT			14
+#define PROTO_REC_PLAY					15
+#define PROTO_REC_DEL					16
+#define PROTO_GET_STREAM_START_POS		17
+#define PROTO_KEEP_ALIVE				18
+
+#define PROTO_GET_CHAN_EPG				19
+#define PROTO_QUERY_STREAM_INFO			20
+
+#define PROTO_SET_STREAM_SZ_POS			21
+#define PROTO_GET_STREAM_SZ_START_POS	22
+#define PROTO_GET_STREAM_SZ_END_POS		23
+#define PROTO_GET_STREAM_SZ_POS			24
+#define PROTO_GET_STREAM_START_POS2		25
+
+#define PROTO_QUERY_TIMER_COUNT			26
+
+
+struct protocol_channel_struct
+{
+	char 		name[255];
+	int32_t		id;
+	int32_t	 	num;
+	char 		xmltv_id[8096];
+	char 		icon_path[8096];
+	uint8_t		is_last;
+};
+typedef struct protocol_channel_struct PROTOCOL_CHANNEL_STRUCT;
+
+
+struct protocol_connection_struct
+{
+	char 		ip[2048];
+	uint16_t	port;
+	int			connect_timeout;
+	int			rw_timeout;
+	int			main_socket;
+	int			data_socket;
+};
+typedef struct protocol_connection_struct PROTOCOL_CONNECTION_STRUCT;
+
+
+
+/*
+struct protocol_stream_struct
+{
+	uint16_t 	pid;
+	uint16_t 	type;
+	uint8_t 	is_last;
+};
+typedef struct protocol_stream_struct PROTOCOL_STREAM_STRUCT;
+*/
+struct protocol_cmd_struct
+{
+	uint8_t cmd;
+	uint8_t *dataptr;
+	uint32_t dataptr_size;
+	int rc;
+};
+typedef struct protocol_cmd_struct PROTOCOL_CMD_STRUCT;
+
+// Defines
+PROTOCOL_CMD_STRUCT *protocol_get_cmd(int);
+
+int protocol_alive(char *, uint16_t, int);
+
+size_t protocol_set_tuner_channel(int, uint32_t);
+size_t protocol_set_tuner_time_pos(int, uint64_t);
+
+size_t protocol_get_tuner_time_pos(int);
+size_t protocol_get_tuner_time_endpos(int);
+size_t protocol_get_tuner_time_startpos(int);
+size_t protocol_get_tuner_time_startpos2(int);
+size_t protocol_get_tuner_id(int);
+size_t protocol_get_tuner_count(char *, uint16_t, int*);
+
+size_t protocol_send_tuner_init_status(int, uint8_t);
+size_t protocol_send_tuner_pos(int, uint64_t);
+size_t protocol_send_tuner_id(int, uint8_t);
+void protocol_free_cmd_struct(PROTOCOL_CMD_STRUCT *);
+
+size_t protocol_get_channel_count(char *, uint16_t, int *);
+size_t protocol_get_channel_list(char *, uint16_t, int*);
+
+size_t protocol_get_rec_count(char *, uint16_t, int *);
+size_t protocol_get_rec_list(char *, uint16_t, int*);
+//size_t protocol_del_rec_id(char *, uint16_t,  uint32_t, int *);
+size_t protocol_del_rec_id(int , uint32_t);
+size_t protocol_del_rec_id2(char *, uint16_t, uint32_t , int *);
+size_t protocol_play_rec_id(int, uint32_t);
+
+//size_t protocol_stop_rec_id(int, uint32_t);
+
+
+size_t protocol_get_timer_count(char *, uint16_t, int *);
+size_t protocol_get_timer_list(char *, uint16_t, int*);
+size_t protocol_add_timer(char *, uint16_t, uint8_t *, uint32_t, int *);
+size_t protocol_del_timer(int, uint32_t);
+size_t protocol_del_timer2(char *, uint16_t, uint32_t, int *);
+size_t protocol_stop_timer(int, uint32_t);
+
+size_t protocol_send_keepalive(int);
+
+size_t protocol_get_channel_epg(char *, uint16_t, int *, char *);
+
+size_t protocol_get_stream_info(char *, uint16_t, int *);
+size_t protocol_get_stream_info2(int);
+
+uint64_t protocol_get_tuner_size_startpos(int);
+uint64_t protocol_get_tuner_size_endpos(int);
+size_t protocol_get_tuner_size_pos(int);
+size_t protocol_set_tuner_size_pos(int, uint64_t);
+
+// End of Function Declarations
+#ifdef __cplusplus
+    }
+#endif
+
+
+#endif
+
diff -Naur stream.org/etp/utils.c stream/etp/utils.c
--- stream.org/etp/utils.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/utils.c	2013-09-02 01:18:17.906198136 -0400
@@ -0,0 +1,783 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <inttypes.h>
+#include <stdint.h>
+#include <memory.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <errno.h>
+#include <time.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <sys/time.h>
+
+
+#include "utils.h"
+//#include "fastmemcpy.h"
+
+#define RW_TIMEOUT 100
+
+static const uint32_t __crc_table[256] =
+{
+        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+        0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
+        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
+        0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
+        0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
+        0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
+        0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
+        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+        0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
+        0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
+        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
+        0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
+        0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
+        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
+        0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+        0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
+        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
+        0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
+        0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
+        0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
+        0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
+        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+        0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
+        0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
+        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
+        0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
+        0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
+        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
+        0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+        0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
+        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+};
+
+
+
+uint32_t crc32(uint8_t *data, uint32_t len)
+{
+	uint32_t i;
+	uint32_t crc = 0xFFFFFFFF;
+
+	for (i = 0; i < len; i++)
+		crc = (crc << 8) ^ __crc_table[((crc >> 24) ^ *data++) & 0xFF];
+	return crc;
+}
+
+
+
+
+unsigned int str_hash(char *str)
+{
+   unsigned int h;
+   unsigned char *p;
+
+   h = 0;
+   for (p = (unsigned char*)str; *p != '\0'; p++)
+      h = 37 * h + *p;
+   return h; // or, h % ARRAY_SIZE;
+}
+
+// ------------------------------
+TEXTFILE_IN_MEMORY * memfile_init(char *data, int len)
+{
+	TEXTFILE_IN_MEMORY * ret = NULL;
+	if (data && len)
+	{
+		ret = calloc(1, sizeof(TEXTFILE_IN_MEMORY));
+		ret->data = (uint8_t *)data;
+		ret->data_size = len;
+		if (1)
+		{
+			int i;
+			for(i=0; i < len; i++)
+			{
+				if(ret->data[i] == '\n')
+					ret->line_count++;
+			}
+		}
+	}
+	return ret;
+}
+
+int memfile_getline_count(TEXTFILE_IN_MEMORY *m)
+{
+	if (m)
+		return m->line_count;
+	return -1;
+}
+
+char * memfile_getnext_line(TEXTFILE_IN_MEMORY *m, int mem)
+{
+	char *ret = NULL;
+	if (m && m->pos < m->data_size)
+	{
+		int i;
+
+		for(i=m->pos; i < m->data_size; i++)
+		{
+			if (m->data[i] == '\n' || m->data[i] == '\0')
+			{
+				m->data[i] = '\0';
+				break;
+			}
+		}
+
+		if (i > m->pos)
+		{
+			ret = (char *) &m->data[m->pos];
+			m->pos = (i+1);
+		}
+	}
+	return ret;
+}
+
+int get_bytes_from_file(int handle, uint8_t * data, int len)
+{
+	return read(handle, data, len);
+
+}
+
+
+int get_bytes_from_socket(int handle, uint8_t * data, int len, long int s, long int us, uint32_t nonblock)
+{
+    int bytes_in = -1;
+	int tmp_count = 0;
+
+	if (handle >= 0 && data && len > 0)
+	{
+//		struct stat buffer = {0};
+		int bytes_read = 0, rc = 0, extra = 0;
+		int want = len, flags;
+
+		rc = select_wait_read(handle, s, us);
+		if (rc == -1)
+		{
+			printf("[UTILS] TimeOut on select(): %s (%d) (h: %d)\n", strerror(errno), errno, handle);
+            return -2;
+		}
+
+        bytes_in = 0;
+		tmp_count = 0;
+		bytes_read = 0;
+
+		if (nonblock)
+		{
+			flags = fcntl(handle, F_GETFL, 0);
+			fcntl(handle, F_SETFL, flags | O_NONBLOCK);
+		}
+
+        while (bytes_in < len)
+        {
+//			printf("1: %d -- %d [c: %d f: %d s: %d, r: %d]\n", want, ioctl(handle, FIONREAD, &status), S_ISCHR(buffer.st_mode),  S_ISFIFO(buffer.st_mode), S_ISSOCK(buffer.st_mode), S_ISREG(buffer.st_mode));
+//			printf("read1()\n");
+
+            bytes_read = read(handle, &data[bytes_in], want);
+//			printf("read2(): r: %d want: %d\n", bytes_read, want);
+			tmp_count++;
+
+            if (bytes_read == -1 || tmp_count > RW_TIMEOUT)
+			{
+				if (nonblock)
+				{
+//					printf("r4, errno: %d (%s) %d\n", errno, strerror(errno), tmp_count);
+
+					usleep(nonblock);
+					if ((tmp_count/1000)/1000 > 4)
+					{
+						printf("[UTILS] Non-block exit\n");
+						return -1;
+					}
+					continue;
+				}
+
+				if (bytes_in <= 0)
+					return -1;
+				else
+					return bytes_in;
+			}
+			else if (bytes_read == 0)
+			{
+				usleep(1000);
+			}
+
+            bytes_in += bytes_read;
+            want -= bytes_read;
+//			printf("2: %d\n", bytes_read);
+        }
+
+		if (nonblock)
+			fcntl(handle, F_SETFL, flags);
+    }
+    return bytes_in;
+}
+
+int write_bytes_to_socket(int handle, uint8_t * data, int len, long int s, long int us)
+{
+	int bytes_out = -1;
+	int tmp_count = 0;
+
+	if (handle >= 0 && data && len > 0)
+	{
+		int bytes_write = 0, rc = 0;
+		int want = len;
+
+		rc = select_wait_write(handle, s, us);
+		if (rc == -1)
+		{
+			printf("write_bytes_to_socket blag: %d %ld %ld\n", handle, s, us);
+			return rc;
+		}
+		bytes_out = 0;
+		tmp_count = 0;
+
+		while (bytes_out < len)
+		{
+			bytes_write = write(handle, &data[bytes_out], want);
+
+ 			if (bytes_write == -1 || tmp_count > RW_TIMEOUT)
+			{
+				if (bytes_out <= 0)
+					return -1;
+				else
+					return bytes_out;
+			}
+			else if (bytes_write == 0)
+			{
+				usleep(1000);
+			}
+			tmp_count++;
+
+			bytes_out += bytes_write;
+			want -= bytes_write;
+		}
+	}
+	return bytes_out;
+}
+
+off_t get_file_size(char *filename)
+{
+    if (filename)
+    {
+        struct stat st1 = {0};
+        stat(filename, &st1);
+        return st1.st_size;
+    }
+    return 0;
+}
+
+int8_t file_exists(char *filename)
+{
+	int fh = open(filename, O_RDONLY);
+	if (fh <= 0)
+		return -1;
+	close(fh);
+	return 0;
+}
+
+
+unsigned int htoi (const char *ptr)
+{
+	unsigned int value = 0;
+	char ch = *ptr;
+
+	while (ch == ' ' || ch == '\t')
+		ch = *(++ptr);
+
+	for (;;)
+	{
+		if (ch >= '0' && ch <= '9')
+			value = (value << 4) + (ch - '0');
+		else if (ch >= 'A' && ch <= 'F')
+			value = (value << 4) + (ch - 'A' + 10);
+		else if (ch >= 'a' && ch <= 'f')
+			value = (value << 4) + (ch - 'a' + 10);
+		else
+			return value;
+		ch = *(++ptr);
+	}
+}
+
+
+char *get_local_time(void)
+{
+	char *ret = calloc(1, 128);
+	char buffer[512] = {0};
+	time_t curtime = {0};
+	struct tm *loctime = NULL;
+	curtime = time (NULL);
+	loctime = localtime (&curtime);
+	strftime(ret, 128, "%I:%M%P", loctime);
+	return ret;
+}
+
+char *get_local_date(void)
+{
+	char *ret = calloc(1, 128);
+	char buffer[512] = {0};
+	time_t curtime = {0};
+	struct tm *loctime = NULL;
+	curtime = time (NULL);
+	loctime = localtime (&curtime);
+	strftime(ret, 128, "%x", loctime);
+	return ret;
+}
+
+
+int select_wait_read(int sock, int timeout_s, int timeout_u)
+{
+	fd_set readfds = {0};
+	struct timeval tv = {0};
+
+	tv.tv_sec = timeout_s;
+	tv.tv_usec = timeout_u;
+
+	FD_ZERO(&readfds);
+	FD_SET(sock, &readfds);
+
+	return select(sock+1, &readfds, NULL, NULL, &tv);
+}
+
+int select_wait_write(int sock, int timeout_s, int timeout_u)
+{
+	fd_set fds = {0};
+	struct timeval tv = {0};
+
+	tv.tv_sec = timeout_s;
+	tv.tv_usec = timeout_u;
+
+	FD_ZERO(&fds);
+	FD_SET(sock, &fds);
+
+	return select(sock+1, NULL, &fds, NULL, &tv);
+}
+
+
+int get_listen_socket(char * ip, uint16_t port)
+{
+	int server_socket = -1;
+	socklen_t address_len;
+	struct sockaddr_storage address;
+	struct addrinfo *addrinfo, hints;
+	char portnumber[10];
+	int yes = 1;
+
+	sprintf(portnumber, "%d", port);
+
+	memset((void *)&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_ADDRCONFIG | AI_PASSIVE;
+
+	if ((getaddrinfo(ip, portnumber, &hints, &addrinfo) != 0) || (addrinfo == NULL))
+	{
+		printf("[TUNER] getaddrinfo() failed..\n");
+		return -1;
+	}
+
+	if (addrinfo->ai_addrlen > sizeof(struct sockaddr_storage))
+	{
+		printf("[TUNER] Weird, failing..\n");
+		freeaddrinfo(addrinfo);
+		return -1;
+	}
+
+	address_len = addrinfo->ai_addrlen;
+	memcpy(&address, addrinfo->ai_addr, addrinfo->ai_addrlen);
+	freeaddrinfo(addrinfo);
+
+	server_socket = socket(address.ss_family, SOCK_STREAM, IPPROTO_TCP);
+	if (server_socket < 0)
+	{
+		printf("[TUNER] socket() failed\n");
+		return -1;
+	}
+
+	if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
+	{
+		printf("[TUNER] setsockopt failed\n");
+		return -1;
+	}
+
+	if (bind(server_socket, (struct sockaddr *) &address, address_len) < 0)
+	{
+		printf("[TUNER] Couldn't bind: %s\n", strerror(errno));
+		close(server_socket);
+		return -1;
+	}
+	listen(server_socket, 1);
+//	printf("[TUNER] Listen on IP/Port: %s/%s\n", ip, portnumber);
+	return server_socket;
+}
+
+
+size_t generic_curl_handler(void *buffer, size_t size, size_t nmemb, void *userp)
+{
+	UTILS_DATAPAIR_STRUCT *carg = NULL;
+
+	if (buffer && size > 0 && nmemb > 0 && userp)
+	{
+		size_t last_sz = 0;
+
+		carg = (UTILS_DATAPAIR_STRUCT *)userp;
+		last_sz = carg->data_size;
+
+		if (carg->data)
+		{
+			carg->data = realloc(carg->data, carg->data_size + nmemb);
+			carg->data_size += nmemb;
+		}
+		else
+		{
+			carg->data = calloc(1, nmemb);
+			carg->data_size = nmemb;
+		}
+		memcpy(carg->data + last_sz, buffer, nmemb);
+	}
+	return nmemb;
+}
+
+uint32_t get_time_ms(void)
+{
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (uint32_t)((tv.tv_sec) * 1000 + (tv.tv_usec) / 1000);
+}
+
+
+size_t get_bufsize(int handle)
+{
+	size_t bsize = 0;
+	struct stat sbuf = {0};
+	if (fstat(handle, &sbuf) == 0)
+		bsize = MAX(sbuf.st_blksize, BUFSIZ);
+
+	return bsize;
+}
+
+uint32_t get_nearest_page_size(uint32_t sz, uint32_t packet_size)
+{
+	uint32_t ret = sz;
+	int pgsize = getpagesize();
+
+	if (pgsize)
+	{
+		pgsize *= packet_size;
+		ret = (sz/pgsize) * pgsize;
+	}
+	return ret;
+}
+
+int doconnect(char *ip, uint16_t port, int timeout)
+{
+	int rc = -1;
+
+	if (ip && port)
+	{
+		int flags = -1;
+		struct addrinfo hints = {0}, *res = NULL;
+		int sock = 0, sz;
+		char service[13] = {0};
+		snprintf(service, 12, "%d", port);
+
+		hints.ai_socktype = SOCK_STREAM;
+		hints.ai_family = AF_INET;
+
+		sz = getaddrinfo(ip, service, &hints, &res);
+		if (sz != 0)
+		{
+			printf("getaddrinfo failed\n");
+			return -1;
+		}
+
+		sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (sock == -1)
+		{
+			printf("BLAAAAAH\n");
+			return -1;
+		}
+
+		if (timeout > 0)
+		{
+			flags = fcntl(sock, F_GETFL, 0);
+			fcntl(sock, F_SETFL, flags | O_NONBLOCK);
+		}
+
+		sz = connect(sock,res->ai_addr, res->ai_addrlen);
+
+		if (timeout > 0)
+		{
+			if (select_wait_write(sock, timeout, 0) == 1)
+			{
+				int so_error;
+				socklen_t len = sizeof so_error;
+				getsockopt(sock, SOL_SOCKET, SO_ERROR, &so_error, &len);
+//				printf("HERE!! %d\n", so_error);
+				if (so_error == 0)
+				{
+					fcntl(sock, F_SETFL, flags);
+					return sock;
+				}
+			}
+
+			close(sock);
+			sz = -1;
+		}
+
+		if (sz == 0)
+		{
+			return sock;
+		}
+		else
+		{
+			printf("[UTILS] Problem connecting: %s -- %d\n", strerror(errno), sz);
+		}
+
+	}
+	return -1;
+}
+
+UTILS_HOSTPORT_STRUCT * utils_split_host(char *in)
+{
+	UTILS_HOSTPORT_STRUCT * ret = NULL;
+	if (in)
+	{
+		ret = calloc(1, sizeof(UTILS_HOSTPORT_STRUCT));
+		if (ret)
+		{
+			char *tmpp = NULL;
+			char *host = strdup(in);
+			int j, sz = strlen(host);
+
+			for (j=0; j < sz; j++)
+			{
+				if (host[j] == ':')
+				{
+					host[j] = '\0';
+					tmpp = &host[j+1];
+				}
+				else if (host[j] == '/')
+				{
+					host[j] = '\0';
+				}
+			}
+			strncpy(ret->hostname, host, 4095);
+			ret->port = atoi(tmpp);
+			free(host);
+		}
+	}
+	return ret;
+}
+
+
+int utils_free_datapair(UTILS_DATAPAIR_STRUCT *carg)
+{
+	if (carg)
+	{
+		if (carg->data)
+			free(carg->data);
+		free(carg);
+		return 0;
+	}
+	return -1;
+}
+
+int32_t utils_ll_get_count(UTILS_LINKEDLIST_STRUCT *list)
+{
+	if (list)
+		return list->count;
+	return -1;
+}
+
+UTILS_DATAPAIR_STRUCT *utils_ll_get_first(UTILS_LINKEDLIST_STRUCT *list)
+{
+	if (list)
+		return list->first;
+	return NULL;
+}
+
+int utils_ll_uninit(UTILS_LINKEDLIST_STRUCT *list)
+{
+	if (list)
+	{
+		UTILS_DATAPAIR_STRUCT *data_pair  = NULL, *del_pair = NULL;
+		data_pair = utils_ll_get_first(list);
+		while(data_pair)
+		{
+			del_pair = data_pair;
+			data_pair = utils_ll_get_next(data_pair);
+			if (del_pair->data)
+				free(del_pair->data);
+			utils_ll_del(list, del_pair);
+		}
+
+		free(list);
+		return 0;
+	}
+	return 1;
+}
+
+UTILS_DATAPAIR_STRUCT *utils_ll_get_next(UTILS_DATAPAIR_STRUCT *data)
+{
+	if (data)
+		return data->next;
+	return NULL;
+}
+
+UTILS_LINKEDLIST_STRUCT * utils_ll_init(void)
+{
+	UTILS_LINKEDLIST_STRUCT *ret = calloc(1, sizeof(UTILS_LINKEDLIST_STRUCT));
+
+	return ret;
+}
+
+UTILS_DATAPAIR_STRUCT *utils_ll_add(UTILS_LINKEDLIST_STRUCT *list, void *data, uint32_t data_size)
+{
+	if (list && data)
+	{
+		UTILS_DATAPAIR_STRUCT *u = calloc(1, sizeof(UTILS_DATAPAIR_STRUCT));
+
+		u->data = data;
+		u->data_size = data_size;
+
+		if (!list->first)
+		{
+			list->first = list->current = u;
+		}
+		else
+		{
+			list->current->next = u;
+			list->current = u;
+		}
+		list->count++;
+		return u;
+	}
+	return NULL;
+}
+
+int utils_ll_del(UTILS_LINKEDLIST_STRUCT *list, UTILS_DATAPAIR_STRUCT *data)
+{
+	if (list && data)
+	{
+		UTILS_DATAPAIR_STRUCT *u = list->first, *del = NULL, *prev = NULL;
+		while (u)
+		{
+			if (u == data)
+			{
+				del = u;
+				if (u == list->first)
+					list->first = list->first->next;
+				else
+					prev->next = u->next;
+
+				if (del)
+				{
+					free(del);
+					list->count--;
+				}
+			}
+			prev = u;
+			u = u->next;
+		}
+	}
+	return 1;
+}
+
+
+UTILS_LOG_STRUCT *utils_log_init(void)
+{
+	UTILS_LOG_STRUCT *ret = calloc(1, sizeof(*ret));
+	if (ret)
+	{
+		ret->log = utils_ll_init();
+		pthread_mutex_init(&ret->log_lock, NULL);
+	}
+	return ret;
+}
+
+
+char * utils_log_getmsg(UTILS_LOG_STRUCT *log)
+{
+	char * ret = NULL;
+	pthread_mutex_lock(&log->log_lock);
+	if (log)
+	{
+		UTILS_DATAPAIR_STRUCT *data_pair  = utils_ll_get_first(log->log);
+		if (data_pair)
+		{
+			ret = (char *)data_pair->data;
+			utils_ll_del(log->log, data_pair);
+		}
+
+	}
+	pthread_mutex_unlock(&log->log_lock);
+	return ret;
+}
+
+void utils_log_print(UTILS_LOG_STRUCT *log, const char *fmt, ...)
+{
+//	pthread_mutex_lock(&log->log_lock);
+	if (log && fmt)
+	{
+		va_list ap;
+		va_start(ap, fmt);
+		utils_log_vprint(log, fmt, ap);
+		va_end(ap);
+	}
+//	pthread_mutex_unlock(&log->log_lock);
+
+}
+
+void utils_log_vprint(UTILS_LOG_STRUCT *log, const char *fmt, va_list ap)
+{
+	pthread_mutex_lock(&log->log_lock);
+	if (log && fmt)
+	{
+		char *msg = calloc(1, UTILS_MAX_LOG_LEN);
+		vsnprintf(msg, UTILS_MAX_LOG_LEN-1, fmt, ap);
+//		utils_ll_add(log->log, msg, UTILS_MAX_LOG_LEN);
+		printf("%s", msg);
+	}
+	pthread_mutex_unlock(&log->log_lock);
+
+}
+
+
+int utils_mutex_init(pthread_mutex_t *m, pthread_mutexattr_t *attr, int type)
+{
+//	if (type == 0)
+//		type = PTHREAD_MUTEX_RECURSIVE;
+
+	if (m)
+	{
+		if (attr)
+		{
+			pthread_mutexattr_init(attr);
+			pthread_mutexattr_settype(attr, type);
+		}
+		return pthread_mutex_init(m, attr);
+	}
+	return -1;
+}
+
+#ifdef _MAIN_
+
+int main(int argc, char *argv[])
+{
+	return 0;
+}
+#endif
diff -Naur stream.org/etp/utils.h stream/etp/utils.h
--- stream.org/etp/utils.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/utils.h	2013-09-02 01:18:17.907198136 -0400
@@ -0,0 +1,145 @@
+#ifndef __UTILS_STUFF
+#define __UTILS_STUFF
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+#include <stdint.h>
+#include <inttypes.h>
+
+#define OUTPUT_FILE_MODE		0666
+#define BYTE_SIZE				8
+
+
+#define	UTILS_MAX_LOG_LEN		4096
+#define MAX_33BITS				0x1FFFFFFFF
+
+#define SLEEP_250MS				usleep(250000);
+#define SLEEP_100MS				usleep(100000);
+#define SLEEP_50MS				usleep(50000);
+#define SLEEP_1MS				usleep(1000);
+
+#define MAX_FILENAME_SIZE		(4096*2)
+#define FILE_INPUT_READ_MIN		1000000
+#define FILE_INPUT_STDIN		"stdin"
+#define FILE_INPUT_STDIN_FD		0
+
+#define FILE_OUTPUT_STDOUT		"stdout"
+#define FILE_OUTPUT_STDOUT_FD		1
+
+#ifndef MIN
+#define MIN(a,b) ( (a)<(b) ? (a) : (b) )
+#endif
+
+#ifndef MAX
+#define MAX(a,b) ( (a)>(b) ? (a) : (b) )
+#endif
+
+struct utils_datapair_struct
+{
+	uint8_t * data;
+	uint32_t data_size;
+	struct utils_datapair_struct *next;
+//	void * extra;
+};
+typedef struct utils_datapair_struct UTILS_DATAPAIR_STRUCT;
+
+struct utils_linkedlist_struct
+{
+	UTILS_DATAPAIR_STRUCT *first;
+	UTILS_DATAPAIR_STRUCT *current;
+	int32_t count;
+};
+typedef struct utils_linkedlist_struct UTILS_LINKEDLIST_STRUCT;
+
+
+struct utils_hostport_struct
+{
+	char hostname[4096];
+	uint16_t port;
+//	void * extra;
+};
+typedef struct utils_hostport_struct UTILS_HOSTPORT_STRUCT;
+
+struct utils_log_struct
+{
+	UTILS_LINKEDLIST_STRUCT *log;
+	pthread_mutex_t log_lock;
+};
+typedef struct utils_log_struct UTILS_LOG_STRUCT;
+
+
+// --------------------------
+struct textfile_in_memory
+{
+    int pos;
+    int line_count;
+    int data_size;
+    uint8_t *data;
+};
+typedef struct textfile_in_memory TEXTFILE_IN_MEMORY;
+
+struct textfile_memline
+{
+	int line_num;
+	char *line_data;
+};
+typedef struct textfile_memline TEXTFILE_MEMLINE;
+
+// Function declarations
+// **************************************
+TEXTFILE_IN_MEMORY * memfile_init(char *, int);
+char * memfile_getnext_line(TEXTFILE_IN_MEMORY *, int);
+int memfile_getline_count(TEXTFILE_IN_MEMORY *);
+
+
+int8_t file_exists(char *);
+off_t get_file_size(char *);
+int write_bytes_to_socket(int, uint8_t *, int, long int, long int);
+int get_bytes_from_socket(int, uint8_t *, int, long int, long int, uint32_t);
+int get_bytes_from_file(int, uint8_t *, int);
+
+int select_wait_read(int, int, int);
+int select_wait_write(int, int, int);
+int get_listen_socket(char *, uint16_t);
+int doconnect(char *, uint16_t, int);
+//int doconnect2(char *, uint16_t);
+size_t generic_curl_handler(void *, size_t, size_t, void *);
+unsigned int htoi (const char *);
+
+unsigned int str_hash(char *);
+
+char *get_local_time(void);
+char *get_local_date(void);
+uint32_t crc32(uint8_t *, uint32_t);
+size_t get_bufsize(int);
+uint32_t get_nearest_page_size(uint32_t, uint32_t);
+uint32_t get_time_ms(void);
+int utils_free_datapair(UTILS_DATAPAIR_STRUCT *);
+UTILS_HOSTPORT_STRUCT * utils_split_host(char *);
+//uint64_t str_to_epoch(char *);
+
+
+int32_t utils_ll_get_count(UTILS_LINKEDLIST_STRUCT *);
+UTILS_DATAPAIR_STRUCT *utils_ll_get_first(UTILS_LINKEDLIST_STRUCT *);
+UTILS_DATAPAIR_STRUCT *utils_ll_get_next(UTILS_DATAPAIR_STRUCT *);
+UTILS_LINKEDLIST_STRUCT * utils_ll_init(void);
+int utils_ll_del(UTILS_LINKEDLIST_STRUCT *, UTILS_DATAPAIR_STRUCT *);
+UTILS_DATAPAIR_STRUCT *utils_ll_add(UTILS_LINKEDLIST_STRUCT *, void *, uint32_t);
+int utils_ll_uninit(UTILS_LINKEDLIST_STRUCT *);
+
+
+UTILS_LOG_STRUCT *utils_log_init(void);
+char * utils_log_getmsg(UTILS_LOG_STRUCT *);
+void utils_log_print(UTILS_LOG_STRUCT *, const char *, ...);
+void utils_log_vprint(UTILS_LOG_STRUCT *, const char *, va_list);
+
+int utils_mutex_init(pthread_mutex_t *, pthread_mutexattr_t *, int);
+
+#ifdef __cplusplus
+    }
+#endif
+
+#endif
+
