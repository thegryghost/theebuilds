diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index 5978906555c4..66c10fc3f3b5 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -529,6 +529,7 @@ add_library(core STATIC
     hle/service/hid/hid_server.h
     hle/service/hid/hid_system_server.cpp
     hle/service/hid/hid_system_server.h
+    hle/service/hid/hid_util.h
     hle/service/hid/hidbus.cpp
     hle/service/hid/hidbus.h
     hle/service/hid/irs.cpp
@@ -540,8 +541,8 @@ add_library(core STATIC
     hle/service/hid/xcd.cpp
     hle/service/hid/xcd.h
     hle/service/hid/errors.h
-    hle/service/hid/controllers/console_sixaxis.cpp
-    hle/service/hid/controllers/console_sixaxis.h
+    hle/service/hid/controllers/console_six_axis.cpp
+    hle/service/hid/controllers/console_six_axis.h
     hle/service/hid/controllers/controller_base.cpp
     hle/service/hid/controllers/controller_base.h
     hle/service/hid/controllers/debug_pad.cpp
@@ -556,6 +557,10 @@ add_library(core STATIC
     hle/service/hid/controllers/npad.h
     hle/service/hid/controllers/palma.cpp
     hle/service/hid/controllers/palma.h
+    hle/service/hid/controllers/seven_six_axis.cpp
+    hle/service/hid/controllers/seven_six_axis.h
+    hle/service/hid/controllers/six_axis.cpp
+    hle/service/hid/controllers/six_axis.h
     hle/service/hid/controllers/stubbed.cpp
     hle/service/hid/controllers/stubbed.h
     hle/service/hid/controllers/touchscreen.cpp
diff --git a/src/core/hid/emulated_controller.cpp b/src/core/hid/emulated_controller.cpp
index 34927cddd4f2..a22015ada9c4 100644
--- a/src/core/hid/emulated_controller.cpp
+++ b/src/core/hid/emulated_controller.cpp
@@ -8,6 +8,7 @@
 #include "common/thread.h"
 #include "core/hid/emulated_controller.h"
 #include "core/hid/input_converter.h"
+#include "core/hle/service/hid/hid_util.h"
 
 namespace Core::HID {
 constexpr s32 HID_JOYSTICK_MAX = 0x7fff;
@@ -82,7 +83,7 @@ Settings::ControllerType EmulatedController::MapNPadToSettingsType(NpadStyleInde
 }
 
 void EmulatedController::ReloadFromSettings() {
-    const auto player_index = NpadIdTypeToIndex(npad_id_type);
+    const auto player_index = Service::HID::NpadIdTypeToIndex(npad_id_type);
     const auto& player = Settings::values.players.GetValue()[player_index];
 
     for (std::size_t index = 0; index < player.buttons.size(); ++index) {
@@ -118,7 +119,7 @@ void EmulatedController::ReloadFromSettings() {
 }
 
 void EmulatedController::ReloadColorsFromSettings() {
-    const auto player_index = NpadIdTypeToIndex(npad_id_type);
+    const auto player_index = Service::HID::NpadIdTypeToIndex(npad_id_type);
     const auto& player = Settings::values.players.GetValue()[player_index];
 
     // Avoid updating colors if overridden by physical controller
@@ -215,7 +216,7 @@ void EmulatedController::LoadDevices() {
 }
 
 void EmulatedController::LoadTASParams() {
-    const auto player_index = NpadIdTypeToIndex(npad_id_type);
+    const auto player_index = Service::HID::NpadIdTypeToIndex(npad_id_type);
     Common::ParamPackage common_params{};
     common_params.Set("engine", "tas");
     common_params.Set("port", static_cast<int>(player_index));
@@ -264,7 +265,7 @@ void EmulatedController::LoadTASParams() {
 }
 
 void EmulatedController::LoadVirtualGamepadParams() {
-    const auto player_index = NpadIdTypeToIndex(npad_id_type);
+    const auto player_index = Service::HID::NpadIdTypeToIndex(npad_id_type);
     Common::ParamPackage common_params{};
     common_params.Set("engine", "virtual_gamepad");
     common_params.Set("port", static_cast<int>(player_index));
@@ -615,7 +616,7 @@ bool EmulatedController::IsConfiguring() const {
 }
 
 void EmulatedController::SaveCurrentConfig() {
-    const auto player_index = NpadIdTypeToIndex(npad_id_type);
+    const auto player_index = Service::HID::NpadIdTypeToIndex(npad_id_type);
     auto& player = Settings::values.players.GetValue()[player_index];
     player.connected = is_connected;
     player.controller_type = MapNPadToSettingsType(npad_type);
@@ -1212,7 +1213,7 @@ bool EmulatedController::SetVibration(std::size_t device_index, VibrationValue v
     if (!output_devices[device_index]) {
         return false;
     }
-    const auto player_index = NpadIdTypeToIndex(npad_id_type);
+    const auto player_index = Service::HID::NpadIdTypeToIndex(npad_id_type);
     const auto& player = Settings::values.players.GetValue()[player_index];
     const f32 strength = static_cast<f32>(player.vibration_strength) / 100.0f;
 
@@ -1238,7 +1239,7 @@ bool EmulatedController::SetVibration(std::size_t device_index, VibrationValue v
 }
 
 bool EmulatedController::IsVibrationEnabled(std::size_t device_index) {
-    const auto player_index = NpadIdTypeToIndex(npad_id_type);
+    const auto player_index = Service::HID::NpadIdTypeToIndex(npad_id_type);
     const auto& player = Settings::values.players.GetValue()[player_index];
 
     if (!player.vibration_enabled) {
@@ -1648,7 +1649,7 @@ void EmulatedController::SetNpadStyleIndex(NpadStyleIndex npad_type_) {
     }
     if (is_connected) {
         LOG_WARNING(Service_HID, "Controller {} type changed while it's connected",
-                    NpadIdTypeToIndex(npad_id_type));
+                    Service::HID::NpadIdTypeToIndex(npad_id_type));
     }
     npad_type = npad_type_;
 }
diff --git a/src/core/hid/hid_core.cpp b/src/core/hid/hid_core.cpp
index cf53c04d9a63..2cf25a870b9c 100644
--- a/src/core/hid/hid_core.cpp
+++ b/src/core/hid/hid_core.cpp
@@ -6,6 +6,7 @@
 #include "core/hid/emulated_controller.h"
 #include "core/hid/emulated_devices.h"
 #include "core/hid/hid_core.h"
+#include "core/hle/service/hid/hid_util.h"
 
 namespace Core::HID {
 
@@ -98,11 +99,11 @@ const EmulatedDevices* HIDCore::GetEmulatedDevices() const {
 }
 
 EmulatedController* HIDCore::GetEmulatedControllerByIndex(std::size_t index) {
-    return GetEmulatedController(IndexToNpadIdType(index));
+    return GetEmulatedController(Service::HID::IndexToNpadIdType(index));
 }
 
 const EmulatedController* HIDCore::GetEmulatedControllerByIndex(std::size_t index) const {
-    return GetEmulatedController(IndexToNpadIdType(index));
+    return GetEmulatedController(Service::HID::IndexToNpadIdType(index));
 }
 
 void HIDCore::SetSupportedStyleTag(NpadStyleTag style_tag) {
diff --git a/src/core/hid/hid_types.h b/src/core/hid/hid_types.h
index 70fcc6b696a6..4bf285f361a1 100644
--- a/src/core/hid/hid_types.h
+++ b/src/core/hid/hid_types.h
@@ -8,6 +8,7 @@
 #include "common/common_types.h"
 #include "common/point.h"
 #include "common/uuid.h"
+#include "common/vector_math.h"
 
 namespace Core::HID {
 
@@ -598,6 +599,29 @@ struct SixAxisSensorIcInformation {
 static_assert(sizeof(SixAxisSensorIcInformation) == 0xC8,
               "SixAxisSensorIcInformation is an invalid size");
 
+// This is nn::hid::SixAxisSensorAttribute
+struct SixAxisSensorAttribute {
+    union {
+        u32 raw{};
+        BitField<0, 1, u32> is_connected;
+        BitField<1, 1, u32> is_interpolated;
+    };
+};
+static_assert(sizeof(SixAxisSensorAttribute) == 4, "SixAxisSensorAttribute is an invalid size");
+
+// This is nn::hid::SixAxisSensorState
+struct SixAxisSensorState {
+    s64 delta_time{};
+    s64 sampling_number{};
+    Common::Vec3f accel{};
+    Common::Vec3f gyro{};
+    Common::Vec3f rotation{};
+    std::array<Common::Vec3f, 3> orientation{};
+    SixAxisSensorAttribute attribute{};
+    INSERT_PADDING_BYTES(4); // Reserved
+};
+static_assert(sizeof(SixAxisSensorState) == 0x60, "SixAxisSensorState is an invalid size");
+
 // This is nn::hid::VibrationDeviceHandle
 struct VibrationDeviceHandle {
     NpadStyleIndex npad_type{NpadStyleIndex::None};
@@ -708,60 +732,4 @@ struct UniquePadId {
 };
 static_assert(sizeof(UniquePadId) == 0x8, "UniquePadId is an invalid size");
 
-/// Converts a NpadIdType to an array index.
-constexpr size_t NpadIdTypeToIndex(NpadIdType npad_id_type) {
-    switch (npad_id_type) {
-    case NpadIdType::Player1:
-        return 0;
-    case NpadIdType::Player2:
-        return 1;
-    case NpadIdType::Player3:
-        return 2;
-    case NpadIdType::Player4:
-        return 3;
-    case NpadIdType::Player5:
-        return 4;
-    case NpadIdType::Player6:
-        return 5;
-    case NpadIdType::Player7:
-        return 6;
-    case NpadIdType::Player8:
-        return 7;
-    case NpadIdType::Handheld:
-        return 8;
-    case NpadIdType::Other:
-        return 9;
-    default:
-        return 0;
-    }
-}
-
-/// Converts an array index to a NpadIdType
-constexpr NpadIdType IndexToNpadIdType(size_t index) {
-    switch (index) {
-    case 0:
-        return NpadIdType::Player1;
-    case 1:
-        return NpadIdType::Player2;
-    case 2:
-        return NpadIdType::Player3;
-    case 3:
-        return NpadIdType::Player4;
-    case 4:
-        return NpadIdType::Player5;
-    case 5:
-        return NpadIdType::Player6;
-    case 6:
-        return NpadIdType::Player7;
-    case 7:
-        return NpadIdType::Player8;
-    case 8:
-        return NpadIdType::Handheld;
-    case 9:
-        return NpadIdType::Other;
-    default:
-        return NpadIdType::Invalid;
-    }
-}
-
 } // namespace Core::HID
diff --git a/src/core/hid/input_interpreter.cpp b/src/core/hid/input_interpreter.cpp
index 11359f318c51..a6bdd28f2ae3 100644
--- a/src/core/hid/input_interpreter.cpp
+++ b/src/core/hid/input_interpreter.cpp
@@ -13,14 +13,14 @@ InputInterpreter::InputInterpreter(Core::System& system)
     : npad{system.ServiceManager()
                .GetService<Service::HID::IHidServer>("hid")
                ->GetResourceManager()
-               ->GetController<Service::HID::Controller_NPad>(Service::HID::HidController::NPad)} {
+               ->GetNpad()} {
     ResetButtonStates();
 }
 
 InputInterpreter::~InputInterpreter() = default;
 
 void InputInterpreter::PollInput() {
-    const auto button_state = npad.GetAndResetPressState();
+    const auto button_state = npad->GetAndResetPressState();
 
     previous_index = current_index;
     current_index = (current_index + 1) % button_states.size();
diff --git a/src/core/hid/input_interpreter.h b/src/core/hid/input_interpreter.h
index 8c521b38188e..3569aac939c0 100644
--- a/src/core/hid/input_interpreter.h
+++ b/src/core/hid/input_interpreter.h
@@ -16,7 +16,7 @@ enum class NpadButton : u64;
 }
 
 namespace Service::HID {
-class Controller_NPad;
+class NPad;
 }
 
 /**
@@ -101,7 +101,7 @@ class InputInterpreter {
     }
 
 private:
-    Service::HID::Controller_NPad& npad;
+    std::shared_ptr<Service::HID::NPad> npad;
 
     /// Stores 9 consecutive button states polled from HID.
     std::array<Core::HID::NpadButton, 9> button_states{};
diff --git a/src/core/hle/service/hid/controllers/console_six_axis.cpp b/src/core/hle/service/hid/controllers/console_six_axis.cpp
new file mode 100644
index 000000000000..b2bf1d78d2e5
--- /dev/null
+++ b/src/core/hle/service/hid/controllers/console_six_axis.cpp
@@ -0,0 +1,42 @@
+// SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include "core/core.h"
+#include "core/core_timing.h"
+#include "core/hid/emulated_console.h"
+#include "core/hid/hid_core.h"
+#include "core/hle/service/hid/controllers/console_six_axis.h"
+#include "core/memory.h"
+
+namespace Service::HID {
+constexpr std::size_t SHARED_MEMORY_OFFSET = 0x3C200;
+
+ConsoleSixAxis::ConsoleSixAxis(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
+    : ControllerBase{hid_core_} {
+    console = hid_core.GetEmulatedConsole();
+    static_assert(SHARED_MEMORY_OFFSET + sizeof(ConsoleSharedMemory) < shared_memory_size,
+                  "ConsoleSharedMemory is bigger than the shared memory");
+    shared_memory = std::construct_at(
+        reinterpret_cast<ConsoleSharedMemory*>(raw_shared_memory_ + SHARED_MEMORY_OFFSET));
+}
+
+ConsoleSixAxis::~ConsoleSixAxis() = default;
+
+void ConsoleSixAxis::OnInit() {}
+
+void ConsoleSixAxis::OnRelease() {}
+
+void ConsoleSixAxis::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    if (!IsControllerActivated()) {
+        return;
+    }
+
+    const auto motion_status = console->GetMotion();
+
+    shared_memory->sampling_number++;
+    shared_memory->is_seven_six_axis_sensor_at_rest = motion_status.is_at_rest;
+    shared_memory->verticalization_error = motion_status.verticalization_error;
+    shared_memory->gyro_bias = motion_status.gyro_bias;
+}
+
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/console_six_axis.h b/src/core/hle/service/hid/controllers/console_six_axis.h
new file mode 100644
index 000000000000..5b7c6a29ae31
--- /dev/null
+++ b/src/core/hle/service/hid/controllers/console_six_axis.h
@@ -0,0 +1,43 @@
+// SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#pragma once
+
+#include "common/vector_math.h"
+#include "core/hle/service/hid/controllers/controller_base.h"
+
+namespace Core::HID {
+class EmulatedConsole;
+} // namespace Core::HID
+
+namespace Service::HID {
+class ConsoleSixAxis final : public ControllerBase {
+public:
+    explicit ConsoleSixAxis(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
+    ~ConsoleSixAxis() override;
+
+    // Called when the controller is initialized
+    void OnInit() override;
+
+    // When the controller is released
+    void OnRelease() override;
+
+    // When the controller is requesting an update for the shared memory
+    void OnUpdate(const Core::Timing::CoreTiming& core_timing) override;
+
+private:
+    // This is nn::hid::detail::ConsoleSixAxisSensorSharedMemoryFormat
+    struct ConsoleSharedMemory {
+        u64 sampling_number{};
+        bool is_seven_six_axis_sensor_at_rest{};
+        INSERT_PADDING_BYTES(3); // padding
+        f32 verticalization_error{};
+        Common::Vec3f gyro_bias{};
+        INSERT_PADDING_BYTES(4); // padding
+    };
+    static_assert(sizeof(ConsoleSharedMemory) == 0x20, "ConsoleSharedMemory is an invalid size");
+
+    ConsoleSharedMemory* shared_memory = nullptr;
+    Core::HID::EmulatedConsole* console = nullptr;
+};
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/debug_pad.cpp b/src/core/hle/service/hid/controllers/debug_pad.cpp
index 8ec9f4a95f57..9de19ebfc880 100644
--- a/src/core/hle/service/hid/controllers/debug_pad.cpp
+++ b/src/core/hle/service/hid/controllers/debug_pad.cpp
@@ -13,7 +13,7 @@
 namespace Service::HID {
 constexpr std::size_t SHARED_MEMORY_OFFSET = 0x00000;
 
-Controller_DebugPad::Controller_DebugPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
+DebugPad::DebugPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
     : ControllerBase{hid_core_} {
     static_assert(SHARED_MEMORY_OFFSET + sizeof(DebugPadSharedMemory) < shared_memory_size,
                   "DebugPadSharedMemory is bigger than the shared memory");
@@ -22,13 +22,13 @@ Controller_DebugPad::Controller_DebugPad(Core::HID::HIDCore& hid_core_, u8* raw_
     controller = hid_core.GetEmulatedController(Core::HID::NpadIdType::Other);
 }
 
-Controller_DebugPad::~Controller_DebugPad() = default;
+DebugPad::~DebugPad() = default;
 
-void Controller_DebugPad::OnInit() {}
+void DebugPad::OnInit() {}
 
-void Controller_DebugPad::OnRelease() {}
+void DebugPad::OnRelease() {}
 
-void Controller_DebugPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void DebugPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     if (!IsControllerActivated()) {
         shared_memory->debug_pad_lifo.buffer_count = 0;
         shared_memory->debug_pad_lifo.buffer_tail = 0;
diff --git a/src/core/hle/service/hid/controllers/debug_pad.h b/src/core/hle/service/hid/controllers/debug_pad.h
index 68ff0ea792c5..5566dba774fd 100644
--- a/src/core/hle/service/hid/controllers/debug_pad.h
+++ b/src/core/hle/service/hid/controllers/debug_pad.h
@@ -15,10 +15,10 @@ struct AnalogStickState;
 } // namespace Core::HID
 
 namespace Service::HID {
-class Controller_DebugPad final : public ControllerBase {
+class DebugPad final : public ControllerBase {
 public:
-    explicit Controller_DebugPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
-    ~Controller_DebugPad() override;
+    explicit DebugPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
+    ~DebugPad() override;
 
     // Called when the controller is initialized
     void OnInit() override;
diff --git a/src/core/hle/service/hid/controllers/gesture.cpp b/src/core/hle/service/hid/controllers/gesture.cpp
index 63eecd42b4aa..59b2ec73c4c8 100644
--- a/src/core/hle/service/hid/controllers/gesture.cpp
+++ b/src/core/hle/service/hid/controllers/gesture.cpp
@@ -23,7 +23,7 @@ constexpr f32 Square(s32 num) {
     return static_cast<f32>(num * num);
 }
 
-Controller_Gesture::Controller_Gesture(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
+Gesture::Gesture(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
     : ControllerBase(hid_core_) {
     static_assert(SHARED_MEMORY_OFFSET + sizeof(GestureSharedMemory) < shared_memory_size,
                   "GestureSharedMemory is bigger than the shared memory");
@@ -31,17 +31,17 @@ Controller_Gesture::Controller_Gesture(Core::HID::HIDCore& hid_core_, u8* raw_sh
         reinterpret_cast<GestureSharedMemory*>(raw_shared_memory_ + SHARED_MEMORY_OFFSET));
     console = hid_core.GetEmulatedConsole();
 }
-Controller_Gesture::~Controller_Gesture() = default;
+Gesture::~Gesture() = default;
 
-void Controller_Gesture::OnInit() {
+void Gesture::OnInit() {
     shared_memory->gesture_lifo.buffer_count = 0;
     shared_memory->gesture_lifo.buffer_tail = 0;
     force_update = true;
 }
 
-void Controller_Gesture::OnRelease() {}
+void Gesture::OnRelease() {}
 
-void Controller_Gesture::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void Gesture::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     if (!IsControllerActivated()) {
         shared_memory->gesture_lifo.buffer_count = 0;
         shared_memory->gesture_lifo.buffer_tail = 0;
@@ -64,7 +64,7 @@ void Controller_Gesture::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     UpdateGestureSharedMemory(gesture, time_difference);
 }
 
-void Controller_Gesture::ReadTouchInput() {
+void Gesture::ReadTouchInput() {
     if (!Settings::values.touchscreen.enabled) {
         fingers = {};
         return;
@@ -76,8 +76,7 @@ void Controller_Gesture::ReadTouchInput() {
     }
 }
 
-bool Controller_Gesture::ShouldUpdateGesture(const GestureProperties& gesture,
-                                             f32 time_difference) {
+bool Gesture::ShouldUpdateGesture(const GestureProperties& gesture, f32 time_difference) {
     const auto& last_entry = GetLastGestureEntry();
     if (force_update) {
         force_update = false;
@@ -100,8 +99,7 @@ bool Controller_Gesture::ShouldUpdateGesture(const GestureProperties& gesture,
     return false;
 }
 
-void Controller_Gesture::UpdateGestureSharedMemory(GestureProperties& gesture,
-                                                   f32 time_difference) {
+void Gesture::UpdateGestureSharedMemory(GestureProperties& gesture, f32 time_difference) {
     GestureType type = GestureType::Idle;
     GestureAttribute attributes{};
 
@@ -138,8 +136,8 @@ void Controller_Gesture::UpdateGestureSharedMemory(GestureProperties& gesture,
     shared_memory->gesture_lifo.WriteNextEntry(next_state);
 }
 
-void Controller_Gesture::NewGesture(GestureProperties& gesture, GestureType& type,
-                                    GestureAttribute& attributes) {
+void Gesture::NewGesture(GestureProperties& gesture, GestureType& type,
+                         GestureAttribute& attributes) {
     const auto& last_entry = GetLastGestureEntry();
 
     gesture.detection_count++;
@@ -152,8 +150,8 @@ void Controller_Gesture::NewGesture(GestureProperties& gesture, GestureType& typ
     }
 }
 
-void Controller_Gesture::UpdateExistingGesture(GestureProperties& gesture, GestureType& type,
-                                               f32 time_difference) {
+void Gesture::UpdateExistingGesture(GestureProperties& gesture, GestureType& type,
+                                    f32 time_difference) {
     const auto& last_entry = GetLastGestureEntry();
 
     // Promote to pan type if touch moved
@@ -186,9 +184,8 @@ void Controller_Gesture::UpdateExistingGesture(GestureProperties& gesture, Gestu
     }
 }
 
-void Controller_Gesture::EndGesture(GestureProperties& gesture,
-                                    GestureProperties& last_gesture_props, GestureType& type,
-                                    GestureAttribute& attributes, f32 time_difference) {
+void Gesture::EndGesture(GestureProperties& gesture, GestureProperties& last_gesture_props,
+                         GestureType& type, GestureAttribute& attributes, f32 time_difference) {
     const auto& last_entry = GetLastGestureEntry();
 
     if (last_gesture_props.active_points != 0) {
@@ -222,9 +219,8 @@ void Controller_Gesture::EndGesture(GestureProperties& gesture,
     }
 }
 
-void Controller_Gesture::SetTapEvent(GestureProperties& gesture,
-                                     GestureProperties& last_gesture_props, GestureType& type,
-                                     GestureAttribute& attributes) {
+void Gesture::SetTapEvent(GestureProperties& gesture, GestureProperties& last_gesture_props,
+                          GestureType& type, GestureAttribute& attributes) {
     type = GestureType::Tap;
     gesture = last_gesture_props;
     force_update = true;
@@ -236,9 +232,8 @@ void Controller_Gesture::SetTapEvent(GestureProperties& gesture,
     }
 }
 
-void Controller_Gesture::UpdatePanEvent(GestureProperties& gesture,
-                                        GestureProperties& last_gesture_props, GestureType& type,
-                                        f32 time_difference) {
+void Gesture::UpdatePanEvent(GestureProperties& gesture, GestureProperties& last_gesture_props,
+                             GestureType& type, f32 time_difference) {
     const auto& last_entry = GetLastGestureEntry();
 
     next_state.delta = gesture.mid_point - last_entry.pos;
@@ -263,9 +258,8 @@ void Controller_Gesture::UpdatePanEvent(GestureProperties& gesture,
     }
 }
 
-void Controller_Gesture::EndPanEvent(GestureProperties& gesture,
-                                     GestureProperties& last_gesture_props, GestureType& type,
-                                     f32 time_difference) {
+void Gesture::EndPanEvent(GestureProperties& gesture, GestureProperties& last_gesture_props,
+                          GestureType& type, f32 time_difference) {
     const auto& last_entry = GetLastGestureEntry();
     next_state.vel_x =
         static_cast<f32>(last_entry.delta.x) / (last_pan_time_difference + time_difference);
@@ -287,8 +281,8 @@ void Controller_Gesture::EndPanEvent(GestureProperties& gesture,
     force_update = true;
 }
 
-void Controller_Gesture::SetSwipeEvent(GestureProperties& gesture,
-                                       GestureProperties& last_gesture_props, GestureType& type) {
+void Gesture::SetSwipeEvent(GestureProperties& gesture, GestureProperties& last_gesture_props,
+                            GestureType& type) {
     const auto& last_entry = GetLastGestureEntry();
 
     type = GestureType::Swipe;
@@ -311,11 +305,11 @@ void Controller_Gesture::SetSwipeEvent(GestureProperties& gesture,
     next_state.direction = GestureDirection::Up;
 }
 
-const Controller_Gesture::GestureState& Controller_Gesture::GetLastGestureEntry() const {
+const Gesture::GestureState& Gesture::GetLastGestureEntry() const {
     return shared_memory->gesture_lifo.ReadCurrentEntry().state;
 }
 
-Controller_Gesture::GestureProperties Controller_Gesture::GetGestureProperties() {
+Gesture::GestureProperties Gesture::GetGestureProperties() {
     GestureProperties gesture;
     std::array<Core::HID::TouchFinger, MAX_POINTS> active_fingers;
     const auto end_iter = std::copy_if(fingers.begin(), fingers.end(), active_fingers.begin(),
diff --git a/src/core/hle/service/hid/controllers/gesture.h b/src/core/hle/service/hid/controllers/gesture.h
index 0d6099ea0d5b..4c6f8ee078c1 100644
--- a/src/core/hle/service/hid/controllers/gesture.h
+++ b/src/core/hle/service/hid/controllers/gesture.h
@@ -12,10 +12,10 @@
 #include "core/hle/service/hid/ring_lifo.h"
 
 namespace Service::HID {
-class Controller_Gesture final : public ControllerBase {
+class Gesture final : public ControllerBase {
 public:
-    explicit Controller_Gesture(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
-    ~Controller_Gesture() override;
+    explicit Gesture(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
+    ~Gesture() override;
 
     // Called when the controller is initialized
     void OnInit() override;
diff --git a/src/core/hle/service/hid/controllers/keyboard.cpp b/src/core/hle/service/hid/controllers/keyboard.cpp
index 117d874332c7..ddb1b0ba4777 100644
--- a/src/core/hle/service/hid/controllers/keyboard.cpp
+++ b/src/core/hle/service/hid/controllers/keyboard.cpp
@@ -12,7 +12,7 @@
 namespace Service::HID {
 constexpr std::size_t SHARED_MEMORY_OFFSET = 0x3800;
 
-Controller_Keyboard::Controller_Keyboard(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
+Keyboard::Keyboard(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
     : ControllerBase{hid_core_} {
     static_assert(SHARED_MEMORY_OFFSET + sizeof(KeyboardSharedMemory) < shared_memory_size,
                   "KeyboardSharedMemory is bigger than the shared memory");
@@ -21,13 +21,13 @@ Controller_Keyboard::Controller_Keyboard(Core::HID::HIDCore& hid_core_, u8* raw_
     emulated_devices = hid_core.GetEmulatedDevices();
 }
 
-Controller_Keyboard::~Controller_Keyboard() = default;
+Keyboard::~Keyboard() = default;
 
-void Controller_Keyboard::OnInit() {}
+void Keyboard::OnInit() {}
 
-void Controller_Keyboard::OnRelease() {}
+void Keyboard::OnRelease() {}
 
-void Controller_Keyboard::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void Keyboard::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     if (!IsControllerActivated()) {
         shared_memory->keyboard_lifo.buffer_count = 0;
         shared_memory->keyboard_lifo.buffer_tail = 0;
diff --git a/src/core/hle/service/hid/controllers/keyboard.h b/src/core/hle/service/hid/controllers/keyboard.h
index 7532f53c65e8..172ec1309afe 100644
--- a/src/core/hle/service/hid/controllers/keyboard.h
+++ b/src/core/hle/service/hid/controllers/keyboard.h
@@ -14,10 +14,10 @@ struct KeyboardKey;
 } // namespace Core::HID
 
 namespace Service::HID {
-class Controller_Keyboard final : public ControllerBase {
+class Keyboard final : public ControllerBase {
 public:
-    explicit Controller_Keyboard(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
-    ~Controller_Keyboard() override;
+    explicit Keyboard(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
+    ~Keyboard() override;
 
     // Called when the controller is initialized
     void OnInit() override;
diff --git a/src/core/hle/service/hid/controllers/mouse.cpp b/src/core/hle/service/hid/controllers/mouse.cpp
index 0afc666811ca..6e5a04e3412d 100644
--- a/src/core/hle/service/hid/controllers/mouse.cpp
+++ b/src/core/hle/service/hid/controllers/mouse.cpp
@@ -12,8 +12,7 @@
 namespace Service::HID {
 constexpr std::size_t SHARED_MEMORY_OFFSET = 0x3400;
 
-Controller_Mouse::Controller_Mouse(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
-    : ControllerBase{hid_core_} {
+Mouse::Mouse(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_) : ControllerBase{hid_core_} {
     static_assert(SHARED_MEMORY_OFFSET + sizeof(MouseSharedMemory) < shared_memory_size,
                   "MouseSharedMemory is bigger than the shared memory");
     shared_memory = std::construct_at(
@@ -21,12 +20,12 @@ Controller_Mouse::Controller_Mouse(Core::HID::HIDCore& hid_core_, u8* raw_shared
     emulated_devices = hid_core.GetEmulatedDevices();
 }
 
-Controller_Mouse::~Controller_Mouse() = default;
+Mouse::~Mouse() = default;
 
-void Controller_Mouse::OnInit() {}
-void Controller_Mouse::OnRelease() {}
+void Mouse::OnInit() {}
+void Mouse::OnRelease() {}
 
-void Controller_Mouse::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void Mouse::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     if (!IsControllerActivated()) {
         shared_memory->mouse_lifo.buffer_count = 0;
         shared_memory->mouse_lifo.buffer_tail = 0;
diff --git a/src/core/hle/service/hid/controllers/mouse.h b/src/core/hle/service/hid/controllers/mouse.h
index 733d005776b8..a80f3823f5e6 100644
--- a/src/core/hle/service/hid/controllers/mouse.h
+++ b/src/core/hle/service/hid/controllers/mouse.h
@@ -14,10 +14,10 @@ struct AnalogStickState;
 } // namespace Core::HID
 
 namespace Service::HID {
-class Controller_Mouse final : public ControllerBase {
+class Mouse final : public ControllerBase {
 public:
-    explicit Controller_Mouse(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
-    ~Controller_Mouse() override;
+    explicit Mouse(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
+    ~Mouse() override;
 
     // Called when the controller is initialized
     void OnInit() override;
diff --git a/src/core/hle/service/hid/controllers/npad.cpp b/src/core/hle/service/hid/controllers/npad.cpp
index 127af2b82f36..08ee9de9ca72 100644
--- a/src/core/hle/service/hid/controllers/npad.cpp
+++ b/src/core/hle/service/hid/controllers/npad.cpp
@@ -18,6 +18,7 @@
 #include "core/hle/kernel/k_readable_event.h"
 #include "core/hle/service/hid/controllers/npad.h"
 #include "core/hle/service/hid/errors.h"
+#include "core/hle/service/hid/hid_util.h"
 #include "core/hle/service/kernel_helpers.h"
 
 namespace Service::HID {
@@ -29,60 +30,8 @@ constexpr std::array<Core::HID::NpadIdType, 10> npad_id_list{
     Core::HID::NpadIdType::Handheld,
 };
 
-bool Controller_NPad::IsNpadIdValid(Core::HID::NpadIdType npad_id) {
-    switch (npad_id) {
-    case Core::HID::NpadIdType::Player1:
-    case Core::HID::NpadIdType::Player2:
-    case Core::HID::NpadIdType::Player3:
-    case Core::HID::NpadIdType::Player4:
-    case Core::HID::NpadIdType::Player5:
-    case Core::HID::NpadIdType::Player6:
-    case Core::HID::NpadIdType::Player7:
-    case Core::HID::NpadIdType::Player8:
-    case Core::HID::NpadIdType::Other:
-    case Core::HID::NpadIdType::Handheld:
-        return true;
-    default:
-        LOG_ERROR(Service_HID, "Invalid npad id {}", npad_id);
-        return false;
-    }
-}
-
-Result Controller_NPad::IsDeviceHandleValid(const Core::HID::VibrationDeviceHandle& device_handle) {
-    const auto npad_id = IsNpadIdValid(static_cast<Core::HID::NpadIdType>(device_handle.npad_id));
-    const bool npad_type = device_handle.npad_type < Core::HID::NpadStyleIndex::MaxNpadType;
-    const bool device_index = device_handle.device_index < Core::HID::DeviceIndex::MaxDeviceIndex;
-
-    if (!npad_type) {
-        return VibrationInvalidStyleIndex;
-    }
-    if (!npad_id) {
-        return VibrationInvalidNpadId;
-    }
-    if (!device_index) {
-        return VibrationDeviceIndexOutOfRange;
-    }
-
-    return ResultSuccess;
-}
-
-Result Controller_NPad::VerifyValidSixAxisSensorHandle(
-    const Core::HID::SixAxisSensorHandle& device_handle) {
-    const auto npad_id = IsNpadIdValid(static_cast<Core::HID::NpadIdType>(device_handle.npad_id));
-    const bool device_index = device_handle.device_index < Core::HID::DeviceIndex::MaxDeviceIndex;
-
-    if (!npad_id) {
-        return InvalidNpadId;
-    }
-    if (!device_index) {
-        return NpadDeviceIndexOutOfRange;
-    }
-
-    return ResultSuccess;
-}
-
-Controller_NPad::Controller_NPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_,
-                                 KernelHelpers::ServiceContext& service_context_)
+NPad::NPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_,
+           KernelHelpers::ServiceContext& service_context_)
     : ControllerBase{hid_core_}, service_context{service_context_} {
     static_assert(NPAD_OFFSET + (NPAD_COUNT * sizeof(NpadInternalState)) < shared_memory_size);
     for (std::size_t i = 0; i < controller_data.size(); ++i) {
@@ -103,7 +52,7 @@ Controller_NPad::Controller_NPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_m
     }
 }
 
-Controller_NPad::~Controller_NPad() {
+NPad::~NPad() {
     for (std::size_t i = 0; i < controller_data.size(); ++i) {
         auto& controller = controller_data[i];
         controller.device->DeleteCallback(controller.callback_key);
@@ -111,8 +60,7 @@ Controller_NPad::~Controller_NPad() {
     OnRelease();
 }
 
-void Controller_NPad::ControllerUpdate(Core::HID::ControllerTriggerType type,
-                                       std::size_t controller_idx) {
+void NPad::ControllerUpdate(Core::HID::ControllerTriggerType type, std::size_t controller_idx) {
     if (type == Core::HID::ControllerTriggerType::All) {
         ControllerUpdate(Core::HID::ControllerTriggerType::Connected, controller_idx);
         ControllerUpdate(Core::HID::ControllerTriggerType::Battery, controller_idx);
@@ -150,7 +98,7 @@ void Controller_NPad::ControllerUpdate(Core::HID::ControllerTriggerType type,
     }
 }
 
-void Controller_NPad::InitNewlyAddedController(Core::HID::NpadIdType npad_id) {
+void NPad::InitNewlyAddedController(Core::HID::NpadIdType npad_id) {
     auto& controller = GetControllerFromNpadIdType(npad_id);
     if (!IsControllerSupported(controller.device->GetNpadStyleIndex())) {
         return;
@@ -350,7 +298,7 @@ void Controller_NPad::InitNewlyAddedController(Core::HID::NpadIdType npad_id) {
     hid_core.SetLastActiveController(npad_id);
 }
 
-void Controller_NPad::OnInit() {
+void NPad::OnInit() {
     if (!IsControllerActivated()) {
         return;
     }
@@ -384,7 +332,7 @@ void Controller_NPad::OnInit() {
     }
 }
 
-void Controller_NPad::WriteEmptyEntry(NpadInternalState* npad) {
+void NPad::WriteEmptyEntry(NpadInternalState* npad) {
     NPadGenericState dummy_pad_state{};
     NpadGcTriggerState dummy_gc_state{};
     dummy_pad_state.sampling_number = npad->fullkey_lifo.ReadCurrentEntry().sampling_number + 1;
@@ -405,7 +353,7 @@ void Controller_NPad::WriteEmptyEntry(NpadInternalState* npad) {
     npad->gc_trigger_lifo.WriteNextEntry(dummy_gc_state);
 }
 
-void Controller_NPad::OnRelease() {
+void NPad::OnRelease() {
     is_controller_initialized = false;
     for (std::size_t i = 0; i < controller_data.size(); ++i) {
         auto& controller = controller_data[i];
@@ -416,7 +364,7 @@ void Controller_NPad::OnRelease() {
     }
 }
 
-void Controller_NPad::RequestPadStateUpdate(Core::HID::NpadIdType npad_id) {
+void NPad::RequestPadStateUpdate(Core::HID::NpadIdType npad_id) {
     std::scoped_lock lock{mutex};
     auto& controller = GetControllerFromNpadIdType(npad_id);
     const auto controller_type = controller.device->GetNpadStyleIndex();
@@ -485,7 +433,7 @@ void Controller_NPad::RequestPadStateUpdate(Core::HID::NpadIdType npad_id) {
     }
 }
 
-void Controller_NPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void NPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     if (!IsControllerActivated()) {
         return;
     }
@@ -615,134 +563,7 @@ void Controller_NPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     }
 }
 
-void Controller_NPad::OnMotionUpdate(const Core::Timing::CoreTiming& core_timing) {
-    if (!IsControllerActivated()) {
-        return;
-    }
-
-    for (std::size_t i = 0; i < controller_data.size(); ++i) {
-        auto& controller = controller_data[i];
-
-        const auto& controller_type = controller.device->GetNpadStyleIndex();
-
-        if (controller_type == Core::HID::NpadStyleIndex::None ||
-            !controller.device->IsConnected()) {
-            continue;
-        }
-
-        auto* npad = controller.shared_memory;
-        const auto& motion_state = controller.device->GetMotions();
-        auto& sixaxis_fullkey_state = controller.sixaxis_fullkey_state;
-        auto& sixaxis_handheld_state = controller.sixaxis_handheld_state;
-        auto& sixaxis_dual_left_state = controller.sixaxis_dual_left_state;
-        auto& sixaxis_dual_right_state = controller.sixaxis_dual_right_state;
-        auto& sixaxis_left_lifo_state = controller.sixaxis_left_lifo_state;
-        auto& sixaxis_right_lifo_state = controller.sixaxis_right_lifo_state;
-
-        // Clear previous state
-        sixaxis_fullkey_state = {};
-        sixaxis_handheld_state = {};
-        sixaxis_dual_left_state = {};
-        sixaxis_dual_right_state = {};
-        sixaxis_left_lifo_state = {};
-        sixaxis_right_lifo_state = {};
-
-        if (controller.sixaxis_sensor_enabled && Settings::values.motion_enabled.GetValue()) {
-            controller.sixaxis_at_rest = true;
-            for (std::size_t e = 0; e < motion_state.size(); ++e) {
-                controller.sixaxis_at_rest =
-                    controller.sixaxis_at_rest && motion_state[e].is_at_rest;
-            }
-        }
-
-        const auto set_motion_state = [&](SixAxisSensorState& state,
-                                          const Core::HID::ControllerMotion& hid_state) {
-            using namespace std::literals::chrono_literals;
-            static constexpr SixAxisSensorState default_motion_state = {
-                .delta_time = std::chrono::nanoseconds(5ms).count(),
-                .accel = {0, 0, -1.0f},
-                .orientation =
-                    {
-                        Common::Vec3f{1.0f, 0, 0},
-                        Common::Vec3f{0, 1.0f, 0},
-                        Common::Vec3f{0, 0, 1.0f},
-                    },
-                .attribute = {1},
-            };
-            if (!controller.sixaxis_sensor_enabled) {
-                state = default_motion_state;
-                return;
-            }
-            if (!Settings::values.motion_enabled.GetValue()) {
-                state = default_motion_state;
-                return;
-            }
-            state.attribute.is_connected.Assign(1);
-            state.delta_time = std::chrono::nanoseconds(5ms).count();
-            state.accel = hid_state.accel;
-            state.gyro = hid_state.gyro;
-            state.rotation = hid_state.rotation;
-            state.orientation = hid_state.orientation;
-        };
-
-        switch (controller_type) {
-        case Core::HID::NpadStyleIndex::None:
-            ASSERT(false);
-            break;
-        case Core::HID::NpadStyleIndex::ProController:
-            set_motion_state(sixaxis_fullkey_state, motion_state[0]);
-            break;
-        case Core::HID::NpadStyleIndex::Handheld:
-            set_motion_state(sixaxis_handheld_state, motion_state[0]);
-            break;
-        case Core::HID::NpadStyleIndex::JoyconDual:
-            set_motion_state(sixaxis_dual_left_state, motion_state[0]);
-            set_motion_state(sixaxis_dual_right_state, motion_state[1]);
-            break;
-        case Core::HID::NpadStyleIndex::JoyconLeft:
-            set_motion_state(sixaxis_left_lifo_state, motion_state[0]);
-            break;
-        case Core::HID::NpadStyleIndex::JoyconRight:
-            set_motion_state(sixaxis_right_lifo_state, motion_state[1]);
-            break;
-        case Core::HID::NpadStyleIndex::Pokeball:
-            using namespace std::literals::chrono_literals;
-            set_motion_state(sixaxis_fullkey_state, motion_state[0]);
-            sixaxis_fullkey_state.delta_time = std::chrono::nanoseconds(15ms).count();
-            break;
-        default:
-            break;
-        }
-
-        sixaxis_fullkey_state.sampling_number =
-            npad->sixaxis_fullkey_lifo.ReadCurrentEntry().state.sampling_number + 1;
-        sixaxis_handheld_state.sampling_number =
-            npad->sixaxis_handheld_lifo.ReadCurrentEntry().state.sampling_number + 1;
-        sixaxis_dual_left_state.sampling_number =
-            npad->sixaxis_dual_left_lifo.ReadCurrentEntry().state.sampling_number + 1;
-        sixaxis_dual_right_state.sampling_number =
-            npad->sixaxis_dual_right_lifo.ReadCurrentEntry().state.sampling_number + 1;
-        sixaxis_left_lifo_state.sampling_number =
-            npad->sixaxis_left_lifo.ReadCurrentEntry().state.sampling_number + 1;
-        sixaxis_right_lifo_state.sampling_number =
-            npad->sixaxis_right_lifo.ReadCurrentEntry().state.sampling_number + 1;
-
-        if (Core::HID::IndexToNpadIdType(i) == Core::HID::NpadIdType::Handheld) {
-            // This buffer only is updated on handheld on HW
-            npad->sixaxis_handheld_lifo.WriteNextEntry(sixaxis_handheld_state);
-        } else {
-            // Handheld doesn't update this buffer on HW
-            npad->sixaxis_fullkey_lifo.WriteNextEntry(sixaxis_fullkey_state);
-        }
-
-        npad->sixaxis_dual_left_lifo.WriteNextEntry(sixaxis_dual_left_state);
-        npad->sixaxis_dual_right_lifo.WriteNextEntry(sixaxis_dual_right_state);
-        npad->sixaxis_left_lifo.WriteNextEntry(sixaxis_left_lifo_state);
-        npad->sixaxis_right_lifo.WriteNextEntry(sixaxis_right_lifo_state);
-    }
-}
-
-void Controller_NPad::SetSupportedStyleSet(Core::HID::NpadStyleTag style_set) {
+void NPad::SetSupportedStyleSet(Core::HID::NpadStyleTag style_set) {
     hid_core.SetSupportedStyleTag(style_set);
 
     if (is_controller_initialized) {
@@ -753,14 +574,14 @@ void Controller_NPad::SetSupportedStyleSet(Core::HID::NpadStyleTag style_set) {
     is_controller_initialized = true;
 }
 
-Core::HID::NpadStyleTag Controller_NPad::GetSupportedStyleSet() const {
+Core::HID::NpadStyleTag NPad::GetSupportedStyleSet() const {
     if (!is_controller_initialized) {
         return {Core::HID::NpadStyleSet::None};
     }
     return hid_core.GetSupportedStyleTag();
 }
 
-Result Controller_NPad::SetSupportedNpadIdTypes(std::span<const u8> data) {
+Result NPad::SetSupportedNpadIdTypes(std::span<const u8> data) {
     constexpr std::size_t max_number_npad_ids = 0xa;
     const auto length = data.size();
     ASSERT(length > 0 && (length % sizeof(u32)) == 0);
@@ -776,17 +597,17 @@ Result Controller_NPad::SetSupportedNpadIdTypes(std::span<const u8> data) {
     return ResultSuccess;
 }
 
-void Controller_NPad::GetSupportedNpadIdTypes(u32* data, std::size_t max_length) {
+void NPad::GetSupportedNpadIdTypes(u32* data, std::size_t max_length) {
     const auto copy_amount = supported_npad_id_types.size() * sizeof(u32);
     ASSERT(max_length <= copy_amount);
     std::memcpy(data, supported_npad_id_types.data(), copy_amount);
 }
 
-std::size_t Controller_NPad::GetSupportedNpadIdTypesSize() const {
+std::size_t NPad::GetSupportedNpadIdTypesSize() const {
     return supported_npad_id_types.size();
 }
 
-void Controller_NPad::SetHoldType(NpadJoyHoldType joy_hold_type) {
+void NPad::SetHoldType(NpadJoyHoldType joy_hold_type) {
     if (joy_hold_type != NpadJoyHoldType::Horizontal &&
         joy_hold_type != NpadJoyHoldType::Vertical) {
         LOG_ERROR(Service_HID, "Npad joy hold type needs to be valid, joy_hold_type={}",
@@ -796,11 +617,11 @@ void Controller_NPad::SetHoldType(NpadJoyHoldType joy_hold_type) {
     hold_type = joy_hold_type;
 }
 
-Controller_NPad::NpadJoyHoldType Controller_NPad::GetHoldType() const {
+NPad::NpadJoyHoldType NPad::GetHoldType() const {
     return hold_type;
 }
 
-void Controller_NPad::SetNpadHandheldActivationMode(NpadHandheldActivationMode activation_mode) {
+void NPad::SetNpadHandheldActivationMode(NpadHandheldActivationMode activation_mode) {
     if (activation_mode >= NpadHandheldActivationMode::MaxActivationMode) {
         ASSERT_MSG(false, "Activation mode should be always None, Single or Dual");
         return;
@@ -809,21 +630,20 @@ void Controller_NPad::SetNpadHandheldActivationMode(NpadHandheldActivationMode a
     handheld_activation_mode = activation_mode;
 }
 
-Controller_NPad::NpadHandheldActivationMode Controller_NPad::GetNpadHandheldActivationMode() const {
+NPad::NpadHandheldActivationMode NPad::GetNpadHandheldActivationMode() const {
     return handheld_activation_mode;
 }
 
-void Controller_NPad::SetNpadCommunicationMode(NpadCommunicationMode communication_mode_) {
+void NPad::SetNpadCommunicationMode(NpadCommunicationMode communication_mode_) {
     communication_mode = communication_mode_;
 }
 
-Controller_NPad::NpadCommunicationMode Controller_NPad::GetNpadCommunicationMode() const {
+NPad::NpadCommunicationMode NPad::GetNpadCommunicationMode() const {
     return communication_mode;
 }
 
-bool Controller_NPad::SetNpadMode(Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType npad_id,
-                                  NpadJoyDeviceType npad_device_type,
-                                  NpadJoyAssignmentMode assignment_mode) {
+bool NPad::SetNpadMode(Core::HID::NpadIdType& new_npad_id, Core::HID::NpadIdType npad_id,
+                       NpadJoyDeviceType npad_device_type, NpadJoyAssignmentMode assignment_mode) {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         return false;
@@ -892,9 +712,8 @@ bool Controller_NPad::SetNpadMode(Core::HID::NpadIdType& new_npad_id, Core::HID:
     return true;
 }
 
-bool Controller_NPad::VibrateControllerAtIndex(Core::HID::NpadIdType npad_id,
-                                               std::size_t device_index,
-                                               const Core::HID::VibrationValue& vibration_value) {
+bool NPad::VibrateControllerAtIndex(Core::HID::NpadIdType npad_id, std::size_t device_index,
+                                    const Core::HID::VibrationValue& vibration_value) {
     auto& controller = GetControllerFromNpadIdType(npad_id);
     if (!controller.device->IsConnected()) {
         return false;
@@ -938,10 +757,9 @@ bool Controller_NPad::VibrateControllerAtIndex(Core::HID::NpadIdType npad_id,
     return controller.device->SetVibration(device_index, vibration);
 }
 
-void Controller_NPad::VibrateController(
-    const Core::HID::VibrationDeviceHandle& vibration_device_handle,
-    const Core::HID::VibrationValue& vibration_value) {
-    if (IsDeviceHandleValid(vibration_device_handle).IsError()) {
+void NPad::VibrateController(const Core::HID::VibrationDeviceHandle& vibration_device_handle,
+                             const Core::HID::VibrationValue& vibration_value) {
+    if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
         return;
     }
 
@@ -985,7 +803,7 @@ void Controller_NPad::VibrateController(
     }
 }
 
-void Controller_NPad::VibrateControllers(
+void NPad::VibrateControllers(
     std::span<const Core::HID::VibrationDeviceHandle> vibration_device_handles,
     std::span<const Core::HID::VibrationValue> vibration_values) {
     if (!Settings::values.vibration_enabled.GetValue() && !permit_vibration_session_enabled) {
@@ -1002,9 +820,9 @@ void Controller_NPad::VibrateControllers(
     }
 }
 
-Core::HID::VibrationValue Controller_NPad::GetLastVibration(
+Core::HID::VibrationValue NPad::GetLastVibration(
     const Core::HID::VibrationDeviceHandle& vibration_device_handle) const {
-    if (IsDeviceHandleValid(vibration_device_handle).IsError()) {
+    if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
         return {};
     }
 
@@ -1013,9 +831,9 @@ Core::HID::VibrationValue Controller_NPad::GetLastVibration(
     return controller.vibration[device_index].latest_vibration_value;
 }
 
-void Controller_NPad::InitializeVibrationDevice(
+void NPad::InitializeVibrationDevice(
     const Core::HID::VibrationDeviceHandle& vibration_device_handle) {
-    if (IsDeviceHandleValid(vibration_device_handle).IsError()) {
+    if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
         return;
     }
 
@@ -1024,8 +842,8 @@ void Controller_NPad::InitializeVibrationDevice(
     InitializeVibrationDeviceAtIndex(npad_index, device_index);
 }
 
-void Controller_NPad::InitializeVibrationDeviceAtIndex(Core::HID::NpadIdType npad_id,
-                                                       std::size_t device_index) {
+void NPad::InitializeVibrationDeviceAtIndex(Core::HID::NpadIdType npad_id,
+                                            std::size_t device_index) {
     auto& controller = GetControllerFromNpadIdType(npad_id);
     if (!Settings::values.vibration_enabled.GetValue()) {
         controller.vibration[device_index].device_mounted = false;
@@ -1036,13 +854,13 @@ void Controller_NPad::InitializeVibrationDeviceAtIndex(Core::HID::NpadIdType npa
         controller.device->IsVibrationEnabled(device_index);
 }
 
-void Controller_NPad::SetPermitVibrationSession(bool permit_vibration_session) {
+void NPad::SetPermitVibrationSession(bool permit_vibration_session) {
     permit_vibration_session_enabled = permit_vibration_session;
 }
 
-bool Controller_NPad::IsVibrationDeviceMounted(
+bool NPad::IsVibrationDeviceMounted(
     const Core::HID::VibrationDeviceHandle& vibration_device_handle) const {
-    if (IsDeviceHandleValid(vibration_device_handle).IsError()) {
+    if (IsVibrationHandleValid(vibration_device_handle).IsError()) {
         return false;
     }
 
@@ -1051,7 +869,7 @@ bool Controller_NPad::IsVibrationDeviceMounted(
     return controller.vibration[device_index].device_mounted;
 }
 
-Kernel::KReadableEvent& Controller_NPad::GetStyleSetChangedEvent(Core::HID::NpadIdType npad_id) {
+Kernel::KReadableEvent& NPad::GetStyleSetChangedEvent(Core::HID::NpadIdType npad_id) {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         // Fallback to player 1
@@ -1063,18 +881,17 @@ Kernel::KReadableEvent& Controller_NPad::GetStyleSetChangedEvent(Core::HID::Npad
     return controller.styleset_changed_event->GetReadableEvent();
 }
 
-void Controller_NPad::SignalStyleSetChangedEvent(Core::HID::NpadIdType npad_id) const {
+void NPad::SignalStyleSetChangedEvent(Core::HID::NpadIdType npad_id) const {
     const auto& controller = GetControllerFromNpadIdType(npad_id);
     controller.styleset_changed_event->Signal();
 }
 
-void Controller_NPad::AddNewControllerAt(Core::HID::NpadStyleIndex controller,
-                                         Core::HID::NpadIdType npad_id) {
+void NPad::AddNewControllerAt(Core::HID::NpadStyleIndex controller, Core::HID::NpadIdType npad_id) {
     UpdateControllerAt(controller, npad_id, true);
 }
 
-void Controller_NPad::UpdateControllerAt(Core::HID::NpadStyleIndex type,
-                                         Core::HID::NpadIdType npad_id, bool connected) {
+void NPad::UpdateControllerAt(Core::HID::NpadStyleIndex type, Core::HID::NpadIdType npad_id,
+                              bool connected) {
     auto& controller = GetControllerFromNpadIdType(npad_id);
     if (!connected) {
         DisconnectNpad(npad_id);
@@ -1085,7 +902,7 @@ void Controller_NPad::UpdateControllerAt(Core::HID::NpadStyleIndex type,
     InitNewlyAddedController(npad_id);
 }
 
-Result Controller_NPad::DisconnectNpad(Core::HID::NpadIdType npad_id) {
+Result NPad::DisconnectNpad(Core::HID::NpadIdType npad_id) {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         return InvalidNpadId;
@@ -1134,54 +951,9 @@ Result Controller_NPad::DisconnectNpad(Core::HID::NpadIdType npad_id) {
     return ResultSuccess;
 }
 
-Result Controller_NPad::SetGyroscopeZeroDriftMode(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-    Core::HID::GyroscopeZeroDriftMode drift_mode) {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    auto& controller = GetControllerFromHandle(sixaxis_handle);
-    sixaxis.gyroscope_zero_drift_mode = drift_mode;
-    controller.device->SetGyroscopeZeroDriftMode(drift_mode);
-
-    return ResultSuccess;
-}
-
-Result Controller_NPad::GetGyroscopeZeroDriftMode(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-    Core::HID::GyroscopeZeroDriftMode& drift_mode) const {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    drift_mode = sixaxis.gyroscope_zero_drift_mode;
-
-    return ResultSuccess;
-}
-
-Result Controller_NPad::IsSixAxisSensorAtRest(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                                              bool& is_at_rest) const {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    const auto& controller = GetControllerFromHandle(sixaxis_handle);
-    is_at_rest = controller.sixaxis_at_rest;
-    return ResultSuccess;
-}
-
-Result Controller_NPad::IsFirmwareUpdateAvailableForSixAxisSensor(
+Result NPad::IsFirmwareUpdateAvailableForSixAxisSensor(
     const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_firmware_available) const {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
     if (is_valid.IsError()) {
         LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
         return is_valid;
@@ -1192,65 +964,9 @@ Result Controller_NPad::IsFirmwareUpdateAvailableForSixAxisSensor(
     return ResultSuccess;
 }
 
-Result Controller_NPad::EnableSixAxisSensorUnalteredPassthrough(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool is_enabled) {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    sixaxis.unaltered_passtrough = is_enabled;
-    return ResultSuccess;
-}
-
-Result Controller_NPad::IsSixAxisSensorUnalteredPassthroughEnabled(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_enabled) const {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    is_enabled = sixaxis.unaltered_passtrough;
-    return ResultSuccess;
-}
-
-Result Controller_NPad::LoadSixAxisSensorCalibrationParameter(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-    Core::HID::SixAxisSensorCalibrationParameter& calibration) const {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    // TODO: Request this data to the controller. On error return 0xd8ca
-    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    calibration = sixaxis.calibration;
-    return ResultSuccess;
-}
-
-Result Controller_NPad::GetSixAxisSensorIcInformation(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-    Core::HID::SixAxisSensorIcInformation& ic_information) const {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    // TODO: Request this data to the controller. On error return 0xd8ca
-    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    ic_information = sixaxis.ic_information;
-    return ResultSuccess;
-}
-
-Result Controller_NPad::ResetIsSixAxisSensorDeviceNewlyAssigned(
+Result NPad::ResetIsSixAxisSensorDeviceNewlyAssigned(
     const Core::HID::SixAxisSensorHandle& sixaxis_handle) {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
     if (is_valid.IsError()) {
         LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
         return is_valid;
@@ -1262,83 +978,32 @@ Result Controller_NPad::ResetIsSixAxisSensorDeviceNewlyAssigned(
     return ResultSuccess;
 }
 
-Result Controller_NPad::SetSixAxisEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                                          bool sixaxis_status) {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    auto& controller = GetControllerFromHandle(sixaxis_handle);
-    controller.sixaxis_sensor_enabled = sixaxis_status;
-    return ResultSuccess;
+NPad::SixAxisLifo& NPad::GetSixAxisFullkeyLifo(Core::HID::NpadIdType npad_id) {
+    return GetControllerFromNpadIdType(npad_id).shared_memory->sixaxis_fullkey_lifo;
 }
 
-Result Controller_NPad::IsSixAxisSensorFusionEnabled(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_fusion_enabled) const {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    is_fusion_enabled = sixaxis.is_fusion_enabled;
-
-    return ResultSuccess;
+NPad::SixAxisLifo& NPad::GetSixAxisHandheldLifo(Core::HID::NpadIdType npad_id) {
+    return GetControllerFromNpadIdType(npad_id).shared_memory->sixaxis_handheld_lifo;
 }
-Result Controller_NPad::SetSixAxisFusionEnabled(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool is_fusion_enabled) {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
 
-    auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    sixaxis.is_fusion_enabled = is_fusion_enabled;
-
-    return ResultSuccess;
+NPad::SixAxisLifo& NPad::GetSixAxisDualLeftLifo(Core::HID::NpadIdType npad_id) {
+    return GetControllerFromNpadIdType(npad_id).shared_memory->sixaxis_dual_left_lifo;
 }
 
-Result Controller_NPad::SetSixAxisFusionParameters(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-    Core::HID::SixAxisSensorFusionParameters sixaxis_fusion_parameters) {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    const auto param1 = sixaxis_fusion_parameters.parameter1;
-    if (param1 < 0.0f || param1 > 1.0f) {
-        return InvalidSixAxisFusionRange;
-    }
-
-    auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    sixaxis.fusion = sixaxis_fusion_parameters;
-
-    return ResultSuccess;
+NPad::SixAxisLifo& NPad::GetSixAxisDualRightLifo(Core::HID::NpadIdType npad_id) {
+    return GetControllerFromNpadIdType(npad_id).shared_memory->sixaxis_dual_right_lifo;
 }
 
-Result Controller_NPad::GetSixAxisFusionParameters(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-    Core::HID::SixAxisSensorFusionParameters& parameters) const {
-    const auto is_valid = VerifyValidSixAxisSensorHandle(sixaxis_handle);
-    if (is_valid.IsError()) {
-        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
-        return is_valid;
-    }
-
-    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
-    parameters = sixaxis.fusion;
+NPad::SixAxisLifo& NPad::GetSixAxisLeftLifo(Core::HID::NpadIdType npad_id) {
+    return GetControllerFromNpadIdType(npad_id).shared_memory->sixaxis_left_lifo;
+}
 
-    return ResultSuccess;
+NPad::SixAxisLifo& NPad::GetSixAxisRightLifo(Core::HID::NpadIdType npad_id) {
+    return GetControllerFromNpadIdType(npad_id).shared_memory->sixaxis_right_lifo;
 }
 
-Result Controller_NPad::MergeSingleJoyAsDualJoy(Core::HID::NpadIdType npad_id_1,
-                                                Core::HID::NpadIdType npad_id_2) {
+Result NPad::MergeSingleJoyAsDualJoy(Core::HID::NpadIdType npad_id_1,
+                                     Core::HID::NpadIdType npad_id_2) {
     if (!IsNpadIdValid(npad_id_1) || !IsNpadIdValid(npad_id_2)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id_1:{}, npad_id_2:{}", npad_id_1,
                   npad_id_2);
@@ -1400,18 +1065,17 @@ Result Controller_NPad::MergeSingleJoyAsDualJoy(Core::HID::NpadIdType npad_id_1,
     return ResultSuccess;
 }
 
-void Controller_NPad::StartLRAssignmentMode() {
+void NPad::StartLRAssignmentMode() {
     // Nothing internally is used for lr assignment mode. Since we have the ability to set the
     // controller types from boot, it doesn't really matter about showing a selection screen
     is_in_lr_assignment_mode = true;
 }
 
-void Controller_NPad::StopLRAssignmentMode() {
+void NPad::StopLRAssignmentMode() {
     is_in_lr_assignment_mode = false;
 }
 
-Result Controller_NPad::SwapNpadAssignment(Core::HID::NpadIdType npad_id_1,
-                                           Core::HID::NpadIdType npad_id_2) {
+Result NPad::SwapNpadAssignment(Core::HID::NpadIdType npad_id_1, Core::HID::NpadIdType npad_id_2) {
     if (!IsNpadIdValid(npad_id_1) || !IsNpadIdValid(npad_id_2)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id_1:{}, npad_id_2:{}", npad_id_1,
                   npad_id_2);
@@ -1442,8 +1106,7 @@ Result Controller_NPad::SwapNpadAssignment(Core::HID::NpadIdType npad_id_1,
     return ResultSuccess;
 }
 
-Result Controller_NPad::GetLedPattern(Core::HID::NpadIdType npad_id,
-                                      Core::HID::LedPattern& pattern) const {
+Result NPad::GetLedPattern(Core::HID::NpadIdType npad_id, Core::HID::LedPattern& pattern) const {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         return InvalidNpadId;
@@ -1453,8 +1116,8 @@ Result Controller_NPad::GetLedPattern(Core::HID::NpadIdType npad_id,
     return ResultSuccess;
 }
 
-Result Controller_NPad::IsUnintendedHomeButtonInputProtectionEnabled(Core::HID::NpadIdType npad_id,
-                                                                     bool& is_valid) const {
+Result NPad::IsUnintendedHomeButtonInputProtectionEnabled(Core::HID::NpadIdType npad_id,
+                                                          bool& is_valid) const {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         return InvalidNpadId;
@@ -1464,8 +1127,8 @@ Result Controller_NPad::IsUnintendedHomeButtonInputProtectionEnabled(Core::HID::
     return ResultSuccess;
 }
 
-Result Controller_NPad::SetUnintendedHomeButtonInputProtectionEnabled(
-    bool is_protection_enabled, Core::HID::NpadIdType npad_id) {
+Result NPad::SetUnintendedHomeButtonInputProtectionEnabled(bool is_protection_enabled,
+                                                           Core::HID::NpadIdType npad_id) {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         return InvalidNpadId;
@@ -1475,11 +1138,11 @@ Result Controller_NPad::SetUnintendedHomeButtonInputProtectionEnabled(
     return ResultSuccess;
 }
 
-void Controller_NPad::SetAnalogStickUseCenterClamp(bool use_center_clamp) {
+void NPad::SetAnalogStickUseCenterClamp(bool use_center_clamp) {
     analog_stick_use_center_clamp = use_center_clamp;
 }
 
-void Controller_NPad::ClearAllConnectedControllers() {
+void NPad::ClearAllConnectedControllers() {
     for (auto& controller : controller_data) {
         if (controller.device->IsConnected() &&
             controller.device->GetNpadStyleIndex() != Core::HID::NpadStyleIndex::None) {
@@ -1489,13 +1152,13 @@ void Controller_NPad::ClearAllConnectedControllers() {
     }
 }
 
-void Controller_NPad::DisconnectAllConnectedControllers() {
+void NPad::DisconnectAllConnectedControllers() {
     for (auto& controller : controller_data) {
         controller.device->Disconnect();
     }
 }
 
-void Controller_NPad::ConnectAllDisconnectedControllers() {
+void NPad::ConnectAllDisconnectedControllers() {
     for (auto& controller : controller_data) {
         if (controller.device->GetNpadStyleIndex() != Core::HID::NpadStyleIndex::None &&
             !controller.device->IsConnected()) {
@@ -1504,18 +1167,18 @@ void Controller_NPad::ConnectAllDisconnectedControllers() {
     }
 }
 
-void Controller_NPad::ClearAllControllers() {
+void NPad::ClearAllControllers() {
     for (auto& controller : controller_data) {
         controller.device->Disconnect();
         controller.device->SetNpadStyleIndex(Core::HID::NpadStyleIndex::None);
     }
 }
 
-Core::HID::NpadButton Controller_NPad::GetAndResetPressState() {
+Core::HID::NpadButton NPad::GetAndResetPressState() {
     return static_cast<Core::HID::NpadButton>(press_state.exchange(0));
 }
 
-void Controller_NPad::ApplyNpadSystemCommonPolicy() {
+void NPad::ApplyNpadSystemCommonPolicy() {
     Core::HID::NpadStyleTag styletag{};
     styletag.fullkey.Assign(1);
     styletag.handheld.Assign(1);
@@ -1540,7 +1203,7 @@ void Controller_NPad::ApplyNpadSystemCommonPolicy() {
     supported_npad_id_types[9] = Core::HID::NpadIdType::Handheld;
 }
 
-bool Controller_NPad::IsControllerSupported(Core::HID::NpadStyleIndex controller) const {
+bool NPad::IsControllerSupported(Core::HID::NpadStyleIndex controller) const {
     if (controller == Core::HID::NpadStyleIndex::Handheld) {
         const bool support_handheld =
             std::find(supported_npad_id_types.begin(), supported_npad_id_types.end(),
@@ -1591,51 +1254,50 @@ bool Controller_NPad::IsControllerSupported(Core::HID::NpadStyleIndex controller
     return false;
 }
 
-Controller_NPad::NpadControllerData& Controller_NPad::GetControllerFromHandle(
-    const Core::HID::SixAxisSensorHandle& device_handle) {
+NPad::NpadControllerData& NPad::GetControllerFromHandle(
+    const Core::HID::VibrationDeviceHandle& device_handle) {
     const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
     return GetControllerFromNpadIdType(npad_id);
 }
 
-const Controller_NPad::NpadControllerData& Controller_NPad::GetControllerFromHandle(
-    const Core::HID::SixAxisSensorHandle& device_handle) const {
+const NPad::NpadControllerData& NPad::GetControllerFromHandle(
+    const Core::HID::VibrationDeviceHandle& device_handle) const {
     const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
     return GetControllerFromNpadIdType(npad_id);
 }
 
-Controller_NPad::NpadControllerData& Controller_NPad::GetControllerFromHandle(
-    const Core::HID::VibrationDeviceHandle& device_handle) {
+NPad::NpadControllerData& NPad::GetControllerFromHandle(
+    const Core::HID::SixAxisSensorHandle& device_handle) {
     const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
     return GetControllerFromNpadIdType(npad_id);
 }
 
-const Controller_NPad::NpadControllerData& Controller_NPad::GetControllerFromHandle(
-    const Core::HID::VibrationDeviceHandle& device_handle) const {
+const NPad::NpadControllerData& NPad::GetControllerFromHandle(
+    const Core::HID::SixAxisSensorHandle& device_handle) const {
     const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
     return GetControllerFromNpadIdType(npad_id);
 }
 
-Controller_NPad::NpadControllerData& Controller_NPad::GetControllerFromNpadIdType(
-    Core::HID::NpadIdType npad_id) {
+NPad::NpadControllerData& NPad::GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id) {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         npad_id = Core::HID::NpadIdType::Player1;
     }
-    const auto npad_index = Core::HID::NpadIdTypeToIndex(npad_id);
+    const auto npad_index = NpadIdTypeToIndex(npad_id);
     return controller_data[npad_index];
 }
 
-const Controller_NPad::NpadControllerData& Controller_NPad::GetControllerFromNpadIdType(
+const NPad::NpadControllerData& NPad::GetControllerFromNpadIdType(
     Core::HID::NpadIdType npad_id) const {
     if (!IsNpadIdValid(npad_id)) {
         LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
         npad_id = Core::HID::NpadIdType::Player1;
     }
-    const auto npad_index = Core::HID::NpadIdTypeToIndex(npad_id);
+    const auto npad_index = NpadIdTypeToIndex(npad_id);
     return controller_data[npad_index];
 }
 
-Core::HID::SixAxisSensorProperties& Controller_NPad::GetSixaxisProperties(
+Core::HID::SixAxisSensorProperties& NPad::GetSixaxisProperties(
     const Core::HID::SixAxisSensorHandle& sixaxis_handle) {
     auto& controller = GetControllerFromHandle(sixaxis_handle);
     switch (sixaxis_handle.npad_type) {
@@ -1658,7 +1320,7 @@ Core::HID::SixAxisSensorProperties& Controller_NPad::GetSixaxisProperties(
     }
 }
 
-const Core::HID::SixAxisSensorProperties& Controller_NPad::GetSixaxisProperties(
+const Core::HID::SixAxisSensorProperties& NPad::GetSixaxisProperties(
     const Core::HID::SixAxisSensorHandle& sixaxis_handle) const {
     const auto& controller = GetControllerFromHandle(sixaxis_handle);
     switch (sixaxis_handle.npad_type) {
@@ -1681,65 +1343,13 @@ const Core::HID::SixAxisSensorProperties& Controller_NPad::GetSixaxisProperties(
     }
 }
 
-Controller_NPad::SixaxisParameters& Controller_NPad::GetSixaxisState(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle) {
-    auto& controller = GetControllerFromHandle(sixaxis_handle);
-    switch (sixaxis_handle.npad_type) {
-    case Core::HID::NpadStyleIndex::ProController:
-    case Core::HID::NpadStyleIndex::Pokeball:
-        return controller.sixaxis_fullkey;
-    case Core::HID::NpadStyleIndex::Handheld:
-        return controller.sixaxis_handheld;
-    case Core::HID::NpadStyleIndex::JoyconDual:
-        if (sixaxis_handle.device_index == Core::HID::DeviceIndex::Left) {
-            return controller.sixaxis_dual_left;
-        }
-        return controller.sixaxis_dual_right;
-    case Core::HID::NpadStyleIndex::JoyconLeft:
-        return controller.sixaxis_left;
-    case Core::HID::NpadStyleIndex::JoyconRight:
-        return controller.sixaxis_right;
-    default:
-        return controller.sixaxis_unknown;
-    }
-}
-
-const Controller_NPad::SixaxisParameters& Controller_NPad::GetSixaxisState(
-    const Core::HID::SixAxisSensorHandle& sixaxis_handle) const {
-    const auto& controller = GetControllerFromHandle(sixaxis_handle);
-    switch (sixaxis_handle.npad_type) {
-    case Core::HID::NpadStyleIndex::ProController:
-    case Core::HID::NpadStyleIndex::Pokeball:
-        return controller.sixaxis_fullkey;
-    case Core::HID::NpadStyleIndex::Handheld:
-        return controller.sixaxis_handheld;
-    case Core::HID::NpadStyleIndex::JoyconDual:
-        if (sixaxis_handle.device_index == Core::HID::DeviceIndex::Left) {
-            return controller.sixaxis_dual_left;
-        }
-        return controller.sixaxis_dual_right;
-    case Core::HID::NpadStyleIndex::JoyconLeft:
-        return controller.sixaxis_left;
-    case Core::HID::NpadStyleIndex::JoyconRight:
-        return controller.sixaxis_right;
-    default:
-        return controller.sixaxis_unknown;
-    }
-}
-
-Controller_NPad::AppletDetailedUiType Controller_NPad::GetAppletDetailedUiType(
-    Core::HID::NpadIdType npad_id) {
-
-    auto controller = GetControllerFromNpadIdType(npad_id);
-    auto shared_memory = controller.shared_memory;
-    Service::HID::Controller_NPad::AppletFooterUiType applet_footer_type =
-        shared_memory->applet_footer_type;
+NPad::AppletDetailedUiType NPad::GetAppletDetailedUiType(Core::HID::NpadIdType npad_id) {
+    const auto& shared_memory = GetControllerFromNpadIdType(npad_id).shared_memory;
 
-    Controller_NPad::AppletDetailedUiType detailed_ui_type{
+    return {
         .ui_variant = 0,
-        .footer = applet_footer_type,
+        .footer = shared_memory->applet_footer_type,
     };
-    return detailed_ui_type;
 }
 
 } // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/npad.h b/src/core/hle/service/hid/controllers/npad.h
index cd93abdd167d..9167c93f0ddd 100644
--- a/src/core/hle/service/hid/controllers/npad.h
+++ b/src/core/hle/service/hid/controllers/npad.h
@@ -10,7 +10,6 @@
 
 #include "common/bit_field.h"
 #include "common/common_types.h"
-#include "common/vector_math.h"
 
 #include "core/hid/hid_types.h"
 #include "core/hle/service/hid/controllers/controller_base.h"
@@ -34,11 +33,11 @@ union Result;
 
 namespace Service::HID {
 
-class Controller_NPad final : public ControllerBase {
+class NPad final : public ControllerBase {
 public:
-    explicit Controller_NPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_,
-                             KernelHelpers::ServiceContext& service_context_);
-    ~Controller_NPad() override;
+    explicit NPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_,
+                  KernelHelpers::ServiceContext& service_context_);
+    ~NPad() override;
 
     // Called when the controller is initialized
     void OnInit() override;
@@ -49,9 +48,6 @@ class Controller_NPad final : public ControllerBase {
     // When the controller is requesting an update for the shared memory
     void OnUpdate(const Core::Timing::CoreTiming& core_timing) override;
 
-    // When the controller is requesting a motion update for the shared memory
-    void OnMotionUpdate(const Core::Timing::CoreTiming& core_timing) override;
-
     // This is nn::hid::NpadJoyHoldType
     enum class NpadJoyHoldType : u64 {
         Vertical = 0,
@@ -133,6 +129,8 @@ class Controller_NPad final : public ControllerBase {
         Revision3 = 3,
     };
 
+    using SixAxisLifo = Lifo<Core::HID::SixAxisSensorState, hid_entry_count>;
+
     void SetSupportedStyleSet(Core::HID::NpadStyleTag style_set);
     Core::HID::NpadStyleTag GetSupportedStyleSet() const;
 
@@ -185,37 +183,18 @@ class Controller_NPad final : public ControllerBase {
 
     Result DisconnectNpad(Core::HID::NpadIdType npad_id);
 
-    Result SetGyroscopeZeroDriftMode(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                                     Core::HID::GyroscopeZeroDriftMode drift_mode);
-    Result GetGyroscopeZeroDriftMode(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                                     Core::HID::GyroscopeZeroDriftMode& drift_mode) const;
-    Result IsSixAxisSensorAtRest(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                                 bool& is_at_rest) const;
     Result IsFirmwareUpdateAvailableForSixAxisSensor(
         const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_firmware_available) const;
-    Result EnableSixAxisSensorUnalteredPassthrough(
-        const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool is_enabled);
-    Result IsSixAxisSensorUnalteredPassthroughEnabled(
-        const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_enabled) const;
-    Result LoadSixAxisSensorCalibrationParameter(
-        const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-        Core::HID::SixAxisSensorCalibrationParameter& calibration) const;
-    Result GetSixAxisSensorIcInformation(
-        const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-        Core::HID::SixAxisSensorIcInformation& ic_information) const;
     Result ResetIsSixAxisSensorDeviceNewlyAssigned(
         const Core::HID::SixAxisSensorHandle& sixaxis_handle);
-    Result SetSixAxisEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                             bool sixaxis_status);
-    Result IsSixAxisSensorFusionEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                                        bool& is_fusion_enabled) const;
-    Result SetSixAxisFusionEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                                   bool is_fusion_enabled);
-    Result SetSixAxisFusionParameters(
-        const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-        Core::HID::SixAxisSensorFusionParameters sixaxis_fusion_parameters);
-    Result GetSixAxisFusionParameters(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
-                                      Core::HID::SixAxisSensorFusionParameters& parameters) const;
+
+    SixAxisLifo& GetSixAxisFullkeyLifo(Core::HID::NpadIdType npad_id);
+    SixAxisLifo& GetSixAxisHandheldLifo(Core::HID::NpadIdType npad_id);
+    SixAxisLifo& GetSixAxisDualLeftLifo(Core::HID::NpadIdType npad_id);
+    SixAxisLifo& GetSixAxisDualRightLifo(Core::HID::NpadIdType npad_id);
+    SixAxisLifo& GetSixAxisLeftLifo(Core::HID::NpadIdType npad_id);
+    SixAxisLifo& GetSixAxisRightLifo(Core::HID::NpadIdType npad_id);
+
     Result GetLedPattern(Core::HID::NpadIdType npad_id, Core::HID::LedPattern& pattern) const;
     Result IsUnintendedHomeButtonInputProtectionEnabled(Core::HID::NpadIdType npad_id,
                                                         bool& is_enabled) const;
@@ -239,10 +218,6 @@ class Controller_NPad final : public ControllerBase {
 
     void ApplyNpadSystemCommonPolicy();
 
-    static bool IsNpadIdValid(Core::HID::NpadIdType npad_id);
-    static Result IsDeviceHandleValid(const Core::HID::VibrationDeviceHandle& device_handle);
-    static Result VerifyValidSixAxisSensorHandle(
-        const Core::HID::SixAxisSensorHandle& device_handle);
     AppletDetailedUiType GetAppletDetailedUiType(Core::HID::NpadIdType npad_id);
 
 private:
@@ -302,29 +277,6 @@ class Controller_NPad final : public ControllerBase {
     };
     static_assert(sizeof(NPadGenericState) == 0x28, "NPadGenericState is an invalid size");
 
-    // This is nn::hid::SixAxisSensorAttribute
-    struct SixAxisSensorAttribute {
-        union {
-            u32 raw{};
-            BitField<0, 1, u32> is_connected;
-            BitField<1, 1, u32> is_interpolated;
-        };
-    };
-    static_assert(sizeof(SixAxisSensorAttribute) == 4, "SixAxisSensorAttribute is an invalid size");
-
-    // This is nn::hid::SixAxisSensorState
-    struct SixAxisSensorState {
-        s64 delta_time{};
-        s64 sampling_number{};
-        Common::Vec3f accel{};
-        Common::Vec3f gyro{};
-        Common::Vec3f rotation{};
-        std::array<Common::Vec3f, 3> orientation{};
-        SixAxisSensorAttribute attribute{};
-        INSERT_PADDING_BYTES(4); // Reserved
-    };
-    static_assert(sizeof(SixAxisSensorState) == 0x60, "SixAxisSensorState is an invalid size");
-
     // This is nn::hid::server::NpadGcTriggerState
     struct NpadGcTriggerState {
         s64 sampling_number{};
@@ -444,12 +396,12 @@ class Controller_NPad final : public ControllerBase {
         Lifo<NPadGenericState, hid_entry_count> joy_right_lifo{};
         Lifo<NPadGenericState, hid_entry_count> palma_lifo{};
         Lifo<NPadGenericState, hid_entry_count> system_ext_lifo{};
-        Lifo<SixAxisSensorState, hid_entry_count> sixaxis_fullkey_lifo{};
-        Lifo<SixAxisSensorState, hid_entry_count> sixaxis_handheld_lifo{};
-        Lifo<SixAxisSensorState, hid_entry_count> sixaxis_dual_left_lifo{};
-        Lifo<SixAxisSensorState, hid_entry_count> sixaxis_dual_right_lifo{};
-        Lifo<SixAxisSensorState, hid_entry_count> sixaxis_left_lifo{};
-        Lifo<SixAxisSensorState, hid_entry_count> sixaxis_right_lifo{};
+        Lifo<Core::HID::SixAxisSensorState, hid_entry_count> sixaxis_fullkey_lifo{};
+        Lifo<Core::HID::SixAxisSensorState, hid_entry_count> sixaxis_handheld_lifo{};
+        Lifo<Core::HID::SixAxisSensorState, hid_entry_count> sixaxis_dual_left_lifo{};
+        Lifo<Core::HID::SixAxisSensorState, hid_entry_count> sixaxis_dual_right_lifo{};
+        Lifo<Core::HID::SixAxisSensorState, hid_entry_count> sixaxis_left_lifo{};
+        Lifo<Core::HID::SixAxisSensorState, hid_entry_count> sixaxis_right_lifo{};
         DeviceType device_type{};
         INSERT_PADDING_BYTES(0x4); // Reserved
         NPadSystemProperties system_properties{};
@@ -483,16 +435,6 @@ class Controller_NPad final : public ControllerBase {
         std::chrono::steady_clock::time_point last_vibration_timepoint{};
     };
 
-    struct SixaxisParameters {
-        bool is_fusion_enabled{true};
-        bool unaltered_passtrough{false};
-        Core::HID::SixAxisSensorFusionParameters fusion{};
-        Core::HID::SixAxisSensorCalibrationParameter calibration{};
-        Core::HID::SixAxisSensorIcInformation ic_information{};
-        Core::HID::GyroscopeZeroDriftMode gyroscope_zero_drift_mode{
-            Core::HID::GyroscopeZeroDriftMode::Standard};
-    };
-
     struct NpadControllerData {
         Kernel::KEvent* styleset_changed_event{};
         NpadInternalState* shared_memory = nullptr;
@@ -506,27 +448,10 @@ class Controller_NPad final : public ControllerBase {
         bool is_dual_left_connected{true};
         bool is_dual_right_connected{true};
 
-        // Motion parameters
-        bool sixaxis_at_rest{true};
-        bool sixaxis_sensor_enabled{true};
-        SixaxisParameters sixaxis_fullkey{};
-        SixaxisParameters sixaxis_handheld{};
-        SixaxisParameters sixaxis_dual_left{};
-        SixaxisParameters sixaxis_dual_right{};
-        SixaxisParameters sixaxis_left{};
-        SixaxisParameters sixaxis_right{};
-        SixaxisParameters sixaxis_unknown{};
-
         // Current pad state
         NPadGenericState npad_pad_state{};
         NPadGenericState npad_libnx_state{};
         NpadGcTriggerState npad_trigger_state{};
-        SixAxisSensorState sixaxis_fullkey_state{};
-        SixAxisSensorState sixaxis_handheld_state{};
-        SixAxisSensorState sixaxis_dual_left_state{};
-        SixAxisSensorState sixaxis_dual_right_state{};
-        SixAxisSensorState sixaxis_left_lifo_state{};
-        SixAxisSensorState sixaxis_right_lifo_state{};
         int callback_key{};
     };
 
@@ -536,14 +461,14 @@ class Controller_NPad final : public ControllerBase {
     void RequestPadStateUpdate(Core::HID::NpadIdType npad_id);
     void WriteEmptyEntry(NpadInternalState* npad);
 
-    NpadControllerData& GetControllerFromHandle(
-        const Core::HID::SixAxisSensorHandle& device_handle);
-    const NpadControllerData& GetControllerFromHandle(
-        const Core::HID::SixAxisSensorHandle& device_handle) const;
     NpadControllerData& GetControllerFromHandle(
         const Core::HID::VibrationDeviceHandle& device_handle);
     const NpadControllerData& GetControllerFromHandle(
         const Core::HID::VibrationDeviceHandle& device_handle) const;
+    NpadControllerData& GetControllerFromHandle(
+        const Core::HID::SixAxisSensorHandle& device_handle);
+    const NpadControllerData& GetControllerFromHandle(
+        const Core::HID::SixAxisSensorHandle& device_handle) const;
     NpadControllerData& GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id);
     const NpadControllerData& GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id) const;
 
@@ -551,9 +476,6 @@ class Controller_NPad final : public ControllerBase {
         const Core::HID::SixAxisSensorHandle& device_handle);
     const Core::HID::SixAxisSensorProperties& GetSixaxisProperties(
         const Core::HID::SixAxisSensorHandle& device_handle) const;
-    SixaxisParameters& GetSixaxisState(const Core::HID::SixAxisSensorHandle& device_handle);
-    const SixaxisParameters& GetSixaxisState(
-        const Core::HID::SixAxisSensorHandle& device_handle) const;
 
     std::atomic<u64> press_state{};
 
diff --git a/src/core/hle/service/hid/controllers/palma.cpp b/src/core/hle/service/hid/controllers/palma.cpp
index 51a18335f5dc..588ff9d620d2 100644
--- a/src/core/hle/service/hid/controllers/palma.cpp
+++ b/src/core/hle/service/hid/controllers/palma.cpp
@@ -12,35 +12,35 @@
 
 namespace Service::HID {
 
-Controller_Palma::Controller_Palma(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_,
-                                   KernelHelpers::ServiceContext& service_context_)
+Palma::Palma(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_,
+             KernelHelpers::ServiceContext& service_context_)
     : ControllerBase{hid_core_}, service_context{service_context_} {
     controller = hid_core.GetEmulatedController(Core::HID::NpadIdType::Other);
     operation_complete_event = service_context.CreateEvent("hid:PalmaOperationCompleteEvent");
 }
 
-Controller_Palma::~Controller_Palma() {
+Palma::~Palma() {
     service_context.CloseEvent(operation_complete_event);
 };
 
-void Controller_Palma::OnInit() {}
+void Palma::OnInit() {}
 
-void Controller_Palma::OnRelease() {}
+void Palma::OnRelease() {}
 
-void Controller_Palma::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void Palma::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     if (!IsControllerActivated()) {
         return;
     }
 }
 
-Result Controller_Palma::GetPalmaConnectionHandle(Core::HID::NpadIdType npad_id,
-                                                  PalmaConnectionHandle& handle) {
+Result Palma::GetPalmaConnectionHandle(Core::HID::NpadIdType npad_id,
+                                       PalmaConnectionHandle& handle) {
     active_handle.npad_id = npad_id;
     handle = active_handle;
     return ResultSuccess;
 }
 
-Result Controller_Palma::InitializePalma(const PalmaConnectionHandle& handle) {
+Result Palma::InitializePalma(const PalmaConnectionHandle& handle) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -48,7 +48,7 @@ Result Controller_Palma::InitializePalma(const PalmaConnectionHandle& handle) {
     return ResultSuccess;
 }
 
-Kernel::KReadableEvent& Controller_Palma::AcquirePalmaOperationCompleteEvent(
+Kernel::KReadableEvent& Palma::AcquirePalmaOperationCompleteEvent(
     const PalmaConnectionHandle& handle) const {
     if (handle.npad_id != active_handle.npad_id) {
         LOG_ERROR(Service_HID, "Invalid npad id {}", handle.npad_id);
@@ -56,9 +56,9 @@ Kernel::KReadableEvent& Controller_Palma::AcquirePalmaOperationCompleteEvent(
     return operation_complete_event->GetReadableEvent();
 }
 
-Result Controller_Palma::GetPalmaOperationInfo(const PalmaConnectionHandle& handle,
-                                               PalmaOperationType& operation_type,
-                                               PalmaOperationData& data) const {
+Result Palma::GetPalmaOperationInfo(const PalmaConnectionHandle& handle,
+                                    PalmaOperationType& operation_type,
+                                    PalmaOperationData& data) const {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -67,8 +67,7 @@ Result Controller_Palma::GetPalmaOperationInfo(const PalmaConnectionHandle& hand
     return ResultSuccess;
 }
 
-Result Controller_Palma::PlayPalmaActivity(const PalmaConnectionHandle& handle,
-                                           u64 palma_activity) {
+Result Palma::PlayPalmaActivity(const PalmaConnectionHandle& handle, u64 palma_activity) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -79,8 +78,7 @@ Result Controller_Palma::PlayPalmaActivity(const PalmaConnectionHandle& handle,
     return ResultSuccess;
 }
 
-Result Controller_Palma::SetPalmaFrModeType(const PalmaConnectionHandle& handle,
-                                            PalmaFrModeType fr_mode_) {
+Result Palma::SetPalmaFrModeType(const PalmaConnectionHandle& handle, PalmaFrModeType fr_mode_) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -88,7 +86,7 @@ Result Controller_Palma::SetPalmaFrModeType(const PalmaConnectionHandle& handle,
     return ResultSuccess;
 }
 
-Result Controller_Palma::ReadPalmaStep(const PalmaConnectionHandle& handle) {
+Result Palma::ReadPalmaStep(const PalmaConnectionHandle& handle) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -99,25 +97,25 @@ Result Controller_Palma::ReadPalmaStep(const PalmaConnectionHandle& handle) {
     return ResultSuccess;
 }
 
-Result Controller_Palma::EnablePalmaStep(const PalmaConnectionHandle& handle, bool is_enabled) {
+Result Palma::EnablePalmaStep(const PalmaConnectionHandle& handle, bool is_enabled) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
     return ResultSuccess;
 }
 
-Result Controller_Palma::ResetPalmaStep(const PalmaConnectionHandle& handle) {
+Result Palma::ResetPalmaStep(const PalmaConnectionHandle& handle) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
     return ResultSuccess;
 }
 
-void Controller_Palma::ReadPalmaApplicationSection() {}
+void Palma::ReadPalmaApplicationSection() {}
 
-void Controller_Palma::WritePalmaApplicationSection() {}
+void Palma::WritePalmaApplicationSection() {}
 
-Result Controller_Palma::ReadPalmaUniqueCode(const PalmaConnectionHandle& handle) {
+Result Palma::ReadPalmaUniqueCode(const PalmaConnectionHandle& handle) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -128,7 +126,7 @@ Result Controller_Palma::ReadPalmaUniqueCode(const PalmaConnectionHandle& handle
     return ResultSuccess;
 }
 
-Result Controller_Palma::SetPalmaUniqueCodeInvalid(const PalmaConnectionHandle& handle) {
+Result Palma::SetPalmaUniqueCodeInvalid(const PalmaConnectionHandle& handle) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -139,10 +137,9 @@ Result Controller_Palma::SetPalmaUniqueCodeInvalid(const PalmaConnectionHandle&
     return ResultSuccess;
 }
 
-void Controller_Palma::WritePalmaActivityEntry() {}
+void Palma::WritePalmaActivityEntry() {}
 
-Result Controller_Palma::WritePalmaRgbLedPatternEntry(const PalmaConnectionHandle& handle,
-                                                      u64 unknown) {
+Result Palma::WritePalmaRgbLedPatternEntry(const PalmaConnectionHandle& handle, u64 unknown) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -153,8 +150,8 @@ Result Controller_Palma::WritePalmaRgbLedPatternEntry(const PalmaConnectionHandl
     return ResultSuccess;
 }
 
-Result Controller_Palma::WritePalmaWaveEntry(const PalmaConnectionHandle& handle, PalmaWaveSet wave,
-                                             Common::ProcessAddress t_mem, u64 size) {
+Result Palma::WritePalmaWaveEntry(const PalmaConnectionHandle& handle, PalmaWaveSet wave,
+                                  Common::ProcessAddress t_mem, u64 size) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -165,8 +162,8 @@ Result Controller_Palma::WritePalmaWaveEntry(const PalmaConnectionHandle& handle
     return ResultSuccess;
 }
 
-Result Controller_Palma::SetPalmaDataBaseIdentificationVersion(const PalmaConnectionHandle& handle,
-                                                               s32 database_id_version_) {
+Result Palma::SetPalmaDataBaseIdentificationVersion(const PalmaConnectionHandle& handle,
+                                                    s32 database_id_version_) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -178,8 +175,7 @@ Result Controller_Palma::SetPalmaDataBaseIdentificationVersion(const PalmaConnec
     return ResultSuccess;
 }
 
-Result Controller_Palma::GetPalmaDataBaseIdentificationVersion(
-    const PalmaConnectionHandle& handle) {
+Result Palma::GetPalmaDataBaseIdentificationVersion(const PalmaConnectionHandle& handle) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -191,26 +187,26 @@ Result Controller_Palma::GetPalmaDataBaseIdentificationVersion(
     return ResultSuccess;
 }
 
-void Controller_Palma::SuspendPalmaFeature() {}
+void Palma::SuspendPalmaFeature() {}
 
-Result Controller_Palma::GetPalmaOperationResult(const PalmaConnectionHandle& handle) const {
+Result Palma::GetPalmaOperationResult(const PalmaConnectionHandle& handle) const {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
     return operation.result;
 }
-void Controller_Palma::ReadPalmaPlayLog() {}
+void Palma::ReadPalmaPlayLog() {}
 
-void Controller_Palma::ResetPalmaPlayLog() {}
+void Palma::ResetPalmaPlayLog() {}
 
-void Controller_Palma::SetIsPalmaAllConnectable(bool is_all_connectable) {
+void Palma::SetIsPalmaAllConnectable(bool is_all_connectable) {
     // If true controllers are able to be paired
     is_connectable = is_all_connectable;
 }
 
-void Controller_Palma::SetIsPalmaPairedConnectable() {}
+void Palma::SetIsPalmaPairedConnectable() {}
 
-Result Controller_Palma::PairPalma(const PalmaConnectionHandle& handle) {
+Result Palma::PairPalma(const PalmaConnectionHandle& handle) {
     if (handle.npad_id != active_handle.npad_id) {
         return InvalidPalmaHandle;
     }
@@ -218,14 +214,14 @@ Result Controller_Palma::PairPalma(const PalmaConnectionHandle& handle) {
     return ResultSuccess;
 }
 
-void Controller_Palma::SetPalmaBoostMode(bool boost_mode) {}
+void Palma::SetPalmaBoostMode(bool boost_mode) {}
 
-void Controller_Palma::CancelWritePalmaWaveEntry() {}
+void Palma::CancelWritePalmaWaveEntry() {}
 
-void Controller_Palma::EnablePalmaBoostMode() {}
+void Palma::EnablePalmaBoostMode() {}
 
-void Controller_Palma::GetPalmaBluetoothAddress() {}
+void Palma::GetPalmaBluetoothAddress() {}
 
-void Controller_Palma::SetDisallowedPalmaConnection() {}
+void Palma::SetDisallowedPalmaConnection() {}
 
 } // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/palma.h b/src/core/hle/service/hid/controllers/palma.h
index a0491a8194a8..a6047f36af83 100644
--- a/src/core/hle/service/hid/controllers/palma.h
+++ b/src/core/hle/service/hid/controllers/palma.h
@@ -23,7 +23,7 @@ class EmulatedController;
 } // namespace Core::HID
 
 namespace Service::HID {
-class Controller_Palma final : public ControllerBase {
+class Palma final : public ControllerBase {
 public:
     using PalmaOperationData = std::array<u8, 0x140>;
 
@@ -97,9 +97,9 @@ class Controller_Palma final : public ControllerBase {
     static_assert(sizeof(PalmaConnectionHandle) == 0x8,
                   "PalmaConnectionHandle has incorrect size.");
 
-    explicit Controller_Palma(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_,
-                              KernelHelpers::ServiceContext& service_context_);
-    ~Controller_Palma() override;
+    explicit Palma(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_,
+                   KernelHelpers::ServiceContext& service_context_);
+    ~Palma() override;
 
     // Called when the controller is initialized
     void OnInit() override;
diff --git a/src/core/hle/service/hid/controllers/console_sixaxis.cpp b/src/core/hle/service/hid/controllers/seven_six_axis.cpp
similarity index 55%
rename from src/core/hle/service/hid/controllers/console_sixaxis.cpp
rename to src/core/hle/service/hid/controllers/seven_six_axis.cpp
index bcb272eaff87..4955684843b7 100644
--- a/src/core/hle/service/hid/controllers/console_sixaxis.cpp
+++ b/src/core/hle/service/hid/controllers/seven_six_axis.cpp
@@ -1,32 +1,29 @@
-// SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project
-// SPDX-License-Identifier: GPL-2.0-or-later
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
 
+#include <cstring>
+#include "common/common_types.h"
 #include "core/core.h"
 #include "core/core_timing.h"
+#include "core/frontend/emu_window.h"
 #include "core/hid/emulated_console.h"
+#include "core/hid/emulated_devices.h"
 #include "core/hid/hid_core.h"
-#include "core/hle/service/hid/controllers/console_sixaxis.h"
+#include "core/hle/service/hid/controllers/seven_six_axis.h"
 #include "core/memory.h"
 
 namespace Service::HID {
-constexpr std::size_t SHARED_MEMORY_OFFSET = 0x3C200;
-
-Controller_ConsoleSixAxis::Controller_ConsoleSixAxis(Core::System& system_, u8* raw_shared_memory_)
+SevenSixAxis::SevenSixAxis(Core::System& system_)
     : ControllerBase{system_.HIDCore()}, system{system_} {
     console = hid_core.GetEmulatedConsole();
-    static_assert(SHARED_MEMORY_OFFSET + sizeof(ConsoleSharedMemory) < shared_memory_size,
-                  "ConsoleSharedMemory is bigger than the shared memory");
-    shared_memory = std::construct_at(
-        reinterpret_cast<ConsoleSharedMemory*>(raw_shared_memory_ + SHARED_MEMORY_OFFSET));
 }
 
-Controller_ConsoleSixAxis::~Controller_ConsoleSixAxis() = default;
-
-void Controller_ConsoleSixAxis::OnInit() {}
+SevenSixAxis::~SevenSixAxis() = default;
 
-void Controller_ConsoleSixAxis::OnRelease() {}
+void SevenSixAxis::OnInit() {}
+void SevenSixAxis::OnRelease() {}
 
-void Controller_ConsoleSixAxis::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void SevenSixAxis::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     if (!IsControllerActivated() || transfer_memory == 0) {
         seven_sixaxis_lifo.buffer_count = 0;
         seven_sixaxis_lifo.buffer_tail = 0;
@@ -53,22 +50,17 @@ void Controller_ConsoleSixAxis::OnUpdate(const Core::Timing::CoreTiming& core_ti
         -motion_status.quaternion.xyz.z,
     };
 
-    shared_memory->sampling_number++;
-    shared_memory->is_seven_six_axis_sensor_at_rest = motion_status.is_at_rest;
-    shared_memory->verticalization_error = motion_status.verticalization_error;
-    shared_memory->gyro_bias = motion_status.gyro_bias;
-
-    // Update seven six axis transfer memory
     seven_sixaxis_lifo.WriteNextEntry(next_seven_sixaxis_state);
     system.ApplicationMemory().WriteBlock(transfer_memory, &seven_sixaxis_lifo,
                                           sizeof(seven_sixaxis_lifo));
 }
 
-void Controller_ConsoleSixAxis::SetTransferMemoryAddress(Common::ProcessAddress t_mem) {
+void SevenSixAxis::SetTransferMemoryAddress(Common::ProcessAddress t_mem) {
     transfer_memory = t_mem;
 }
 
-void Controller_ConsoleSixAxis::ResetTimestamp() {
+void SevenSixAxis::ResetTimestamp() {
     last_saved_timestamp = last_global_timestamp;
 }
+
 } // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/console_sixaxis.h b/src/core/hle/service/hid/controllers/seven_six_axis.h
similarity index 66%
rename from src/core/hle/service/hid/controllers/console_sixaxis.h
rename to src/core/hle/service/hid/controllers/seven_six_axis.h
index 7015d924c16f..40e3f5d125d3 100644
--- a/src/core/hle/service/hid/controllers/console_sixaxis.h
+++ b/src/core/hle/service/hid/controllers/seven_six_axis.h
@@ -1,10 +1,9 @@
-// SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project
-// SPDX-License-Identifier: GPL-2.0-or-later
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
 
 #pragma once
 
-#include <array>
-
+#include "common/common_types.h"
 #include "common/quaternion.h"
 #include "common/typed_address.h"
 #include "core/hle/service/hid/controllers/controller_base.h"
@@ -19,10 +18,10 @@ class EmulatedConsole;
 } // namespace Core::HID
 
 namespace Service::HID {
-class Controller_ConsoleSixAxis final : public ControllerBase {
+class SevenSixAxis final : public ControllerBase {
 public:
-    explicit Controller_ConsoleSixAxis(Core::System& system_, u8* raw_shared_memory_);
-    ~Controller_ConsoleSixAxis() override;
+    explicit SevenSixAxis(Core::System& system_);
+    ~SevenSixAxis() override;
 
     // Called when the controller is initialized
     void OnInit() override;
@@ -51,28 +50,16 @@ class Controller_ConsoleSixAxis final : public ControllerBase {
     };
     static_assert(sizeof(SevenSixAxisState) == 0x48, "SevenSixAxisState is an invalid size");
 
-    // This is nn::hid::detail::ConsoleSixAxisSensorSharedMemoryFormat
-    struct ConsoleSharedMemory {
-        u64 sampling_number{};
-        bool is_seven_six_axis_sensor_at_rest{};
-        INSERT_PADDING_BYTES(3); // padding
-        f32 verticalization_error{};
-        Common::Vec3f gyro_bias{};
-        INSERT_PADDING_BYTES(4); // padding
-    };
-    static_assert(sizeof(ConsoleSharedMemory) == 0x20, "ConsoleSharedMemory is an invalid size");
-
     Lifo<SevenSixAxisState, 0x21> seven_sixaxis_lifo{};
     static_assert(sizeof(seven_sixaxis_lifo) == 0xA70, "SevenSixAxisState is an invalid size");
 
+    u64 last_saved_timestamp{};
+    u64 last_global_timestamp{};
+
     SevenSixAxisState next_seven_sixaxis_state{};
     Common::ProcessAddress transfer_memory{};
-    ConsoleSharedMemory* shared_memory = nullptr;
     Core::HID::EmulatedConsole* console = nullptr;
 
-    u64 last_saved_timestamp{};
-    u64 last_global_timestamp{};
-
     Core::System& system;
 };
 } // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/six_axis.cpp b/src/core/hle/service/hid/controllers/six_axis.cpp
new file mode 100644
index 000000000000..3d24a5c04832
--- /dev/null
+++ b/src/core/hle/service/hid/controllers/six_axis.cpp
@@ -0,0 +1,413 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "common/common_types.h"
+#include "core/core_timing.h"
+#include "core/hid/emulated_controller.h"
+#include "core/hid/hid_core.h"
+#include "core/hle/service/hid/controllers/npad.h"
+#include "core/hle/service/hid/controllers/six_axis.h"
+#include "core/hle/service/hid/errors.h"
+#include "core/hle/service/hid/hid_util.h"
+
+namespace Service::HID {
+
+SixAxis::SixAxis(Core::HID::HIDCore& hid_core_, std::shared_ptr<NPad> npad_)
+    : ControllerBase{hid_core_}, npad{npad_} {
+    for (std::size_t i = 0; i < controller_data.size(); ++i) {
+        auto& controller = controller_data[i];
+        controller.device = hid_core.GetEmulatedControllerByIndex(i);
+    }
+}
+
+SixAxis::~SixAxis() = default;
+
+void SixAxis::OnInit() {}
+void SixAxis::OnRelease() {}
+
+void SixAxis::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+    if (!IsControllerActivated()) {
+        return;
+    }
+
+    for (std::size_t i = 0; i < controller_data.size(); ++i) {
+        auto& controller = controller_data[i];
+
+        const auto npad_id = IndexToNpadIdType(i);
+        const auto& controller_type = controller.device->GetNpadStyleIndex();
+
+        if (controller_type == Core::HID::NpadStyleIndex::None ||
+            !controller.device->IsConnected()) {
+            continue;
+        }
+
+        const auto& motion_state = controller.device->GetMotions();
+        auto& sixaxis_fullkey_state = controller.sixaxis_fullkey_state;
+        auto& sixaxis_handheld_state = controller.sixaxis_handheld_state;
+        auto& sixaxis_dual_left_state = controller.sixaxis_dual_left_state;
+        auto& sixaxis_dual_right_state = controller.sixaxis_dual_right_state;
+        auto& sixaxis_left_lifo_state = controller.sixaxis_left_lifo_state;
+        auto& sixaxis_right_lifo_state = controller.sixaxis_right_lifo_state;
+
+        auto& sixaxis_fullkey_lifo = npad->GetSixAxisFullkeyLifo(npad_id);
+        auto& sixaxis_handheld_lifo = npad->GetSixAxisHandheldLifo(npad_id);
+        auto& sixaxis_dual_left_lifo = npad->GetSixAxisDualLeftLifo(npad_id);
+        auto& sixaxis_dual_right_lifo = npad->GetSixAxisDualRightLifo(npad_id);
+        auto& sixaxis_left_lifo = npad->GetSixAxisLeftLifo(npad_id);
+        auto& sixaxis_right_lifo = npad->GetSixAxisRightLifo(npad_id);
+
+        // Clear previous state
+        sixaxis_fullkey_state = {};
+        sixaxis_handheld_state = {};
+        sixaxis_dual_left_state = {};
+        sixaxis_dual_right_state = {};
+        sixaxis_left_lifo_state = {};
+        sixaxis_right_lifo_state = {};
+
+        if (controller.sixaxis_sensor_enabled && Settings::values.motion_enabled.GetValue()) {
+            controller.sixaxis_at_rest = true;
+            for (std::size_t e = 0; e < motion_state.size(); ++e) {
+                controller.sixaxis_at_rest =
+                    controller.sixaxis_at_rest && motion_state[e].is_at_rest;
+            }
+        }
+
+        const auto set_motion_state = [&](Core::HID::SixAxisSensorState& state,
+                                          const Core::HID::ControllerMotion& hid_state) {
+            using namespace std::literals::chrono_literals;
+            static constexpr Core::HID::SixAxisSensorState default_motion_state = {
+                .delta_time = std::chrono::nanoseconds(5ms).count(),
+                .accel = {0, 0, -1.0f},
+                .orientation =
+                    {
+                        Common::Vec3f{1.0f, 0, 0},
+                        Common::Vec3f{0, 1.0f, 0},
+                        Common::Vec3f{0, 0, 1.0f},
+                    },
+                .attribute = {1},
+            };
+            if (!controller.sixaxis_sensor_enabled) {
+                state = default_motion_state;
+                return;
+            }
+            if (!Settings::values.motion_enabled.GetValue()) {
+                state = default_motion_state;
+                return;
+            }
+            state.attribute.is_connected.Assign(1);
+            state.delta_time = std::chrono::nanoseconds(5ms).count();
+            state.accel = hid_state.accel;
+            state.gyro = hid_state.gyro;
+            state.rotation = hid_state.rotation;
+            state.orientation = hid_state.orientation;
+        };
+
+        switch (controller_type) {
+        case Core::HID::NpadStyleIndex::None:
+            ASSERT(false);
+            break;
+        case Core::HID::NpadStyleIndex::ProController:
+            set_motion_state(sixaxis_fullkey_state, motion_state[0]);
+            break;
+        case Core::HID::NpadStyleIndex::Handheld:
+            set_motion_state(sixaxis_handheld_state, motion_state[0]);
+            break;
+        case Core::HID::NpadStyleIndex::JoyconDual:
+            set_motion_state(sixaxis_dual_left_state, motion_state[0]);
+            set_motion_state(sixaxis_dual_right_state, motion_state[1]);
+            break;
+        case Core::HID::NpadStyleIndex::JoyconLeft:
+            set_motion_state(sixaxis_left_lifo_state, motion_state[0]);
+            break;
+        case Core::HID::NpadStyleIndex::JoyconRight:
+            set_motion_state(sixaxis_right_lifo_state, motion_state[1]);
+            break;
+        case Core::HID::NpadStyleIndex::Pokeball:
+            using namespace std::literals::chrono_literals;
+            set_motion_state(sixaxis_fullkey_state, motion_state[0]);
+            sixaxis_fullkey_state.delta_time = std::chrono::nanoseconds(15ms).count();
+            break;
+        default:
+            break;
+        }
+
+        sixaxis_fullkey_state.sampling_number =
+            sixaxis_fullkey_lifo.ReadCurrentEntry().state.sampling_number + 1;
+        sixaxis_handheld_state.sampling_number =
+            sixaxis_handheld_lifo.ReadCurrentEntry().state.sampling_number + 1;
+        sixaxis_dual_left_state.sampling_number =
+            sixaxis_dual_left_lifo.ReadCurrentEntry().state.sampling_number + 1;
+        sixaxis_dual_right_state.sampling_number =
+            sixaxis_dual_right_lifo.ReadCurrentEntry().state.sampling_number + 1;
+        sixaxis_left_lifo_state.sampling_number =
+            sixaxis_left_lifo.ReadCurrentEntry().state.sampling_number + 1;
+        sixaxis_right_lifo_state.sampling_number =
+            sixaxis_right_lifo.ReadCurrentEntry().state.sampling_number + 1;
+
+        if (IndexToNpadIdType(i) == Core::HID::NpadIdType::Handheld) {
+            // This buffer only is updated on handheld on HW
+            sixaxis_handheld_lifo.WriteNextEntry(sixaxis_handheld_state);
+        } else {
+            // Handheld doesn't update this buffer on HW
+            sixaxis_fullkey_lifo.WriteNextEntry(sixaxis_fullkey_state);
+        }
+
+        sixaxis_dual_left_lifo.WriteNextEntry(sixaxis_dual_left_state);
+        sixaxis_dual_right_lifo.WriteNextEntry(sixaxis_dual_right_state);
+        sixaxis_left_lifo.WriteNextEntry(sixaxis_left_lifo_state);
+        sixaxis_right_lifo.WriteNextEntry(sixaxis_right_lifo_state);
+    }
+}
+
+Result SixAxis::SetGyroscopeZeroDriftMode(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                          Core::HID::GyroscopeZeroDriftMode drift_mode) {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    auto& controller = GetControllerFromHandle(sixaxis_handle);
+    sixaxis.gyroscope_zero_drift_mode = drift_mode;
+    controller.device->SetGyroscopeZeroDriftMode(drift_mode);
+
+    return ResultSuccess;
+}
+
+Result SixAxis::GetGyroscopeZeroDriftMode(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                          Core::HID::GyroscopeZeroDriftMode& drift_mode) const {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    drift_mode = sixaxis.gyroscope_zero_drift_mode;
+
+    return ResultSuccess;
+}
+
+Result SixAxis::IsSixAxisSensorAtRest(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                      bool& is_at_rest) const {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    const auto& controller = GetControllerFromHandle(sixaxis_handle);
+    is_at_rest = controller.sixaxis_at_rest;
+    return ResultSuccess;
+}
+
+Result SixAxis::LoadSixAxisSensorCalibrationParameter(
+    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+    Core::HID::SixAxisSensorCalibrationParameter& calibration) const {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    // TODO: Request this data to the controller. On error return 0xd8ca
+    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    calibration = sixaxis.calibration;
+    return ResultSuccess;
+}
+
+Result SixAxis::GetSixAxisSensorIcInformation(
+    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+    Core::HID::SixAxisSensorIcInformation& ic_information) const {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    // TODO: Request this data to the controller. On error return 0xd8ca
+    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    ic_information = sixaxis.ic_information;
+    return ResultSuccess;
+}
+
+Result SixAxis::EnableSixAxisSensorUnalteredPassthrough(
+    const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool is_enabled) {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    sixaxis.unaltered_passtrough = is_enabled;
+    return ResultSuccess;
+}
+
+Result SixAxis::IsSixAxisSensorUnalteredPassthroughEnabled(
+    const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_enabled) const {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    is_enabled = sixaxis.unaltered_passtrough;
+    return ResultSuccess;
+}
+
+Result SixAxis::SetSixAxisEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                  bool sixaxis_status) {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    auto& controller = GetControllerFromHandle(sixaxis_handle);
+    controller.sixaxis_sensor_enabled = sixaxis_status;
+    return ResultSuccess;
+}
+
+Result SixAxis::IsSixAxisSensorFusionEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                             bool& is_fusion_enabled) const {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    is_fusion_enabled = sixaxis.is_fusion_enabled;
+
+    return ResultSuccess;
+}
+Result SixAxis::SetSixAxisFusionEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                        bool is_fusion_enabled) {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    sixaxis.is_fusion_enabled = is_fusion_enabled;
+
+    return ResultSuccess;
+}
+
+Result SixAxis::SetSixAxisFusionParameters(
+    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+    Core::HID::SixAxisSensorFusionParameters sixaxis_fusion_parameters) {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    const auto param1 = sixaxis_fusion_parameters.parameter1;
+    if (param1 < 0.0f || param1 > 1.0f) {
+        return InvalidSixAxisFusionRange;
+    }
+
+    auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    sixaxis.fusion = sixaxis_fusion_parameters;
+
+    return ResultSuccess;
+}
+
+Result SixAxis::GetSixAxisFusionParameters(
+    const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+    Core::HID::SixAxisSensorFusionParameters& parameters) const {
+    const auto is_valid = IsSixaxisHandleValid(sixaxis_handle);
+    if (is_valid.IsError()) {
+        LOG_ERROR(Service_HID, "Invalid handle, error_code={}", is_valid.raw);
+        return is_valid;
+    }
+
+    const auto& sixaxis = GetSixaxisState(sixaxis_handle);
+    parameters = sixaxis.fusion;
+
+    return ResultSuccess;
+}
+
+SixAxis::SixaxisParameters& SixAxis::GetSixaxisState(
+    const Core::HID::SixAxisSensorHandle& sixaxis_handle) {
+    auto& controller = GetControllerFromHandle(sixaxis_handle);
+    switch (sixaxis_handle.npad_type) {
+    case Core::HID::NpadStyleIndex::ProController:
+    case Core::HID::NpadStyleIndex::Pokeball:
+        return controller.sixaxis_fullkey;
+    case Core::HID::NpadStyleIndex::Handheld:
+        return controller.sixaxis_handheld;
+    case Core::HID::NpadStyleIndex::JoyconDual:
+        if (sixaxis_handle.device_index == Core::HID::DeviceIndex::Left) {
+            return controller.sixaxis_dual_left;
+        }
+        return controller.sixaxis_dual_right;
+    case Core::HID::NpadStyleIndex::JoyconLeft:
+        return controller.sixaxis_left;
+    case Core::HID::NpadStyleIndex::JoyconRight:
+        return controller.sixaxis_right;
+    default:
+        return controller.sixaxis_unknown;
+    }
+}
+
+const SixAxis::SixaxisParameters& SixAxis::GetSixaxisState(
+    const Core::HID::SixAxisSensorHandle& sixaxis_handle) const {
+    const auto& controller = GetControllerFromHandle(sixaxis_handle);
+    switch (sixaxis_handle.npad_type) {
+    case Core::HID::NpadStyleIndex::ProController:
+    case Core::HID::NpadStyleIndex::Pokeball:
+        return controller.sixaxis_fullkey;
+    case Core::HID::NpadStyleIndex::Handheld:
+        return controller.sixaxis_handheld;
+    case Core::HID::NpadStyleIndex::JoyconDual:
+        if (sixaxis_handle.device_index == Core::HID::DeviceIndex::Left) {
+            return controller.sixaxis_dual_left;
+        }
+        return controller.sixaxis_dual_right;
+    case Core::HID::NpadStyleIndex::JoyconLeft:
+        return controller.sixaxis_left;
+    case Core::HID::NpadStyleIndex::JoyconRight:
+        return controller.sixaxis_right;
+    default:
+        return controller.sixaxis_unknown;
+    }
+}
+
+SixAxis::NpadControllerData& SixAxis::GetControllerFromHandle(
+    const Core::HID::SixAxisSensorHandle& device_handle) {
+    const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
+    return GetControllerFromNpadIdType(npad_id);
+}
+
+const SixAxis::NpadControllerData& SixAxis::GetControllerFromHandle(
+    const Core::HID::SixAxisSensorHandle& device_handle) const {
+    const auto npad_id = static_cast<Core::HID::NpadIdType>(device_handle.npad_id);
+    return GetControllerFromNpadIdType(npad_id);
+}
+
+SixAxis::NpadControllerData& SixAxis::GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id) {
+    if (!IsNpadIdValid(npad_id)) {
+        LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
+        npad_id = Core::HID::NpadIdType::Player1;
+    }
+    const auto npad_index = NpadIdTypeToIndex(npad_id);
+    return controller_data[npad_index];
+}
+
+const SixAxis::NpadControllerData& SixAxis::GetControllerFromNpadIdType(
+    Core::HID::NpadIdType npad_id) const {
+    if (!IsNpadIdValid(npad_id)) {
+        LOG_ERROR(Service_HID, "Invalid NpadIdType npad_id:{}", npad_id);
+        npad_id = Core::HID::NpadIdType::Player1;
+    }
+    const auto npad_index = NpadIdTypeToIndex(npad_id);
+    return controller_data[npad_index];
+}
+
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/six_axis.h b/src/core/hle/service/hid/controllers/six_axis.h
new file mode 100644
index 000000000000..4c4f5dc7b134
--- /dev/null
+++ b/src/core/hle/service/hid/controllers/six_axis.h
@@ -0,0 +1,111 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#pragma once
+
+#include "common/common_types.h"
+#include "core/hid/hid_types.h"
+#include "core/hle/service/hid/controllers/controller_base.h"
+#include "core/hle/service/hid/ring_lifo.h"
+
+namespace Core::HID {
+class EmulatedController;
+} // namespace Core::HID
+
+namespace Service::HID {
+class NPad;
+
+class SixAxis final : public ControllerBase {
+public:
+    explicit SixAxis(Core::HID::HIDCore& hid_core_, std::shared_ptr<NPad> npad_);
+    ~SixAxis() override;
+
+    // Called when the controller is initialized
+    void OnInit() override;
+
+    // When the controller is released
+    void OnRelease() override;
+
+    // When the controller is requesting an update for the shared memory
+    void OnUpdate(const Core::Timing::CoreTiming& core_timing) override;
+
+    Result SetGyroscopeZeroDriftMode(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                     Core::HID::GyroscopeZeroDriftMode drift_mode);
+    Result GetGyroscopeZeroDriftMode(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                     Core::HID::GyroscopeZeroDriftMode& drift_mode) const;
+    Result IsSixAxisSensorAtRest(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                 bool& is_at_rest) const;
+    Result EnableSixAxisSensorUnalteredPassthrough(
+        const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool is_enabled);
+    Result IsSixAxisSensorUnalteredPassthroughEnabled(
+        const Core::HID::SixAxisSensorHandle& sixaxis_handle, bool& is_enabled) const;
+    Result LoadSixAxisSensorCalibrationParameter(
+        const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+        Core::HID::SixAxisSensorCalibrationParameter& calibration) const;
+    Result GetSixAxisSensorIcInformation(
+        const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+        Core::HID::SixAxisSensorIcInformation& ic_information) const;
+    Result SetSixAxisEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                             bool sixaxis_status);
+    Result IsSixAxisSensorFusionEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                        bool& is_fusion_enabled) const;
+    Result SetSixAxisFusionEnabled(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                   bool is_fusion_enabled);
+    Result SetSixAxisFusionParameters(
+        const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+        Core::HID::SixAxisSensorFusionParameters sixaxis_fusion_parameters);
+    Result GetSixAxisFusionParameters(const Core::HID::SixAxisSensorHandle& sixaxis_handle,
+                                      Core::HID::SixAxisSensorFusionParameters& parameters) const;
+
+private:
+    static constexpr std::size_t NPAD_COUNT = 10;
+
+    struct SixaxisParameters {
+        bool is_fusion_enabled{true};
+        bool unaltered_passtrough{false};
+        Core::HID::SixAxisSensorFusionParameters fusion{};
+        Core::HID::SixAxisSensorCalibrationParameter calibration{};
+        Core::HID::SixAxisSensorIcInformation ic_information{};
+        Core::HID::GyroscopeZeroDriftMode gyroscope_zero_drift_mode{
+            Core::HID::GyroscopeZeroDriftMode::Standard};
+    };
+
+    struct NpadControllerData {
+        Core::HID::EmulatedController* device = nullptr;
+
+        // Motion parameters
+        bool sixaxis_at_rest{true};
+        bool sixaxis_sensor_enabled{true};
+        SixaxisParameters sixaxis_fullkey{};
+        SixaxisParameters sixaxis_handheld{};
+        SixaxisParameters sixaxis_dual_left{};
+        SixaxisParameters sixaxis_dual_right{};
+        SixaxisParameters sixaxis_left{};
+        SixaxisParameters sixaxis_right{};
+        SixaxisParameters sixaxis_unknown{};
+
+        // Current pad state
+        Core::HID::SixAxisSensorState sixaxis_fullkey_state{};
+        Core::HID::SixAxisSensorState sixaxis_handheld_state{};
+        Core::HID::SixAxisSensorState sixaxis_dual_left_state{};
+        Core::HID::SixAxisSensorState sixaxis_dual_right_state{};
+        Core::HID::SixAxisSensorState sixaxis_left_lifo_state{};
+        Core::HID::SixAxisSensorState sixaxis_right_lifo_state{};
+        int callback_key{};
+    };
+
+    SixaxisParameters& GetSixaxisState(const Core::HID::SixAxisSensorHandle& device_handle);
+    const SixaxisParameters& GetSixaxisState(
+        const Core::HID::SixAxisSensorHandle& device_handle) const;
+
+    NpadControllerData& GetControllerFromHandle(
+        const Core::HID::SixAxisSensorHandle& device_handle);
+    const NpadControllerData& GetControllerFromHandle(
+        const Core::HID::SixAxisSensorHandle& device_handle) const;
+    NpadControllerData& GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id);
+    const NpadControllerData& GetControllerFromNpadIdType(Core::HID::NpadIdType npad_id) const;
+
+    std::shared_ptr<NPad> npad;
+    std::array<NpadControllerData, NPAD_COUNT> controller_data{};
+};
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/controllers/touchscreen.cpp b/src/core/hle/service/hid/controllers/touchscreen.cpp
index 3ef91df4bc53..3bcf0ee9f23a 100644
--- a/src/core/hle/service/hid/controllers/touchscreen.cpp
+++ b/src/core/hle/service/hid/controllers/touchscreen.cpp
@@ -15,8 +15,7 @@
 namespace Service::HID {
 constexpr std::size_t SHARED_MEMORY_OFFSET = 0x400;
 
-Controller_Touchscreen::Controller_Touchscreen(Core::HID::HIDCore& hid_core_,
-                                               u8* raw_shared_memory_)
+TouchScreen::TouchScreen(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
     : ControllerBase{hid_core_} {
     static_assert(SHARED_MEMORY_OFFSET + sizeof(TouchSharedMemory) < shared_memory_size,
                   "TouchSharedMemory is bigger than the shared memory");
@@ -25,13 +24,13 @@ Controller_Touchscreen::Controller_Touchscreen(Core::HID::HIDCore& hid_core_,
     console = hid_core.GetEmulatedConsole();
 }
 
-Controller_Touchscreen::~Controller_Touchscreen() = default;
+TouchScreen::~TouchScreen() = default;
 
-void Controller_Touchscreen::OnInit() {}
+void TouchScreen::OnInit() {}
 
-void Controller_Touchscreen::OnRelease() {}
+void TouchScreen::OnRelease() {}
 
-void Controller_Touchscreen::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void TouchScreen::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     shared_memory->touch_screen_lifo.timestamp = core_timing.GetGlobalTimeNs().count();
 
     if (!IsControllerActivated()) {
diff --git a/src/core/hle/service/hid/controllers/touchscreen.h b/src/core/hle/service/hid/controllers/touchscreen.h
index dd00921fdbc8..cd342ce9146a 100644
--- a/src/core/hle/service/hid/controllers/touchscreen.h
+++ b/src/core/hle/service/hid/controllers/touchscreen.h
@@ -14,10 +14,10 @@ class EmulatedConsole;
 } // namespace Core::HID
 
 namespace Service::HID {
-class Controller_Touchscreen final : public ControllerBase {
+class TouchScreen final : public ControllerBase {
 public:
-    explicit Controller_Touchscreen(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
-    ~Controller_Touchscreen() override;
+    explicit TouchScreen(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
+    ~TouchScreen() override;
 
     // Called when the controller is initialized
     void OnInit() override;
diff --git a/src/core/hle/service/hid/controllers/xpad.cpp b/src/core/hle/service/hid/controllers/xpad.cpp
index 62119e2c55af..0aaed1fa730e 100644
--- a/src/core/hle/service/hid/controllers/xpad.cpp
+++ b/src/core/hle/service/hid/controllers/xpad.cpp
@@ -10,20 +10,19 @@
 namespace Service::HID {
 constexpr std::size_t SHARED_MEMORY_OFFSET = 0x3C00;
 
-Controller_XPad::Controller_XPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_)
-    : ControllerBase{hid_core_} {
+XPad::XPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_) : ControllerBase{hid_core_} {
     static_assert(SHARED_MEMORY_OFFSET + sizeof(XpadSharedMemory) < shared_memory_size,
                   "XpadSharedMemory is bigger than the shared memory");
     shared_memory = std::construct_at(
         reinterpret_cast<XpadSharedMemory*>(raw_shared_memory_ + SHARED_MEMORY_OFFSET));
 }
-Controller_XPad::~Controller_XPad() = default;
+XPad::~XPad() = default;
 
-void Controller_XPad::OnInit() {}
+void XPad::OnInit() {}
 
-void Controller_XPad::OnRelease() {}
+void XPad::OnRelease() {}
 
-void Controller_XPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
+void XPad::OnUpdate(const Core::Timing::CoreTiming& core_timing) {
     if (!IsControllerActivated()) {
         shared_memory->basic_xpad_lifo.buffer_count = 0;
         shared_memory->basic_xpad_lifo.buffer_tail = 0;
diff --git a/src/core/hle/service/hid/controllers/xpad.h b/src/core/hle/service/hid/controllers/xpad.h
index d01dee5fc5c4..9e63a317afb9 100644
--- a/src/core/hle/service/hid/controllers/xpad.h
+++ b/src/core/hle/service/hid/controllers/xpad.h
@@ -10,10 +10,10 @@
 #include "core/hle/service/hid/ring_lifo.h"
 
 namespace Service::HID {
-class Controller_XPad final : public ControllerBase {
+class XPad final : public ControllerBase {
 public:
-    explicit Controller_XPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
-    ~Controller_XPad() override;
+    explicit XPad(Core::HID::HIDCore& hid_core_, u8* raw_shared_memory_);
+    ~XPad() override;
 
     // Called when the controller is initialized
     void OnInit() override;
diff --git a/src/core/hle/service/hid/hid_server.cpp b/src/core/hle/service/hid/hid_server.cpp
index 9caed6541a0e..583142e350cf 100644
--- a/src/core/hle/service/hid/hid_server.cpp
+++ b/src/core/hle/service/hid/hid_server.cpp
@@ -12,11 +12,12 @@
 #include "core/hle/service/hid/errors.h"
 #include "core/hle/service/hid/hid_firmware_settings.h"
 #include "core/hle/service/hid/hid_server.h"
+#include "core/hle/service/hid/hid_util.h"
 #include "core/hle/service/hid/resource_manager.h"
 #include "core/hle/service/ipc_helpers.h"
 #include "core/memory.h"
 
-#include "core/hle/service/hid/controllers/console_sixaxis.h"
+#include "core/hle/service/hid/controllers/console_six_axis.h"
 #include "core/hle/service/hid/controllers/controller_base.h"
 #include "core/hle/service/hid/controllers/debug_pad.h"
 #include "core/hle/service/hid/controllers/gesture.h"
@@ -24,9 +25,9 @@
 #include "core/hle/service/hid/controllers/mouse.h"
 #include "core/hle/service/hid/controllers/npad.h"
 #include "core/hle/service/hid/controllers/palma.h"
-#include "core/hle/service/hid/controllers/stubbed.h"
+#include "core/hle/service/hid/controllers/seven_six_axis.h"
+#include "core/hle/service/hid/controllers/six_axis.h"
 #include "core/hle/service/hid/controllers/touchscreen.h"
-#include "core/hle/service/hid/controllers/xpad.h"
 
 namespace Service::HID {
 
@@ -50,8 +51,7 @@ class IActiveVibrationDeviceList final : public ServiceFramework<IActiveVibratio
         const auto vibration_device_handle{rp.PopRaw<Core::HID::VibrationDeviceHandle>()};
 
         if (resource_manager != nullptr) {
-            resource_manager->GetController<Controller_NPad>(HidController::NPad)
-                .InitializeVibrationDevice(vibration_device_handle);
+            resource_manager->GetNpad()->InitializeVibrationDevice(vibration_device_handle);
         }
 
         LOG_DEBUG(Service_HID, "called, npad_type={}, npad_id={}, device_index={}",
@@ -235,15 +235,14 @@ void IHidServer::ActivateDebugPad(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
     Result result = ResultSuccess;
-    auto& debug_pad =
-        GetResourceManager()->GetController<Controller_DebugPad>(HidController::DebugPad);
+    auto debug_pad = GetResourceManager()->GetDebugPad();
 
     if (!firmware_settings->IsDeviceManaged()) {
-        result = debug_pad.Activate();
+        result = debug_pad->Activate();
     }
 
     if (result.IsSuccess()) {
-        result = debug_pad.Activate(applet_resource_user_id);
+        result = debug_pad->Activate(applet_resource_user_id);
     }
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -257,15 +256,14 @@ void IHidServer::ActivateTouchScreen(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
     Result result = ResultSuccess;
-    auto& touch_screen =
-        GetResourceManager()->GetController<Controller_Touchscreen>(HidController::Touchscreen);
+    auto touch_screen = GetResourceManager()->GetTouchScreen();
 
     if (!firmware_settings->IsDeviceManaged()) {
-        result = touch_screen.Activate();
+        result = touch_screen->Activate();
     }
 
     if (result.IsSuccess()) {
-        result = touch_screen.Activate(applet_resource_user_id);
+        result = touch_screen->Activate(applet_resource_user_id);
     }
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -279,14 +277,14 @@ void IHidServer::ActivateMouse(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
     Result result = ResultSuccess;
-    auto& mouse = GetResourceManager()->GetController<Controller_Mouse>(HidController::Mouse);
+    auto mouse = GetResourceManager()->GetMouse();
 
     if (!firmware_settings->IsDeviceManaged()) {
-        result = mouse.Activate();
+        result = mouse->Activate();
     }
 
     if (result.IsSuccess()) {
-        result = mouse.Activate(applet_resource_user_id);
+        result = mouse->Activate(applet_resource_user_id);
     }
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -300,15 +298,14 @@ void IHidServer::ActivateKeyboard(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
     Result result = ResultSuccess;
-    auto& keyboard =
-        GetResourceManager()->GetController<Controller_Keyboard>(HidController::Keyboard);
+    auto keyboard = GetResourceManager()->GetKeyboard();
 
     if (!firmware_settings->IsDeviceManaged()) {
-        result = keyboard.Activate();
+        result = keyboard->Activate();
     }
 
     if (result.IsSuccess()) {
-        result = keyboard.Activate(applet_resource_user_id);
+        result = keyboard->Activate(applet_resource_user_id);
     }
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -502,8 +499,8 @@ void IHidServer::StartSixAxisSensor(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.SetSixAxisEnabled(parameters.sixaxis_handle, true);
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    const auto result = six_axis->SetSixAxisEnabled(parameters.sixaxis_handle, true);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -525,8 +522,8 @@ void IHidServer::StopSixAxisSensor(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.SetSixAxisEnabled(parameters.sixaxis_handle, false);
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    const auto result = six_axis->SetSixAxisEnabled(parameters.sixaxis_handle, false);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -549,9 +546,9 @@ void IHidServer::IsSixAxisSensorFusionEnabled(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     bool is_enabled{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto six_axis = GetResourceManager()->GetSixAxis();
     const auto result =
-        controller.IsSixAxisSensorFusionEnabled(parameters.sixaxis_handle, is_enabled);
+        six_axis->IsSixAxisSensorFusionEnabled(parameters.sixaxis_handle, is_enabled);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -575,9 +572,9 @@ void IHidServer::EnableSixAxisSensorFusion(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.SetSixAxisFusionEnabled(parameters.sixaxis_handle,
-                                                           parameters.enable_sixaxis_sensor_fusion);
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    const auto result = six_axis->SetSixAxisFusionEnabled(parameters.sixaxis_handle,
+                                                          parameters.enable_sixaxis_sensor_fusion);
 
     LOG_DEBUG(Service_HID,
               "called, enable_sixaxis_sensor_fusion={}, npad_type={}, npad_id={}, "
@@ -602,9 +599,9 @@ void IHidServer::SetSixAxisSensorFusionParameters(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto six_axis = GetResourceManager()->GetSixAxis();
     const auto result =
-        controller.SetSixAxisFusionParameters(parameters.sixaxis_handle, parameters.sixaxis_fusion);
+        six_axis->SetSixAxisFusionParameters(parameters.sixaxis_handle, parameters.sixaxis_fusion);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, parameter1={}, "
@@ -629,10 +626,9 @@ void IHidServer::GetSixAxisSensorFusionParameters(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     Core::HID::SixAxisSensorFusionParameters fusion_parameters{};
-    const auto& controller =
-        GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto six_axis = GetResourceManager()->GetSixAxis();
     const auto result =
-        controller.GetSixAxisFusionParameters(parameters.sixaxis_handle, fusion_parameters);
+        six_axis->GetSixAxisFusionParameters(parameters.sixaxis_handle, fusion_parameters);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -660,10 +656,10 @@ void IHidServer::ResetSixAxisSensorFusionParameters(HLERequestContext& ctx) {
         .parameter1 = 0.03f,
         .parameter2 = 0.4f,
     };
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto six_axis = GetResourceManager()->GetSixAxis();
     const auto result1 =
-        controller.SetSixAxisFusionParameters(parameters.sixaxis_handle, fusion_parameters);
-    const auto result2 = controller.SetSixAxisFusionEnabled(parameters.sixaxis_handle, true);
+        six_axis->SetSixAxisFusionParameters(parameters.sixaxis_handle, fusion_parameters);
+    const auto result2 = six_axis->SetSixAxisFusionEnabled(parameters.sixaxis_handle, true);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -684,8 +680,8 @@ void IHidServer::SetGyroscopeZeroDriftMode(HLERequestContext& ctx) {
     const auto drift_mode{rp.PopEnum<Core::HID::GyroscopeZeroDriftMode>()};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.SetGyroscopeZeroDriftMode(sixaxis_handle, drift_mode);
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    const auto result = six_axis->SetGyroscopeZeroDriftMode(sixaxis_handle, drift_mode);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, drift_mode={}, "
@@ -709,8 +705,8 @@ void IHidServer::GetGyroscopeZeroDriftMode(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     auto drift_mode{Core::HID::GyroscopeZeroDriftMode::Standard};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.GetGyroscopeZeroDriftMode(parameters.sixaxis_handle, drift_mode);
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    const auto result = six_axis->GetGyroscopeZeroDriftMode(parameters.sixaxis_handle, drift_mode);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -734,8 +730,8 @@ void IHidServer::ResetGyroscopeZeroDriftMode(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     const auto drift_mode{Core::HID::GyroscopeZeroDriftMode::Standard};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.SetGyroscopeZeroDriftMode(parameters.sixaxis_handle, drift_mode);
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    const auto result = six_axis->SetGyroscopeZeroDriftMode(parameters.sixaxis_handle, drift_mode);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -758,8 +754,8 @@ void IHidServer::IsSixAxisSensorAtRest(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     bool is_at_rest{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    controller.IsSixAxisSensorAtRest(parameters.sixaxis_handle, is_at_rest);
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    six_axis->IsSixAxisSensorAtRest(parameters.sixaxis_handle, is_at_rest);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -783,9 +779,9 @@ void IHidServer::IsFirmwareUpdateAvailableForSixAxisSensor(HLERequestContext& ct
     const auto parameters{rp.PopRaw<Parameters>()};
 
     bool is_firmware_available{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    controller.IsFirmwareUpdateAvailableForSixAxisSensor(parameters.sixaxis_handle,
-                                                         is_firmware_available);
+    auto controller = GetResourceManager()->GetNpad();
+    controller->IsFirmwareUpdateAvailableForSixAxisSensor(parameters.sixaxis_handle,
+                                                          is_firmware_available);
 
     LOG_WARNING(
         Service_HID,
@@ -809,9 +805,9 @@ void IHidServer::EnableSixAxisSensorUnalteredPassthrough(HLERequestContext& ctx)
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.EnableSixAxisSensorUnalteredPassthrough(
-        parameters.sixaxis_handle, parameters.enabled);
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    const auto result = six_axis->EnableSixAxisSensorUnalteredPassthrough(parameters.sixaxis_handle,
+                                                                          parameters.enabled);
 
     LOG_DEBUG(Service_HID,
               "(STUBBED) called, enabled={}, npad_type={}, npad_id={}, device_index={}, "
@@ -836,8 +832,8 @@ void IHidServer::IsSixAxisSensorUnalteredPassthroughEnabled(HLERequestContext& c
     const auto parameters{rp.PopRaw<Parameters>()};
 
     bool is_unaltered_sisxaxis_enabled{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.IsSixAxisSensorUnalteredPassthroughEnabled(
+    auto six_axis = GetResourceManager()->GetSixAxis();
+    const auto result = six_axis->IsSixAxisSensorUnalteredPassthroughEnabled(
         parameters.sixaxis_handle, is_unaltered_sisxaxis_enabled);
 
     LOG_DEBUG(
@@ -863,9 +859,9 @@ void IHidServer::LoadSixAxisSensorCalibrationParameter(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     Core::HID::SixAxisSensorCalibrationParameter calibration{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto six_axis = GetResourceManager()->GetSixAxis();
     const auto result =
-        controller.LoadSixAxisSensorCalibrationParameter(parameters.sixaxis_handle, calibration);
+        six_axis->LoadSixAxisSensorCalibrationParameter(parameters.sixaxis_handle, calibration);
 
     LOG_WARNING(
         Service_HID,
@@ -893,9 +889,9 @@ void IHidServer::GetSixAxisSensorIcInformation(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     Core::HID::SixAxisSensorIcInformation ic_information{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto six_axis = GetResourceManager()->GetSixAxis();
     const auto result =
-        controller.GetSixAxisSensorIcInformation(parameters.sixaxis_handle, ic_information);
+        six_axis->GetSixAxisSensorIcInformation(parameters.sixaxis_handle, ic_information);
 
     LOG_WARNING(
         Service_HID,
@@ -922,9 +918,9 @@ void IHidServer::ResetIsSixAxisSensorDeviceNewlyAssigned(HLERequestContext& ctx)
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto controller = GetResourceManager()->GetNpad();
     const auto result =
-        controller.ResetIsSixAxisSensorDeviceNewlyAssigned(parameters.sixaxis_handle);
+        controller->ResetIsSixAxisSensorDeviceNewlyAssigned(parameters.sixaxis_handle);
 
     LOG_WARNING(
         Service_HID,
@@ -951,15 +947,15 @@ void IHidServer::ActivateGesture(HLERequestContext& ctx) {
              parameters.basic_gesture_id, parameters.applet_resource_user_id);
 
     Result result = ResultSuccess;
-    auto& gesture = GetResourceManager()->GetController<Controller_Gesture>(HidController::Gesture);
+    auto gesture = GetResourceManager()->GetGesture();
 
     if (!firmware_settings->IsDeviceManaged()) {
-        result = gesture.Activate();
+        result = gesture->Activate();
     }
 
     if (result.IsSuccess()) {
         // TODO: Use gesture id here
-        result = gesture.Activate(parameters.applet_resource_user_id);
+        result = gesture->Activate(parameters.applet_resource_user_id);
     }
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -977,9 +973,7 @@ void IHidServer::SetSupportedNpadStyleSet(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .SetSupportedStyleSet({parameters.supported_styleset});
+    GetResourceManager()->GetNpad()->SetSupportedStyleSet({parameters.supported_styleset});
 
     LOG_DEBUG(Service_HID, "called, supported_styleset={}, applet_resource_user_id={}",
               parameters.supported_styleset, parameters.applet_resource_user_id);
@@ -996,19 +990,14 @@ void IHidServer::GetSupportedNpadStyleSet(HLERequestContext& ctx) {
 
     IPC::ResponseBuilder rb{ctx, 3};
     rb.Push(ResultSuccess);
-    rb.PushEnum(GetResourceManager()
-                    ->GetController<Controller_NPad>(HidController::NPad)
-                    .GetSupportedStyleSet()
-                    .raw);
+    rb.PushEnum(GetResourceManager()->GetNpad()->GetSupportedStyleSet().raw);
 }
 
 void IHidServer::SetSupportedNpadIdType(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    const auto result = GetResourceManager()
-                            ->GetController<Controller_NPad>(HidController::NPad)
-                            .SetSupportedNpadIdTypes(ctx.ReadBuffer());
+    const auto result = GetResourceManager()->GetNpad()->SetSupportedNpadIdTypes(ctx.ReadBuffer());
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
@@ -1022,10 +1011,10 @@ void IHidServer::ActivateNpad(HLERequestContext& ctx) {
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
-    auto& npad = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto npad = GetResourceManager()->GetNpad();
 
     // TODO: npad->SetRevision(applet_resource_user_id, NpadRevision::Revision0);
-    const Result result = npad.Activate(applet_resource_user_id);
+    const Result result = npad->Activate(applet_resource_user_id);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -1059,15 +1048,12 @@ void IHidServer::AcquireNpadStyleSetUpdateEventHandle(HLERequestContext& ctx) {
               parameters.npad_id, parameters.applet_resource_user_id, parameters.unknown);
 
     // Games expect this event to be signaled after calling this function
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .SignalStyleSetChangedEvent(parameters.npad_id);
+    GetResourceManager()->GetNpad()->SignalStyleSetChangedEvent(parameters.npad_id);
 
     IPC::ResponseBuilder rb{ctx, 2, 1};
     rb.Push(ResultSuccess);
-    rb.PushCopyObjects(GetResourceManager()
-                           ->GetController<Controller_NPad>(HidController::NPad)
-                           .GetStyleSetChangedEvent(parameters.npad_id));
+    rb.PushCopyObjects(
+        GetResourceManager()->GetNpad()->GetStyleSetChangedEvent(parameters.npad_id));
 }
 
 void IHidServer::DisconnectNpad(HLERequestContext& ctx) {
@@ -1081,8 +1067,8 @@ void IHidServer::DisconnectNpad(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    controller.DisconnectNpad(parameters.npad_id);
+    auto controller = GetResourceManager()->GetNpad();
+    controller->DisconnectNpad(parameters.npad_id);
 
     LOG_DEBUG(Service_HID, "called, npad_id={}, applet_resource_user_id={}", parameters.npad_id,
               parameters.applet_resource_user_id);
@@ -1096,8 +1082,8 @@ void IHidServer::GetPlayerLedPattern(HLERequestContext& ctx) {
     const auto npad_id{rp.PopEnum<Core::HID::NpadIdType>()};
 
     Core::HID::LedPattern pattern{0, 0, 0, 0};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.GetLedPattern(npad_id, pattern);
+    auto controller = GetResourceManager()->GetNpad();
+    const auto result = controller->GetLedPattern(npad_id, pattern);
 
     LOG_DEBUG(Service_HID, "called, npad_id={}", npad_id);
 
@@ -1109,7 +1095,7 @@ void IHidServer::GetPlayerLedPattern(HLERequestContext& ctx) {
 void IHidServer::ActivateNpadWithRevision(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     struct Parameters {
-        Controller_NPad::NpadRevision revision;
+        NPad::NpadRevision revision;
         INSERT_PADDING_WORDS_NOINIT(1);
         u64 applet_resource_user_id;
     };
@@ -1120,10 +1106,10 @@ void IHidServer::ActivateNpadWithRevision(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called, revision={}, applet_resource_user_id={}", parameters.revision,
               parameters.applet_resource_user_id);
 
-    auto& npad = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto npad = GetResourceManager()->GetNpad();
 
     // TODO: npad->SetRevision(applet_resource_user_id, revision);
-    const auto result = npad.Activate(parameters.applet_resource_user_id);
+    const auto result = npad->Activate(parameters.applet_resource_user_id);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -1132,11 +1118,9 @@ void IHidServer::ActivateNpadWithRevision(HLERequestContext& ctx) {
 void IHidServer::SetNpadJoyHoldType(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
-    const auto hold_type{rp.PopEnum<Controller_NPad::NpadJoyHoldType>()};
+    const auto hold_type{rp.PopEnum<NPad::NpadJoyHoldType>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .SetHoldType(hold_type);
+    GetResourceManager()->GetNpad()->SetHoldType(hold_type);
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}, hold_type={}",
               applet_resource_user_id, hold_type);
@@ -1153,8 +1137,7 @@ void IHidServer::GetNpadJoyHoldType(HLERequestContext& ctx) {
 
     IPC::ResponseBuilder rb{ctx, 4};
     rb.Push(ResultSuccess);
-    rb.PushEnum(
-        GetResourceManager()->GetController<Controller_NPad>(HidController::NPad).GetHoldType());
+    rb.PushEnum(GetResourceManager()->GetNpad()->GetHoldType());
 }
 
 void IHidServer::SetNpadJoyAssignmentModeSingleByDefault(HLERequestContext& ctx) {
@@ -1169,10 +1152,9 @@ void IHidServer::SetNpadJoyAssignmentModeSingleByDefault(HLERequestContext& ctx)
     const auto parameters{rp.PopRaw<Parameters>()};
 
     Core::HID::NpadIdType new_npad_id{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    controller.SetNpadMode(new_npad_id, parameters.npad_id,
-                           Controller_NPad::NpadJoyDeviceType::Left,
-                           Controller_NPad::NpadJoyAssignmentMode::Single);
+    auto controller = GetResourceManager()->GetNpad();
+    controller->SetNpadMode(new_npad_id, parameters.npad_id, NPad::NpadJoyDeviceType::Left,
+                            NPad::NpadJoyAssignmentMode::Single);
 
     LOG_INFO(Service_HID, "called, npad_id={}, applet_resource_user_id={}", parameters.npad_id,
              parameters.applet_resource_user_id);
@@ -1187,16 +1169,16 @@ void IHidServer::SetNpadJoyAssignmentModeSingle(HLERequestContext& ctx) {
         Core::HID::NpadIdType npad_id;
         INSERT_PADDING_WORDS_NOINIT(1);
         u64 applet_resource_user_id;
-        Controller_NPad::NpadJoyDeviceType npad_joy_device_type;
+        NPad::NpadJoyDeviceType npad_joy_device_type;
     };
     static_assert(sizeof(Parameters) == 0x18, "Parameters has incorrect size.");
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
     Core::HID::NpadIdType new_npad_id{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    controller.SetNpadMode(new_npad_id, parameters.npad_id, parameters.npad_joy_device_type,
-                           Controller_NPad::NpadJoyAssignmentMode::Single);
+    auto controller = GetResourceManager()->GetNpad();
+    controller->SetNpadMode(new_npad_id, parameters.npad_id, parameters.npad_joy_device_type,
+                            NPad::NpadJoyAssignmentMode::Single);
 
     LOG_INFO(Service_HID, "called, npad_id={}, applet_resource_user_id={}, npad_joy_device_type={}",
              parameters.npad_id, parameters.applet_resource_user_id,
@@ -1218,9 +1200,8 @@ void IHidServer::SetNpadJoyAssignmentModeDual(HLERequestContext& ctx) {
     const auto parameters{rp.PopRaw<Parameters>()};
 
     Core::HID::NpadIdType new_npad_id{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    controller.SetNpadMode(new_npad_id, parameters.npad_id, {},
-                           Controller_NPad::NpadJoyAssignmentMode::Dual);
+    auto controller = GetResourceManager()->GetNpad();
+    controller->SetNpadMode(new_npad_id, parameters.npad_id, {}, NPad::NpadJoyAssignmentMode::Dual);
 
     LOG_DEBUG(Service_HID, "called, npad_id={}, applet_resource_user_id={}", parameters.npad_id,
               parameters.applet_resource_user_id); // Spams a lot when controller applet is open
@@ -1235,8 +1216,8 @@ void IHidServer::MergeSingleJoyAsDualJoy(HLERequestContext& ctx) {
     const auto npad_id_2{rp.PopEnum<Core::HID::NpadIdType>()};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.MergeSingleJoyAsDualJoy(npad_id_1, npad_id_2);
+    auto controller = GetResourceManager()->GetNpad();
+    const auto result = controller->MergeSingleJoyAsDualJoy(npad_id_1, npad_id_2);
 
     LOG_DEBUG(Service_HID, "called, npad_id_1={}, npad_id_2={}, applet_resource_user_id={}",
               npad_id_1, npad_id_2, applet_resource_user_id);
@@ -1249,9 +1230,7 @@ void IHidServer::StartLrAssignmentMode(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .StartLRAssignmentMode();
+    GetResourceManager()->GetNpad()->StartLRAssignmentMode();
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
@@ -1263,9 +1242,7 @@ void IHidServer::StopLrAssignmentMode(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .StopLRAssignmentMode();
+    GetResourceManager()->GetNpad()->StopLRAssignmentMode();
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
@@ -1276,11 +1253,9 @@ void IHidServer::StopLrAssignmentMode(HLERequestContext& ctx) {
 void IHidServer::SetNpadHandheldActivationMode(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
-    const auto activation_mode{rp.PopEnum<Controller_NPad::NpadHandheldActivationMode>()};
+    const auto activation_mode{rp.PopEnum<NPad::NpadHandheldActivationMode>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .SetNpadHandheldActivationMode(activation_mode);
+    GetResourceManager()->GetNpad()->SetNpadHandheldActivationMode(activation_mode);
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}, activation_mode={}",
               applet_resource_user_id, activation_mode);
@@ -1297,9 +1272,7 @@ void IHidServer::GetNpadHandheldActivationMode(HLERequestContext& ctx) {
 
     IPC::ResponseBuilder rb{ctx, 4};
     rb.Push(ResultSuccess);
-    rb.PushEnum(GetResourceManager()
-                    ->GetController<Controller_NPad>(HidController::NPad)
-                    .GetNpadHandheldActivationMode());
+    rb.PushEnum(GetResourceManager()->GetNpad()->GetNpadHandheldActivationMode());
 }
 
 void IHidServer::SwapNpadAssignment(HLERequestContext& ctx) {
@@ -1308,8 +1281,8 @@ void IHidServer::SwapNpadAssignment(HLERequestContext& ctx) {
     const auto npad_id_2{rp.PopEnum<Core::HID::NpadIdType>()};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.SwapNpadAssignment(npad_id_1, npad_id_2);
+    auto controller = GetResourceManager()->GetNpad();
+    const auto result = controller->SwapNpadAssignment(npad_id_1, npad_id_2);
 
     LOG_DEBUG(Service_HID, "called, npad_id_1={}, npad_id_2={}, applet_resource_user_id={}",
               npad_id_1, npad_id_2, applet_resource_user_id);
@@ -1330,9 +1303,9 @@ void IHidServer::IsUnintendedHomeButtonInputProtectionEnabled(HLERequestContext&
     const auto parameters{rp.PopRaw<Parameters>()};
 
     bool is_enabled = false;
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto controller = GetResourceManager()->GetNpad();
     const auto result =
-        controller.IsUnintendedHomeButtonInputProtectionEnabled(parameters.npad_id, is_enabled);
+        controller->IsUnintendedHomeButtonInputProtectionEnabled(parameters.npad_id, is_enabled);
 
     LOG_WARNING(Service_HID, "(STUBBED) called, npad_id={}, applet_resource_user_id={}",
                 parameters.npad_id, parameters.applet_resource_user_id);
@@ -1354,8 +1327,8 @@ void IHidServer::EnableUnintendedHomeButtonInputProtection(HLERequestContext& ct
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
-    const auto result = controller.SetUnintendedHomeButtonInputProtectionEnabled(
+    auto controller = GetResourceManager()->GetNpad();
+    const auto result = controller->SetUnintendedHomeButtonInputProtectionEnabled(
         parameters.is_enabled, parameters.npad_id);
 
     LOG_DEBUG(Service_HID,
@@ -1372,17 +1345,17 @@ void IHidServer::SetNpadJoyAssignmentModeSingleWithDestination(HLERequestContext
         Core::HID::NpadIdType npad_id;
         INSERT_PADDING_WORDS_NOINIT(1);
         u64 applet_resource_user_id;
-        Controller_NPad::NpadJoyDeviceType npad_joy_device_type;
+        NPad::NpadJoyDeviceType npad_joy_device_type;
     };
     static_assert(sizeof(Parameters) == 0x18, "Parameters has incorrect size.");
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
     Core::HID::NpadIdType new_npad_id{};
-    auto& controller = GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    auto controller = GetResourceManager()->GetNpad();
     const auto is_reassigned =
-        controller.SetNpadMode(new_npad_id, parameters.npad_id, parameters.npad_joy_device_type,
-                               Controller_NPad::NpadJoyAssignmentMode::Single);
+        controller->SetNpadMode(new_npad_id, parameters.npad_id, parameters.npad_joy_device_type,
+                                NPad::NpadJoyAssignmentMode::Single);
 
     LOG_INFO(Service_HID, "called, npad_id={}, applet_resource_user_id={}, npad_joy_device_type={}",
              parameters.npad_id, parameters.applet_resource_user_id,
@@ -1405,9 +1378,8 @@ void IHidServer::SetNpadAnalogStickUseCenterClamp(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .SetAnalogStickUseCenterClamp(parameters.analog_stick_use_center_clamp);
+    GetResourceManager()->GetNpad()->SetAnalogStickUseCenterClamp(
+        parameters.analog_stick_use_center_clamp);
 
     LOG_WARNING(Service_HID,
                 "(STUBBED) called, analog_stick_use_center_clamp={}, applet_resource_user_id={}",
@@ -1451,8 +1423,7 @@ void IHidServer::ClearNpadCaptureButtonAssignment(HLERequestContext& ctx) {
 void IHidServer::GetVibrationDeviceInfo(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto vibration_device_handle{rp.PopRaw<Core::HID::VibrationDeviceHandle>()};
-    const auto& controller =
-        GetResourceManager()->GetController<Controller_NPad>(HidController::NPad);
+    const auto controller = GetResourceManager()->GetNpad();
 
     Core::HID::VibrationDeviceInfo vibration_device_info;
     bool check_device_index = false;
@@ -1496,7 +1467,7 @@ void IHidServer::GetVibrationDeviceInfo(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called, vibration_device_type={}, vibration_device_position={}",
               vibration_device_info.type, vibration_device_info.position);
 
-    const auto result = controller.IsDeviceHandleValid(vibration_device_handle);
+    const auto result = IsVibrationHandleValid(vibration_device_handle);
     if (result.IsError()) {
         IPC::ResponseBuilder rb{ctx, 2};
         rb.Push(result);
@@ -1520,9 +1491,8 @@ void IHidServer::SendVibrationValue(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .VibrateController(parameters.vibration_device_handle, parameters.vibration_value);
+    GetResourceManager()->GetNpad()->VibrateController(parameters.vibration_device_handle,
+                                                       parameters.vibration_value);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}",
@@ -1553,9 +1523,8 @@ void IHidServer::GetActualVibrationValue(HLERequestContext& ctx) {
 
     IPC::ResponseBuilder rb{ctx, 6};
     rb.Push(ResultSuccess);
-    rb.PushRaw(GetResourceManager()
-                   ->GetController<Controller_NPad>(HidController::NPad)
-                   .GetLastVibration(parameters.vibration_device_handle));
+    rb.PushRaw(
+        GetResourceManager()->GetNpad()->GetLastVibration(parameters.vibration_device_handle));
 }
 
 void IHidServer::CreateActiveVibrationDeviceList(HLERequestContext& ctx) {
@@ -1606,9 +1575,7 @@ void IHidServer::SendVibrationValues(HLERequestContext& ctx) {
     auto vibration_values = std::span(
         reinterpret_cast<const Core::HID::VibrationValue*>(vibration_data.data()), vibration_count);
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .VibrateControllers(vibration_device_handles, vibration_values);
+    GetResourceManager()->GetNpad()->VibrateControllers(vibration_device_handles, vibration_values);
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
@@ -1662,9 +1629,8 @@ void IHidServer::SendVibrationGcErmCommand(HLERequestContext& ctx) {
         }
     }();
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .VibrateController(parameters.vibration_device_handle, vibration_value);
+    GetResourceManager()->GetNpad()->VibrateController(parameters.vibration_device_handle,
+                                                       vibration_value);
 
     LOG_DEBUG(Service_HID,
               "called, npad_type={}, npad_id={}, device_index={}, applet_resource_user_id={}, "
@@ -1688,9 +1654,8 @@ void IHidServer::GetActualVibrationGcErmCommand(HLERequestContext& ctx) {
 
     const auto parameters{rp.PopRaw<Parameters>()};
 
-    const auto last_vibration = GetResourceManager()
-                                    ->GetController<Controller_NPad>(HidController::NPad)
-                                    .GetLastVibration(parameters.vibration_device_handle);
+    const auto last_vibration =
+        GetResourceManager()->GetNpad()->GetLastVibration(parameters.vibration_device_handle);
 
     const auto gc_erm_command = [last_vibration] {
         if (last_vibration.low_amplitude != 0.0f || last_vibration.high_amplitude != 0.0f) {
@@ -1725,9 +1690,7 @@ void IHidServer::BeginPermitVibrationSession(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .SetPermitVibrationSession(true);
+    GetResourceManager()->GetNpad()->SetPermitVibrationSession(true);
 
     LOG_DEBUG(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
@@ -1736,9 +1699,7 @@ void IHidServer::BeginPermitVibrationSession(HLERequestContext& ctx) {
 }
 
 void IHidServer::EndPermitVibrationSession(HLERequestContext& ctx) {
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .SetPermitVibrationSession(false);
+    GetResourceManager()->GetNpad()->SetPermitVibrationSession(false);
 
     LOG_DEBUG(Service_HID, "called");
 
@@ -1765,9 +1726,8 @@ void IHidServer::IsVibrationDeviceMounted(HLERequestContext& ctx) {
 
     IPC::ResponseBuilder rb{ctx, 3};
     rb.Push(ResultSuccess);
-    rb.Push(GetResourceManager()
-                ->GetController<Controller_NPad>(HidController::NPad)
-                .IsVibrationDeviceMounted(parameters.vibration_device_handle));
+    rb.Push(GetResourceManager()->GetNpad()->IsVibrationDeviceMounted(
+        parameters.vibration_device_handle));
 }
 
 void IHidServer::ActivateConsoleSixAxisSensor(HLERequestContext& ctx) {
@@ -1777,15 +1737,14 @@ void IHidServer::ActivateConsoleSixAxisSensor(HLERequestContext& ctx) {
     LOG_INFO(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
     Result result = ResultSuccess;
-    auto console_sixaxis = GetResourceManager()->GetController<Controller_ConsoleSixAxis>(
-        HidController::ConsoleSixAxisSensor);
+    auto console_sixaxis = GetResourceManager()->GetConsoleSixAxis();
 
     if (!firmware_settings->IsDeviceManaged()) {
-        result = console_sixaxis.Activate();
+        result = console_sixaxis->Activate();
     }
 
     if (result.IsSuccess()) {
-        result = console_sixaxis.Activate(applet_resource_user_id);
+        result = console_sixaxis->Activate(applet_resource_user_id);
     }
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -1839,15 +1798,14 @@ void IHidServer::ActivateSevenSixAxisSensor(HLERequestContext& ctx) {
     LOG_INFO(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
     Result result = ResultSuccess;
-    auto console_sixaxis = GetResourceManager()->GetController<Controller_ConsoleSixAxis>(
-        HidController::ConsoleSixAxisSensor);
+    auto seven_sixaxis = GetResourceManager()->GetSevenSixAxis();
 
     if (!firmware_settings->IsDeviceManaged()) {
-        result = console_sixaxis.Activate();
+        result = seven_sixaxis->Activate();
     }
 
     if (result.IsSuccess()) {
-        console_sixaxis.Activate(applet_resource_user_id);
+        seven_sixaxis->Activate(applet_resource_user_id);
     }
 
     IPC::ResponseBuilder rb{ctx, 2};
@@ -1911,13 +1869,10 @@ void IHidServer::InitializeSevenSixAxisSensor(HLERequestContext& ctx) {
     ASSERT_MSG(t_mem_2->GetSize() == 0x7F000, "t_mem_2 has incorrect size");
 
     // Activate console six axis controller
-    GetResourceManager()
-        ->GetController<Controller_ConsoleSixAxis>(HidController::ConsoleSixAxisSensor)
-        .Activate();
+    GetResourceManager()->GetConsoleSixAxis()->Activate();
+    GetResourceManager()->GetSevenSixAxis()->Activate();
 
-    GetResourceManager()
-        ->GetController<Controller_ConsoleSixAxis>(HidController::ConsoleSixAxisSensor)
-        .SetTransferMemoryAddress(t_mem_1->GetSourceAddress());
+    GetResourceManager()->GetSevenSixAxis()->SetTransferMemoryAddress(t_mem_1->GetSourceAddress());
 
     LOG_WARNING(Service_HID,
                 "called, t_mem_1_handle=0x{:08X}, t_mem_2_handle=0x{:08X}, "
@@ -1943,9 +1898,7 @@ void IHidServer::ResetSevenSixAxisSensorTimestamp(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
 
-    GetResourceManager()
-        ->GetController<Controller_ConsoleSixAxis>(HidController::ConsoleSixAxisSensor)
-        .ResetTimestamp();
+    GetResourceManager()->GetSevenSixAxis()->ResetTimestamp();
 
     LOG_WARNING(Service_HID, "called, applet_resource_user_id={}", applet_resource_user_id);
 
@@ -1977,9 +1930,9 @@ void IHidServer::GetPalmaConnectionHandle(HLERequestContext& ctx) {
     LOG_WARNING(Service_HID, "(STUBBED) called, npad_id={}, applet_resource_user_id={}",
                 parameters.npad_id, parameters.applet_resource_user_id);
 
-    Controller_Palma::PalmaConnectionHandle handle;
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
-    const auto result = controller.GetPalmaConnectionHandle(parameters.npad_id, handle);
+    Palma::PalmaConnectionHandle handle;
+    auto controller = GetResourceManager()->GetPalma();
+    const auto result = controller->GetPalmaConnectionHandle(parameters.npad_id, handle);
 
     IPC::ResponseBuilder rb{ctx, 4};
     rb.Push(result);
@@ -1988,12 +1941,12 @@ void IHidServer::GetPalmaConnectionHandle(HLERequestContext& ctx) {
 
 void IHidServer::InitializePalma(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
-    const auto result = controller.InitializePalma(connection_handle);
+    auto controller = GetResourceManager()->GetPalma();
+    const auto result = controller->InitializePalma(connection_handle);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -2001,27 +1954,27 @@ void IHidServer::InitializePalma(HLERequestContext& ctx) {
 
 void IHidServer::AcquirePalmaOperationCompleteEvent(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
+    auto controller = GetResourceManager()->GetPalma();
 
     IPC::ResponseBuilder rb{ctx, 2, 1};
     rb.Push(ResultSuccess);
-    rb.PushCopyObjects(controller.AcquirePalmaOperationCompleteEvent(connection_handle));
+    rb.PushCopyObjects(controller->AcquirePalmaOperationCompleteEvent(connection_handle));
 }
 
 void IHidServer::GetPalmaOperationInfo(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    Controller_Palma::PalmaOperationType operation_type;
-    Controller_Palma::PalmaOperationData data;
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
-    const auto result = controller.GetPalmaOperationInfo(connection_handle, operation_type, data);
+    Palma::PalmaOperationType operation_type;
+    Palma::PalmaOperationData data;
+    auto controller = GetResourceManager()->GetPalma();
+    const auto result = controller->GetPalmaOperationInfo(connection_handle, operation_type, data);
 
     if (result.IsError()) {
         IPC::ResponseBuilder rb{ctx, 2};
@@ -2036,14 +1989,14 @@ void IHidServer::GetPalmaOperationInfo(HLERequestContext& ctx) {
 
 void IHidServer::PlayPalmaActivity(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
     const auto palma_activity{rp.Pop<u64>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}, palma_activity={}",
                 connection_handle.npad_id, palma_activity);
 
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
-    const auto result = controller.PlayPalmaActivity(connection_handle, palma_activity);
+    auto controller = GetResourceManager()->GetPalma();
+    const auto result = controller->PlayPalmaActivity(connection_handle, palma_activity);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -2051,14 +2004,14 @@ void IHidServer::PlayPalmaActivity(HLERequestContext& ctx) {
 
 void IHidServer::SetPalmaFrModeType(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
-    const auto fr_mode{rp.PopEnum<Controller_Palma::PalmaFrModeType>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
+    const auto fr_mode{rp.PopEnum<Palma::PalmaFrModeType>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}, fr_mode={}",
                 connection_handle.npad_id, fr_mode);
 
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
-    const auto result = controller.SetPalmaFrModeType(connection_handle, fr_mode);
+    auto controller = GetResourceManager()->GetPalma();
+    const auto result = controller->SetPalmaFrModeType(connection_handle, fr_mode);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -2066,12 +2019,12 @@ void IHidServer::SetPalmaFrModeType(HLERequestContext& ctx) {
 
 void IHidServer::ReadPalmaStep(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
-    const auto result = controller.ReadPalmaStep(connection_handle);
+    auto controller = GetResourceManager()->GetPalma();
+    const auto result = controller->ReadPalmaStep(connection_handle);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -2082,7 +2035,7 @@ void IHidServer::EnablePalmaStep(HLERequestContext& ctx) {
     struct Parameters {
         bool is_enabled;
         INSERT_PADDING_WORDS_NOINIT(1);
-        Controller_Palma::PalmaConnectionHandle connection_handle;
+        Palma::PalmaConnectionHandle connection_handle;
     };
     static_assert(sizeof(Parameters) == 0x10, "Parameters has incorrect size.");
 
@@ -2091,9 +2044,9 @@ void IHidServer::EnablePalmaStep(HLERequestContext& ctx) {
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}, is_enabled={}",
                 parameters.connection_handle.npad_id, parameters.is_enabled);
 
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
+    auto controller = GetResourceManager()->GetPalma();
     const auto result =
-        controller.EnablePalmaStep(parameters.connection_handle, parameters.is_enabled);
+        controller->EnablePalmaStep(parameters.connection_handle, parameters.is_enabled);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -2101,12 +2054,12 @@ void IHidServer::EnablePalmaStep(HLERequestContext& ctx) {
 
 void IHidServer::ResetPalmaStep(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    auto& controller = GetResourceManager()->GetController<Controller_Palma>(HidController::Palma);
-    const auto result = controller.ResetPalmaStep(connection_handle);
+    auto controller = GetResourceManager()->GetPalma();
+    const auto result = controller->ResetPalmaStep(connection_handle);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -2128,13 +2081,11 @@ void IHidServer::WritePalmaApplicationSection(HLERequestContext& ctx) {
 
 void IHidServer::ReadPalmaUniqueCode(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .ReadPalmaUniqueCode(connection_handle);
+    GetResourceManager()->GetPalma()->ReadPalmaUniqueCode(connection_handle);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2142,13 +2093,11 @@ void IHidServer::ReadPalmaUniqueCode(HLERequestContext& ctx) {
 
 void IHidServer::SetPalmaUniqueCodeInvalid(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .SetPalmaUniqueCodeInvalid(connection_handle);
+    GetResourceManager()->GetPalma()->SetPalmaUniqueCodeInvalid(connection_handle);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2163,7 +2112,7 @@ void IHidServer::WritePalmaActivityEntry(HLERequestContext& ctx) {
 
 void IHidServer::WritePalmaRgbLedPatternEntry(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
     const auto unknown{rp.Pop<u64>()};
 
     [[maybe_unused]] const auto buffer = ctx.ReadBuffer();
@@ -2171,9 +2120,7 @@ void IHidServer::WritePalmaRgbLedPatternEntry(HLERequestContext& ctx) {
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}, unknown={}",
                 connection_handle.npad_id, unknown);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .WritePalmaRgbLedPatternEntry(connection_handle, unknown);
+    GetResourceManager()->GetPalma()->WritePalmaRgbLedPatternEntry(connection_handle, unknown);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2181,8 +2128,8 @@ void IHidServer::WritePalmaRgbLedPatternEntry(HLERequestContext& ctx) {
 
 void IHidServer::WritePalmaWaveEntry(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
-    const auto wave_set{rp.PopEnum<Controller_Palma::PalmaWaveSet>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
+    const auto wave_set{rp.PopEnum<Palma::PalmaWaveSet>()};
     const auto unknown{rp.Pop<u64>()};
     const auto t_mem_size{rp.Pop<u64>()};
     const auto t_mem_handle{ctx.GetCopyHandle(0)};
@@ -2207,9 +2154,8 @@ void IHidServer::WritePalmaWaveEntry(HLERequestContext& ctx) {
                 "t_mem_handle=0x{:08X}, t_mem_size={}, size={}",
                 connection_handle.npad_id, wave_set, unknown, t_mem_handle, t_mem_size, size);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .WritePalmaWaveEntry(connection_handle, wave_set, t_mem->GetSourceAddress(), t_mem_size);
+    GetResourceManager()->GetPalma()->WritePalmaWaveEntry(connection_handle, wave_set,
+                                                          t_mem->GetSourceAddress(), t_mem_size);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2220,7 +2166,7 @@ void IHidServer::SetPalmaDataBaseIdentificationVersion(HLERequestContext& ctx) {
     struct Parameters {
         s32 database_id_version;
         INSERT_PADDING_WORDS_NOINIT(1);
-        Controller_Palma::PalmaConnectionHandle connection_handle;
+        Palma::PalmaConnectionHandle connection_handle;
     };
     static_assert(sizeof(Parameters) == 0x10, "Parameters has incorrect size.");
 
@@ -2229,10 +2175,8 @@ void IHidServer::SetPalmaDataBaseIdentificationVersion(HLERequestContext& ctx) {
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}, database_id_version={}",
                 parameters.connection_handle.npad_id, parameters.database_id_version);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .SetPalmaDataBaseIdentificationVersion(parameters.connection_handle,
-                                               parameters.database_id_version);
+    GetResourceManager()->GetPalma()->SetPalmaDataBaseIdentificationVersion(
+        parameters.connection_handle, parameters.database_id_version);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2240,13 +2184,11 @@ void IHidServer::SetPalmaDataBaseIdentificationVersion(HLERequestContext& ctx) {
 
 void IHidServer::GetPalmaDataBaseIdentificationVersion(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .GetPalmaDataBaseIdentificationVersion(connection_handle);
+    GetResourceManager()->GetPalma()->GetPalmaDataBaseIdentificationVersion(connection_handle);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2261,13 +2203,12 @@ void IHidServer::SuspendPalmaFeature(HLERequestContext& ctx) {
 
 void IHidServer::GetPalmaOperationResult(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    const auto result = GetResourceManager()
-                            ->GetController<Controller_Palma>(HidController::Palma)
-                            .GetPalmaOperationResult(connection_handle);
+    const auto result =
+        GetResourceManager()->GetPalma()->GetPalmaOperationResult(connection_handle);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(result);
@@ -2302,9 +2243,7 @@ void IHidServer::SetIsPalmaAllConnectable(HLERequestContext& ctx) {
                 "(STUBBED) called, is_palma_all_connectable={},applet_resource_user_id={}",
                 parameters.is_palma_all_connectable, parameters.applet_resource_user_id);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .SetIsPalmaAllConnectable(parameters.is_palma_all_connectable);
+    GetResourceManager()->GetPalma()->SetIsPalmaAllConnectable(parameters.is_palma_all_connectable);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2319,13 +2258,11 @@ void IHidServer::SetIsPalmaPairedConnectable(HLERequestContext& ctx) {
 
 void IHidServer::PairPalma(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
-    const auto connection_handle{rp.PopRaw<Controller_Palma::PalmaConnectionHandle>()};
+    const auto connection_handle{rp.PopRaw<Palma::PalmaConnectionHandle>()};
 
     LOG_WARNING(Service_HID, "(STUBBED) called, connection_handle={}", connection_handle.npad_id);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .PairPalma(connection_handle);
+    GetResourceManager()->GetPalma()->PairPalma(connection_handle);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2337,9 +2274,7 @@ void IHidServer::SetPalmaBoostMode(HLERequestContext& ctx) {
 
     LOG_WARNING(Service_HID, "(STUBBED) called, palma_boost_mode={}", palma_boost_mode);
 
-    GetResourceManager()
-        ->GetController<Controller_Palma>(HidController::Palma)
-        .SetPalmaBoostMode(palma_boost_mode);
+    GetResourceManager()->GetPalma()->SetPalmaBoostMode(palma_boost_mode);
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -2376,11 +2311,9 @@ void IHidServer::SetDisallowedPalmaConnection(HLERequestContext& ctx) {
 void IHidServer::SetNpadCommunicationMode(HLERequestContext& ctx) {
     IPC::RequestParser rp{ctx};
     const auto applet_resource_user_id{rp.Pop<u64>()};
-    const auto communication_mode{rp.PopEnum<Controller_NPad::NpadCommunicationMode>()};
+    const auto communication_mode{rp.PopEnum<NPad::NpadCommunicationMode>()};
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .SetNpadCommunicationMode(communication_mode);
+    GetResourceManager()->GetNpad()->SetNpadCommunicationMode(communication_mode);
 
     LOG_WARNING(Service_HID, "(STUBBED) called, applet_resource_user_id={}, communication_mode={}",
                 applet_resource_user_id, communication_mode);
@@ -2396,9 +2329,7 @@ void IHidServer::GetNpadCommunicationMode(HLERequestContext& ctx) {
 
     IPC::ResponseBuilder rb{ctx, 4};
     rb.Push(ResultSuccess);
-    rb.PushEnum(GetResourceManager()
-                    ->GetController<Controller_NPad>(HidController::NPad)
-                    .GetNpadCommunicationMode());
+    rb.PushEnum(GetResourceManager()->GetNpad()->GetNpadCommunicationMode());
 }
 
 void IHidServer::SetTouchScreenConfiguration(HLERequestContext& ctx) {
diff --git a/src/core/hle/service/hid/hid_system_server.cpp b/src/core/hle/service/hid/hid_system_server.cpp
index 6f1902ee54a0..b56d0347a3a2 100644
--- a/src/core/hle/service/hid/hid_system_server.cpp
+++ b/src/core/hle/service/hid/hid_system_server.cpp
@@ -16,206 +16,206 @@ IHidSystemServer::IHidSystemServer(Core::System& system_, std::shared_ptr<Resour
       resource_manager{resource} {
     // clang-format off
     static const FunctionInfo functions[] = {
-            {31, nullptr, "SendKeyboardLockKeyEvent"},
-            {101, nullptr, "AcquireHomeButtonEventHandle"},
-            {111, nullptr, "ActivateHomeButton"},
-            {121, nullptr, "AcquireSleepButtonEventHandle"},
-            {131, nullptr, "ActivateSleepButton"},
-            {141, nullptr, "AcquireCaptureButtonEventHandle"},
-            {151, nullptr, "ActivateCaptureButton"},
-            {161, nullptr, "GetPlatformConfig"},
-            {210, nullptr, "AcquireNfcDeviceUpdateEventHandle"},
-            {211, nullptr, "GetNpadsWithNfc"},
-            {212, nullptr, "AcquireNfcActivateEventHandle"},
-            {213, nullptr, "ActivateNfc"},
-            {214, nullptr, "GetXcdHandleForNpadWithNfc"},
-            {215, nullptr, "IsNfcActivated"},
-            {230, nullptr, "AcquireIrSensorEventHandle"},
-            {231, nullptr, "ActivateIrSensor"},
-            {232, nullptr, "GetIrSensorState"},
-            {233, nullptr, "GetXcdHandleForNpadWithIrSensor"},
-            {301, nullptr, "ActivateNpadSystem"},
-            {303, &IHidSystemServer::ApplyNpadSystemCommonPolicy, "ApplyNpadSystemCommonPolicy"},
-            {304, &IHidSystemServer::EnableAssigningSingleOnSlSrPress, "EnableAssigningSingleOnSlSrPress"},
-            {305, &IHidSystemServer::DisableAssigningSingleOnSlSrPress, "DisableAssigningSingleOnSlSrPress"},
-            {306, &IHidSystemServer::GetLastActiveNpad, "GetLastActiveNpad"},
-            {307, nullptr, "GetNpadSystemExtStyle"},
-            {308, &IHidSystemServer::ApplyNpadSystemCommonPolicyFull, "ApplyNpadSystemCommonPolicyFull"},
-            {309, &IHidSystemServer::GetNpadFullKeyGripColor, "GetNpadFullKeyGripColor"},
-            {310, &IHidSystemServer::GetMaskedSupportedNpadStyleSet, "GetMaskedSupportedNpadStyleSet"},
-            {311, nullptr, "SetNpadPlayerLedBlinkingDevice"},
-            {312, &IHidSystemServer::SetSupportedNpadStyleSetAll, "SetSupportedNpadStyleSetAll"},
-            {313, nullptr, "GetNpadCaptureButtonAssignment"},
-            {314, nullptr, "GetAppletFooterUiType"},
-            {315, &IHidSystemServer::GetAppletDetailedUiType, "GetAppletDetailedUiType"},
-            {316, &IHidSystemServer::GetNpadInterfaceType, "GetNpadInterfaceType"},
-            {317, &IHidSystemServer::GetNpadLeftRightInterfaceType, "GetNpadLeftRightInterfaceType"},
-            {318, &IHidSystemServer::HasBattery, "HasBattery"},
-            {319, &IHidSystemServer::HasLeftRightBattery, "HasLeftRightBattery"},
-            {321, &IHidSystemServer::GetUniquePadsFromNpad, "GetUniquePadsFromNpad"},
-            {322, &IHidSystemServer::GetIrSensorState, "GetIrSensorState"},
-            {323, nullptr, "GetXcdHandleForNpadWithIrSensor"},
-            {324, nullptr, "GetUniquePadButtonSet"},
-            {325, nullptr, "GetUniquePadColor"},
-            {326, nullptr, "GetUniquePadAppletDetailedUiType"},
-            {327, nullptr, "GetAbstractedPadIdDataFromNpad"},
-            {328, nullptr, "AttachAbstractedPadToNpad"},
-            {329, nullptr, "DetachAbstractedPadAll"},
-            {330, nullptr, "CheckAbstractedPadConnection"},
-            {500, nullptr, "SetAppletResourceUserId"},
-            {501, nullptr, "RegisterAppletResourceUserId"},
-            {502, nullptr, "UnregisterAppletResourceUserId"},
-            {503, nullptr, "EnableAppletToGetInput"},
-            {504, nullptr, "SetAruidValidForVibration"},
-            {505, nullptr, "EnableAppletToGetSixAxisSensor"},
-            {506, nullptr, "EnableAppletToGetPadInput"},
-            {507, nullptr, "EnableAppletToGetTouchScreen"},
-            {510, nullptr, "SetVibrationMasterVolume"},
-            {511, nullptr, "GetVibrationMasterVolume"},
-            {512, nullptr, "BeginPermitVibrationSession"},
-            {513, nullptr, "EndPermitVibrationSession"},
-            {514, nullptr, "Unknown514"},
-            {520, nullptr, "EnableHandheldHids"},
-            {521, nullptr, "DisableHandheldHids"},
-            {522, nullptr, "SetJoyConRailEnabled"},
-            {523, nullptr, "IsJoyConRailEnabled"},
-            {524, nullptr, "IsHandheldHidsEnabled"},
-            {525, nullptr, "IsJoyConAttachedOnAllRail"},
-            {540, nullptr, "AcquirePlayReportControllerUsageUpdateEvent"},
-            {541, nullptr, "GetPlayReportControllerUsages"},
-            {542, nullptr, "AcquirePlayReportRegisteredDeviceUpdateEvent"},
-            {543, nullptr, "GetRegisteredDevicesOld"},
-            {544, &IHidSystemServer::AcquireConnectionTriggerTimeoutEvent, "AcquireConnectionTriggerTimeoutEvent"},
-            {545, nullptr, "SendConnectionTrigger"},
-            {546, &IHidSystemServer::AcquireDeviceRegisteredEventForControllerSupport, "AcquireDeviceRegisteredEventForControllerSupport"},
-            {547, nullptr, "GetAllowedBluetoothLinksCount"},
-            {548, &IHidSystemServer::GetRegisteredDevices, "GetRegisteredDevices"},
-            {549, nullptr, "GetConnectableRegisteredDevices"},
-            {700, nullptr, "ActivateUniquePad"},
-            {702, &IHidSystemServer::AcquireUniquePadConnectionEventHandle, "AcquireUniquePadConnectionEventHandle"},
-            {703, &IHidSystemServer::GetUniquePadIds, "GetUniquePadIds"},
-            {751, &IHidSystemServer::AcquireJoyDetachOnBluetoothOffEventHandle, "AcquireJoyDetachOnBluetoothOffEventHandle"},
-            {800, nullptr, "ListSixAxisSensorHandles"},
-            {801, nullptr, "IsSixAxisSensorUserCalibrationSupported"},
-            {802, nullptr, "ResetSixAxisSensorCalibrationValues"},
-            {803, nullptr, "StartSixAxisSensorUserCalibration"},
-            {804, nullptr, "CancelSixAxisSensorUserCalibration"},
-            {805, nullptr, "GetUniquePadBluetoothAddress"},
-            {806, nullptr, "DisconnectUniquePad"},
-            {807, nullptr, "GetUniquePadType"},
-            {808, nullptr, "GetUniquePadInterface"},
-            {809, nullptr, "GetUniquePadSerialNumber"},
-            {810, nullptr, "GetUniquePadControllerNumber"},
-            {811, nullptr, "GetSixAxisSensorUserCalibrationStage"},
-            {812, nullptr, "GetConsoleUniqueSixAxisSensorHandle"},
-            {821, nullptr, "StartAnalogStickManualCalibration"},
-            {822, nullptr, "RetryCurrentAnalogStickManualCalibrationStage"},
-            {823, nullptr, "CancelAnalogStickManualCalibration"},
-            {824, nullptr, "ResetAnalogStickManualCalibration"},
-            {825, nullptr, "GetAnalogStickState"},
-            {826, nullptr, "GetAnalogStickManualCalibrationStage"},
-            {827, nullptr, "IsAnalogStickButtonPressed"},
-            {828, nullptr, "IsAnalogStickInReleasePosition"},
-            {829, nullptr, "IsAnalogStickInCircumference"},
-            {830, nullptr, "SetNotificationLedPattern"},
-            {831, nullptr, "SetNotificationLedPatternWithTimeout"},
-            {832, nullptr, "PrepareHidsForNotificationWake"},
-            {850, &IHidSystemServer::IsUsbFullKeyControllerEnabled, "IsUsbFullKeyControllerEnabled"},
-            {851, nullptr, "EnableUsbFullKeyController"},
-            {852, nullptr, "IsUsbConnected"},
-            {870, &IHidSystemServer::IsHandheldButtonPressedOnConsoleMode, "IsHandheldButtonPressedOnConsoleMode"},
-            {900, nullptr, "ActivateInputDetector"},
-            {901, nullptr, "NotifyInputDetector"},
-            {1000, &IHidSystemServer::InitializeFirmwareUpdate, "InitializeFirmwareUpdate"},
-            {1001, nullptr, "GetFirmwareVersion"},
-            {1002, nullptr, "GetAvailableFirmwareVersion"},
-            {1003, nullptr, "IsFirmwareUpdateAvailable"},
-            {1004, nullptr, "CheckFirmwareUpdateRequired"},
-            {1005, nullptr, "StartFirmwareUpdate"},
-            {1006, nullptr, "AbortFirmwareUpdate"},
-            {1007, nullptr, "GetFirmwareUpdateState"},
-            {1008, nullptr, "ActivateAudioControl"},
-            {1009, nullptr, "AcquireAudioControlEventHandle"},
-            {1010, nullptr, "GetAudioControlStates"},
-            {1011, nullptr, "DeactivateAudioControl"},
-            {1050, nullptr, "IsSixAxisSensorAccurateUserCalibrationSupported"},
-            {1051, nullptr, "StartSixAxisSensorAccurateUserCalibration"},
-            {1052, nullptr, "CancelSixAxisSensorAccurateUserCalibration"},
-            {1053, nullptr, "GetSixAxisSensorAccurateUserCalibrationState"},
-            {1100, nullptr, "GetHidbusSystemServiceObject"},
-            {1120, nullptr, "SetFirmwareHotfixUpdateSkipEnabled"},
-            {1130, nullptr, "InitializeUsbFirmwareUpdate"},
-            {1131, nullptr, "FinalizeUsbFirmwareUpdate"},
-            {1132, nullptr, "CheckUsbFirmwareUpdateRequired"},
-            {1133, nullptr, "StartUsbFirmwareUpdate"},
-            {1134, nullptr, "GetUsbFirmwareUpdateState"},
-            {1135, &IHidSystemServer::InitializeUsbFirmwareUpdateWithoutMemory, "InitializeUsbFirmwareUpdateWithoutMemory"},
-            {1150, nullptr, "SetTouchScreenMagnification"},
-            {1151, nullptr, "GetTouchScreenFirmwareVersion"},
-            {1152, nullptr, "SetTouchScreenDefaultConfiguration"},
-            {1153, &IHidSystemServer::GetTouchScreenDefaultConfiguration, "GetTouchScreenDefaultConfiguration"},
-            {1154, nullptr, "IsFirmwareAvailableForNotification"},
-            {1155, nullptr, "SetForceHandheldStyleVibration"},
-            {1156, nullptr, "SendConnectionTriggerWithoutTimeoutEvent"},
-            {1157, nullptr, "CancelConnectionTrigger"},
-            {1200, nullptr, "IsButtonConfigSupported"},
-            {1201, nullptr, "IsButtonConfigEmbeddedSupported"},
-            {1202, nullptr, "DeleteButtonConfig"},
-            {1203, nullptr, "DeleteButtonConfigEmbedded"},
-            {1204, nullptr, "SetButtonConfigEnabled"},
-            {1205, nullptr, "SetButtonConfigEmbeddedEnabled"},
-            {1206, nullptr, "IsButtonConfigEnabled"},
-            {1207, nullptr, "IsButtonConfigEmbeddedEnabled"},
-            {1208, nullptr, "SetButtonConfigEmbedded"},
-            {1209, nullptr, "SetButtonConfigFull"},
-            {1210, nullptr, "SetButtonConfigLeft"},
-            {1211, nullptr, "SetButtonConfigRight"},
-            {1212, nullptr, "GetButtonConfigEmbedded"},
-            {1213, nullptr, "GetButtonConfigFull"},
-            {1214, nullptr, "GetButtonConfigLeft"},
-            {1215, nullptr, "GetButtonConfigRight"},
-            {1250, nullptr, "IsCustomButtonConfigSupported"},
-            {1251, nullptr, "IsDefaultButtonConfigEmbedded"},
-            {1252, nullptr, "IsDefaultButtonConfigFull"},
-            {1253, nullptr, "IsDefaultButtonConfigLeft"},
-            {1254, nullptr, "IsDefaultButtonConfigRight"},
-            {1255, nullptr, "IsButtonConfigStorageEmbeddedEmpty"},
-            {1256, nullptr, "IsButtonConfigStorageFullEmpty"},
-            {1257, nullptr, "IsButtonConfigStorageLeftEmpty"},
-            {1258, nullptr, "IsButtonConfigStorageRightEmpty"},
-            {1259, nullptr, "GetButtonConfigStorageEmbeddedDeprecated"},
-            {1260, nullptr, "GetButtonConfigStorageFullDeprecated"},
-            {1261, nullptr, "GetButtonConfigStorageLeftDeprecated"},
-            {1262, nullptr, "GetButtonConfigStorageRightDeprecated"},
-            {1263, nullptr, "SetButtonConfigStorageEmbeddedDeprecated"},
-            {1264, nullptr, "SetButtonConfigStorageFullDeprecated"},
-            {1265, nullptr, "SetButtonConfigStorageLeftDeprecated"},
-            {1266, nullptr, "SetButtonConfigStorageRightDeprecated"},
-            {1267, nullptr, "DeleteButtonConfigStorageEmbedded"},
-            {1268, nullptr, "DeleteButtonConfigStorageFull"},
-            {1269, nullptr, "DeleteButtonConfigStorageLeft"},
-            {1270, nullptr, "DeleteButtonConfigStorageRight"},
-            {1271, nullptr, "IsUsingCustomButtonConfig"},
-            {1272, nullptr, "IsAnyCustomButtonConfigEnabled"},
-            {1273, nullptr, "SetAllCustomButtonConfigEnabled"},
-            {1274, nullptr, "SetDefaultButtonConfig"},
-            {1275, nullptr, "SetAllDefaultButtonConfig"},
-            {1276, nullptr, "SetHidButtonConfigEmbedded"},
-            {1277, nullptr, "SetHidButtonConfigFull"},
-            {1278, nullptr, "SetHidButtonConfigLeft"},
-            {1279, nullptr, "SetHidButtonConfigRight"},
-            {1280, nullptr, "GetHidButtonConfigEmbedded"},
-            {1281, nullptr, "GetHidButtonConfigFull"},
-            {1282, nullptr, "GetHidButtonConfigLeft"},
-            {1283, nullptr, "GetHidButtonConfigRight"},
-            {1284, nullptr, "GetButtonConfigStorageEmbedded"},
-            {1285, nullptr, "GetButtonConfigStorageFull"},
-            {1286, nullptr, "GetButtonConfigStorageLeft"},
-            {1287, nullptr, "GetButtonConfigStorageRight"},
-            {1288, nullptr, "SetButtonConfigStorageEmbedded"},
-            {1289, nullptr, "SetButtonConfigStorageFull"},
-            {1290, nullptr, "DeleteButtonConfigStorageRight"},
-            {1291, nullptr, "DeleteButtonConfigStorageRight"},
+        {31, nullptr, "SendKeyboardLockKeyEvent"},
+        {101, nullptr, "AcquireHomeButtonEventHandle"},
+        {111, nullptr, "ActivateHomeButton"},
+        {121, nullptr, "AcquireSleepButtonEventHandle"},
+        {131, nullptr, "ActivateSleepButton"},
+        {141, nullptr, "AcquireCaptureButtonEventHandle"},
+        {151, nullptr, "ActivateCaptureButton"},
+        {161, nullptr, "GetPlatformConfig"},
+        {210, nullptr, "AcquireNfcDeviceUpdateEventHandle"},
+        {211, nullptr, "GetNpadsWithNfc"},
+        {212, nullptr, "AcquireNfcActivateEventHandle"},
+        {213, nullptr, "ActivateNfc"},
+        {214, nullptr, "GetXcdHandleForNpadWithNfc"},
+        {215, nullptr, "IsNfcActivated"},
+        {230, nullptr, "AcquireIrSensorEventHandle"},
+        {231, nullptr, "ActivateIrSensor"},
+        {232, nullptr, "GetIrSensorState"},
+        {233, nullptr, "GetXcdHandleForNpadWithIrSensor"},
+        {301, nullptr, "ActivateNpadSystem"},
+        {303, &IHidSystemServer::ApplyNpadSystemCommonPolicy, "ApplyNpadSystemCommonPolicy"},
+        {304, &IHidSystemServer::EnableAssigningSingleOnSlSrPress, "EnableAssigningSingleOnSlSrPress"},
+        {305, &IHidSystemServer::DisableAssigningSingleOnSlSrPress, "DisableAssigningSingleOnSlSrPress"},
+        {306, &IHidSystemServer::GetLastActiveNpad, "GetLastActiveNpad"},
+        {307, nullptr, "GetNpadSystemExtStyle"},
+        {308, &IHidSystemServer::ApplyNpadSystemCommonPolicyFull, "ApplyNpadSystemCommonPolicyFull"},
+        {309, &IHidSystemServer::GetNpadFullKeyGripColor, "GetNpadFullKeyGripColor"},
+        {310, &IHidSystemServer::GetMaskedSupportedNpadStyleSet, "GetMaskedSupportedNpadStyleSet"},
+        {311, nullptr, "SetNpadPlayerLedBlinkingDevice"},
+        {312, &IHidSystemServer::SetSupportedNpadStyleSetAll, "SetSupportedNpadStyleSetAll"},
+        {313, nullptr, "GetNpadCaptureButtonAssignment"},
+        {314, nullptr, "GetAppletFooterUiType"},
+        {315, &IHidSystemServer::GetAppletDetailedUiType, "GetAppletDetailedUiType"},
+        {316, &IHidSystemServer::GetNpadInterfaceType, "GetNpadInterfaceType"},
+        {317, &IHidSystemServer::GetNpadLeftRightInterfaceType, "GetNpadLeftRightInterfaceType"},
+        {318, &IHidSystemServer::HasBattery, "HasBattery"},
+        {319, &IHidSystemServer::HasLeftRightBattery, "HasLeftRightBattery"},
+        {321, &IHidSystemServer::GetUniquePadsFromNpad, "GetUniquePadsFromNpad"},
+        {322, &IHidSystemServer::GetIrSensorState, "GetIrSensorState"},
+        {323, nullptr, "GetXcdHandleForNpadWithIrSensor"},
+        {324, nullptr, "GetUniquePadButtonSet"},
+        {325, nullptr, "GetUniquePadColor"},
+        {326, nullptr, "GetUniquePadAppletDetailedUiType"},
+        {327, nullptr, "GetAbstractedPadIdDataFromNpad"},
+        {328, nullptr, "AttachAbstractedPadToNpad"},
+        {329, nullptr, "DetachAbstractedPadAll"},
+        {330, nullptr, "CheckAbstractedPadConnection"},
+        {500, nullptr, "SetAppletResourceUserId"},
+        {501, nullptr, "RegisterAppletResourceUserId"},
+        {502, nullptr, "UnregisterAppletResourceUserId"},
+        {503, nullptr, "EnableAppletToGetInput"},
+        {504, nullptr, "SetAruidValidForVibration"},
+        {505, nullptr, "EnableAppletToGetSixAxisSensor"},
+        {506, nullptr, "EnableAppletToGetPadInput"},
+        {507, nullptr, "EnableAppletToGetTouchScreen"},
+        {510, nullptr, "SetVibrationMasterVolume"},
+        {511, nullptr, "GetVibrationMasterVolume"},
+        {512, nullptr, "BeginPermitVibrationSession"},
+        {513, nullptr, "EndPermitVibrationSession"},
+        {514, nullptr, "Unknown514"},
+        {520, nullptr, "EnableHandheldHids"},
+        {521, nullptr, "DisableHandheldHids"},
+        {522, nullptr, "SetJoyConRailEnabled"},
+        {523, nullptr, "IsJoyConRailEnabled"},
+        {524, nullptr, "IsHandheldHidsEnabled"},
+        {525, nullptr, "IsJoyConAttachedOnAllRail"},
+        {540, nullptr, "AcquirePlayReportControllerUsageUpdateEvent"},
+        {541, nullptr, "GetPlayReportControllerUsages"},
+        {542, nullptr, "AcquirePlayReportRegisteredDeviceUpdateEvent"},
+        {543, nullptr, "GetRegisteredDevicesOld"},
+        {544, &IHidSystemServer::AcquireConnectionTriggerTimeoutEvent, "AcquireConnectionTriggerTimeoutEvent"},
+        {545, nullptr, "SendConnectionTrigger"},
+        {546, &IHidSystemServer::AcquireDeviceRegisteredEventForControllerSupport, "AcquireDeviceRegisteredEventForControllerSupport"},
+        {547, nullptr, "GetAllowedBluetoothLinksCount"},
+        {548, &IHidSystemServer::GetRegisteredDevices, "GetRegisteredDevices"},
+        {549, nullptr, "GetConnectableRegisteredDevices"},
+        {700, nullptr, "ActivateUniquePad"},
+        {702, &IHidSystemServer::AcquireUniquePadConnectionEventHandle, "AcquireUniquePadConnectionEventHandle"},
+        {703, &IHidSystemServer::GetUniquePadIds, "GetUniquePadIds"},
+        {751, &IHidSystemServer::AcquireJoyDetachOnBluetoothOffEventHandle, "AcquireJoyDetachOnBluetoothOffEventHandle"},
+        {800, nullptr, "ListSixAxisSensorHandles"},
+        {801, nullptr, "IsSixAxisSensorUserCalibrationSupported"},
+        {802, nullptr, "ResetSixAxisSensorCalibrationValues"},
+        {803, nullptr, "StartSixAxisSensorUserCalibration"},
+        {804, nullptr, "CancelSixAxisSensorUserCalibration"},
+        {805, nullptr, "GetUniquePadBluetoothAddress"},
+        {806, nullptr, "DisconnectUniquePad"},
+        {807, nullptr, "GetUniquePadType"},
+        {808, nullptr, "GetUniquePadInterface"},
+        {809, nullptr, "GetUniquePadSerialNumber"},
+        {810, nullptr, "GetUniquePadControllerNumber"},
+        {811, nullptr, "GetSixAxisSensorUserCalibrationStage"},
+        {812, nullptr, "GetConsoleUniqueSixAxisSensorHandle"},
+        {821, nullptr, "StartAnalogStickManualCalibration"},
+        {822, nullptr, "RetryCurrentAnalogStickManualCalibrationStage"},
+        {823, nullptr, "CancelAnalogStickManualCalibration"},
+        {824, nullptr, "ResetAnalogStickManualCalibration"},
+        {825, nullptr, "GetAnalogStickState"},
+        {826, nullptr, "GetAnalogStickManualCalibrationStage"},
+        {827, nullptr, "IsAnalogStickButtonPressed"},
+        {828, nullptr, "IsAnalogStickInReleasePosition"},
+        {829, nullptr, "IsAnalogStickInCircumference"},
+        {830, nullptr, "SetNotificationLedPattern"},
+        {831, nullptr, "SetNotificationLedPatternWithTimeout"},
+        {832, nullptr, "PrepareHidsForNotificationWake"},
+        {850, &IHidSystemServer::IsUsbFullKeyControllerEnabled, "IsUsbFullKeyControllerEnabled"},
+        {851, nullptr, "EnableUsbFullKeyController"},
+        {852, nullptr, "IsUsbConnected"},
+        {870, &IHidSystemServer::IsHandheldButtonPressedOnConsoleMode, "IsHandheldButtonPressedOnConsoleMode"},
+        {900, nullptr, "ActivateInputDetector"},
+        {901, nullptr, "NotifyInputDetector"},
+        {1000, &IHidSystemServer::InitializeFirmwareUpdate, "InitializeFirmwareUpdate"},
+        {1001, nullptr, "GetFirmwareVersion"},
+        {1002, nullptr, "GetAvailableFirmwareVersion"},
+        {1003, nullptr, "IsFirmwareUpdateAvailable"},
+        {1004, nullptr, "CheckFirmwareUpdateRequired"},
+        {1005, nullptr, "StartFirmwareUpdate"},
+        {1006, nullptr, "AbortFirmwareUpdate"},
+        {1007, nullptr, "GetFirmwareUpdateState"},
+        {1008, nullptr, "ActivateAudioControl"},
+        {1009, nullptr, "AcquireAudioControlEventHandle"},
+        {1010, nullptr, "GetAudioControlStates"},
+        {1011, nullptr, "DeactivateAudioControl"},
+        {1050, nullptr, "IsSixAxisSensorAccurateUserCalibrationSupported"},
+        {1051, nullptr, "StartSixAxisSensorAccurateUserCalibration"},
+        {1052, nullptr, "CancelSixAxisSensorAccurateUserCalibration"},
+        {1053, nullptr, "GetSixAxisSensorAccurateUserCalibrationState"},
+        {1100, nullptr, "GetHidbusSystemServiceObject"},
+        {1120, nullptr, "SetFirmwareHotfixUpdateSkipEnabled"},
+        {1130, nullptr, "InitializeUsbFirmwareUpdate"},
+        {1131, nullptr, "FinalizeUsbFirmwareUpdate"},
+        {1132, nullptr, "CheckUsbFirmwareUpdateRequired"},
+        {1133, nullptr, "StartUsbFirmwareUpdate"},
+        {1134, nullptr, "GetUsbFirmwareUpdateState"},
+        {1135, &IHidSystemServer::InitializeUsbFirmwareUpdateWithoutMemory, "InitializeUsbFirmwareUpdateWithoutMemory"},
+        {1150, nullptr, "SetTouchScreenMagnification"},
+        {1151, nullptr, "GetTouchScreenFirmwareVersion"},
+        {1152, nullptr, "SetTouchScreenDefaultConfiguration"},
+        {1153, &IHidSystemServer::GetTouchScreenDefaultConfiguration, "GetTouchScreenDefaultConfiguration"},
+        {1154, nullptr, "IsFirmwareAvailableForNotification"},
+        {1155, nullptr, "SetForceHandheldStyleVibration"},
+        {1156, nullptr, "SendConnectionTriggerWithoutTimeoutEvent"},
+        {1157, nullptr, "CancelConnectionTrigger"},
+        {1200, nullptr, "IsButtonConfigSupported"},
+        {1201, nullptr, "IsButtonConfigEmbeddedSupported"},
+        {1202, nullptr, "DeleteButtonConfig"},
+        {1203, nullptr, "DeleteButtonConfigEmbedded"},
+        {1204, nullptr, "SetButtonConfigEnabled"},
+        {1205, nullptr, "SetButtonConfigEmbeddedEnabled"},
+        {1206, nullptr, "IsButtonConfigEnabled"},
+        {1207, nullptr, "IsButtonConfigEmbeddedEnabled"},
+        {1208, nullptr, "SetButtonConfigEmbedded"},
+        {1209, nullptr, "SetButtonConfigFull"},
+        {1210, nullptr, "SetButtonConfigLeft"},
+        {1211, nullptr, "SetButtonConfigRight"},
+        {1212, nullptr, "GetButtonConfigEmbedded"},
+        {1213, nullptr, "GetButtonConfigFull"},
+        {1214, nullptr, "GetButtonConfigLeft"},
+        {1215, nullptr, "GetButtonConfigRight"},
+        {1250, nullptr, "IsCustomButtonConfigSupported"},
+        {1251, nullptr, "IsDefaultButtonConfigEmbedded"},
+        {1252, nullptr, "IsDefaultButtonConfigFull"},
+        {1253, nullptr, "IsDefaultButtonConfigLeft"},
+        {1254, nullptr, "IsDefaultButtonConfigRight"},
+        {1255, nullptr, "IsButtonConfigStorageEmbeddedEmpty"},
+        {1256, nullptr, "IsButtonConfigStorageFullEmpty"},
+        {1257, nullptr, "IsButtonConfigStorageLeftEmpty"},
+        {1258, nullptr, "IsButtonConfigStorageRightEmpty"},
+        {1259, nullptr, "GetButtonConfigStorageEmbeddedDeprecated"},
+        {1260, nullptr, "GetButtonConfigStorageFullDeprecated"},
+        {1261, nullptr, "GetButtonConfigStorageLeftDeprecated"},
+        {1262, nullptr, "GetButtonConfigStorageRightDeprecated"},
+        {1263, nullptr, "SetButtonConfigStorageEmbeddedDeprecated"},
+        {1264, nullptr, "SetButtonConfigStorageFullDeprecated"},
+        {1265, nullptr, "SetButtonConfigStorageLeftDeprecated"},
+        {1266, nullptr, "SetButtonConfigStorageRightDeprecated"},
+        {1267, nullptr, "DeleteButtonConfigStorageEmbedded"},
+        {1268, nullptr, "DeleteButtonConfigStorageFull"},
+        {1269, nullptr, "DeleteButtonConfigStorageLeft"},
+        {1270, nullptr, "DeleteButtonConfigStorageRight"},
+        {1271, nullptr, "IsUsingCustomButtonConfig"},
+        {1272, nullptr, "IsAnyCustomButtonConfigEnabled"},
+        {1273, nullptr, "SetAllCustomButtonConfigEnabled"},
+        {1274, nullptr, "SetDefaultButtonConfig"},
+        {1275, nullptr, "SetAllDefaultButtonConfig"},
+        {1276, nullptr, "SetHidButtonConfigEmbedded"},
+        {1277, nullptr, "SetHidButtonConfigFull"},
+        {1278, nullptr, "SetHidButtonConfigLeft"},
+        {1279, nullptr, "SetHidButtonConfigRight"},
+        {1280, nullptr, "GetHidButtonConfigEmbedded"},
+        {1281, nullptr, "GetHidButtonConfigFull"},
+        {1282, nullptr, "GetHidButtonConfigLeft"},
+        {1283, nullptr, "GetHidButtonConfigRight"},
+        {1284, nullptr, "GetButtonConfigStorageEmbedded"},
+        {1285, nullptr, "GetButtonConfigStorageFull"},
+        {1286, nullptr, "GetButtonConfigStorageLeft"},
+        {1287, nullptr, "GetButtonConfigStorageRight"},
+        {1288, nullptr, "SetButtonConfigStorageEmbedded"},
+        {1289, nullptr, "SetButtonConfigStorageFull"},
+        {1290, nullptr, "DeleteButtonConfigStorageRight"},
+        {1291, nullptr, "DeleteButtonConfigStorageRight"},
     };
     // clang-format on
 
@@ -240,9 +240,7 @@ IHidSystemServer::~IHidSystemServer() {
 void IHidSystemServer::ApplyNpadSystemCommonPolicy(HLERequestContext& ctx) {
     LOG_WARNING(Service_HID, "called");
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .ApplyNpadSystemCommonPolicy();
+    GetResourceManager()->GetNpad()->ApplyNpadSystemCommonPolicy();
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -273,9 +271,7 @@ void IHidSystemServer::GetLastActiveNpad(HLERequestContext& ctx) {
 void IHidSystemServer::ApplyNpadSystemCommonPolicyFull(HLERequestContext& ctx) {
     LOG_WARNING(Service_HID, "called");
 
-    GetResourceManager()
-        ->GetController<Controller_NPad>(HidController::NPad)
-        .ApplyNpadSystemCommonPolicy();
+    GetResourceManager()->GetNpad()->ApplyNpadSystemCommonPolicy();
 
     IPC::ResponseBuilder rb{ctx, 2};
     rb.Push(ResultSuccess);
@@ -304,10 +300,7 @@ void IHidSystemServer::GetMaskedSupportedNpadStyleSet(HLERequestContext& ctx) {
     LOG_INFO(Service_HID, "(STUBBED) called");
 
     Core::HID::NpadStyleSet supported_styleset =
-        GetResourceManager()
-            ->GetController<Controller_NPad>(HidController::NPad)
-            .GetSupportedStyleSet()
-            .raw;
+        GetResourceManager()->GetNpad()->GetSupportedStyleSet().raw;
 
     IPC::ResponseBuilder rb{ctx, 3};
     rb.Push(ResultSuccess);
@@ -320,10 +313,7 @@ void IHidSystemServer::SetSupportedNpadStyleSetAll(HLERequestContext& ctx) {
     LOG_INFO(Service_HID, "(STUBBED) called");
 
     Core::HID::NpadStyleSet supported_styleset =
-        GetResourceManager()
-            ->GetController<Controller_NPad>(HidController::NPad)
-            .GetSupportedStyleSet()
-            .raw;
+        GetResourceManager()->GetNpad()->GetSupportedStyleSet().raw;
 
     IPC::ResponseBuilder rb{ctx, 3};
     rb.Push(ResultSuccess);
@@ -337,10 +327,8 @@ void IHidSystemServer::GetAppletDetailedUiType(HLERequestContext& ctx) {
     LOG_DEBUG(Service_HID, "called, npad_id_type={}",
               npad_id_type); // Spams a lot when controller applet is running
 
-    const Service::HID::Controller_NPad::AppletDetailedUiType detailed_ui_type =
-        GetResourceManager()
-            ->GetController<Controller_NPad>(HidController::NPad)
-            .GetAppletDetailedUiType(npad_id_type);
+    const NPad::AppletDetailedUiType detailed_ui_type =
+        GetResourceManager()->GetNpad()->GetAppletDetailedUiType(npad_id_type);
 
     IPC::ResponseBuilder rb{ctx, 3};
     rb.Push(ResultSuccess);
diff --git a/src/core/hle/service/hid/hid_util.h b/src/core/hle/service/hid/hid_util.h
new file mode 100644
index 000000000000..b87cc10e30c7
--- /dev/null
+++ b/src/core/hle/service/hid/hid_util.h
@@ -0,0 +1,146 @@
+// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#pragma once
+
+#include "core/hid/hid_types.h"
+#include "core/hle/service/hid/errors.h"
+
+namespace Service::HID {
+
+constexpr bool IsNpadIdValid(const Core::HID::NpadIdType npad_id) {
+    switch (npad_id) {
+    case Core::HID::NpadIdType::Player1:
+    case Core::HID::NpadIdType::Player2:
+    case Core::HID::NpadIdType::Player3:
+    case Core::HID::NpadIdType::Player4:
+    case Core::HID::NpadIdType::Player5:
+    case Core::HID::NpadIdType::Player6:
+    case Core::HID::NpadIdType::Player7:
+    case Core::HID::NpadIdType::Player8:
+    case Core::HID::NpadIdType::Other:
+    case Core::HID::NpadIdType::Handheld:
+        return true;
+    default:
+        return false;
+    }
+}
+
+constexpr Result IsSixaxisHandleValid(const Core::HID::SixAxisSensorHandle& handle) {
+    const auto npad_id = IsNpadIdValid(static_cast<Core::HID::NpadIdType>(handle.npad_id));
+    const bool device_index = handle.device_index < Core::HID::DeviceIndex::MaxDeviceIndex;
+
+    if (!npad_id) {
+        return InvalidNpadId;
+    }
+    if (!device_index) {
+        return NpadDeviceIndexOutOfRange;
+    }
+
+    return ResultSuccess;
+}
+
+constexpr Result IsVibrationHandleValid(const Core::HID::VibrationDeviceHandle& handle) {
+    switch (handle.npad_type) {
+    case Core::HID::NpadStyleIndex::ProController:
+    case Core::HID::NpadStyleIndex::Handheld:
+    case Core::HID::NpadStyleIndex::JoyconDual:
+    case Core::HID::NpadStyleIndex::JoyconLeft:
+    case Core::HID::NpadStyleIndex::JoyconRight:
+    case Core::HID::NpadStyleIndex::GameCube:
+    case Core::HID::NpadStyleIndex::N64:
+    case Core::HID::NpadStyleIndex::SystemExt:
+    case Core::HID::NpadStyleIndex::System:
+        // These support vibration
+        break;
+    default:
+        return VibrationInvalidStyleIndex;
+    }
+
+    if (!IsNpadIdValid(static_cast<Core::HID::NpadIdType>(handle.npad_id))) {
+        return VibrationInvalidNpadId;
+    }
+
+    if (handle.device_index >= Core::HID::DeviceIndex::MaxDeviceIndex) {
+        return VibrationDeviceIndexOutOfRange;
+    }
+
+    return ResultSuccess;
+}
+
+/// Converts a Core::HID::NpadIdType to an array index.
+constexpr size_t NpadIdTypeToIndex(Core::HID::NpadIdType npad_id_type) {
+    switch (npad_id_type) {
+    case Core::HID::NpadIdType::Player1:
+        return 0;
+    case Core::HID::NpadIdType::Player2:
+        return 1;
+    case Core::HID::NpadIdType::Player3:
+        return 2;
+    case Core::HID::NpadIdType::Player4:
+        return 3;
+    case Core::HID::NpadIdType::Player5:
+        return 4;
+    case Core::HID::NpadIdType::Player6:
+        return 5;
+    case Core::HID::NpadIdType::Player7:
+        return 6;
+    case Core::HID::NpadIdType::Player8:
+        return 7;
+    case Core::HID::NpadIdType::Handheld:
+        return 8;
+    case Core::HID::NpadIdType::Other:
+        return 9;
+    default:
+        return 8;
+    }
+}
+
+/// Converts an array index to a Core::HID::NpadIdType
+constexpr Core::HID::NpadIdType IndexToNpadIdType(size_t index) {
+    switch (index) {
+    case 0:
+        return Core::HID::NpadIdType::Player1;
+    case 1:
+        return Core::HID::NpadIdType::Player2;
+    case 2:
+        return Core::HID::NpadIdType::Player3;
+    case 3:
+        return Core::HID::NpadIdType::Player4;
+    case 4:
+        return Core::HID::NpadIdType::Player5;
+    case 5:
+        return Core::HID::NpadIdType::Player6;
+    case 6:
+        return Core::HID::NpadIdType::Player7;
+    case 7:
+        return Core::HID::NpadIdType::Player8;
+    case 8:
+        return Core::HID::NpadIdType::Handheld;
+    case 9:
+        return Core::HID::NpadIdType::Other;
+    default:
+        return Core::HID::NpadIdType::Invalid;
+    }
+}
+
+constexpr Core::HID::NpadStyleSet GetStylesetByIndex(std::size_t index) {
+    switch (index) {
+    case 0:
+        return Core::HID::NpadStyleSet::Fullkey;
+    case 1:
+        return Core::HID::NpadStyleSet::Handheld;
+    case 2:
+        return Core::HID::NpadStyleSet::JoyDual;
+    case 3:
+        return Core::HID::NpadStyleSet::JoyLeft;
+    case 4:
+        return Core::HID::NpadStyleSet::JoyRight;
+    case 5:
+        return Core::HID::NpadStyleSet::Palma;
+    default:
+        return Core::HID::NpadStyleSet::None;
+    }
+}
+
+} // namespace Service::HID
diff --git a/src/core/hle/service/hid/irs.cpp b/src/core/hle/service/hid/irs.cpp
index d383a266d9d1..39b9a4474b8b 100644
--- a/src/core/hle/service/hid/irs.cpp
+++ b/src/core/hle/service/hid/irs.cpp
@@ -12,6 +12,7 @@
 #include "core/hle/kernel/k_transfer_memory.h"
 #include "core/hle/kernel/kernel.h"
 #include "core/hle/service/hid/errors.h"
+#include "core/hle/service/hid/hid_util.h"
 #include "core/hle/service/hid/irs.h"
 #include "core/hle/service/hid/irsensor/clustering_processor.h"
 #include "core/hle/service/hid/irsensor/image_transfer_processor.h"
@@ -320,7 +321,7 @@ void IRS::GetNpadIrCameraHandle(HLERequestContext& ctx) {
     }
 
     Core::IrSensor::IrCameraHandle camera_handle{
-        .npad_id = static_cast<u8>(NpadIdTypeToIndex(npad_id)),
+        .npad_id = static_cast<u8>(HID::NpadIdTypeToIndex(npad_id)),
         .npad_type = Core::HID::NpadStyleIndex::None,
     };
 
@@ -545,7 +546,7 @@ void IRS::ActivateIrsensorWithFunctionLevel(HLERequestContext& ctx) {
 
 Result IRS::IsIrCameraHandleValid(const Core::IrSensor::IrCameraHandle& camera_handle) const {
     if (camera_handle.npad_id >
-        static_cast<u8>(NpadIdTypeToIndex(Core::HID::NpadIdType::Handheld))) {
+        static_cast<u8>(HID::NpadIdTypeToIndex(Core::HID::NpadIdType::Handheld))) {
         return InvalidIrCameraHandle;
     }
     if (camera_handle.npad_type != Core::HID::NpadStyleIndex::None) {
diff --git a/src/core/hle/service/hid/resource_manager.cpp b/src/core/hle/service/hid/resource_manager.cpp
index d6f42c646bb9..e76d4eea98cc 100644
--- a/src/core/hle/service/hid/resource_manager.cpp
+++ b/src/core/hle/service/hid/resource_manager.cpp
@@ -9,14 +9,15 @@
 #include "core/hle/service/hid/resource_manager.h"
 #include "core/hle/service/ipc_helpers.h"
 
-#include "core/hle/service/hid/controllers/console_sixaxis.h"
-#include "core/hle/service/hid/controllers/controller_base.h"
+#include "core/hle/service/hid/controllers/console_six_axis.h"
 #include "core/hle/service/hid/controllers/debug_pad.h"
 #include "core/hle/service/hid/controllers/gesture.h"
 #include "core/hle/service/hid/controllers/keyboard.h"
 #include "core/hle/service/hid/controllers/mouse.h"
 #include "core/hle/service/hid/controllers/npad.h"
 #include "core/hle/service/hid/controllers/palma.h"
+#include "core/hle/service/hid/controllers/seven_six_axis.h"
+#include "core/hle/service/hid/controllers/six_axis.h"
 #include "core/hle/service/hid/controllers/stubbed.h"
 #include "core/hle/service/hid/controllers/touchscreen.h"
 #include "core/hle/service/hid/controllers/xpad.h"
@@ -42,76 +43,132 @@ void ResourceManager::Initialize() {
     }
 
     u8* shared_memory = system.Kernel().GetHidSharedMem().GetPointer();
-    MakeController<Controller_DebugPad>(HidController::DebugPad, shared_memory);
-    MakeController<Controller_Touchscreen>(HidController::Touchscreen, shared_memory);
-    MakeController<Controller_Mouse>(HidController::Mouse, shared_memory);
-    MakeController<Controller_Keyboard>(HidController::Keyboard, shared_memory);
-    MakeController<Controller_XPad>(HidController::XPad, shared_memory);
-    MakeController<Controller_Stubbed>(HidController::HomeButton, shared_memory);
-    MakeController<Controller_Stubbed>(HidController::SleepButton, shared_memory);
-    MakeController<Controller_Stubbed>(HidController::CaptureButton, shared_memory);
-    MakeController<Controller_Stubbed>(HidController::InputDetector, shared_memory);
-    MakeController<Controller_Stubbed>(HidController::UniquePad, shared_memory);
-    MakeControllerWithServiceContext<Controller_NPad>(HidController::NPad, shared_memory);
-    MakeController<Controller_Gesture>(HidController::Gesture, shared_memory);
-    MakeController<Controller_ConsoleSixAxis>(HidController::ConsoleSixAxisSensor, shared_memory);
-    MakeController<Controller_Stubbed>(HidController::DebugMouse, shared_memory);
-    MakeControllerWithServiceContext<Controller_Palma>(HidController::Palma, shared_memory);
+    debug_pad = std::make_shared<DebugPad>(system.HIDCore(), shared_memory);
+    mouse = std::make_shared<Mouse>(system.HIDCore(), shared_memory);
+    debug_mouse = std::make_shared<DebugMouse>(system.HIDCore(), shared_memory);
+    keyboard = std::make_shared<Keyboard>(system.HIDCore(), shared_memory);
+    unique_pad = std::make_shared<UniquePad>(system.HIDCore(), shared_memory);
+    npad = std::make_shared<NPad>(system.HIDCore(), shared_memory, service_context);
+    gesture = std::make_shared<Gesture>(system.HIDCore(), shared_memory);
+    touch_screen = std::make_shared<TouchScreen>(system.HIDCore(), shared_memory);
+    xpad = std::make_shared<XPad>(system.HIDCore(), shared_memory);
+
+    palma = std::make_shared<Palma>(system.HIDCore(), shared_memory, service_context);
+
+    home_button = std::make_shared<HomeButton>(system.HIDCore(), shared_memory);
+    sleep_button = std::make_shared<SleepButton>(system.HIDCore(), shared_memory);
+    capture_button = std::make_shared<CaptureButton>(system.HIDCore(), shared_memory);
+
+    six_axis = std::make_shared<SixAxis>(system.HIDCore(), npad);
+    console_six_axis = std::make_shared<ConsoleSixAxis>(system.HIDCore(), shared_memory);
+    seven_six_axis = std::make_shared<SevenSixAxis>(system);
+
+    home_button->SetCommonHeaderOffset(0x4C00);
+    sleep_button->SetCommonHeaderOffset(0x4E00);
+    capture_button->SetCommonHeaderOffset(0x5000);
+    unique_pad->SetCommonHeaderOffset(0x5A00);
+    debug_mouse->SetCommonHeaderOffset(0x3DC00);
 
     // Homebrew doesn't try to activate some controllers, so we activate them by default
-    GetController<Controller_NPad>(HidController::NPad).Activate();
-    GetController<Controller_Touchscreen>(HidController::Touchscreen).Activate();
-
-    GetController<Controller_Stubbed>(HidController::HomeButton).SetCommonHeaderOffset(0x4C00);
-    GetController<Controller_Stubbed>(HidController::SleepButton).SetCommonHeaderOffset(0x4E00);
-    GetController<Controller_Stubbed>(HidController::CaptureButton).SetCommonHeaderOffset(0x5000);
-    GetController<Controller_Stubbed>(HidController::InputDetector).SetCommonHeaderOffset(0x5200);
-    GetController<Controller_Stubbed>(HidController::UniquePad).SetCommonHeaderOffset(0x5A00);
-    GetController<Controller_Stubbed>(HidController::DebugMouse).SetCommonHeaderOffset(0x3DC00);
+    npad->Activate();
+    six_axis->Activate();
+    touch_screen->Activate();
 
     system.HIDCore().ReloadInputDevices();
     is_initialized = true;
 }
+std::shared_ptr<CaptureButton> ResourceManager::GetCaptureButton() const {
+    return capture_button;
+}
+
+std::shared_ptr<ConsoleSixAxis> ResourceManager::GetConsoleSixAxis() const {
+    return console_six_axis;
+}
+
+std::shared_ptr<DebugMouse> ResourceManager::GetDebugMouse() const {
+    return debug_mouse;
+}
+
+std::shared_ptr<DebugPad> ResourceManager::GetDebugPad() const {
+    return debug_pad;
+}
+
+std::shared_ptr<Gesture> ResourceManager::GetGesture() const {
+    return gesture;
+}
+
+std::shared_ptr<HomeButton> ResourceManager::GetHomeButton() const {
+    return home_button;
+}
+
+std::shared_ptr<Keyboard> ResourceManager::GetKeyboard() const {
+    return keyboard;
+}
+
+std::shared_ptr<Mouse> ResourceManager::GetMouse() const {
+    return mouse;
+}
+
+std::shared_ptr<NPad> ResourceManager::GetNpad() const {
+    return npad;
+}
+
+std::shared_ptr<Palma> ResourceManager::GetPalma() const {
+    return palma;
+}
+
+std::shared_ptr<SevenSixAxis> ResourceManager::GetSevenSixAxis() const {
+    return seven_six_axis;
+}
+
+std::shared_ptr<SixAxis> ResourceManager::GetSixAxis() const {
+    return six_axis;
+}
+
+std::shared_ptr<SleepButton> ResourceManager::GetSleepButton() const {
+    return sleep_button;
+}
+
+std::shared_ptr<TouchScreen> ResourceManager::GetTouchScreen() const {
+    return touch_screen;
+}
+
+std::shared_ptr<UniquePad> ResourceManager::GetUniquePad() const {
+    return unique_pad;
+}
 
 void ResourceManager::UpdateControllers(std::uintptr_t user_data,
                                         std::chrono::nanoseconds ns_late) {
     auto& core_timing = system.CoreTiming();
-
-    for (const auto& controller : controllers) {
-        // Keyboard has it's own update event
-        if (controller == controllers[static_cast<size_t>(HidController::Keyboard)]) {
-            continue;
-        }
-        // Mouse has it's own update event
-        if (controller == controllers[static_cast<size_t>(HidController::Mouse)]) {
-            continue;
-        }
-        // Npad has it's own update event
-        if (controller == controllers[static_cast<size_t>(HidController::NPad)]) {
-            continue;
-        }
-        controller->OnUpdate(core_timing);
-    }
+    debug_pad->OnUpdate(core_timing);
+    unique_pad->OnUpdate(core_timing);
+    gesture->OnUpdate(core_timing);
+    touch_screen->OnUpdate(core_timing);
+    palma->OnUpdate(core_timing);
+    home_button->OnUpdate(core_timing);
+    sleep_button->OnUpdate(core_timing);
+    capture_button->OnUpdate(core_timing);
+    xpad->OnUpdate(core_timing);
 }
 
 void ResourceManager::UpdateNpad(std::uintptr_t user_data, std::chrono::nanoseconds ns_late) {
     auto& core_timing = system.CoreTiming();
-
-    controllers[static_cast<size_t>(HidController::NPad)]->OnUpdate(core_timing);
+    npad->OnUpdate(core_timing);
 }
 
 void ResourceManager::UpdateMouseKeyboard(std::uintptr_t user_data,
                                           std::chrono::nanoseconds ns_late) {
     auto& core_timing = system.CoreTiming();
-
-    controllers[static_cast<size_t>(HidController::Mouse)]->OnUpdate(core_timing);
-    controllers[static_cast<size_t>(HidController::Keyboard)]->OnUpdate(core_timing);
+    mouse->OnUpdate(core_timing);
+    debug_mouse->OnUpdate(core_timing);
+    keyboard->OnUpdate(core_timing);
 }
 
 void ResourceManager::UpdateMotion(std::uintptr_t user_data, std::chrono::nanoseconds ns_late) {
     auto& core_timing = system.CoreTiming();
-
-    controllers[static_cast<size_t>(HidController::NPad)]->OnMotionUpdate(core_timing);
+    six_axis->OnUpdate(core_timing);
+    seven_six_axis->OnUpdate(core_timing);
+    console_six_axis->OnUpdate(core_timing);
 }
 
 IAppletResource::IAppletResource(Core::System& system_, std::shared_ptr<ResourceManager> resource)
diff --git a/src/core/hle/service/hid/resource_manager.h b/src/core/hle/service/hid/resource_manager.h
index 34dbf36bc2d3..2b6a9b5e63a5 100644
--- a/src/core/hle/service/hid/resource_manager.h
+++ b/src/core/hle/service/hid/resource_manager.h
@@ -3,10 +3,6 @@
 
 #pragma once
 
-#include <chrono>
-
-#include "core/core.h"
-#include "core/hle/service/hid/controllers/controller_base.h"
 #include "core/hle/service/kernel_helpers.h"
 #include "core/hle/service/service.h"
 
@@ -14,74 +10,85 @@ namespace Core::Timing {
 struct EventType;
 }
 
-namespace Core::HID {
-class HIDCore;
-}
-
 namespace Service::HID {
+class Controller_Stubbed;
+class ConsoleSixAxis;
+class DebugPad;
+class Gesture;
+class Keyboard;
+class Mouse;
+class NPad;
+class Palma;
+class SevenSixAxis;
+class SixAxis;
+class TouchScreen;
+class XPad;
+
+using CaptureButton = Controller_Stubbed;
+using DebugMouse = Controller_Stubbed;
+using HomeButton = Controller_Stubbed;
+using SleepButton = Controller_Stubbed;
+using UniquePad = Controller_Stubbed;
 
-enum class HidController : std::size_t {
-    DebugPad,
-    Touchscreen,
-    Mouse,
-    Keyboard,
-    XPad,
-    HomeButton,
-    SleepButton,
-    CaptureButton,
-    InputDetector,
-    UniquePad,
-    NPad,
-    Gesture,
-    ConsoleSixAxisSensor,
-    DebugMouse,
-    Palma,
-
-    MaxControllers,
-};
 class ResourceManager {
+
 public:
     explicit ResourceManager(Core::System& system_);
     ~ResourceManager();
 
-    template <typename T>
-    T& GetController(HidController controller) {
-        return static_cast<T&>(*controllers[static_cast<size_t>(controller)]);
-    }
-
-    template <typename T>
-    const T& GetController(HidController controller) const {
-        return static_cast<T&>(*controllers[static_cast<size_t>(controller)]);
-    }
-
     void Initialize();
 
+    std::shared_ptr<CaptureButton> GetCaptureButton() const;
+    std::shared_ptr<ConsoleSixAxis> GetConsoleSixAxis() const;
+    std::shared_ptr<DebugMouse> GetDebugMouse() const;
+    std::shared_ptr<DebugPad> GetDebugPad() const;
+    std::shared_ptr<Gesture> GetGesture() const;
+    std::shared_ptr<HomeButton> GetHomeButton() const;
+    std::shared_ptr<Keyboard> GetKeyboard() const;
+    std::shared_ptr<Mouse> GetMouse() const;
+    std::shared_ptr<NPad> GetNpad() const;
+    std::shared_ptr<Palma> GetPalma() const;
+    std::shared_ptr<SevenSixAxis> GetSevenSixAxis() const;
+    std::shared_ptr<SixAxis> GetSixAxis() const;
+    std::shared_ptr<SleepButton> GetSleepButton() const;
+    std::shared_ptr<TouchScreen> GetTouchScreen() const;
+    std::shared_ptr<UniquePad> GetUniquePad() const;
+
     void UpdateControllers(std::uintptr_t user_data, std::chrono::nanoseconds ns_late);
     void UpdateNpad(std::uintptr_t user_data, std::chrono::nanoseconds ns_late);
     void UpdateMouseKeyboard(std::uintptr_t user_data, std::chrono::nanoseconds ns_late);
     void UpdateMotion(std::uintptr_t user_data, std::chrono::nanoseconds ns_late);
 
 private:
-    template <typename T>
-    void MakeController(HidController controller, u8* shared_memory) {
-        if constexpr (std::is_constructible_v<T, Core::System&, u8*>) {
-            controllers[static_cast<std::size_t>(controller)] =
-                std::make_unique<T>(system, shared_memory);
-        } else {
-            controllers[static_cast<std::size_t>(controller)] =
-                std::make_unique<T>(system.HIDCore(), shared_memory);
-        }
-    }
-
-    template <typename T>
-    void MakeControllerWithServiceContext(HidController controller, u8* shared_memory) {
-        controllers[static_cast<std::size_t>(controller)] =
-            std::make_unique<T>(system.HIDCore(), shared_memory, service_context);
-    }
-
     bool is_initialized{false};
-    std::array<std::unique_ptr<ControllerBase>, static_cast<size_t>(HidController::MaxControllers)>
-        controllers{};
+
+    std::shared_ptr<CaptureButton> capture_button = nullptr;
+    std::shared_ptr<ConsoleSixAxis> console_six_axis = nullptr;
+    std::shared_ptr<DebugMouse> debug_mouse = nullptr;
+    std::shared_ptr<DebugPad> debug_pad = nullptr;
+    std::shared_ptr<Gesture> gesture = nullptr;
+    std::shared_ptr<HomeButton> home_button = nullptr;
+    std::shared_ptr<Keyboard> keyboard = nullptr;
+    std::shared_ptr<Mouse> mouse = nullptr;
+    std::shared_ptr<NPad> npad = nullptr;
+    std::shared_ptr<Palma> palma = nullptr;
+    std::shared_ptr<SevenSixAxis> seven_six_axis = nullptr;
+    std::shared_ptr<SixAxis> six_axis = nullptr;
+    std::shared_ptr<SleepButton> sleep_button = nullptr;
+    std::shared_ptr<TouchScreen> touch_screen = nullptr;
+    std::shared_ptr<UniquePad> unique_pad = nullptr;
+    std::shared_ptr<XPad> xpad = nullptr;
+
+    // TODO: Create these resources
+    // std::shared_ptr<AudioControl> audio_control = nullptr;
+    // std::shared_ptr<ButtonConfig> button_config = nullptr;
+    // std::shared_ptr<Config> config = nullptr;
+    // std::shared_ptr<Connection> connection = nullptr;
+    // std::shared_ptr<CustomConfig> custom_config = nullptr;
+    // std::shared_ptr<Digitizer> digitizer = nullptr;
+    // std::shared_ptr<Hdls> hdls = nullptr;
+    // std::shared_ptr<PlayReport> play_report = nullptr;
+    // std::shared_ptr<Rail> rail = nullptr;
 
     Core::System& system;
     KernelHelpers::ServiceContext service_context;
diff --git a/src/core/hle/service/nfc/common/device_manager.cpp b/src/core/hle/service/nfc/common/device_manager.cpp
index a71d26157f90..ad534177df34 100644
--- a/src/core/hle/service/nfc/common/device_manager.cpp
+++ b/src/core/hle/service/nfc/common/device_manager.cpp
@@ -7,6 +7,7 @@
 #include "core/core.h"
 #include "core/hid/hid_types.h"
 #include "core/hle/kernel/k_event.h"
+#include "core/hle/service/hid/hid_util.h"
 #include "core/hle/service/ipc_helpers.h"
 #include "core/hle/service/nfc/common/device.h"
 #include "core/hle/service/nfc/common/device_manager.h"
@@ -24,7 +25,7 @@ DeviceManager::DeviceManager(Core::System& system_, KernelHelpers::ServiceContex
 
     for (u32 device_index = 0; device_index < devices.size(); device_index++) {
         devices[device_index] =
-            std::make_shared<NfcDevice>(Core::HID::IndexToNpadIdType(device_index), system,
+            std::make_shared<NfcDevice>(HID::IndexToNpadIdType(device_index), system,
                                         service_context, availability_change_event);
     }
 
diff --git a/src/core/memory/cheat_engine.cpp b/src/core/memory/cheat_engine.cpp
index da140c01c797..db30ba598c78 100644
--- a/src/core/memory/cheat_engine.cpp
+++ b/src/core/memory/cheat_engine.cpp
@@ -68,10 +68,7 @@ u64 StandardVmCallbacks::HidKeysDown() {
         return 0;
     }
 
-    const auto press_state =
-        applet_resource
-            ->GetController<Service::HID::Controller_NPad>(Service::HID::HidController::NPad)
-            .GetAndResetPressState();
+    const auto press_state = applet_resource->GetNpad()->GetAndResetPressState();
     return static_cast<u64>(press_state & HID::NpadButton::All);
 }
 
