diff --git a/src/audio_core/renderer/adsp/audio_renderer.cpp b/src/audio_core/renderer/adsp/audio_renderer.cpp
index 503f4034966..1cbeed30290 100644
--- a/src/audio_core/renderer/adsp/audio_renderer.cpp
+++ b/src/audio_core/renderer/adsp/audio_renderer.cpp
@@ -154,6 +154,11 @@ void AudioRenderer::ThreadFunc() {
             return;
 
         case RenderMessage::AudioRenderer_Render: {
+            if (system.IsShuttingDown()) [[unlikely]] {
+                std::this_thread::sleep_for(std::chrono::milliseconds(5));
+                mailbox->ADSPSendMessage(RenderMessage::AudioRenderer_RenderResponse);
+                continue;
+            }
             std::array<bool, MaxRendererSessions> buffers_reset{};
             std::array<u64, MaxRendererSessions> render_times_taken{};
             const auto start_time{system.CoreTiming().GetClockTicks()};
diff --git a/src/audio_core/renderer/system_manager.cpp b/src/audio_core/renderer/system_manager.cpp
index 07d8ed093ef..300ecdbf131 100644
--- a/src/audio_core/renderer/system_manager.cpp
+++ b/src/audio_core/renderer/system_manager.cpp
@@ -27,7 +27,7 @@ bool SystemManager::InitializeUnsafe() {
     if (!active) {
         if (adsp.Start()) {
             active = true;
-            thread = std::jthread([this](std::stop_token stop_token) { ThreadFunc(); });
+            thread = std::jthread([this](std::stop_token stop_token) { ThreadFunc(stop_token); });
         }
     }
 
@@ -39,8 +39,7 @@ void SystemManager::Stop() {
         return;
     }
     active = false;
-    update.store(true);
-    update.notify_all();
+    thread.request_stop();
     thread.join();
     adsp.Stop();
 }
@@ -85,12 +84,12 @@ bool SystemManager::Remove(System& system_) {
     return true;
 }
 
-void SystemManager::ThreadFunc() {
+void SystemManager::ThreadFunc(std::stop_token stop_token) {
     static constexpr char name[]{"AudioRenderSystemManager"};
     MicroProfileOnThreadCreate(name);
     Common::SetCurrentThreadName(name);
     Common::SetCurrentThreadPriority(Common::ThreadPriority::High);
-    while (active) {
+    while (active && !stop_token.stop_requested()) {
         {
             std::scoped_lock l{mutex1};
 
diff --git a/src/audio_core/renderer/system_manager.h b/src/audio_core/renderer/system_manager.h
index 1f0bbd8b4c2..9681fd12192 100644
--- a/src/audio_core/renderer/system_manager.h
+++ b/src/audio_core/renderer/system_manager.h
@@ -66,13 +66,7 @@ class SystemManager {
     /**
      * Main thread responsible for command generation.
      */
-    void ThreadFunc();
-
-    enum class StreamState {
-        Filling,
-        Steady,
-        Draining,
-    };
+    void ThreadFunc(std::stop_token stop_token);
 
     /// Core system
     Core::System& core;
@@ -90,8 +84,6 @@ class SystemManager {
     ADSP::ADSP& adsp;
     /// AudioRenderer mailbox for communication
     ADSP::AudioRenderer_Mailbox* mailbox{};
-    /// Atomic for main thread to wait on
-    std::atomic<bool> update{};
 };
 
 } // namespace AudioCore::AudioRenderer
diff --git a/src/audio_core/sink/sink_stream.cpp b/src/audio_core/sink/sink_stream.cpp
index 13ba26e74db..9bbb5416258 100644
--- a/src/audio_core/sink/sink_stream.cpp
+++ b/src/audio_core/sink/sink_stream.cpp
@@ -271,8 +271,8 @@ u64 SinkStream::GetExpectedPlayedSampleCount() {
 
 void SinkStream::WaitFreeSpace() {
     std::unique_lock lk{release_mutex};
-    release_cv.wait(
-        lk, [this]() { return queued_buffers < max_queue_size || system.IsShuttingDown(); });
+    release_cv.wait_for(lk, std::chrono::milliseconds(5),
+                        [this]() { return queued_buffers < max_queue_size; });
 }
 
 } // namespace AudioCore::Sink
