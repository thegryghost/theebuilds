diff --git a/src/core/hle/service/nvnflinger/buffer_queue_core.cpp b/src/core/hle/service/nvnflinger/buffer_queue_core.cpp
index 2dbe296168ab..ed66f6f5b13b 100644
--- a/src/core/hle/service/nvnflinger/buffer_queue_core.cpp
+++ b/src/core/hle/service/nvnflinger/buffer_queue_core.cpp
@@ -41,7 +41,7 @@ bool BufferQueueCore::WaitForDequeueCondition(std::unique_lock<std::mutex>& lk)
 s32 BufferQueueCore::GetMinUndequeuedBufferCountLocked(bool async) const {
     // If DequeueBuffer is allowed to error out, we don't have to add an extra buffer.
     if (!use_async_buffer) {
-        return max_acquired_buffer_count;
+        return 0;
     }
 
     if (dequeue_buffer_cannot_block || async) {
@@ -52,7 +52,7 @@ s32 BufferQueueCore::GetMinUndequeuedBufferCountLocked(bool async) const {
 }
 
 s32 BufferQueueCore::GetMinMaxBufferCountLocked(bool async) const {
-    return GetMinUndequeuedBufferCountLocked(async) + 1;
+    return GetMinUndequeuedBufferCountLocked(async);
 }
 
 s32 BufferQueueCore::GetMaxBufferCountLocked(bool async) const {
@@ -61,7 +61,7 @@ s32 BufferQueueCore::GetMaxBufferCountLocked(bool async) const {
 
     if (override_max_buffer_count != 0) {
         ASSERT(override_max_buffer_count >= min_buffer_count);
-        max_buffer_count = override_max_buffer_count;
+        return override_max_buffer_count;
     }
 
     // Any buffers that are dequeued by the producer or sitting in the queue waiting to be consumed
diff --git a/src/core/hle/service/nvnflinger/buffer_queue_producer.cpp b/src/core/hle/service/nvnflinger/buffer_queue_producer.cpp
index dc6917d5db44..6e7a49658943 100644
--- a/src/core/hle/service/nvnflinger/buffer_queue_producer.cpp
+++ b/src/core/hle/service/nvnflinger/buffer_queue_producer.cpp
@@ -134,7 +134,7 @@ Status BufferQueueProducer::WaitForFreeSlotThenRelock(bool async, s32* found, St
         const s32 max_buffer_count = core->GetMaxBufferCountLocked(async);
         if (async && core->override_max_buffer_count) {
             if (core->override_max_buffer_count < max_buffer_count) {
-                LOG_ERROR(Service_Nvnflinger, "async mode is invalid with buffer count override");
+                *found = BufferQueueCore::INVALID_BUFFER_SLOT;
                 return Status::BadValue;
             }
         }
@@ -142,7 +142,8 @@ Status BufferQueueProducer::WaitForFreeSlotThenRelock(bool async, s32* found, St
         // Free up any buffers that are in slots beyond the max buffer count
         for (s32 s = max_buffer_count; s < BufferQueueDefs::NUM_BUFFER_SLOTS; ++s) {
             ASSERT(slots[s].buffer_state == BufferState::Free);
-            if (slots[s].graphic_buffer != nullptr) {
+            if (slots[s].graphic_buffer != nullptr && slots[s].buffer_state == BufferState::Free &&
+                !slots[s].is_preallocated) {
                 core->FreeBufferLocked(s);
                 *return_flags |= Status::ReleaseAllBuffers;
             }
