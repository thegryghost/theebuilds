diff -Naur mplayer-1.0_rc4_p20120109/cfg-common.h mplayer-1.0_rc4_p20120109-new/cfg-common.h
--- mplayer-1.0_rc4_p20120109/cfg-common.h	2012-01-09 14:47:06.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/cfg-common.h	2012-01-16 15:51:41.000000000 +0100
@@ -523,6 +523,7 @@
     {"vfm", &video_fm_list, CONF_TYPE_STRING_LIST, 0, 0, 0, NULL},
     {"ac", &audio_codec_list, CONF_TYPE_STRING_LIST, 0, 0, 0, NULL},
     {"vc", &video_codec_list, CONF_TYPE_STRING_LIST, 0, 0, 0, NULL},
+    {"va", &video_hwaccel_name, CONF_TYPE_STRING, 0, 0, 0, NULL},
 
     // postprocessing:
 #ifdef CONFIG_FFMPEG
diff -Naur mplayer-1.0_rc4_p20120109/codec-cfg.c mplayer-1.0_rc4_p20120109-new/codec-cfg.c
--- mplayer-1.0_rc4_p20120109/codec-cfg.c	2012-01-09 14:46:49.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/codec-cfg.c	2012-01-16 15:51:41.000000000 +0100
@@ -231,6 +231,13 @@
     {"VDPAU_VC1",   IMGFMT_VDPAU_VC1},
     {"VDPAU_MPEG4", IMGFMT_VDPAU_MPEG4},
 
+    {"VAAPI_MPEG2", IMGFMT_VAAPI_MPEG2},
+    {"VAAPI_MPEG4", IMGFMT_VAAPI_MPEG4},
+    {"VAAPI_H263",  IMGFMT_VAAPI_H263},
+    {"VAAPI_H264",  IMGFMT_VAAPI_H264},
+    {"VAAPI_WMV3",  IMGFMT_VAAPI_WMV3},
+    {"VAAPI_VC1",   IMGFMT_VAAPI_VC1},
+
     {NULL,    0}
 };
 
diff -Naur mplayer-1.0_rc4_p20120109/configure mplayer-1.0_rc4_p20120109-new/configure
--- mplayer-1.0_rc4_p20120109/configure	2012-01-09 14:46:57.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/configure	2012-01-16 15:51:41.000000000 +0100
@@ -50,12 +50,13 @@
 if ! test -e ffmpeg ; then
     echo "No FFmpeg checkout, press enter to download one with git or CTRL+C to abort"
     read tmp
-    if ! git clone --depth 1 git://git.videolan.org/ffmpeg.git ffmpeg ; then
+    if ! git clone git://git.videolan.org/ffmpeg.git ffmpeg ; then
         rm -rf ffmpeg
         echo "Failed to get a FFmpeg checkout"
         exit 1
     fi
-    touch ffmpeg/mp_auto_pull
+    ffrevision=fc09bf57a60d4c4a6d339b204b3282337067c06d
+    cd ffmpeg && git checkout $ffrevision && cd ..
 fi
 
 # Prevent locale nonsense from breaking basic text processing utilities
@@ -389,6 +390,7 @@
   --disable-vstream      disable TiVo vstream client support [autodetect]
   --disable-pthreads     disable Posix threads support [autodetect]
   --disable-w32threads   disable Win32 threads support [autodetect]
+  --disable-os2threads   disable OS/2 threads support [autodetect]
   --enable-ass-internal  enable internal SSA/ASS subtitle support [autodetect]
   --disable-ass          disable SSA/ASS subtitle support [autodetect]
   --enable-rpath         enable runtime linker path for extra libs [disabled]
@@ -461,6 +463,9 @@
   --disable-muxer=MUXER     disable specified FFmpeg muxer
   --enable-muxer=MUXER      enable specified FFmpeg muxer
 
+Hardware acceleration:
+  --enable-vaapi            enable VA-API acceleration [disable]
+
 Video output:
   --disable-vidix          disable VIDIX [for x86 *nix]
   --with-vidix-drivers[=*] list of VIDIX drivers to be compiled in
@@ -490,6 +495,7 @@
   --enable-dvb             enable DVB video output [autodetect]
   --enable-mga             enable mga_vid video output [autodetect]
   --enable-xmga            enable mga_vid X11 video output [autodetect]
+  --enable-xrender	   enable Xrender video output [autodetect]
   --enable-xv              enable Xv video output [autodetect]
   --enable-xvmc            enable XvMC acceleration [disable]
   --enable-vdpau           enable VDPAU acceleration [autodetect]
@@ -597,6 +603,7 @@
   --extra-libs-mencoder=FLAGS extra linker flags for MEncoder
   --with-xvmclib=NAME         adapter-specific library name (e.g. XvMCNVIDIA)
 
+  --with-vaapi-prefix=PATH    prefix to VA-API include and lib directories
   --with-freetype-config=PATH path to freetype-config
   --with-glib-config=PATH     path to glib*-config
   --with-gtk-config=PATH      path to gtk*-config
@@ -663,8 +670,7 @@
 libavbsfs_all=$(sed -n 's/^[^#]*BSF.*(.*, *\(.*\)).*/\1_bsf/p' ffmpeg/libavcodec/allcodecs.c | tr '[a-z]' '[A-Z]')
 libavbsfs=$libavbsfs_all
 libavhwaccels_all=$(sed -n 's/^[^#]*HWACCEL.*(.*, *\(.*\)).*/\1_hwaccel/p' ffmpeg/libavcodec/allcodecs.c | tr '[a-z]' '[A-Z]')
-# Disable all hardware accelerators for now.
-libavhwaccels=
+libavhwaccels=$(for h in $libavhwaccels_all; do case $h in (*_VAAPI_HWACCEL) echo $h;; esac; done)
 libavdemuxers_all=$(sed -n 's/^[^#]*DEMUX.*(.*, *\(.*\)).*/\1_demuxer/p' ffmpeg/libavformat/allformats.c | tr '[a-z]' '[A-Z]')
 libavdemuxers=$(echo $libavdemuxers_all | sed -e 's/ LIB[A-Z0-9_]*_DEMUXER//g' -e s/REDIR_DEMUXER// -e s/AVISYNTH_DEMUXER//)
 libavmuxers_all=$(sed -n 's/^[^#]*_MUX.*(.*, *\(.*\)).*/\1_muxer/p' ffmpeg/libavformat/allformats.c | tr '[a-z]' '[A-Z]')
@@ -676,11 +682,15 @@
 libavfilters=$(echo $libavfilters_all | sed -e 's/ LIB[A-Z0-9_]*_FILTER//g' -e 's/ FREI0R[A-Z0-9_]*_FILTER//g' -e 's/ OCV_FILTER//g' -e 's/ MP_FILTER//g')
 _mencoder=yes
 _mplayer=yes
+_vaapi=auto
+_vaapi_glx=no
+_libgtop=auto
 _x11=auto
 _xshape=auto
 _xss=auto
 _dga1=auto
 _dga2=auto
+_xrender=auto
 _xv=auto
 _xvmc=no  #auto when complete
 _vdpau=auto
@@ -858,6 +868,7 @@
 _vstream=auto
 _pthreads=auto
 _w32threads=auto
+_os2threads=auto
 _ass=auto
 ass_internal=auto
 _rpath=no
@@ -903,6 +914,9 @@
     _xvmclib=$(echo $ac_option | cut -d '=' -f 2)
     ;;
 
+  --with-vaapi-prefix=*)
+    _vaapiprefix=$(echo $ac_option | cut -d '=' -f 2)
+    ;;
   --with-sdl-config=*)
     _sdlconfig=$(echo $ac_option | cut -d '=' -f 2)
     ;;
@@ -1018,10 +1032,14 @@
   --disable-xshape)     _xshape=no      ;;
   --enable-xss)         _xss=yes        ;;
   --disable-xss)        _xss=no         ;;
+  --enable-xrender)     _xrender=yes    ;;
+  --disable-xrender)    _xrender=no     ;;
   --enable-xv)          _xv=yes         ;;
   --disable-xv)         _xv=no          ;;
   --enable-xvmc)        _xvmc=yes       ;;
   --disable-xvmc)       _xvmc=no        ;;
+  --enable-vaapi)       _vaapi=yes      ;;
+  --disable-vaapi)      _vaapi=no       ;;
   --enable-vdpau)       _vdpau=yes      ;;
   --disable-vdpau)      _vdpau=no       ;;
   --enable-sdl)         _sdl=yes        ;;
@@ -1116,6 +1134,8 @@
   --disable-twolame)    _twolame=no     ;;
   --enable-libcdio)     _libcdio=yes    ;;
   --disable-libcdio)    _libcdio=no     ;;
+  --enable-libgtop)     _libgtop=yes    ;;
+  --disable-libgtop)    _libgtop=no     ;;
   --enable-liblzo)      _liblzo=yes     ;;
   --disable-liblzo)     _liblzo=no      ;;
   --enable-libvorbis)   _libvorbis=yes  ;;
@@ -1351,6 +1371,8 @@
   --disable-pthreads)   _pthreads=no    ;;
   --enable-w32threads)  _w32threads=yes ;;
   --disable-w32threads) _w32threads=no  ;;
+  --enable-os2threads)  _os2threads=yes ;;
+  --disable-os2threads) _os2threads=no  ;;
   --enable-ass)         _ass=yes        ;;
   --disable-ass)        _ass=no         ;;
   --enable-ass-internal)  ass_internal=yes ;;
@@ -3560,6 +3582,7 @@
 def_threads='#define HAVE_THREADS 0'
 def_pthreads='#define HAVE_PTHREADS 0'
 def_w32threads='#define HAVE_W32THREADS 0'
+def_os2threads='#define HAVE_OS2THREADS 0'
 
 echocheck "pthread"
 if linux ; then
@@ -3615,6 +3638,20 @@
 test "$_w32threads" = yes && def_threads='#define HAVE_THREADS 1' && def_w32threads='#define HAVE_W32THREADS 1'
 echores "$_w32threads"
 
+if os2 ; then
+echocheck "os2threads"
+if test "$_pthreads" = yes ; then
+  res_comment="using pthread instead"
+  _os2threads=no
+fi
+if test "$_os2threads" = auto ; then
+  _os2threads=no
+  os2 && _os2threads=yes
+fi
+test "$_os2threads" = yes && def_threads='#define HAVE_THREADS 1' && def_os2threads='#define HAVE_OS2THREADS 1'
+echores "$_os2threads"
+fi #if os2
+
 echocheck "rpath"
 if test "$_rpath" = yes ; then
   for I in $(echo $extra_ldflags | sed 's/-L//g') ; do
@@ -3888,6 +3925,28 @@
 echores "$gettimeofday"
 
 
+echocheck "clock_gettime()"
+cat > $TMPC << EOF
+#include <time.h>
+int main(void) {
+    struct timespec t;
+    clock_gettime(CLOCK_REALTIME, &t);
+    return 0;
+}
+EOF
+_clock_gettime=no
+cc_check -lrt && _clock_gettime=yes
+if test "$_clock_gettime" = yes ; then
+  def_clock_gettime='#define HAVE_CLOCK_GETTIME 1'
+  extra_ldflags="$extra_ldflags -lrt"
+  _need_clock_gettime=no
+else
+  def_clock_gettime='#undef HAVE_CLOCK_GETTIME'
+  _need_clock_gettime=yes
+fi
+echores "$_clock_gettime"
+
+
 echocheck "glob()"
 # glob_win disables a Windows-specific glob() replacement.
 glob=yes
@@ -4296,6 +4355,30 @@
 fi
 
 
+echocheck "Xrender"
+if test "$_xrender" = auto ; then
+  cat > $TMPC <<EOF
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrender.h>
+int main(void) {
+  (void) XRenderCreatePicture(0, 0, 0, 0, 0);
+  return 0; }
+EOF
+  _xrender=no
+  cc_check -lXrender && _xrender=yes
+fi
+
+if test "$_xrender" = yes ; then
+  def_xrender='#define CONFIG_XRENDER 1'
+  libs_mplayer="$libs_mplayer -lXrender"
+  vomodules="xrender $vomodules"
+else
+  def_xrender='#undef CONFIG_XRENDER'
+  novomodules="xrender $novomodules"
+fi
+echores "$_xrender"
+
+
 echocheck "Xv"
 if test "$_xv" = auto && test "$_x11" = yes ; then
   _xv=no
@@ -4353,7 +4436,6 @@
   def_vdpau='#define CONFIG_VDPAU 1'
   libs_mplayer="$libs_mplayer -lvdpau"
   vomodules="vdpau $vomodules"
-  libavhwaccels="MPEG1_VDPAU_HWACCEL MPEG2_VDPAU_HWACCEL"
 else
   def_vdpau='#define CONFIG_VDPAU 0'
   novomodules="vdpau $novomodules"
@@ -4776,6 +4858,31 @@
 fi #if darwin
 
 
+echocheck "libgtop"
+if test "$_libgtop" = auto ; then
+  _libgtop=no
+  if $_pkg_config --exists 'libgtop-2.0' ; then
+
+cat > $TMPC << EOF
+#include <glibtop/cpu.h>
+#include <glibtop/proctime.h>
+int main(void) { return 0; }
+EOF
+cc_check $($_pkg_config --libs --cflags libgtop-2.0) && tmp_run && _libgtop=yes
+
+  fi
+fi
+echores "$_libgtop"
+
+if test "$_libgtop" = yes ; then
+  def_libgtop='#define CONFIG_LIBGTOP 1'
+  libs_mplayer="$libs_mplayer $($_pkg_config --libs libgtop-2.0)"
+  extra_cflags="$extra_cflags $($_pkg_config --cflags libgtop-2.0)"
+else
+  def_libgtop='#define CONFIG_LIBGTOP 0'
+fi
+
+
 echocheck "PNG support"
 if test "$_png" = auto ; then
   _png=no
@@ -5156,6 +5263,23 @@
 fi
 echores "$_gl"
 
+echocheck "OpenGL utilities (GLU)"
+_glu=no
+if test "$_gl" = yes; then
+  cat > $TMPC << EOF
+#include <GL/glu.h>
+int main(void) {
+  gluPerspective(0.0, 0.0, 0.0, 0.0);
+  return 0;
+}
+EOF
+  cc_check -lGLU && _glu=yes
+fi
+if test "$_glu" = yes; then
+  libs_mplayer="$libs_mplayer -lGLU"
+fi
+echores "$_glu"
+
 
 echocheck "MatrixView"
 if test "$matrixview" = auto ; then
@@ -5630,6 +5754,57 @@
 fi #if os2
 
 
+#########################
+# HARDWARE ACCELERATORS #
+#########################
+
+echocheck "VA-API"
+if test -n "$_vaapiprefix"; then
+  _vaapiinc="-I$_vaapiprefix/include"
+  _vaapilib="-L$_vaapiprefix/lib"
+fi
+if test "$_vaapi" = yes -o "$_vaapi" = auto; then
+  _vaapi=no
+  cat > $TMPC <<EOF
+#include <va/va_x11.h>
+int main(void) { (void) vaGetDisplay(0); return 0; }
+EOF
+  cc_check $_vaapiinc $_vaapilib -lva-x11 -lva && _vaapi=yes
+fi
+
+if test "$_vaapi" = yes ; then
+  def_vaapi='#define CONFIG_VAAPI 1'
+  extra_cflags="$extra_cflags $_vaapiinc"
+  libs_mencoder="$libs_mencoder $_vaapilib -lva"
+  libs_mplayer="$libs_mplayer $_vaapilib -lva-x11 -lva"
+  vomodules="vaapi $vomodules"
+else
+  def_vaapi='#define CONFIG_VAAPI 0'
+  novomodules="vaapi $novomodules"
+  libavhwaccels=`echo $libavhwaccels | sed -e "s/\(MPEG[124]\|H26[34]\|WMV3\|VC1\)_VAAPI_HWACCEL//g"`
+fi
+echores "$_vaapi"
+
+echocheck "VA-API (with GLX support)"
+if test "$_vaapi" = yes; then
+  _vaapi_glx=no
+  if test "$_gl" = "yes" -a "$_glu" = yes; then
+    cat > $TMPC <<EOF
+#include <va/va_glx.h>
+int main(void) { (void) vaGetDisplayGLX(0); return 0; }
+EOF
+    cc_check $_vaapiinc $_vaapilib -lva-glx -lva && _vaapi_glx=yes
+  fi
+fi
+if test "$_vaapi_glx" = yes; then
+  def_vaapi_glx='#define CONFIG_VAAPI_GLX 1'
+  libs_mplayer="$libs_mplayer -lva-glx -lva"
+else
+  def_vaapi_glx='#define CONFIG_VAAPI_GLX 0'
+fi
+echores "$_vaapi_glx"
+
+
 # set default CD/DVD devices
 if win32 || os2 ; then
   default_cdrom_device="D:"
@@ -8088,6 +8263,7 @@
 TWOLAME=$_twolame
 UNRAR_EXEC = $_unrar_exec
 V4L2 = $_v4l2
+VAAPI = $_vaapi
 VCD = $_vcd
 VDPAU = $_vdpau
 VESA = $_vesa
@@ -8194,12 +8370,15 @@
 CONFIG_MUXERS   = yes
 CONFIG_NETWORK  = $networking
 CONFIG_RTPDEC   = $networking
+CONFIG_VAAPI    = $_vaapi
 CONFIG_VF_LAVFI = $_vf_lavfi
 CONFIG_VDPAU    = $_vdpau
+CONFIG_XRENDER	= $_xrender
 CONFIG_XVMC     = $_xvmc
 CONFIG_ZLIB     = $_zlib
 
 HAVE_GNU_AS     = $gnu_as
+HAVE_OS2THREADS = $_os2threads
 HAVE_PTHREADS   = $_pthreads
 HAVE_SHM        = $_shm
 HAVE_W32THREADS = $_w32threads
@@ -8310,6 +8489,7 @@
 
 
 /* system functions */
+$def_clock_gettime
 $def_gethostbyname2
 $def_gettimeofday
 $def_glob
@@ -8339,6 +8519,7 @@
 $def_extern_prefix
 $def_iconv
 $def_kstat
+$def_libgtop
 $def_macosx_bundle
 $def_macosx_finder
 $def_maemo
@@ -8567,6 +8748,8 @@
 $def_tdfxvid
 $def_tga
 $def_v4l2
+$def_vaapi
+$def_vaapi_glx
 $def_vdpau
 $def_vesa
 $def_vidix
@@ -8592,6 +8775,7 @@
 $def_xinerama
 $def_xmga
 $def_xss
+$def_xrender
 $def_xv
 $def_xvmc
 $def_xvr100
@@ -8635,6 +8819,7 @@
 $def_mkstemp
 $def_mmap
 $def_network
+$def_os2threads
 $def_pic
 $def_poll_h
 $def_posix_memalign
@@ -8677,7 +8862,6 @@
 #define HAVE_LDBRX 0
 #define HAVE_LOCALTIME_R 0
 #define HAVE_MAPVIEWOFFILE 0
-#define HAVE_OS2THREADS 0
 #define HAVE_PPC4XX 0
 #define HAVE_STRERROR_R 0
 #define HAVE_STRPTIME 0
diff -Naur mplayer-1.0_rc4_p20120109/Copyright mplayer-1.0_rc4_p20120109-new/Copyright
--- mplayer-1.0_rc4_p20120109/Copyright	2012-01-09 14:46:50.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/Copyright	2012-01-16 15:51:41.000000000 +0100
@@ -178,3 +178,10 @@
 Copyright:  2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>
             2009 Grigori Goronzy <greg@geekmind.org>
 License:    GNU General Public License
+
+Name:       Icons
+Version:    2012-01-07
+URL:        http://www.andreasn.se
+Directory:  etc/
+Copyright:  Andreas Nilsson <andreas@andreasn.se>
+License:    GNU General Public License
diff -Naur mplayer-1.0_rc4_p20120109/debian/rules mplayer-1.0_rc4_p20120109-new/debian/rules
--- mplayer-1.0_rc4_p20120109/debian/rules	2012-01-09 14:46:44.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/debian/rules	2012-01-16 15:51:41.000000000 +0100
@@ -121,8 +121,18 @@
 	install -D -m 755 mplayer $(CURDIR)/debian/mplayer-gui/usr/bin/gmplayer
 	install -D -m 644 etc/mplayer.desktop \
 	                  $(CURDIR)/debian/mplayer-gui/usr/share/applications/mplayer.desktop
-	install -D -m 644 etc/mplayer.png \
-	                  $(CURDIR)/debian/mplayer-gui/usr/share/pixmaps/mplayer.png
+	install -D -m 644 etc/mplayer16x16.png \
+	                  $(CURDIR)/debian/mplayer-gui/usr/share/icons/hicolor/16x16/apps/mplayer.png
+	install -D -m 644 etc/mplayer22x22.png \
+	                  $(CURDIR)/debian/mplayer-gui/usr/share/icons/hicolor/22x22/apps/mplayer.png
+	install -D -m 644 etc/mplayer24x24.png \
+	                  $(CURDIR)/debian/mplayer-gui/usr/share/icons/hicolor/24x24/apps/mplayer.png
+	install -D -m 644 etc/mplayer32x32.png \
+	                  $(CURDIR)/debian/mplayer-gui/usr/share/icons/hicolor/32x32/apps/mplayer.png
+	install -D -m 644 etc/mplayer48x48.png \
+	                  $(CURDIR)/debian/mplayer-gui/usr/share/icons/hicolor/48x48/apps/mplayer.png
+	install -D -m 644 etc/mplayer256x256.png \
+	                  $(CURDIR)/debian/mplayer-gui/usr/share/icons/hicolor/256x256/apps/mplayer.png
 
 
 # binaries already installed via build rules as we have to build several flavors
diff -Naur mplayer-1.0_rc4_p20120109/DOCS/xml/de/skin.xml mplayer-1.0_rc4_p20120109-new/DOCS/xml/de/skin.xml
--- mplayer-1.0_rc4_p20120109/DOCS/xml/de/skin.xml	2012-01-09 14:46:59.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/DOCS/xml/de/skin.xml	2012-01-16 15:51:41.000000000 +0100
@@ -1301,6 +1301,15 @@
       </varlistentry>
 
       <varlistentry>
+        <term><emphasis role="bold">evMenu</emphasis></term>
+        <listitem>
+          <para>
+            Ã–ffne das (Standard-)MenÃ¼.
+          </para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term><emphasis role="bold">evIconify</emphasis></term>
         <listitem>
           <para>
diff -Naur mplayer-1.0_rc4_p20120109/DOCS/xml/en/skin.xml mplayer-1.0_rc4_p20120109-new/DOCS/xml/en/skin.xml
--- mplayer-1.0_rc4_p20120109/DOCS/xml/en/skin.xml	2012-01-09 14:46:57.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/DOCS/xml/en/skin.xml	2012-01-16 15:51:41.000000000 +0100
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<!-- $Revision: 34475 $ -->
+<!-- $Revision: 34546 $ -->
 <appendix id="skin">
 <title><application>MPlayer</application> skin format</title>
 
@@ -1100,6 +1100,13 @@
   </para></listitem>
 </varlistentry>
 
+<varlistentry>
+  <term><emphasis role="bold">evMenu</emphasis></term>
+  <listitem><para>
+  Open the (default) menu.
+  </para></listitem>
+</varlistentry>
+
 <varlistentry>
   <term><emphasis role="bold">evIconify</emphasis></term>
   <listitem><para>
diff -Naur mplayer-1.0_rc4_p20120109/etc/codecs.conf mplayer-1.0_rc4_p20120109-new/etc/codecs.conf
--- mplayer-1.0_rc4_p20120109/etc/codecs.conf	2012-01-09 14:47:11.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/etc/codecs.conf	2012-01-16 15:51:41.000000000 +0100
@@ -271,6 +271,7 @@
   fourcc MPEG
   fourcc m1v1
   fourcc "m1v "
+  fourcc BW10
   driver ffmpeg
   dll "mpeg1video"
   out YV12,I420,IYUV
@@ -310,6 +311,7 @@
   fourcc slif ; SoftLab MPEG-2 I-frames Codec
   driver ffmpeg
   dll "mpeg2video"
+  out VAAPI_MPEG2
   out YV12,I420,IYUV
   out 422P,444P
   out IDCT_MPEG2
@@ -578,7 +580,7 @@
   fourcc "tiff" ; for TIFF-encoded QuickTime files
   driver ffmpeg
   dll tiff
-  out BGR32,BGR24,BGR8,Y800,RGB32,RGB24,RGB8
+  out BGR32,BGR24,BGR8,Y800,RGB48BE,RGB48LE,RGB32,RGB24,RGB8
 
 videocodec ffpcx
   info "FFmpeg PCX"
@@ -1106,6 +1108,7 @@
   fourcc WMV3,wmv3
   driver ffmpeg
   dll wmv3
+  out VAAPI_WMV3
   out YV12,I420,IYUV
 
 videocodec ffwvp2
@@ -1147,6 +1150,7 @@
   fourcc vc-1,VC-1
   driver ffmpeg
   dll vc1
+  out VAAPI_VC1
   out YV12,I420,IYUV
 
 videocodec ffvc1vdpau
@@ -1188,6 +1192,7 @@
   out 422P,422P10
   out 444P,444P9,444P10
   out GBR24P
+  out VAAPI_H264
 
 videocodec ffh264vdpau
   info "FFmpeg H.264 (VDPAU)"
@@ -1225,8 +1230,9 @@
   dll h264_crystalhd
   out YUY2
 
+;http://corecodec.org/
 videocodec coreavcwindows
-  info "CoreAVC H.264 for x86 - http://corecodec.org/"
+  info "CoreAVC H.264 for x86"
   comment "this codec will only work after purchasing it"
   status working
   fourcc H264,h264
@@ -1287,6 +1293,7 @@
   fourcc QMP4
   driver ffmpeg
   dll mpeg4 ;opendivx
+  out VAAPI_MPEG4
   out YV12,I420,IYUV
 
 videocodec ffodivxvdpau
@@ -1936,6 +1943,7 @@
   fourcc VX1K     ; Agora Labs VX1000S H263
   driver ffmpeg
   dll h263
+  out VAAPI_H263
   out YV12,I420,IYUV
 
 videocodec ffzygo
@@ -2351,9 +2359,10 @@
   dll lagarith
   out YV12
 
+;http://lags.leetcode.net/codec.html
 videocodec lagarith
   info "Lagarith Lossless Video Codec"
-  comment "http://lags.leetcode.net/codec.html, requires an MMX2 CPU."
+  comment "requires an MMX2 CPU."
   status working
   fourcc LAGS
   driver vfw
@@ -2368,9 +2377,9 @@
   dll utvideo
   out YV12,422P,RGB24,RGB32
 
+ ;http://umezawa.dyndns.info/wordpress/
 videocodec utvideovfw
   info "UTVideo Codec"
-  comment "http://umezawa.dyndns.info/wordpress/"
   status working
   fourcc ULRA,ULRG,ULY2,ULY0
   driver vfw
@@ -2379,9 +2388,9 @@
   out RGB32,RGB24 flip
   out YV12,UYVY,YUY2 flip
 
+ ;http://umezawa.dyndns.info/wordpress/
 videocodec utvideodmo
   info "UTVideo Codec"
-  comment "http://umezawa.dyndns.info/wordpress/"
   status buggy ; input format not accepted
   fourcc ULRA,ULRG,ULY2,ULY0
   driver dmo
@@ -2407,8 +2416,8 @@
   dll "psiv.dll"
   out BGR32,BGR24 query,flip
 
+;http://www.midivid.com/codec/download.html
 videocodec midivid1
-  info "http://www.midivid.com/codec/download.html"
   status working
   fourcc MVLZ
   driver vfw
@@ -2416,7 +2425,6 @@
   out BGR24,BGR16 flip
 
 videocodec midivid2
-  info "http://www.midivid.com/codec/download.html"
   status working
   fourcc MVDV
   driver vfw
@@ -2424,7 +2432,6 @@
   out BGR24 flip
 
 videocodec midivid3
-  info "www.midivid.com/codec/mv3codec.html"
   status working
   fourcc MV30
   driver vfw
@@ -5178,10 +5185,10 @@
   driver ffmpeg
   dll "imc"
 
+ ;driver at http://codeczone.virtualave.net/FXIMCAUD.zip
 audiocodec imc
   info "Intel Music Coder"
   status working
-  comment "driver at http://codeczone.virtualave.net/FXIMCAUD.zip"
   format 0x401
   driver acm
   dll "imc32.acm"
diff -Naur mplayer-1.0_rc4_p20120109/etc/mplayer16x16.png mplayer-1.0_rc4_p20120109-new/etc/mplayer16x16.png
--- mplayer-1.0_rc4_p20120109/etc/mplayer16x16.png	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/etc/mplayer16x16.png	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,8 @@
+‰PNG
+
+   IHDR         óÿa   sBIT|dˆ   	pHYs  ×  ×B(›x   tEXtSoftware www.inkscape.org›î<   tEXtTitle Firewall®®   tEXtAuthor Lapo Calamandreiß‘*  ÊIDAT8}‘MhœU†Ÿ¹÷›é$ãO“è’¨‰B-N]X©QTjE
+ÆÆ ±ˆ]táÆ•!±YéF´
+‚…â"‹Z4H‚?!!ˆicÕcÃd©­˜ßÎß÷İ{Ïq1ÓQT|6÷Â=ïû¸©çMwYcG‘=”İaÒ*Š(„ ¸ ø 8'8/ø $>Ps’¸ WK¼µdí{ßÛ=´w÷­6“¶¨‚¢¨€ ¨Ö¥Q¬ª”k¾ezî—f¿ûU£¹ÌS:íz9aí÷
+5W7ù Q\ãî‚à¼YèÜ™å`ÿöÌùKÏE7îH·d,ÕõÀÛrô´e€º	Uš§¢,\*3»´Å]9lŠt”8Oe»â›áíRÌ_YZY#qŞî›yfÿİ´İ”¥ĞÓÊô…z¡L©š¨B9ö¨*[×ª?=GOg#GğÚKOĞ×}ÇNœam³J
+¢(Š³]©¹@%¨*ã_ıÌ#÷õqğ¡]¼óÖ›yzÿ=<ùèn>üì{T'Bâ„8ö˜ŠWu³œ°v-FD8·¸Êƒ{n`rr’ÁÁA¦¦¦xìş;9·pU¥ª.P‹c¢­­
+ÛUÏo5Bğ,,_Áù @±X¤££ƒr¹LÂÕõªJì…Ä£*x/\g_¡‹‰™E ˜ŸŸgxx˜‰™EöºšsŞªBõ?¾Î+‡ûyñõ	 Ş}ÿ$ø`|“Ÿelt¨9WÏ(€Ú|È·çâíSsœøä›æVc£CäÛsmĞÈD ¢ËZ¾])±·÷òí9Şxùqş‰çWJä²i8#cR‰s.êÍ·òå…ÆÏşñ¯àßiÍZúò­ˆŒI%‘±æÔôìÅ#‡ÒÏöwcŒi¸ş‹¨²¼ºÉç3½ìGQ¨¤F~Z¾ÂK«‡E4ó¿úÖ¤cÍéD’‘?4–‚RØ	    IEND®B`‚
\ Brak znaku nowej linii na koÅ„cu pliku
diff -Naur mplayer-1.0_rc4_p20120109/etc/mplayer22x22.png mplayer-1.0_rc4_p20120109-new/etc/mplayer22x22.png
--- mplayer-1.0_rc4_p20120109/etc/mplayer22x22.png	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/etc/mplayer22x22.png	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,7 @@
+‰PNG
+
+   IHDR         Ä´l;   sBIT|dˆ   	pHYs  ×  ×B(›x   tEXtSoftware www.inkscape.org›î<   tEXtTitle Firewall®®   tEXtAuthor Lapo Calamandreiß‘*  ˆIDAT8•Yl”U€¿ûÏtÚN[¨-t-¶ÚÒ Ø``ªÄ•¤ &šˆ¤Q|ğTHiŒ1QA|<øRÁD›BB±˜PQ)­Š,º©tßè´3ıç¿÷¦L)‹z’;÷œ/çåşª¢¢‚ÿ#W&æ%GupŸÂÙv1¢´äí¯¨¸`dï¿WÑĞpZí<p&x·î|}İ‹VÜC¤”d_rzP9~¢Soå”İZ;±âõm>yiº¢b‹Üí£îD¼øéıi‰û!V½ê8*D¬eD”1V#cÑVĞÚâ‹§ãyŠj{tZûŞ[Ğs8<'âùIòAa^ÆîÒâlRb‚ BìB¬;óm-ˆ¾Ép4ıÔù®=¯Fš9à@¢oçº’ÿXXÓ5Ak‹0VĞV°VĞ&ö®g"÷´E)È—Ä–õy	—Úß¼øÒæ¥èwY›—Fnz"ÀLä{¶÷…i¼2FÑ’4DëÌxñÊœìÒº2± àz–œô ó¦ëÖ8çZ{èî'êr¤°¹4Ÿ¢¼ã±ÜdêZGb4™­Ÿ?«´«Fù“Š¸c…HÔÌg[ºiü¹+V$+ÖHG˜¶ëı<¿¡€måE(â¹F3V¨ª@jvÚTØÅ3–°k±tŞçTóMD„­›Š)[µ€ï[:9~ª•MWy|Y&Åù0V0ÖbŒƒ¥œ±šPØÅÕ–HT#"4şÔIhjšÍë
+yncïìİÃ`ïŸT–—PY^BÄõøöÜu@b­g7ªùe$ëe «¿òÂ#S-Wû›ŒÒ?>µ–¶ö>nON³iM ÍÍÍìØ±ƒšš\‘EÄÕüz£‘Xú\Ï0íz |‡//:ıù‘#b¢ÃnÔ#ìFBQŒ1t÷pùF?a€IMMÅâ§oh‚©ˆ‹H¬=- '’¬w¯S11aó†`ÑvvìK–gP[	€ÊÊJÚÚÚ¨®®æ‹Ó¿Í±ĞÖ"XüÉéAp^ğ¬Îh¼)‚1³íRµuM»©=Ù
+J±ïİƒŒFàØÑï¨=ÙJ‚ßGÕÖUq{cbcª”Es!mgÁ…K3Ù»k=Õş@mı¥xä o¿¶Â¥™÷ùFC}S >6±TXGÁöò"V>º/Ï\åZ× ÅùyåÙqèXf}½k2úÎ+¥˜ôs¾ı6O,OC)X’ûÕ»6p¯D<‹´t†˜ô£”`Mz_Ü}|½CC·æ¦r±k’³×nÇÇúa¢”"5ÉGan*#£!„^Â±µ8Øóä@]ÓïïW>³2¸eu.~¿ó¯ĞY?KëıÔ7]	mŞÑÇÁKFÿ­”ûù×?VÕKA|
+5"ñ»ÀªUbÀÿWÄÓ‡Ò3ıÇ˜œÙÍÃşym£‹;o[BZN
+bğ"c“¢§‡»{uÆ@ãíÄWPPğÀ…ÜäĞ7}“)ÓÆ-·îd›Xıé`ŞÔ®ÎhÇAşJ1…Jhü0ä    IEND®B`‚
\ Brak znaku nowej linii na koÅ„cu pliku
diff -Naur mplayer-1.0_rc4_p20120109/etc/mplayer24x24.png mplayer-1.0_rc4_p20120109-new/etc/mplayer24x24.png
--- mplayer-1.0_rc4_p20120109/etc/mplayer24x24.png	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/etc/mplayer24x24.png	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,6 @@
+‰PNG
+
+   IHDR         àw=ø   sBIT|dˆ   	pHYs  ×  ×B(›x   tEXtSoftware www.inkscape.org›î<   tEXtTitle Firewall®®   tEXtAuthor Lapo Calamandreiß‘*  IDATH‰µ•khÕeÀïÿÜ<ÎinÌÙ^ÒDÛX¡–—°\Š˜‰}üĞ‡˜}èCÈ*%Í>”Š‰dºa–ZŞ2]FšÇ¹\»xÜÎvçò¿¼ïÓ‡³ÎP¨çËïsù=—÷åQ555üŸb=q½mû{"µ—âcO5ö”µ6vG>¬¯¯WÿæãÔà—bcjJ}¾Ê*/.P–'ÙñÁ˜™oUCûë˜µòıaİ}\Ï¬¤XD0¥ET©ÖJkĞÆàiÁó®6®§W8Z<:mOoJÄ¼-å‰/œ!ñ>ßúÉ#ß™>51<¿7"‚ôŸ#“»÷Å“Ù'¿ÿ¹¥î7é
+’`ı€a!ÿêYUc‰¬GÛßI2Áˆ  µàÁ¨@6xF‘QaÏjü3¶}£Géè³©¬AEQ°_“ËşagÓÍ§®ö2©l¢õ˜!gp)^öål Û5T…P* =v‡“[iéèÅõ4eÅ#˜?cãÊFPY>œ£M=ı¹ÈƒC¾ÔyÏò—elm„Œ£û³N7µqätÛqñ<ƒãiÚºœ½ÜÆ²—¦°höD”êŸàiı @¡jƒ…‘ÂTÆÁÕBÆÖˆnv%8øÓ<­YøÂdæVCŸ²ïX_ibRÅh&–FÁAko ÷Ñ”Õ&F“LÛØ&íhD„£§£$RYæÏxŠåaÃ'ëpÒ½¼±¨š¥ó¦’Éºìÿ¡\mp´Áq5İ¥¯ˆÈ/O_¼ÒIoÊåV_cM×:I¦l^|v< ,]º”72·ªœŒírùÚ-D„¬c°]MÆveíˆF'‡ò€’ô-ÚM÷¥36©¬G,a£µæÊ¿_mÇõreG£QZ[[‰Çã8®G{,AO"H®×ƒŞ)ê{7(/O8Jämƒ6&ß¿©ãKoš ˜7oçÎ£®®Ã§£y›ÑÆ b„‹
+ßŠAÏ´º¸óĞ5É} Yµ¤Š/Ü`Çş³ lÛ¹€ÏvŸ`Çş³ø,‹UKªòöAY~D¤b odî¦M(¡våL¶|}í{Ï°}ï™¼ÎgYÔ®œÉ´	%ø:ÉÎ°mh€ÎµH”‚7WòÜ”»¿k¢¹%–oËª%Uùà+ï«c·~İUGMÍƒ K)F†}œ¿dæ„B”ÊUòií‚ûMóÁÏ_O22ìÃR¹ÕP=º}ı‹l ôwİ'K'F
+9ŞÜË·‡z¿<1ÜÏÄH!=ñ;„‚ş.Òwuƒ F›ÏoşxùÂÊğkÏ—ğ?ÚÂs=ÃåhŒC'š³‘M÷êìáÍutû·î9¹Öñt1`Áıqà(éŸ” ü¾¸§õÖ´²7ßk­†ZúõõGÕ¸Õ»B™?~Ù§TàåàÈÒ1/Ó›2v*ƒ²jÃSç|{¯Ï]«íššWäşXCî‚fY%Ó[Ö)e­QJµ!ú`¸@mx:Ô‘}¨Óã şù.ƒÏ"[çê    IEND®B`‚
\ Brak znaku nowej linii na koÅ„cu pliku
diff -Naur mplayer-1.0_rc4_p20120109/etc/mplayer256x256.png mplayer-1.0_rc4_p20120109-new/etc/mplayer256x256.png
--- mplayer-1.0_rc4_p20120109/etc/mplayer256x256.png	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/etc/mplayer256x256.png	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,74 @@
+‰PNG
+
+   IHDR         \r¨f   sBIT|dˆ   	pHYs  ×  ×B(›x   tEXtSoftware www.inkscape.org›î<   tEXtTitle Firewall®®   tEXtAuthor Lapo Calamandreiß‘*    IDATxœí½y E/ş©î³Ü%÷fßHHÀ„ì$È&">·QŸ£òÏ—'*8€(âˆ
+.££¾qæ7€â6‚D I 	¹!$,ÙÈr³Ü$w;çt×÷÷GwuWõrNŸí{î­Orîé®®®ªîSßÏw©êjvé¥—BCCctÂht444M £š 44F14hhŒbhĞĞÅĞ ¡1Š¡	@CcC€†Æ(†& QM £š 44F14hhŒbhĞĞÅĞ ¡1Š¡	@CcC€†Æ(†& QM £š 44F14hhŒbhĞĞÅĞ ¡1Š¡	@CcC€†Æ(†& QŒT£ 12ğ¼}Ö6Yï1`Ì £#œØQbÔ“‚ùÈó©gİ>hhĞ¨[rgÌãbï ËÏc p€ ˆ`“E[ìå¿Ã§7>Õè6k¨`úİ€åâÅy¹¶–›ˆãc`,ÆÀ˜0ææ`€K ˆ»ö`ŠŞ=?»µ§‘í×ğ¡c ‰±fÍì¹ÜÒhÉ¼@„OÁ0200Ã`Î6óÒL—Ä‡ŞhQê¾={Vg}-4h$B—µì¼üã ßcÌœ
+Ãt…]|RÊŞ¶{œ™.	à¼É½?nôõh80çÎÛè6hcl¦3OîÎOü!ˆneÌœÎ<-/¾£é™ák{æºŒ1Ï5`^©´è =­cJêÀƒº.ÚĞˆÄ–ã‹ZŸË-ıg#—ı-XŠ©š>í	?˜oî;‚Ï$³ß c¦k8– ƒşÉ­ù%+}£z@#„-¹åï£,ÿ*fÂ`®û>¾·G»+ú]|‘[3@ 'Ù0  àdÚœ¾àÜ!½8ÚĞğĞÅ—ŸùÜàÒ'üc&¿>f¦.›ù.	€Á~wC¤Á·œsåÀ ÎÙ’[ş¾F^óh‡& ¼`­œúÜàÒÿ¤‚ıWÆØjÇdöóa8Úß|!ùHğIÀËkø$À` Ä¿²åø¢Ö¡¾fš F1öìYy.¿ô3+ÿcø XÊDœŸ/†ù`(Ú½4˜û_¸Ì)Ëå°“)›ùl/U#š F)ºòKßvlRo#ÜÃè„7dçã™)×T7=ÁgŠà'~™\Âµ2À0â×l¦3O®Ï•jƒ2lÍŸ¾˜Ãş^/fï9¦½ìÛ{ÚÙZ”£ñã 	'JÈ€q€¡ò·#ƒ+ª½>ò -€Q‚­}gŒïÊ/û®Mö³ özßÏO™r°Ï”ü|Ÿª~‚GÀ|+@ÑßvYËÎ«¾r 	`„cÍêÕÆ–Á¥WÛ¦µƒˆ>Â˜™‚%üb¦^%~~RÈ#®…!H ã6}sÍšjY¡F	è™€#[—_ÒñJî>0|€F+‘}˜¦êç{Ãz@ù~~Bx± ™_œ‡hzçkÚ;Å<¸¡ökDA[ #]…es\zŸÍøƒ`Æ"ˆñw%Â/ëÉãùu|ê¨€t¬âìKr«ÇÔ±4Œ <KKÛ·ä–İFœ¶0Æ.ûùéúûù‰!Ï0t¦;î¦¶°¾›‡°!£š F6ç–_eæ° OƒYaîÃ0‡ØÏOÉpg
+*V á£[ø²Ó†¸Q£z°É±5¿ì\NôM¾R©'¦ŞÂ³öuŞ~C_Fô° c"Ê¢ÀïD—5°£ÚhRl)œ9ã¹Ü’ŸpâØJuún£ıü„g
+ÂòWzKWşt½\U¡	 É°-·ºeKaùMÄsÛŒw;éÚñÌÿ ŸÁ÷à9îsR@8ñ;×t^e6¶#š š]¹¥ï)àÄóàüŒí!?ß”Ïüá$ü.¼‡…õ9Ã -œqğé«İÄ‘M M€çíÅg<—[úüƒ9[}L7å=¦«¬ÆSïñüšAà½G†A7nÁ¢	näˆ…&€aŒÆŠÉ[—üĞ¶ØÓìuÑé¦J<¦Û,`A%³ñ,—º¥Ñ­©qË‚/|ÓM§úí÷Ú6ÎæÄÀÆÉÄ©"î,U#V°öE„)édE”JŠU¨ Dá4ùpÌ¶¼ãAÊ!¹h5Äÿw_dô¹ü}RÊ&y›Èo–»-çSÒıj½6yiäí¹Ûòµ’’ŸÈ/ ¸Tañ;æÕà3Œ›ÃÓÙŒqÿà–;v—]d“bDÀü7ÜtÓÀ‰Âõ¦ÉZR)éŒ3Å`b¬™ŸùÂ¬ÄÈ˜*ğ!yÒFe b{!¡^_„¤s$¡…Ì'
+äU…ØØ Ñ/¨D:¤²Hm3m¹Hj—\·Br~ùº¤:Ë‚8Ü&Ø·9ˆS¦5uS¡ëÛÊ,±)1"`Õe7ŸÚÓWø%Y8=Ó’BK‹‰l‹‰TÊ@*Å`LÓ÷ÆÃ2?¨õC«ÚF>K@’î”Ò"¶Â‡€P……/L!jâ€à…O&åXŒÊu©Ûr!@-¡ò¡I\Ùòõ$bup·9l‹`…¼;ÏÁLöxK{ê}}ënİ™¬ÔæDÓÀoºé”ıö&Ó4:ÚÚÓhoO¡¥-LÚ@*mÀ0“9ÁHÁ÷ÅÖ˜G¼wN„OP-<ó;fà¢ù¼ôH-ÌÈ£m„%#èr±$ ×-“HŒĞªB.È!Ğ~ADà²9ùmã”œ ”[O q‡ l‹´İÛ¢cmcÓËG2	4ıLÀ¾<ÿ…™2:ÆŒÉ £3Ö¶ZZSHfÊ€!„Ù`!Eb;Jà™î+‡ÂG¢4¿“.ş„÷#ıãXÓ[J“¬E{ye­ÖÒÕ §hBP¶=+;POĞB	YIá‘C*MàH¥Ì43€\¿5v°×ú€×•QjS¡©	`Á%_ø¼5h¯èèÌbLG
+ícÒhiI#•b0S®Ö7O (‘à|³XZÉŒ56d“Ø?ÈBÂ'ÒŠkÚdbÆ•÷‰ &m˜$€Î6óê#±§,¬c®r·ÑL:1åqq½Š»íõH€ƒ &\‹¤ğPœ~Â9Ky€80Ğ—?7½èš©1¦u]ú…}=Öö1™Öqã3;.‹Öö2i¦»d½aÊ<o&<‹|å9u$³¤/$£R·Ji÷ÿ-ùË€$äÒy „óP8"4sK@6¿ÃåÈçÄ™ÿ¥¶c¬Ù
+ÖU‰àİ|ŸmËF~ÀÆ@¯…¾9äúìş¶6sÁHhZ ãW&kÍ¶˜hmO#Û’B:Å` 3e­EëÇ	¾üb[ÿXœ H_	À<däœ(‰º”Ë×ârá"]ºï¶Ó›ÀÄycş¾›H$Ne~Î‰övÕ´›Ñß–€·-•#Nón
+¹çFm‹Œ$İ@ï\æ³š¼-İ	)3-)D@C*c Ób"ŸK!?`·åòür ß­°ôa‹¦% Û¦Õ©C6k “6‘N9‘~1Şï­:%kı€\™Æé QV€,i”§+3GŞ¼‚cŒ¹	N÷,W”}!—Îó„ÖMò¤Cô*H Hâf1AÂ¼mû§Ê×®üeäUsµ­ŞµÁsMük«ôÇpF 3e;1Ó ç´ªÂ‡5š– À±(İj N!6œH?c0Ä„I³­ gWÎMBÈ”y Ò1ùYB ˆãqÔ;F’´HG(iL_Æk L–[z$@’4²„ Ìi¦l‹,~›à–í‘B€ ˜¬ÒKX}TcxÅ˜˜)©”3eÀ°—Äi³MK ¶Åg§R¤R€i2˜†áiÿ8“_1÷‹~Ğ
+P!Fã39s<íµO;©LéÊBË«–A	"´µbò]‚rH Â¤wË†KL2aEğ€ÜïâóßO÷›p-P &WgxŠÃ0ÀLg™l{^e¥o4-0 Õ4óÌ0…$ü·ÏÀ3ùEQö… 'µB/»ş~ÂV#¬Ì˜ä“É@ÎEßí•¯ÆÄ~(PŠ¤âB,š&™ÿ,ÆˆV™5|#Š'JYÎırë
+Så kÂ0<…ÑQƒ‚‡š–  Ã5ù]ágÑÂòEí!ü(¡/mÄ#¬ıÕ’‚dà ¤~P@|!bQAÂä$ 7‡Éä ÒK™ÿ²ƒB„€ÆXIcRó•¶ƒ<G¨2ˆka€÷&äˆ¦% Ã$wñ‚!iîXá—´¼¿/ùø‚_Lè+µŠkÿ@™ğÇºe"`€# øş´ç·Kûe‘ „à–ÃbâAW@QÔªd—m0x‡±iÛkv íâN††²!Ü‰äV^s¡i	 Òšßh9¨ÔúAï~"+@ê ¥fÊr¯ı!wä„â-‚ ú“]‚$àÄ‚ˆq‚Z<Å­€¨‘=hx×¡Üg÷x„4 i	 89§á¹BØ'øBÏ¢=NS8CaŞ÷E^g— ’ĞKéA[\EPĞ’€oBË„ ¯\@ì°BwH”TÍ¯¸8şğ_¤ 	¸°TÍE¢=·FºÊmUU¥0
+ĞÄ€æ.KøKYˆ ƒ€ĞËÂÎ‚	Qmvµ¹Ò%]I%ƒ +AHG¬ÉŸ€dÁñeÉÉ«šóP\±í6/¬ùåà`ô€oQxMPG¸^YA7@¾75wF2š– Bf»§Å“
+Ø×Û—_µT@éìòb±ûç8X"ÉùU»½/°$„ÏtHš³8	,H² 5tŒO‚ß©Zï^EÆÄ=%ßÌ÷ÚïÖ+MdŒãÕzñîg±ÖjÑ¼ CÖâ’€&~u˜OÙ~Pè=A’÷Ef¥}ˆTCLøãAho(•*cıEH âº¡˜ÿŞ½óòÈÛáêU•í®_T²X€ˆ%H­GªWp×f©ü`^µß¥ÚÑ€æ% WP!
+¼¼]Dø£­€hÁ—;W¤Õãİ!X
+Á„J¬ú½ÚwÜ”"Y}*æ¿¿4$¶<ó»ØÄ›Â	Şªáğ+$á ‚T´¦% IÙ»ûò¤_à=Õ—TøZœÃ¶-·À¹âÜ˜©õyíˆ# ¨P~jÏÍ=BÎq"GøCûÒ‰âÓ¼üÎ³îNá<\.ƒÏÏãÎíÇ•«î—*Ã©Óß #•™m™nE:Û
+ÃLKVT€4Š¢i	 €¯•%6P5tT€°´ğ!¶rı°òƒßÑ†ÎöVt¶gÑÙ–E&R"ş—>Iï¼qù9Q¹ªæ>ŸBç«çÈå’’®–lkùé½ƒv<û{°§û¶ïÙ‡lûX´ŸêÚGZôËAs àkvD™ş’à+Ñ~÷Ôá'ÛF~àZ³i,_p2ÆµgÔ
+ƒM¨@øãLÒè²Š	uøXñôø2ã„59ADr2(ÕfgcÜãÆLÆ²×L ìêîÃ=mB÷;y&Ìl‹âhó¿8šö'ÜaÁm¦nK™ı¡¾áç6rıÇ0cÊ8œ½pFQáçVÔ~VÎùåUÂ¼k.ÖŞh"+v¼X:İçØÖEœW9NÔë®8œ1G÷½+7èUãwkd@4- ¢‹3eÛÓúò'Òô—İ¿Œü@/fNù3ÇÃ0B¬âìU!ø‘×ÁÂŸè«ŸWZèŠY,Ác,p<º­åRÒü•İTÓdxÛêSqşÊyè9¸;ÒJ©åï5’Ğ¼Àßb;Fû‡M±í/äĞ’6qÚŒñ•üHê‰ù$¸¼„Bœ@ªçUê¶#„à¯ŒJ¶ ¤Eâãò×ÎÁ„ÎVô=øœÑ¦% Eş…	xígúÃÍ"Xù,:eJ@óKyb[RnG+ ’	Aˆ2¿«± "r— Úz"m2¼ÿ’30pü0¸U¨{}#MK @˜BŠtŞ éOÜBg[ãÆdcÏ	×^¯N]	¨ÇÂB^Ì_[”Ö/×ı(7½Zøå:­§LŸˆBn@ëÿhjˆva™BĞşŞq7·-t´gƒ…%¬Ø/«Ôgh§ícr—á$Ê“5Äª¹/Qç<e,
+¹şš”?ÒÑ¼À¢wåï¤ş#Àmm-ác12˜'i'KNÕjúpÕ@ÔñâVBã¤î”éca8­ĞÂ_ÍK …)û±ùæ¿o8ÃmÂ¨^ÛóéË/«TÉËH6ÂÜ„/^_¹ùkƒS§…UÈZ¢™ 
+MM @Dh}Yèå}?¿Ÿ/Jæ—nQ”@E}’”ÙÜ¢uÖr yz­P}ù-)=0!š— äÍ‚¦~Ğ=(uÜËW^ç«Œ ÊÍ&ŒäÃƒÕÔ›¼Ìrµú™åZé—DÓMŞ[=&ƒ¾›æSiò*OÇ£å¢6½±bSW=‡%AŞÒÇ´Ñª4.½œ24†šÆX³æ¶9·üª,ú¶3àÚF·§¨$¨XìxÂ’¥6,ÇİĞêy8 ),€­ùeçÎ¸è¿Å+œ¥€kÏ[r@°Öå
+Dkã¨Z}_üÜZ£m$¸Üê­“5š`’`XÀs¹å3ú:]Áà¼¡10ÌšÕµ0E4â4aôÙAÍW»Î_päø NôçÑ?Gß`½ıyô8ß½ıyä-Œ¡­%…öÖZ³)´µd0¦-ö–Æ´e0uB;2iSRU€K»)7ùY”ÄHÄ°$€m¹Õ-øˆš1´™®àÎ7€òÈ(~Á]¿#t\=½˜©[ğCª³|Á/õ¯Š\ŞÆƒÇ±kví?†BÁwÑàÜ]Äƒ‹…688œrtí—Üpòq÷±Ş“;1oöDÌ›5Ç¶%jyÜõÆß‡ú…ó <4ì1ì «°ì½œz¿Ê€YÌpÌ}" #bù	)AvO$‘_NˆèbÄPÜ~¨—‰ÛÛ_ÀƒÇ°kÿ18|6÷…Ü[ÿÎ{?¦Qê—ŸÏ]õgçşcxe_xb&mÅüÙ±à”I˜5mlìhI¹×[O7@» É0làùÂ²§otnPØ3}¸/×¼óI€”ı8D‘"|ÿò†©Êp"˜ßø²â¼²÷ßyG8‹%ºD±ZO@º¥cQ Y¨«şt÷ôãà‘>üyÃN´µ¤±bÁtœÆ,´·fj4{m!èè…A£ÑpØh¬˜lö¾Æÿ ƒa:¯šûÎ·#üÒÒœ
+d‹€!(–a!uÖàgş¹±R()hA(µÇÇˆŠ	¾—3¢LàÕîãØ´}?õæ|Mï®õ§ôë2%‰úƒ¤²¼“HÉ'Ò{ûóøóúWğøÆİ¸på)8ÿŒYÈ¤KûÛõú…+t¾ôj@ÅÑ08thvú@Gç5)>†±`)GÀ=sßtLM!üp…?ZFüıïoˆü†ˆœ4¸ûI´4	ÔÚ`8|¬›^Øî£}Ò›¾@
+“_, éÕ'órá
+¤CÍ)È@*'_°ğÀÛñØ³;ñÆ×ÎÁÙ‹gHQ—wqë&A\lA“¡!°uğôËùûv §Á3ó£Ì}Ã×ú7¥ûÊ–Ü<L ª ˆ—KK§Æjø€™¯68ÑŸÃs;`ïÁãàÒ*¹b›BŸKéóJ	$çyUÈ•Ï"Pvq¼7‡{Ú‚‡×½Œ·¼î4,?mZ=nI	¨,à‹,‚Ğ4‚RxŞ^µĞ²¾	f_Âà
+·§íe"˜û1“L Õ¤%ißóB=Au5¿¼ífôÌó I„kJ6Y&)¢Ìâç_éF×ËÁmu9l×(¬ı%Á%DX
+Âü—*T‰qe’°A88p¤?üïg0ÿ”‰øà[Nwã!ÇBA]çèÇ aÈì¤-ùeŸ·ƒŒK3ÁÌH™)çÛH¦çû‚æ,d©÷¶e¡×ÜGÄ¶LR±euN‚ÚxÈ3÷ä:,›cí¦İØòbXø•uò6ûƒÚŸ¸¯ıƒ÷@>_9&·^òÿåc*Iø4#ĞÖ—ákw=½—scrGB@2Ô Öt^e>—[úÿè‹`FÚ‰ó™Ö7%Á€'ø@)¿Ú×WQÛğ·E_‡$D’JVêˆC|ÿ*NQÁÀ¾Á<Y÷öv“>,üŞ¶$àà»µò@œ@”%›*øÇÔ@!I7O&õ6Éu‹ì‡{úqëİã™mûâo`ì½«œ@MŒ‚ºº r«ÇÌì~ò¿	ìbÅ¿g¦â÷;æ>PÊÜ…l“(B6ó	~,€¤ò<@’®RN›’çí>Ú‡¿nŞ\Şr.C¼9§ˆğËéB e £-‹ÉãÛĞÖ’F{kí­ig¶_km-iä
+NôåÑÛŸÃñş<Nôâx_‡zú±÷Àq…d¬ğˆ|Ï#\ƒ|ŞÆ÷~¹—Ÿ7o9÷4Ïò2œUcÑÔ• ²è»‡À.fğ»¦¿"ø¥ıü(ÈnÕT•ÜËìü‘g‡1‘ä“@9ªKóÅ=Gğì¶}¡Wa_'üI€0y\fOSN‡‰c[cÚë4:›1ÑÙĞ!¹@úòØ¶ó¶¾|ÛwFÛEÍˆb£\üú‘mØ}à8®zëéÈ¤ıœµÈ¸2ÄL@
+”Fu#€-öYKAƒ—‡…ßD8º_©Qx7j¦^D@ÈOgÑ´SW¼f‰{".
+[^:ˆ®—*px¯^ŒğëhÁ¢×LÁ¬éc1Æ”?¤•NkoMãŒùÓqÆüé(X;vÁ3Û^ÅÆ¨ş¾GVÁLÔ°®ëUêéÇ§ÿîµhÉ$ïrÉüÿèc†dqTBÒ~¼f$‡êgØù/À`Ä¤!übˆ¯Zá'?8¨zğ¾–—µ€:0`²¤n€œ«ØÄ¡ Ô¼/ï=Š-;øÂí
+º|@%…hkMcåÂ“pÚÉO–#ü¥‘NXxêD,<u".X1¿ùËvlÛuHŠ¸Ú5`±@:&ÚüÒ£øîÏ×ã“ï=F¤DÕXK³ğû+(DúŒLÔ%øB~Õ|€Ş.&d0yœ¿Â Rgc’Ï*÷@eJ¬ĞHo>Vnı• ûhîÚ›spÎ½ 3­×õ!?=2qÖ’¸âK0oVPøkÑşøBNšÜ‰¿çJ|è+1}Ò5!Î•İ±@Œ€ˆ°ñ…ıøÉš®!ñÇ½wAºM“E¹œ0²) .€mØ‚ÓŸÌã²±úª…ß0İ}cS@6èÉÍ	€(0<äS;ei‡ ôäğè†—aY<8š^hQÙÔ€Ås¦àŒÓ‘I‰ŸL&ºbµRÄñò$P>ÁìI˜÷ş	X·e~õççq¢w0“d^Üãß?±'MƒVÌ.Ú–R$!Ç4¢`î»Aı’²0’ .€Í1@ ÈäÔêÔø _û¼íi§€ßa¶ª¥ûCcÕ¶´`ÙxdİËÈYŞ£º6?¶Ëå'ûˆ`š.>kÎ^r²$üÊ%¯¹Èñ0é%+aÕâ“ğé÷­Æ´‰z?¨ı•aJ©Üÿ¸ïY¼°óP¨î˜‹7(ëÇjğ»|Ô… ÿåzLLÊ`µRüüÓç˜zÌÉÓ}%Èš?^OTODÀ£^Á‘ã¾GA[ko=fOÑ¦Z
+eù&ŒmÅµï_Ås¦€8Šk)P°9nÿñ_Ñ}´/Y#*€cÔè6b'Õg"I ûˆ5¯Ç×ìŞò…ââKò_Å~YUÊ½;âXğóÌ¶W±ûÀ±°ÀG¾ˆL™Ğw\¸ã;ÃCzò%I)%—>LŞ—¨ó²é>üÎ3qÉk_ÒşCòOà\çñŞ<n¿g-l;\hÜıUÇ_ Ü@£Sw¥şT<`¤¡>ÀàLsµ€SÿTr}¼@jl\€”u_ngLmEÒ£>õbÓöª°G™ıb›8^3s<.;o>²™tL]ÅQL€’
+‘ÒCûŒï¼h!®¼|™dqË÷X¸$½ôj~÷Äö¤—‚»‚\Í>#õqóÇğÁ¢d7)B~=<ƒ q± ˆ±À’?ššT`îÚÛæŠ°Ûnô_<'î‘À”ñcpá™§F˜œuUhÚÇiÎ¨sÂÖ@|¹n¬^z2ŞyñÂï/koj²Û”_üñyôä×“ô8Ó1€D¨,0ŸŞ
+Âf×ˆ{°Ù«€ì×&çÄÅÈß'iŸ &ç«Eğpàp/^ÙÛ#	½$ì’ÖÁÀ¶–4Ş¸z.ïYö°E°¬Ù_ªœ¨zåö½iõœ³ìdïgV'/‰òıŒ½yüâOÏ)»X½EFMü~&Leb‘Ú‘…:>dÿBXîY 5%eO6Èûİ)° 0¢Òä9­ˆìW¥|şbX»ilÎİ1ÿpä_&Ó`xÓ9óĞšM#®1Å„ÿÈ‘#‘éÅÚu]Å¯‰b¶U|ğ²å˜{òÅš¢ ¸ßœ¿Ú„    IDAT{|;í«™ö˜3µı ôõâ-h>Ô Œì¿¨ß™ÃÊ²á=ÆV+€ æûñräYŞçŞ¶¼AKŠë@‰:x2WæÅ=G°ïğ	ßç'Šü»±€‹ÏšƒIãZcË.Õùo¿ı<úè£ âEÎK*èjŞØ1YR¦_q&m“´½8Gş5œjò=ğ\ÂºKcÌµèjÌ tÅÖü²s‹4 éP7Xœ^·—˜q‡gw:'qÔÄ oåÙ”ì‹ãò¸0¹û^xÂÍVì²áÎîR‘¢İ 'Š¿vÓî Û6EOŸ?¯™1>XA‘ºıúÅñ\.‡ûî»ßüæ·ğê«{‹œW>)„cñ¿Ÿ(£sLÿ÷ŠU^vyyrYû‹¾ğçõ;ñÒŞ ×æÒÇ8³NkópXÀ`œè›kÖ<0bÂ‚u]€åò·€h7¸kp¨… —!Ly)YÚ—İ?)¹’™'IÛDt½Ô£ò˜Pè%K ›IaÕ¢Ñ¥QTÇW-Ÿtœ©Å;wîÄm·}÷ßÿXV¡Âk	æ-&üñËkfŒÇk—ÌT~ Ğÿ=ÄıøÏßn*ÑÎäÇä©ÀÕıyÛNœhåI^ÿ¿‹4¤©PWXÜÙ5 f|à¾À7 8W.¢M÷S÷!å…T³ï
+øy€¤š3¾e·ï™ş¶BN0Ğæg-tÊô„]şD_qt{pÎaÛ6Ö¬Yƒ[nù
+vìØ{Nô}O&üÅ‚‡²ïÿ®7,DÊ4Ô‘·$… lØº{"Vª$Ëj!ı,X¦Ç¶ Ş[=¦üV?Ô}E ÅÙ?"ÂZ§WsÙ®+ ¿U¥_JcÌŞ÷G |k@îxŠ•Y‘jnÃ±ŞA8ÒÛøÙrà/ ı;Û³X:·Ø"šjİÒå†Ú$ "Âşıûqûíwà{îÁÀ@ÑvG_¿<Mºø…G[PÀ”	í¸xÕ©aÓ?‚„'6í‰«¡Hİácµ² d+ î’u ¦eĞwSlƒšC²& iĞÇn‹€¬Ú ”a?¦î“›èò‚÷í#Šêl_Ìï&…mTìØ}$~Æ'pÛ8wù¬ˆ¥´ãËn—“W& "òH€sG}7Şø¬_¿>p\f2Ó>*O<):ŞyÑB´dS‘¦?qò»OlT	 \ß_€U;(ÿùÛş¢µø¿]…esÜ¤a!!€…™çÖpÈw+ xM€<¹‡Kû^ßò4¼&§©µ¸™+åÈçlß}ØYä#â#ÿåD˜<¡ófO/¦å¢Ìw?A&€(8zô(¾óïâÛßş6zzFÜÍğ~œö—ÛŞ_CG{o=WRĞô—İƒm»ãğ±í+}¬.Q:o%+ ²ÜÆõ¨f(1d«gÌÌõ :î[ µT<Yx%ëBMD–¿…¶OĞ—rìŞw,<ôG¤Ìàœ°ì´©%§˜FÇ¢‰"H 2	ÈiëÖ­Ã7|úÓÃ	j-Ù¦$ù‚¿ÌÅ«N…˜,†^vBbeTWqRŒó´w-?Ò{*™Æèò­ƒË/)q#†5†Œ æ¥Ö _[ÁaÁd$°ÿÈ º¢w  ›K‚*ÇÈ%ò;˜×©È?G¸Ñz£¸É/cû®#°Ü‰?ÁOæÌœø+.ôáúEŞ($ÜïííÅøCÜ|ó—°oß¾@=~¹ñiá}UXÃçŒëÈâ´™C¦¿²è©{Şãw%üÅho6_í¦¸{‹ÚŠ€ ÿÆšÕ«›ö5DCÚğiÇÀ‹Å‡“ÁĞ—³±¯gÛöÀËûpğxî	´3Ñ‡À¼I?pÓ¸ˆxéÅÕ±*Ñİ¶óPqÿßıL›Ø1­ÙW˜Ì-y£„?¨ıƒ¤°uëV\wİõøÅ/~	Ë²b®5˜æ¤GÇ"Ôs‚ûg/9Éxùı†Ş7yÀ³/Dÿ`>áµGƒ‰Õz²àúş	Àğ–¯_4ó‘¾oÍğÅÀ¤I;ŒáÚ¢Ã‚	] Cä,t÷bÇ¾x~Ï1ììîÃáã9ä,%ğ$|Î UàÅJà+B‚m^ÜS" èœ6kB°äˆO<Ô68y‹¹ A+@NËårøÉO~‚ë®»Û·ïˆ­¯ø~´ğóµx†ÿÀ÷û•ß€ù‚Ûö½şR÷HZŠ¦†s!¨ËÜÑç·ö?“kcÈM—E™Í¿f`p~ñˆaÁ„`ˆ'k›'
+Ø×3€ûO kÏ1¼r°İÇÑŸ³¼¾Cñ8}*8ìUŠüÜİÓ‡Áœòób ş\€y³&–,?º>!láóŠ¹ AˆJ{å•¸şúğoÿöCæ¼òƒf~|Ì 4i4¹'MîPbù/ˆ Î¯±cw0PUg<j€0\áÜ•®2`(m¹d£†!â»0f|’À-uX°–Ï	¨°9áø@û`û¾Ø¼»/èÅcƒè´¼Ñxó6„c½ƒ‘Âœ0¾³“Ç·'jw)¡—G å€eYøõ¯ïÃG?úQ¬_¿¡ˆï_wœ6–Óår^+Ü€€ß¯Å®”,6€R]epÉÀzeX}¨+·rIj­+B 3Ïn1ûj@ĞµÊ*©²™İÄŞûbÇ¾^<·ó^Ú×Û¶ÍTÌäâD_.ÒÜ¦M×V2øçkÈ$‚“'Îß—Óƒy‚£‚8€oü<n»í6?~,FèJ„… Ì9yBHë‹¢DP"	 Éï P»§ "œ	×?,E¬ğDFhXô’Ì"¢#Ê° HbÈ¦Yµ¡?_€Í9,«€B¡ Ë²\é>O0ù¥0 àx_ÎŞ¿È§½MşEùşI:¸ŸW&(a‹%ÛüãŸpÕUÂşğ‡@»â¶İR¿E>"`|Gk¤ğû¤àœØİ5s1¹z0j¼"?àÇüaA÷e7Dwå–¿=q#‡F ÛŸ9Ê€/‚8ˆ;‚FJ@P v®@qÈ6#y‚`Y6
+–U€m[àÜ‘gŒÁ'‚c½9p;z7È&t´Å?ï_*A	(¨Ñ£¶ãH )ôôôà«_ı*n¸áìß¿_©?ş‚Ö'ßÑ?ùÀ2Pô|…R¨‡à–+‘€÷6kwXÀ¿¾gÏêL*¯9:~¹ç¢1ÿB—Ûà¯ä’@‘ßÜòÈßUNıT 
+©Ğ²B»Z–ËÊ{¤°}ç!êéÃ€Æ D ³½%áİ	[Q–‡@1íı
+|1K€ˆğä“OáÊ+ÿî½÷ç°mn@lûDÛï‰c[aÂ/&K,\ŞÂ£½Èåí
+ßAmVvÊøVk@ä° Øœ)½×VÔè ®/-…K×®å[±ü“üAçù|Æ¹ûb7aGŠí0£ÇÙT†¸ “_·8.÷'~<¹eÛq€³Rî˜¶Æ´gÑÑ–Å˜¶:Ú²hÍ¦ÑÑTÑ<Y¿÷3	AnA–Óã>QÇå´şş~|ûÛßÆƒ>ˆn¸sæøSá}³¿¸õ–I›H§ë„eq—Y’At÷ôaÆä$7"„Zô‡ø~åôIFÄ0 §^°Vşû¼ÔúU4aHĞğL[6>DÄî÷‡ËL:›è£
+¹
+51Jwñ}Ö\ÁÂácıØùêQ<·c?şºiúëvüö±çÁ@°,[ÒÌ$¦BÕğáö¨™¢´|1íg	ÄÍwuuáÊ+ÿ7şõ_¿‡|>!ür|"\OÚ4ĞÛŸÇ`ŞBÁ²#… º‚±(¼ Q•¶ÕJ¤€ ?,Æ:óVşÖÊ?th8 €aâS åPá°`ÔoU‰ü³€©­",tr¾şÁBğ„l›££5"_Àœåº–”&¦¯…ãÚP,ò/B9x‘fÛ6r¹úúúpìØ1<x·Şz>÷¹A$Ê¿İ^„_‚ójòÒÈY¥3Å ùG‘t©ñ€?$è?'€÷uñågV|C„†º ‹Ò›^|.·ì_ÑµşÜ wÈ™‘ä[Ìo«¾§šüáòDgöímiœèÏ•¬çÈñ~L…¥˜%@¤^ëºuë`š&Ãˆı‚,JŠùòTa èììÄÍ7øÀû]¢§w0şÂ$´·VŞ=ÅÊ¾• õ±Ør˜ô%,` Ãäyş-´àœÊQ €<ÚoÊ¢ï} >Ü˜ë_wnj‘X@m —ëy”ßÌ “Çµcÿ¡Ş’µtíÇÜ“ƒS“!jXÍ+·»»¢2+Áå—_†Ûn»S§N-:À;9ÄÆäqmµO¼ŠnHÀàÆ˜«ıM€ˆ°zKnùûg7şhhS>†…  +²k{9Øç¼ÉA¼ÄòaÂÄcµû„ˆËC˜<>Yg=p¤4Iã¥êª¡ÒiÓ¦áî»ïÂ]wıgÅÂ?˜·¹KŒ“*$ q~ÍúElÿ |WÀÍøW·_ı~·a€aC  ğê#_ûw ëïÆ,VM\'Ş÷‹ú•£†Ã¹¦$œŞ{àH_¬€— †‡‡Œ1\yåñä“kqÙeoqZRTøãËê>\ì#ã:ZN™e¶ÔG}úG‰£‡gRkúŸ*¾:cXÀ¥—¾‰Æ>p"wT øòaµÿ‰ã;oq"Hª­%z#nPĞ‡VàeÌ;¿ùÍ}¸óÎ;ĞÙÙé´®¤ğÇ·õğ±dæRB‡¡£ Ù
+€	f˜)}j3yr•T+ €…™MØ½¥–cî†Z™z¢ã×ÄÑD0i\R ñ^ '6,ét×^{{ì/8ç?UJÀKµÿpRÿ?¡K‡š›ÿ%M )sà9ÚX!{UT';pÀ>M„~uù0ÑÓÉëcõáw_““!i‡İ¶óp¢|‘5Æº
+µe€•+Wà‘Gş„Ï}îŸÍúCv¥„?É¬½ç^J¬LúÄdj5 ‰ş÷+ùäçÜaA¢¿í²–WÕEÕÃ’ –d7îa†ñuIV€ãx]¬Ö¿nèNJNŞi“uØW»O`ÛÎÃ%ã ¥cµwÚÚÚpË-_Æƒ®Á¢E‹ÔÚj ü ğğºWå›6¡Z C,ıR…’	!-Æ¸Mßno–  )jı
+»àˆ§ÅB_µıÿ+'#‚SgŒG{k²g@^÷r™w£şñ€‹/¾ıëøÈG>ÃP»E­„ÿ¥½G±û@øÅQ˜?{b¢|q¨uß(‡Äˆ c"è-%~úÌ‹®ÿPUVc[˜Ÿ];ÈLÜà-ÆÕ§ÕûzŒ%ÀGkeÓ`xİé³]ÛÃO¿‚h¡úàßÄ‰ñƒ|?ÿù½8ùd5N%¦òÖBøà‘õ»åË¦M¬Z|Râr£P“ üï2À#0Ã}Gû´ ÑÍ/öÌë¬êâjˆaK  °(½é¿ìq1,(?'PPQ-/òÄ‘ÁëWš¨–­¯tãÀáÒóJ¡Ú àW\'Ÿ\‹w½ë]‘eüò„ ^ÿJ¢|¯]:-™êæ¨5fÌD†k€Á{NÀ0À€©¹¶–›İ:aM  2puô[…Üp«ÅcŸêTà¤‚¥’Á¹ËNF*•ì–>¼~gY÷!>&P¾•0kÖ,üüç?Ã÷¿ÿ¯˜81lj'3ùË«óà‘>l}9Y ğÂ•³Ë*;
+µëÂ
+(Çu—­€ğòaÄñ±-|ÙiU_d0ì	`AzÓ"ÜÆgjçñ;¹†%ŒiKcÕ¢d¦ëÏş°Å{ŸAyÀÊİÃ0ğ‘|k×>‹/~}ø
+jlòËøÙ»İGÓ`8ÿŒ@>@Tß(³QÃ‚ä1,–ö  v[úz€ÉÃ‚µç•c	ÑP‰ T'¾he27`Çî#¸ÿÑçCõÔ+°xñb<øàÜrË—ÑÖ¦Y&|'_eõ<Ò‡ış¹Dy—Ï›ŠqÉ,†Z÷Û?Š5Â‡ÁèÍ[rËŞTõ…V‰¦ €å|C7€¯ÈVÀĞ{ya« J.<svâÎò{×!W°PÏkÉf³¸ñÆÏáá‡ÿˆ•+W„—ØS™¿/ã»?_‡\ÁN”÷‚Õk`8Ä  á
+xx«w¬é¼ªòùÎ5@S  L=qü€m÷†ƒ4µøW¹EDÎÖ¥s§$º¦ƒGûp÷o7Ut?’<?pÎ9çà±Çş‚k®ùÒétÄ¹Iµ~åâ´}×üö±èa0†×Ÿ™Ì‚*FµÛ¶EX`Ês´pÆÁ§¯®ÉWˆ¦!€I“v2¼·
+ÉÄZ«!åøıNş !¼û’äËÃÿÇıÏ¢çDñçã£cñ®Agg'î¼óüæ7÷aîÜ9¡r’¸•-ÄÆ7ò$xÂr.:s6Nš<¦ê:Úö‹â.bÉ–D¸şÂ! İ¸‹*{>¼h €…-ÏŞO`9“j
+íù‹V–[Ò›Î™ã¾ı§4úòø—{Ÿ* L¸ì²·àÉ'×âÊ+?èl¨Ú¾¾æ¾ŒÇ7îÁÚÍ{å5M{×ªšÔ@†4½	BŒ±ñÈ§¾Ò¨V5 @*•ıˆ
+5ÕşEƒ<ê» ’À`ŸxïÙ‰¯éçÜŠûİ†jS§NÅ]wı'î¾û.L›6­,3_ Zs_Æ«İ½øü÷NœÿÎÇìéckR7Pã¾* §5~8 bxQy·àU[­‹JR4,0ŸŞ
+Æ~PKß?™§Z¥Èàœe3qö’‰¯ëŸølÜ^ù"²O=õW\vÙeei{Z™ûƒ|êÎ5è9Qz‰4 hmIãŞPVƒÚö‹j" ~‹|ŸU¬$b†IÜ¾ªê**@Ó  ¤Pøó{,«Í§\¿¿Ø›‚ à“ï=;ñˆ@Á²qÍk°?áAÕM ttt <¡¯½à‹r?ûİGJ¼ÜSÅŞ¼:k¼hNú„ò©A›<BQ¬ €ï¬Ae£)	`~vk¸øMj÷ûR…B!}R˜?{şÇ9É'|96ˆOŞş ²n8&|o`ym[]¸VøÎÏÖáÑgv&Î?ql+Şÿæe5oÇp“}¿UâKö10à”-…ågÕ¬ª„hJ  Æ@Ê=¬ÁG†,È•Á²½k%2éäC½ÛvÂõßşóV„ WÖ˜ziû ~òàüÇıÏ–uÎ‡ÿf%Z³µ_›¶Öñ¡¤–\¢¶‰ë¹Â*0®¨]-ÉĞ´0t6UEÓ'u”İşË3»pÕÍ÷áà‘$Ë‡E#l-Ô–ÅqË<†Ûî^[Öy+LÃÛ/œ_§VUÿ¨ Ybƒ1Ÿò§›— Âğêk³’âıo^ŠÿqÎœÒ%t½|ï»ñWØ´#y`PmÛĞ„õôâ£_û=~ñ§çKg–0}Rnıø`ÔRµJ¨¹Póº¿\0CòÀIĞ´0ø=ü~½ø¼_øĞ‰g
+>6€¿ÿòopß£/DÔ®¨ñâ#øÀçõÏï+ë¼Ö–4îüÔ%ß™ôE©åc˜é}$Q³øİÄoGš Ê€KËÃÊÉ‹ñf:eàO½S'–7Ó-_à¸éÆÍÿïQtírËâ¸÷¡-¸ò‹÷co÷‰²ÎeøòG.Äi³ê<ù­Öı¢FıÃßÄuˆ@ÚHá`”‹	-øÆ5o¬(èõßŞ†·]{/¾ó³§ÑÛŸ¯CëJƒx`í‹ø›ë†¯İµ6Ñ>‚øØ»Î¬Ù?ÅPË>Q}ÿp çµ÷îËnÄj×Îw!CÆUUSš– š‰  `Ş¬	øòG/ªH¡æ-üû}ñÖkŠ»·	ù„OØÕİ¼÷ù_áŸ¾û0ö,Oë¼ùÜ¹ø_—Ÿ^ã–Ecø(Ï¼÷„ä<Ğ¦,yo°ÍK¯ÛYUU`Ø¼°léy¨%¹
+\°b6®{ÿjÜz÷ÚŠFõæğÿz
+?^³o¿`>.X1N©nÍ(9>€G7ìÂïØõ[Ëóóƒ8gÙLÜxÕù5jYTÛªîW$}‰7[	oƒÈqÛ!pË4R_ª²Å¡i	ÀùMÊŸĞ;\pÅ%‹1ql>ÿı?c0_Ùk°éÃ~µ?øÕL›8¬˜…WÎÆÊÓaš•w»öÃ#ëwâ‘õ¯`óîÄOòÃoX„Oÿİk+nS%¨ÍäİJú)_ğûšŸ¸»Ä½ûX;„»šÏ¼Tuƒ+@Ó€!â3õˆå.>ëTÌœÚ‰kî|(ñà8ì?Ü‹Ÿ>Ô…Ÿ>Ô…¶,–Ì™„ÉãÛ1ql&oÃÄ±­˜4¶Æ¶ o €C=ı8ÔÓÃÇpèX?ÀË¯öà•}=5º: •2pıÎÁ;/ZP³2“¢ê~ ú“Ø.yB”à#àçÛ>+ü`÷ì²êCKo®²Á•¡i	`¤`şì‰¸çæ·ãÓßzÏn«üa 'ús‰Ã­Æw¶àÖ¿+Lkh;†Qæ¾«ñA®¿ï
+=ùšß vË¢–Mÿ´äxe‹ÂÔM	ßÙ‚ïßğ–:ÎŠZœ6kîşâÛFğûÑ}_øEtßv„Ş¶@\|l€[ â'£XÔ²©áoÖÀ0A*eàÆ«ÎÃâ×LÆ?~²¢!¶á€Ë^77\yN]æ÷óó%s_Šö;¤ NŒı8ÅÓ×-hY_]TµFÉ¿RSâ-À…+gã¿Ú€_>¼¶]ûÕêÓçMÅÕï9ËO+o¶có¡ˆ¹/Eùı}îºx’™öÕKÒ]O5®íah†˜ĞÙŠ>x.şç¥Kğ/÷>?>ıJ£›‹SO‡¿{ÕLîi<(,ø OĞ‰Ÿ Ğ^2ŒÏ,Io¼»‘-ƒ&€aŒYÓÆâÖ«ß€Í;â?y²fAÂZ`ò¸6|øoVâòóçÁ4šhè¥(~¾ĞúäE÷e+ Ä˜oĞ ı¥%›İô8hh,;?üÜåøË3»ğ“‡ºğt×«s^3c<ŞvÁ<üíÅ«~_³Á³—ı|®~s€û%O™×,5Ÿİ…d/ŒnF×/Øä8ïŒY8ïŒY8Ş—ÃcÏîÆ#vâ‰M{0PÇ€¡Á–6®œW‚“§›Û=xÌ°ïçodŒ}bqfÓŸİÔ¤ĞĞ„èlÏâÍçÎÅ›Ï‹|ãé®WñÈúWğ—gv¡»§¿êò[2)œµä$\¸âœÆ¬º>¶ÛL3øÂÚŸÂ4¾°÷O_ûş¥—¾©qiV M MLÚÀ¹ËgâÜå3 ‡zú±ÿp/õô£ûè º{úp¸Ç™í×}´'úsÈ¤R˜4®S&´aâØ6L×ŠÉãÛ1il+¦LhÇI“;F__ˆ[@”Ã¿¶æ>?gÜÇ—\ÚğWı•M #“ÆµaÒ¸¶Ò5Ê†xxÎŞ(•úÄ’Ô†Pı»LM IÁm°‘ù©Å-Ïş¾ÑÍ©ôT`„ °Oï¼jñH~@[ ‰±$»ñö%Ç76º5…¶ $4Ó£Äµ€& 	ı¹æ˜w¯Qıyı;&…& 	Gû‡n=úáhŸş“B€M #‡5$†& 	‡{+[›OcxáHŸş“B€„î^OèÎÓÌè>aëß°h@<ır?,ŞTÓ¹5\Øxêå¾*Şè<ú 	 €ŞÇÆİƒn†FØ´g ½z$§,è‰@Øq0Æ€e3[ÒÅ{ØÜşäİ”¦ƒ&€l?Ã¾VÚ†)ú6WtŸ°ñÔË}ZóWİ³‹ 7Çñğó½˜Ü‘Â¤1)Lh71¡İD[F{NBãhŸÃ}6ô9A[íóWM 	Ğ}ÂB·,kŒ@hU¦¡1Š¡	@CcC€†Æ(†& QM £š 44F14hhŒb4-pòŞÍè¼ŸMC£Æ /ÅˆlÔ´ NÎ{÷®kĞ¨)œşÄ@œ{Û#M;ìç|*·]k ÑŠóş LîD,Ü¥‚‹’²`¦|ÕÚ»jBsÉûÈ;ŒŸh0çÀDà°ÇÃ6ºUõ@Ó€a²m¶ESm›ƒ<¨S3Yˆ%áeAá8&‹rXÈ!5™É›P!°y™å^{„XRô‘ )P`‡‚y#ˆ€(ş¸w,&}há\·	Üæ°-ƒÑhI½Ñ¼`ĞFÛ¢ó‚e¸M0L€ÀÊXß[`o»¨°;BÊdea`ÒAÕ
+Pëˆ;lŸ|´	$½òH¹
+iê°ğ*Gd ç‘	#xœér½T4?©yiµ ‘S/çËâ(lX3“Y/pÑ´`šæÚB<Ÿ³PÈÛ°²7`šá¼Œ©Â/ôÌÍs“¥(1$OWI_Êq9=àAD\¨¼MAÓ<|<¼C„hM¼D	:‹OSÎ•Ó¢	¢\rà°,…¼|Ã²82i<U^)Í¦% ÊşòéCùŸ48h!1a¦lÌ„a:BdB€TAÚWÉ¡DYÂG ‚DÔ}Q/¸=Ÿ¶  	ÊIDAT±–lqJ	Q<0ÂšÜİ%Iä%ç‡…<(Ğ~zñ4!ÀN¹œºX8O@è²äı@×ÃmGøó9ÁA¹œâ8JÄsËšMK ;şú±Ó.¾ù£¹ÂOû-–IH§€3ÁLƒŒ¢Â^ŠŠ	~´Ğ3©,Qn‘4é\Y°#…Ÿ©bO(!??(ø²»©)è*1øBĞÌnš/Àr‡+ÈÍÏÜrÜ}@joŸEïƒ‰2cò»#l›`Ù¹}ôY(r´É~bÇŸ¿p¨ÌÛÛ0çÎÛè6TŒ#/?Ü5mÎë—Ú_d0†á‘a Œ˜'4ş§Ø¾Cy8Çä}Ã=.“‡OğÎÇ)Í`ê>cÌ-R¹nšK`ŞÇ`0İmÓğÓMé¸ÁœÉüí¨“÷ÅµIu1/Mj¯’._£ø&Õ"‚ĞÙ29ydæû2ñ1W›‹m±ïäç÷ıoØÓÈ;Wøû¶ëóçáïëµ0ĞoÁ4qÿ‹~ñ3¥{cs¢i- Ö	é«úåÏìï³f;Ã6v+G&“B:M0MÌÄ juHûAmHf€ DÏBœe»¿¼  Ÿƒ`>IªJÅ@£z¤jm)M$(ù¼²ç•Ü—­×Š¬ Ù¢PÏõ5¶j1ü|i_>t) q€Á¶8
+|ŞÆà ş¾rı6ˆ°»µİ¸²øİln°K/½´Ñm¨oxß­í¯èÿ·\¿;›5YKK
+™¬tÆ@Ê0a¤\MfD›ïŠù-;£l)ÈB©¸ó„<Š2½mHÂ*í‹:à•|©.q¾–õË).ùí
+g@ˆ½ü¾P*nE¿_‡»/Õ!„R®ƒ¤:Ò‰$	©<¹¾¨ëˆ‹@ Nàäúü¶…B#—ãÈÏ¥³æÏÚÙøÿ³ñOŸ8y#GF,zÃÍïì/|DSRi©”3eÀ0Á`†$Ä ôÿeíò¨áAYÓ‹c!« ¾À#TJ8¢"Ï
+ûvB>æ•+×}”ºó¥›äiPq’/<ˆzxÇ¤ï€µ [ŞY„ Zòu¨dEJå˜ƒß^aˆ»~¿Åa[6
+"Öİ6.óÑúÂÏ£ïàÈÂˆ"  XıZïÏœçq¢¶ 'ûÖ àB&=àÎf )1y‡?D–manR˜(“<Á¬BHn:“Ïw	ücRK˜ÿ€$Ø!”RbˆÁ7ÙÅ¾Ø4s–*t€‘dGŠ_÷[äüu"w<ö<ˆ9"îÄ½ó¸ßfÎ@äX  7R©.ÓÀzÃL=ftyô…ß~sÔ¬/>â`(Ñ5¸ìËÄè³0R`†	f¤À˜	Œ tc¨n'ÚD ¹sáÉ8w¾‰ƒ@}Ì0¾âm_Ÿ]«ß¦Ò„hú `#AyëŸ)k~q>Ãt20"€@Ìù¶$PLğÉtñÍmWër"?eFæÓ‹Óëö6¨ñ5@ó>8°¸³k †ñ‚#$BC:æ­ìıR±bYøÉó‹…†'nƒ¸¥|@6 Zgæë–d7¾WóC@•X’Şx7€'i»A†²ï“wŸ¸kæÛ€í
+<·­Ïmpâû9K]µ8»iÕ‚ô³O4ú*4jM 5 3ì«İÇ]AIØÎ²à;û¹ï
+¾Ğø¶¬õm€ø ˆn³3˜»4óÌ¿7ö4jM 5Àât×SÄØ…¿L"pæGÉˆhÁ÷z\A~Ûµè>#e.^Ü²ùºÓÙæ¾Æ^‡F= ƒ€5BøÇèmŒx¸0"æÏ:lH@0èçÃìCøû¶èsÇÏ¶À'¶lúÃ6V£Ğ@0?»i?€¯	á"ÉPí€¡°	"ü|Dùù_ãsDü0Wï¹°}ÙÂìf-ü£ š jˆqİcnáepw4À3—cõD?ŸGEömaXŒÑwÓ°æ.nÙôíK×®ÕïÚ%ĞPCÌœ¹6àZxÃ‚¶?¦.gÍ™ ‰Ÿï=q×
+ úC*Õ²lQfóÇæg·öÔ¸aÃš jŒÅ-›bûÁÀ°`Í7oÇç;ÑıŒ¥ß¶$»é’æÓ[ëÒ4aM õ@Úø¬ú–Ö#™û6@ü@7L=q|Ñ¢Ì†ûªl„F“£©®˜bì?xÈ6 3ıG
+÷Ñ Ã¨hD âé»6î²[3o]jn|°­í˜öó5ô0`½@Yë³4h\Áˆg lÉÀˆÌ¨pX°È°p3BÃzöxÊ`W/HoŞ -ö´P',F×Àø’<9H}N@ ‰+?}—<sßMß§]Ì`ÿsIvÓë¤7m¨Ï•j434Ô{§¬úm…"¬	””ıÒÓwğ9ŞOŒ})ÅÚç/Joú¯z_§FóBÇ êˆ¹¹gèŸ¾ƒÀÿ–óQV
+qÁÜÏ—Ì}Îá<¦Ëîco]’İøëI©=ÖĞ\©F³B[ uÆ¢Ì³kğ[å9á
+,ØâŒ
+Óå ¾Ş`ì¼%ÙMïY’İ¸§!«ÑtĞ0H³OÈù³mO{ûS…}ï¸ÑéªÓwA´ŸÃø?{¹mÕÂÌ¦Ç}©Íí¦°GÚÓ şF lñ3Eûûd@p„ßó÷¥@9¾™Gûßœ]÷äÜ¹÷é5iŒh"LIXÛmOD ³@‚È]>¾ö­yBd1€ƒ÷&Şº8³é§ÓS{òº&æ‡v†{¹íjüšÀ½ùøÁ)ºdü…9lî¾c	ğ.ÆÙ¥KZ6½uQzÓ‹¾æ‡&€!Ä¥—¾‰Róîñ‚<_ßÓòÒ¶´
+ï€}rÏEc–.jİô`£¯Ccä@/Ş ¼P8sv
+Ÿá`¬€ÿÒçÁ!‹çD?Ë ğ#ı¤F= 	 ÁØ–[=ÍFîµ`4Æƒ0ÌØWÈĞ½Ëù†îF·OcdC?Ğ`ÌÏ®İà¿Côœ}!€hhŒbhĞĞÅĞ ¡1Š¡	@CcC€†Æ(†& QM £š 44F14hhŒbhĞĞÅĞ ¡1Š¡	@CcC€†Æ(†& QM £š 44F14hhŒbhĞĞÅĞ ¡1Š¡	@CcC€†Æ(†& QŒÿ±iiş¼€Ö    IEND®B`‚
\ Brak znaku nowej linii na koÅ„cu pliku
diff -Naur mplayer-1.0_rc4_p20120109/etc/mplayer32x32.png mplayer-1.0_rc4_p20120109-new/etc/mplayer32x32.png
--- mplayer-1.0_rc4_p20120109/etc/mplayer32x32.png	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/etc/mplayer32x32.png	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,7 @@
+‰PNG
+
+   IHDR           szzô   sBIT|dˆ   	pHYs  ×  ×B(›x   tEXtSoftware www.inkscape.org›î<   tEXtTitle Firewall®®   tEXtAuthor Lapo Calamandreiß‘*  IDATX…Å—mlÇÇ³»wçó;ÄÆ„Ä8`¡ØnÀ7%/mTÅM“ ŠQ5M[õK*¤¶ª‚@ªRUIû‰6i@Q£Fı’¦DD¤jmÒFÊ‹°1¦È6àˆmê»óîÎÌÓw66gÀD‰úH§›ù?¿}™gwÔš5køš÷Yˆ´P·ÖQÎsˆT¢äs£lY;¨?w€“nİ"Ï:;Ôr/ZP‹F¾{w^8áÛÓÑp>ã3æá¢V©ûkU³M¬Š&JN$r"DòŠ‚jhU÷¯˜VNfÖılçÉËOÕ;J¹cı"‚ˆ`-”Š`­`læ_[Á‹»6åÚÈá´ù"ÚFD‹°ÇOëgï¸øj÷òcòÊªee,]TâxîÄ 	ˆ B¦ ’…ËŞË€‚åjÛŒ÷#çÿÛ¡.¬¿!ÀŒDäkµ÷”8—®ø+“îYs8ÖŒ€XÁŠ`,Ù¾L$¬€µ‚ã(¾º|®óŞ¡®Goš‚ü¨ëÆ¢.Rh”¯IfÜéXèM6ÆÚÌõ5?m„ü˜ËŒx„¨±ˆ‹ÂæøËéˆF¥ğ\EÒ7,¹+Ÿ¹Å1ÔÄTÈÚ™káÄ…>h¿BiQ4®Ğªî_ñåì@ÇQXÊKò²ÇóÉ‡-İtvÒÕ7Œ6–9%Ì]ÄƒµåÄcI¥ º,Áş)½-£¯˜œÒq€ı~wwŒ?*ì·Œµ™Ü¡EMxÊîAŞy¿áZ[BcÑÚ00œæøé>vòÔ×k¨Z0 Geã‘oÅNP³¿¶¸ßôÜXÜÆ
+¡|mÇŸ½p™×ÿzmlæi—WPqçíğŸóı¼ûş)Nu|Â¯dË¦û¨©,ÍÄ-»C°6Àk78N$!À¨f‘%Ğ!í‡¼ù÷S¤ıjçóì¦¯P»ø.n+Œ3³0ÎŠª¹lûA=|­/ÿù(©t˜]¸+‚˜Ü8ÙÜœEˆ0ê‡„&^?Ì üóx}ıÿeNÉ}h	J)¶nİJooïU!¥ØôeT”sq`„w?8L.VÚjÎ˜¥E9 Öš_J¤}6–P¾6€ĞŞ5@j4¤~åB”Ê,É¦¦&6nÜÈ®]»‚`â‰Gª	µ¡õì% »M…ŒfhğEı2 Ê;¾+G¬µÍí}'5WÒ!#iˆĞÖÕOz4¤¢¬x|b*•bhhˆ;vĞĞĞ@SS ‹ç•â‡†–OB}5~¢Ä~ç¤®]4iˆ
+1mNñT JœëO¡µ¦­ãÃÉ ™Pp]c‰Db<
+ ô%1Ú "Œ†f¼8 "ñAz'ğĞx ª½–v°‘œ\Y6“T:à£ö«9ïêê¢§§‡Í›7ÓØØÈêÕ«ø¸½­-‹çOÒ06Sº]7Ïdy‹¿dí$ €˜ëş±Øk jÎà¥İ±Ù}¹nİ:ZZZØ¾};yyy@¦T¿´ûà¤9cf­@¶¸‘DÂ¢ËXè6ÑN´õUÌ..àX[7/¾v +ÂŞ½{©¨¨¸ê@„_;À±¶nf°¡¾*'c¦DÀu¾ˆŒL(È²íéUüè…}üş­C:qï¯¿¥÷Ü	@óé^yëCšO÷ ”bÛÓ«(ÈN­)‚ñ‡Sˆİ}} ›[0VÖ”ñÛŸ¬eûÎ4Ÿîá‡Ïÿ%gÌ¬™ùlæAVÖ”]W3éKìíq‹·ÔL@$ób¨«)ãÍ_­ç÷Z8yö­ı ,™_Bõ‚R\]Ea"6iîµšVß[Øq¸&Û?%€ë(¢Ca¾ÇÑÎ¾4¿`üUZ˜ˆñ½Çj§š6É8Ú9Ba¾GÔspŒÂ½…‡'› ê:Ä£.åÅqöŸäí÷ßÔáT–Ès)/‰ºDİ©¿s …CíÅ#.yE.¥EyØ‰ïÔi›"ûĞ( 5"ç¬‰z{öÿ«í±'êkÜ²’‚[t:µõ&Ù½¯ÅD¢Ş’7‚àÇGN·u>nE>“““£”Dİ·ƒ Ørí=5³áG—ç¬å4Æ‹$Pc¹tzĞ†É~øSÄu~ZUxáò­Â¹•••7tG|¤§otFµ	RN$µa
+èBÒÉc¶aéí½¯–Æ®¤oÕ9ÜÂÙğb~ÇS³“ó3:xîI¥8‡5Ï/+¾øÎ§q:Ñ¦•‚ÏÓşÈs¤¬!ÙU3    IEND®B`‚
\ Brak znaku nowej linii na koÅ„cu pliku
diff -Naur mplayer-1.0_rc4_p20120109/etc/mplayer48x48.png mplayer-1.0_rc4_p20120109-new/etc/mplayer48x48.png
--- mplayer-1.0_rc4_p20120109/etc/mplayer48x48.png	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/etc/mplayer48x48.png	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,13 @@
+‰PNG
+
+   IHDR   0   0   Wù‡   sBIT|dˆ   	pHYs  ×  ×B(›x   tEXtSoftware www.inkscape.org›î<   tEXtTitle Firewall®®   tEXtAuthor Lapo Calamandreiß‘*  	êIDAThİZ{pUgÿí9ç>rIHOK›(HZµmŠ¢C;c­3‚¶ÖQ¤øÎ8´cméØ­3v:µ2-Juj…šJ(–G;™ÒæQ!@€$Èë>ÏãÛõsï¹¹ÉMî…„vêÎœœÇ·ßîşv÷Ûïì¹¡õë×ã“LÚÇmÀdéÀø(•µkõuÌøˆ
+Ÿ<UkŠMVæGà„ªŸïèÚ³4èFÀ/ÂÊ°¬M-Îm«kŒı—'#ûšhö×‡|~"mÕ O÷ A f¸‚À·&£ãš­6ªÀ°¨‹ŒÀ£¾‚²=0Í i ‚á/
+ÑƒmR_3=Sc¨_ĞôÅFpZé~€€ä€ DĞıE6#Ï¨»Z}9V?z}ĞĞ~ëÓ´¿ÏĞˆÒc"  q¯Yå „,Åî˜{vï8}ÖËÚ¯G1X(%–vFãÖöÿñÒ¤ ù}øR}U]õ¢223î‚}å^©k$Éä‹xóD †À4ãá®÷9ğÈU¸Tuohq¡ouí’™Ô;‡bÉÊç“6„%'eNó¥x¼3.¡VÏ3ö5u=8) ‹Ì+œ1- †îz^×cSh¤7İƒ#Œ#Ò,äF†€’24À	|:ˆÈ?‘}9}:ùu" C#€ ËfD
+¦Ã‡)ºùÎ"v¨¤çYÜÜw×FúŞåŠ‚:ŠC|º@’’±9{%  À04t "$l+«
+QYÅ)ëÁÉØu‘mŒ…Ñt*‚¦Ó”§åê9ÍÏcĞ5AÓ.ÂÜÒ ˆ42Ÿ™^^Ùù„2ÇR÷jæ"n1àú	”UÂX7íT¿ ó¿MÏßpß: ÏX]Ë›Ê÷”a§ºĞq¶]½C8waAEY*gcÙ‚2,ª(Éª/™2£f/8*ë
+İÁfˆÏÏ#Ë GšN‹˜ic÷h9ÙG1”b8,PŠÑ:|	tôáµ·cmM%øüŒQ)—®@‡Ô_@ø(‘1]Ó!Òt(Gy›à(öjyŠÎõcç­Š˜PÌŞâ”ä¦%â.^ xûı³héèÃæ¯®ÆüÙÓ3lAzÏ ÆèÉ	ÀÿYÓ|e¤ûü)¶£2ª…­Râ]Š%lìx½á˜f†bÁªe•Xñ©9¨ª(RŒÎóı8Òr‡ß?ÅŒ‹ƒQ<óÒ;øå÷î@À¯§1Œ0 ó•€ğùİ2-0L[A±»Å‹lÅ¡ÿÇşvÇÁ"ıøú†U¨]:;Cìu¥E¨«5ÕsñìÎCÛ&z/‡ñ§=àÛ_¾Éãs÷t9V¾\ 2ªA‹rl/XI ©ÃQŒ”ŸNœíÇ»m=°lËVØx—k|4ÅöíÛ‰D2”Õ/¯ÂC÷®…ã0Åh<|§ÎzgqIíŠµyÕ­ùĞä1fËqC'X–ã.Fv¥­Ò¯	-}0m¦í nyj–ÌNÎìŞ½7nÄÁƒ3Şöé…¸¹ºJ1l‡ñ^{/RKE€ÅM¥ÌôBc}ı¸å>c`šzHñlÇ½VÏ´m¯¢8ÊM!·úN÷À´˜–ÂòQicš&º»»±eË<şøã‡ÃŞØÚšù°Ãqí]nC–ÚÍS ¥@D•s˜ßÌ  ‚Ñ'ÁvXØ5¼åä%Å„ãâ–‚íH²:NKpP5g†'CD`š¦w¼òÊ+¸ûî»±oß> ÀÒù3aÛ
+¶£pìôEïµÜñÒÔMUÇQĞŒ‚B?İY1-/ ‹ù¸)PßUV4
+b	qËÁ`ÔÂÅáNõE ”‚R
+ç/¡÷rıÃ1¯L¦(‘HÀ4MX–åœ¬*Ì®ÜpÌD$nAÄ-½	KÁQâ½'Òtæôó¼  @µ¯ùïna•àTN¦½›z‡”p¾o§»ğÁñ^‡™ÑÕÕ…ôööâöÛoÇ={ĞĞĞ  8ÚŞÁpÑ¸……#"7’”ˆ·è¾‚ ˜n³—/Î€+ÁyH™1p7¤lt}ÕLïúÍw:F€D"„B!ìØ±Ï=÷fÌHúï#'ÒÎZTU6Ëˆ4h¾ Ÿ¿Ï@uA[3iø«Iİºbw½³ñ}ìoêtõaÓ¦MhmmÅ†2æ¼º¯oIƒ][S™U¶¸]w¯ûB:ˆëZ¬ê;ó  ZöS ' XS]/Ô¥£ºuûkØßÔ‰éÓ§ãÅ_Ìğ: ¼şv;¶ı®Ñ»¿¯a®¯*Ë*[eqšn‚%£C›°Ğ|³ú!â°È¸|?ŞtŞm;á†ãøÆcÁıëjqçÚ%X¾tl[¡åä4lÇko}èÍ›]V„­_ÿcgõ"UyHNRÌã˜1-ˆ_m^‡ıf/† €]{›±koó¸Ëg„°}Ë:„‚ã¿)ŒN[a9#v~6òy^¶ÆK¡İ|Ãìzâ+¸sõÂœ²îúìRìzò~Ü8Îâ­S„áÄâvôâ°<RSØñÏ‘|9#jÎsQIqOmY‡wZ»q¤åZ;/áø™ËĞtà†å¸qQ9nY>+–ÎÊ)+õ• ¬pOœÏÇÖ¶53ÏæÍ'…@Hwb¹ŞÑ×TW`MuEn±YŒÈÓ“ìûXƒ¬¬)ê8¢ìóòJ!C×à74øu|vEòè•ò'Á»aèğ®®äG«¦°ãø„¶å”N®÷ı†‹µª<„İGûñÒ¡‹Sc}’J}˜;3äéÑ(?åõq×€Û9•ë(/^¥™ùIînÈÀR!+ J¥<Ï|D "QšFf.Ş	ÔZ‹+¼çÀÛïøâg–QeY!|×ˆbAgÏşuàC„—sñçL!3a=üvÓ™§ÿs¨ã.ÑsñOéšfùíe‡ím¹xéj'nî¯˜§ˆK„H›¸÷vâƒâD/&„ğ*3o]UÚÓ;á„+ }É’%W5qVAx¸;1-$u³,ÎŠ€íCg£ÊŠS°ïYUÒû›9£:ıIÒ¤~b
+è‘_Ø‡íXHó…¼ç¢lX‘1¶¢qˆl¾©¬÷¥I[:MjEVÇù¾9t>*Ê‚°;Òg'úOÆÙıZgÿü•×Ğx`
+~ä[Yzaç{ı³K—;Ÿ"‡oè¤ı ¶¤ûìT˜‹®z¦FÓ4ÖÎ”»š²¢şqüü³Çÿ Yæ¹^ç;¸    IEND®B`‚
\ Brak znaku nowej linii na koÅ„cu pliku
diff -Naur mplayer-1.0_rc4_p20120109/etc/mplayer.ico mplayer-1.0_rc4_p20120109-new/etc/mplayer.ico
--- mplayer-1.0_rc4_p20120109/etc/mplayer.ico	2012-01-09 14:47:11.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/etc/mplayer.ico	2012-01-16 15:51:41.000000000 +0100
@@ -1,2 +1,91 @@
-    00     ¨%     (   0   `                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              t#1t#2xt#2ºt#2Ót#2Åt#2t#2/t"3                                                                                                                                                        t#.t#2at#2ï}1?ÿfpÿ°‚Šÿ¦r|ÿ…?Lÿt#2ût#2–s$1                                                                                                                                                    t#2et#2ü©wÿßÙÚÿÿÿÿÿÿÿÿÿÿÿÿÿûøùÿÄ¢©ÿy*9ÿt#2§u#2                                                                                                                                            t#2%t#2ó®‡ÿşşşÿ???ÿiiiÿåååÿÿÿÿÿÿÿÿÿÿÿÿÿÔ»¿ÿu$3şt#2c                            t#2u%4Wcnš¹‘˜¿¾™Ÿ·Ä¡§›Ä¢¨ˆÇ¦¬oË¬²TÃ¡§CÇ§­%Å£©³†ŒKT                                                        t#28Eÿ÷óôÿÿÿÿÿ888ÿ   ÿÿÿîîîÿÿÿÿÿÿÿÿÿ¡jtÿt#2Ôu$3                    t#2Et#2Üu%4ÿ}2@ÿ‚9Fÿ‡@MÿJVÿ“T`ÿš`kÿ¢lvÿªy‚ÿ²…ÿ¶Œ”ú¼•œíÁœ£İÂŸ¦ÌÈ¨®­Ê«°šÌ¯´ƒÒ¸½gÎ±·VÔ¼Á8Ğ´¹&¿š¡¯€‡            t#3t#2Ñ¬|…ÿÿÿÿÿÿÿÿÿ888ÿ   ÿ   ÿ   ÿÿ’’’ÿöööÿÓº¿ÿt#2ût#2                 u%4KNZùŸgrÿ isÿ isÿ isÿ isÿ isÿ isÿ isÿ¡jtÿ¡kuÿ£nxÿ¦r{ÿ©wÿ­~‡ÿ²…ÿ¸–ÿ½—ÿÃŸ¦ÿÈ¨®ÿÎ±¶ÿÓ¹¾ÿ×ÀÄıÜÈÌ÷àÎÑîáÏÒßçÚÜÁéÜŞ­âÑÔ›t$3ö¹‘˜ÿÿÿÿÿÿÿÿÿ888ÿ   ÿ   ÿ   ÿ   ÿ   ÿGGGÿàÒÔÿt#2ÿt#2;            Ôº¾âÑÔêÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿüûûÿ…=Jÿ·•ÿÿÿÿÿÿÿÿÿ;;;ÿ   ÿ   ÿ   ÿÿ†††ÿöööÿßÌÏÿt#2ÿt#2.            ıüı•ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿŸhrÿ“T`ÿşııÿÿÿÿÿ;;;ÿ   ÿÿbbbÿãããÿÿÿÿÿÿÿÿÿ¹‘˜ÿv%3ï~/.        ÿÿÿÿÿÿŞÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÒ¸½ÿu%3ÿÖ¾Ãÿÿÿÿÿ;;;ÿ???ÿÉÉÉÿÿÿÿÿÿÿÿÿÿÿÿÿóìíÿ4Bÿ¨rmıç«t        ÿÿÿÿÿÿæÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıüüÿfpÿ~2AÿŞËÎÿËËËÿıııÿÿÿÿÿÿÿÿÿÿÿÿÿñéêÿ’S^ÿƒ;HÿğãØÿç«úç§4    øç½
-ÿşüëÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿöğñÿ—Zeÿw(7ÿªx‚ÿ×¿ÄÿèÚİÿŞÌÏÿº‘™ÿ€6Dÿ‚9FÿäÔ×ÿıøìÿç«ÿæ¨£    ÷ã±şüøùÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿûùùÿÂŸ¥ÿˆBOÿt#2ÿt#2ÿt#2ÿ~3Aÿ¯€‰ÿñéëÿÿÿÿÿıøìÿè®ÿí¿Mâ    øå·&şıøÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿüûûÿìàãÿßÌÏÿæ×Úÿùö÷ÿÿÿÿÿÿÿÿÿÿÿÿÿıøìÿé°!ÿòÑ~÷    öà©Hşü÷ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıøìÿé³*ÿóÕ‰æ    øä²_şüöÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ×××ÿÙÙÙÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıøìÿê·3ÿôÙ“Ä    öß¦şûôÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ444ÿ___ÿ©©©ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıøìÿì»?ÿôÚ—¯    öß¦˜şûóÿÿÿÿÿÿÿÿÿıüüÿŞËÏÿóìíÿÿÿÿÿğçèÿáĞÓÿÿÿÿÿşşşÿàÍÑÿñéëÿîäæÿáÏÒÿÿÿÿÿÿÿÿÿÿÿÿÿóóóÿÄÄÄÿïïïÿşşşÿÎÎÎÿåååÿìììÿĞĞĞÿñññÿÿÿÿÿ{{{ÿÛÛÛÿÿÿÿÿÿÿÿÿöööÿÄÄÄÿâââÿÿÿÿÿïïïÿÙÙÙÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıøìÿíÀMÿöŞ£    õÛ›ºşúñÿÿÿÿÿÿÿÿÿıüıÿ†?LÿÁ£ÿÿÿÿÿ¥qzÿx*8ÿòêëÿ÷òóÿx*8ÿÖ¿Ãÿ¼”œÿ†?Lÿÿÿÿÿÿÿÿÿÿÿÿÿÿ!!!ÿ¨¨¨ÿÿÿrrrÿ:::ÿ>>>ÿÈÈÈÿÿÿÿÿ^^^ÿXXXÿÿÿÿÿüüüÿAAAÿCCCÿ{{{ÿœœœÿÁÁÁÿÿşşşÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıùíÿîÅ[ÿöß¤wúîËõÚ—Ğıúğÿÿÿÿÿÿÿÿÿÿÿÿÿœcmÿ©v€ÿøôõÿ~2@ÿu$3ÿÇ¦¬ÿäÔ×ÿu%4ÿíâäÿ¼”œÿ†?Lÿÿÿÿÿÿÿÿÿÿÿÿÿ¬¬¬ÿ---ÿşşşÿfffÿRRRÿÿÿÿÿzzzÿ```ÿÿÿÿÿıııÿ'''ÿJJJÿÚÚÚÿêêêÿ			ÿÖÖÖÿÿÿÿÿøøøÿëëëÿÿàààÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıùîÿğÊjÿ÷ã±Võß¦óÖêıùîÿÿÿÿÿÿÿÿÿÿÿÿÿµ‰‘ÿP\ÿÓ¹¾ÿ|/>ÿ¤pyÿ˜[fÿÌ®´ÿ€5Cÿú÷øÿ¼”œÿ‚9FÿáÏÒÿôîïÿÿÿÿÿÜÜÜÿÿîîîÿ‰‰‰ÿ???ÿÿÿÿÿ©©©ÿ333ÿÿÿÿÿêêêÿÿĞĞĞÿoooÿ÷÷÷ÿÿ```ÿQQQÿÿÿÿÿÿ'''ÿ©©©ÿşşşÿÿÿÿÿÿÿÿÿÿÿÿÿıùïÿñÏyÿ÷á«>øç¼óÓ„ûıøíÿÿÿÿÿÿÿÿÿÿÿÿÿÍ°µÿy,:ÿ¢mwÿ¡jtÿİÉÍÿv&5ÿ¦s|ÿ’S_ÿÿÿÿÿ¼”œÿu$3ÿw(6ÿy,:ÿÕ¼Àÿ÷÷÷ÿÿËËËÿëëëÿ!!!ÿÃÃÃÿÃÃÃÿÿôôôÿ®®®ÿÿùùùÿeeeÿÊÊÊÿ›››ÿ[[[ÿàààÿÿéééÿGGGÿIIIÿ„„„ÿtttÿÿÿÿÿÿÿÿÿşúğÿóÔˆÿøã± öá­,ñÏwÿıøëÿÿÿÿÿÿÿÿÿÿÿÿÿäÕØÿu$3ÿv'6ÿÏ³¸ÿüûûÿ„=Jÿv'6ÿªy‚ÿÿÿÿÿ¼”œÿ„<Jÿïæèÿfqÿš_jÿÿÿÿÿ===ÿ›››ÿÿÿÿÿŞŞŞÿ|||ÿ{{{ÿtttÿÌÌÌÿ„„„ÿ˜˜˜ÿÿÿÿÿÎÎÎÿˆˆˆÿıııÿ»»»ÿÿšššÿßßßÿŠŠŠÿ¢¢¢ÿ“““ÿÿÿÿÿÿÿÿÿÿşúñÿôØ’ø÷å´øä´EğÉhÿı÷êÿÿÿÿÿÿÿÿÿÿÿÿÿ÷óôÿz,:ÿ{/=ÿöñòÿÿÿÿÿ±ƒ‹ÿt#2ÿÂ¤ÿÿÿÿÿ¼”œÿ}2@ÿº’™ÿ†?Lÿ¦r|ÿÿÿÿÿlllÿkkkÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşûóÿõÜœãöâ­öá«dîÄYÿı÷èÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿš`kÿ¬|…ÿÿÿÿÿÿÿÿÿâĞÔÿ‰DPÿİÊÍÿÿÿÿÿÆ¤ªÿ‰DQÿJVÿ£nxÿğçéÿåååÿMMMÿDDDÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşûôÿöß¥Ì    öß¦í¿Jÿı÷çÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿöööÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşûõÿ÷á«²    õİŸœëº=ÿı÷çÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşüöÿøå·“    ôÚ–¹êµ0ÿı÷çÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşü÷ÿøæ¹|    ô×Ñé²&ÿı÷çÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşıùÿúìÉ[    ñÍtÆè¯ÿı÷çÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşıúÿùêÃE    è¯‘ç«ÿı÷çÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşûşüóİ%    æ§0æ©úıöçÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşûúûñÙ        æ§	†úïÒşÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿú÷÷ãûğÖ        æ¨øæ¹ŒÿÿÿşÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşşÿÌ¯´®                üöæÿÿÿfÿÿÿÚÿÿÿ÷ÿÿÿøşşşüşşşşşşşÿşışÿşııÿşııÿıüıÿıüüÿıüüÿıûüÿüûûÿüûûÿüúúÿüúúÿûùúÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûùùÿûøùÿìáãÿ°‚Šşx)7L                            ÿÿÿáÏÒÑ·¼!áÎÒ0ŞËÎGØÂÆcİÉÌsÔ»À’Óº¿¦Ğ´¹½Ê¬±ÙÉª°çÃ §ô½—ı¸–ÿ°‚Šÿ¨u~ÿ isÿ˜\gÿ‘R]ÿ‹HTÿ†?Lÿ8Fÿ}2@ÿz-<ÿx*8ÿw(6ÿv'5ÿv&5ÿv&5ÿv&5ÿv&5ÿv&5ÿv&5ÿv&5ÿv&5ÿv&5ÿu%4ÿt#2ÿt#2¦u"0                                                                        ´‡ŒÂ¥Óº¾Ñ·¼3Î²·PÔ¼À`Í°¶~Ì¯´“Ê«±©Å£©ÆÄ¡§Õ¾˜Ÿëº‘™ú¶‹“ÿ®ˆÿ¦r|ÿepÿ—ZeÿO[ÿ‰EQÿ„<Jÿ5Bÿ|/=ÿx*9ÿv'5ÿt$3ÿt#2şt#2¢t"3	                                                                                                                    –Wc¶Œ“	É©¯Áœ¤ Ã §<Í°µNÇ§­kÇ¦¬Å¤ª•Àœ¢²¿š Äº’™à·Œ”÷±„ş—[fçv&5ªt#2Dt"2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿğ  ÿÿÿÿÀ  ÿÿÿÿÀ  ÿÿÿÿ€  ø ÿ€  ğ     à      À      À      €      €       €       €       €       €       €       €       €       €                                                                                                       €      €      À      ø      ÿÿ     ÿÿÿÀ   ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  
\ Brak znaku nowej linii na koÅ„cu pliku
+         h  f          Î       ˆ	  Ş         ¨  f  00     ¨%  '         WI  ¶L  (                                     ™M&˜W)œ–T'õ•R%û•R%û•R%û•R%û•R%û•R%û•R%û•R%û•R%û•R%û–T(õ˜W*’U$˜W)œ°{TúÛ¼ ÿê×ÄÿìÙÆÿëÙÆÿëÙÆÿëÙÆÿëÙÆÿëÙÆÿëÙÆÿìÙÆÿëØÆÿÛ¾¢ÿ³Wû™X*–T'õØ¸šÿÙ¶“ÿÏ rÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÏ rÿÙ¶“ÿÚ»ÿ–T'õ•R%ûİ½ŸÿÏ sÿàÎ»ÿìîíÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîíÿàÎ»ÿÏ sÿİ½Ÿÿ•R%û•R%ûİ¾¡ÿÌ˜hÿìîîÿìîîÿáÜØÿªƒgÿX2ÿX2ÿªƒgÿáÜØÿìîîÿìîîÿÌ˜hÿİ¾¡ÿ•R%û•R%ûŞÁ¥ÿÌ˜hÿìîîÿáÜØÿ’[5ÿÈ¬˜ÿòëçÿòëçÿÈ¬˜ÿ’[5ÿáÜØÿìîîÿÌ˜hÿŞÁ¥ÿ•R%û–R%ûàÄªÿÌ˜hÿìîîÿªƒgÿÈ¬˜ÿÿÿÿÿUUUÿêêêÿÿÿÿÿÈ¬˜ÿªƒgÿìîîÿÌ˜hÿàÄªÿ–R%û˜S&ûâÈ®ÿÌ˜hÿìîîÿX2ÿòëçÿÿÿÿÿÿÿ¬¬¬ÿòëçÿX2ÿìîîÿÌ˜hÿâÈ®ÿ˜S&û¢b5ûæÑ¼ÿÔ©ÿğññÿ¨|^ÿõïìÿÿÿÿÿ000ÿ<<<ÿ···ÿôîêÿœjIÿíïïÿÎœoÿäÌ´ÿšV'û¹‡düìÜÌÿÛ¶”ÿòóóÿÂ¦“ÿ×Ã´ÿÿÿÿÿ~~~ÿïïïÿÿÿÿÿÒ»ªÿ·–~ÿîğğÿÑ£wÿçÑ½ÿ¡]/ûÀ’rüïáÔÿŞ½ÿóôôÿëèæÿ¶’xÿÙÆ¹ÿöñîÿöğíÿÕÀ±ÿª~aÿçâßÿïññÿÓ¥|ÿéÖÃÿ¥d6ûÆ›~ıñäØÿâÄ©ÿôõõÿôõõÿíéçÿÈ¯ÿµvÿ²ŠpÿÁ¥ÿèäáÿğòòÿïñğÿÔ§ÿêÖÄÿ¨g:ûÊ „ıòæÛÿæÎ·ÿîäÙÿôõõÿôõõÿóôôÿòôôÿòóóÿñóóÿñòòÿğòñÿåÕÅÿÖ®ˆÿê×Åÿ«i;ûÃ“qøïàÒÿéÕÀÿãÇ­ÿáÂ¥ÿß¿¡ÿŞ¼ÿİºšÿÛ·•ÿÚ´‘ÿØ±Œÿ×­‡ÿ×°‹ÿßÀ¢ÿçÑ¼ÿ«h8ö½ˆa­ØµœüíİÎÿğâÔÿğáÓÿïáÒÿïßÑÿîßÏÿíŞÎÿíİÌÿìÛÊÿìÚÈÿëÙÇÿçÑ¼ÿÈšvü¬i9 º€X¼‚[«¿†_÷ÁgüÀ‹füÀŠdü¾‡aü½„\ü»Xü¹|Sü·xNüµuJü²qDü°l<ö®i7¡®].                                                                (      ,                                                          `3ra6Úa5»`5jUU                                                                 a5£d7ô|DÿyCÿh:ó`6ß^5D                                            €@@—S$i™X,Ş•R$ü”R$ÿ•R%ÿ•R%ÿ•R%ÿ•R%ÿ•R$ÿ”R$ÿ•R$ş•R$ü•R%û•R%û™X,Ş•S#l™f3                –R$p¤i?õÑ¬ÿêÕÃÿìÙÇÿìÙÇÿìÙÇÿìÙÇÿìÙÇÿìÙÇÿìÙÇÿìÙÇÿìÙÇÿìÙÇÿêÔÂÿÒ®ÿ§kCõ—S&q                —W)åĞ¬ÿÛº™ÿÑ¥{ÿÎoÿÍœnÿÍœnÿÍœnÿÍœnÿÍœnÿÍœnÿÍœnÿÍœnÿÎoÿÑ¥{ÿÛº™ÿÒ¯ÿ™W)å                ”Q#ÿßÁ£ÿÏ¡tÿİÆ°ÿêèäÿêéåÿêéåÿêéåÿêéåÿêéåÿêéåÿêéåÿêéåÿêèäÿİÆ°ÿÏ¡tÿßÁ£ÿ”Q#ÿ                ”Q#ÿŞÀ¢ÿË—eÿìíìÿìîîÿìîîÿÙĞÉÿ¯ŠpÿšiGÿšiGÿ¯ŠpÿÙĞÉÿìîîÿìîîÿìíìÿË—eÿŞÀ¢ÿ”Q#ÿ`7Ÿ            ”Q#ÿàÃ¦ÿË—eÿìîîÿìîîÿÄ­œÿŠO&ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿŠO&ÿÄ­œÿìîîÿìîîÿË—eÿàÃ¦ÿ”Q#ÿe8ôa5t        ”Q#ÿáÅªÿË—eÿìîîÿÙĞÉÿŠN%ÿ‡J ÿº—~ÿçÜÓÿçÜÓÿº—~ÿ‡J ÿŠN%ÿÙĞÉÿìîîÿË—eÿáÅªÿ”Q#ÿ~Eÿ`5ç    ^5D•R#ÿâÈ­ÿË—eÿìîîÿªƒhÿ‡J ÿ¹–~ÿÿÿÿÿ[[[ÿåååÿÿÿÿÿ¹–~ÿ‡J ÿªƒhÿìîîÿË—eÿâÈ­ÿ•R#ÿ{Dÿa5ÍUU a6à—R$ÿäÊ±ÿË—eÿìîîÿ”a=ÿ‡J ÿìãÜÿÿÿÿÿÿÿŠŠŠÿçŞØÿ‡J ÿ”a=ÿìîîÿË—eÿäÊ±ÿ—R$ÿk;õ_5^4lg9ôœX+ÿçÑ»ÿÑ¤xÿïññÿ§{]ÿŸoMÿóíêÿÿÿÿÿ...ÿ,,,ÿ~~~ÿãŞÚÿ•_9ÿ›jHÿíïïÿÌšiÿåÎ¶ÿ™S$ÿ`5ìf3
+b6ÃzCÿµ‚_ÿíİÌÿÙ´ÿñóóÿÀ¢ÿ§{\ÿÓ¼¬ÿÿÿÿÿiiiÿØØØÿÿÿÿÿÍ´¢ÿ™fBÿ³wÿîğğÿÏ rÿèÓ½ÿZ,ÿ]4X    `5â~Eÿ¼ŒlÿïáÓÿİº™ÿòôôÿâÙÒÿ¯†iÿ®…hÿ×ÃµÿöòîÿöòîÿÔ¾¯ÿ¢sRÿmKÿÛÏÇÿïğğÿÑ£wÿéÖÂÿ¢`3ÿ        _5g9òÃ–wÿñäØÿàÁ£ÿôõõÿóõõÿÓÁ´ÿ²‹pÿ¯‡kÿ­ƒfÿªaÿ§z[ÿ¤uUÿÈ° ÿğññÿïññÿÒ¥zÿëØÅÿ¦c6ÿ        €  a5³Ç€ÿòæÛÿãÇ¬ÿõöõÿôõõÿôõõÿãÚÔÿÄ¨”ÿ´tÿ±‰nÿ¼†ÿİÒÊÿğòòÿğññÿïñğÿÓ¦{ÿëØÆÿ©f:ÿ                ÉÿòçÛÿåÌ³ÿïæİÿôööÿôõõÿóõõÿóôôÿòôôÿòóóÿñóóÿñòòÿğòòÿğññÿæØÊÿÕ­†ÿëØÆÿªg:ÿ                Æ˜wòìÜÍÿèÒ¼ÿâÆªÿàÂ¦ÿàÁ¤ÿß¿¡ÿŞ½ÿİ»›ÿÜ¸—ÿÛ¶“ÿÙ³ÿØ±‹ÿÖ­†ÿÖ®‡ÿŞ¼ÿäÌ¶ÿ®k;ì                Ã‘q•Ô±–ûëÚËÿğáÓÿïáÒÿïàÑÿïßĞÿîßÏÿíŞÎÿíÜÌÿíÛÊÿìÛÉÿìÙÇÿëØÆÿëØÅÿåÎ¹ÿÄ’nú®i9                Ä‰bÂi–ÃiòÄkıÃküÂiıÁŒfş¿‰cÿ¾†`ÿ¼ƒ]ÿ»Yÿ¹}Uÿ·zPÿ´vKÿ³sFü²nAï°j;‡³f3
+                        ÿ  ¹‹]¹‹]¹‹]¹‹]j>!^c8ìn=õ~Fÿ‚H ÿk=ôe9¸ªq9	ÿ                                                          U9	_5a5Ó_5î`4…€                          şü üü À  À  À  À  À  À   À   €                       À  À  À  À  ğ < ÿÀü (      0                                                                                                                                                          €  _4„a5èb6Ì_5|`@                                                                 ÿ  Ÿ` d8³i9ô€Gÿ}Eÿm<ôb5ëd6YŸ` Ÿ` Ÿ` Ÿ` ÿ                                  Ÿ` •U'{—W+ê”S%ı”S%ÿ•S%ÿ•S%ÿ•S%ÿ•S%ÿ”S%ÿ”S%ÿ•S%ş”S%ı•S%ü•S%ü˜W*ë•T&U	                        –T'w¨nEöÕ´—ÿëØÆÿíÜËÿíÜËÿíÜËÿíÜËÿíÜËÿíÜËÿíÜËÿíÜËÿíÜËÿíÜËÿëØÆÿÖµ™ÿ©qH÷—U&x                        ˜W)èÒ°ÿÛ¸–ÿÏ¡uÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿÏ¡uÿÛ¸–ÿÓ°’ÿ˜W*è                        ”Q#ÿßÁ¤ÿÎ sÿßË·ÿìííÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìííÿßË·ÿÎ sÿßÁ¤ÿ”Q#ÿ                        ”Q#ÿŞÀ¢ÿË—eÿìííÿìîîÿìîîÿ×ÌÃÿ©€dÿ”_:ÿ”_:ÿ©€dÿ×ÌÃÿìîîÿìîîÿìííÿË—eÿŞÀ¢ÿ”Q#ÿa6°                   ”Q#ÿàÃ¦ÿË—eÿìîîÿìîîÿ¿¤‘ÿ‰L#ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‰L#ÿ¿¤‘ÿìîîÿìîîÿË—eÿàÃ¦ÿ”Q#ÿg9ô`5}                ”Q#ÿáÅªÿË—eÿìîîÿ×ÌÃÿ‰L#ÿˆL"ÿÀ ŠÿîåàÿîåàÿÀ ŠÿˆL"ÿ‰L#ÿ×ÌÃÿìîîÿË—eÿáÅªÿ”Q#ÿFÿ`5è            _4N•R#ÿâÈ®ÿË—eÿìîîÿ©€dÿ‡J ÿÀ ŠÿÿÿÿÿKKKÿÚÚÚÿÿÿÿÿÀ Šÿ‡J ÿ©€dÿìîîÿË—eÿâÈ®ÿ•R#ÿ{Dÿa6Ë        U++`5æ—S$ÿäÊ±ÿË—eÿìîîÿ”_:ÿ‡K!ÿîæáÿÿÿÿÿÿÿ{{{ÿãÚÕÿ‡J ÿ”_:ÿìîîÿË—eÿäÊ±ÿ—S$ÿi;ô^6w        a5tj:õ\.ÿèÒ¼ÿÒ¥zÿïññÿ©aÿ¡qPÿòêæÿÿÿÿÿ///ÿ000ÿŒŒŒÿçßÛÿ•_:ÿmLÿíïïÿÍšjÿåÎ¶ÿ™T$ÿ`5çm$$        b6Æ{Cÿ¶ƒ`ÿíİÌÿÚ´ÿñóóÿÁ£ÿ¨|]ÿÑ¹©ÿÿÿÿÿuuuÿâââÿÿÿÿÿË±ŸÿšfCÿ´‘yÿîğğÿÏ rÿèÓ½ÿŸ[-ÿ^4O            `5â~Eÿ½mÿğáÓÿİºšÿòôôÿäİ×ÿ°‡kÿ­„gÿÓ¼­ÿóìéÿòìèÿÏ¶¦ÿ¡rQÿŸnLÿŞÔÍÿïğğÿÑ£wÿêÖÃÿ¢`3ÿ                _5tf8òÃ–xÿñäØÿàÁ£ÿôõõÿóõõÿ×Ç»ÿ´rÿ¯‡kÿ­ƒgÿªaÿ§z[ÿ¥wXÿÍ·¨ÿğññÿïññÿÒ¥zÿëØÅÿ¦c6ÿ                    `6¢ÈÿòæÛÿãÇ¬ÿõõõÿôööÿôõõÿçàÛÿÈ®ÿ¸•|ÿµ‘wÿÁ¤ÿáÙÒÿğòòÿğññÿïğğÿÓ¦{ÿëØÆÿ©f:ÿ                        É€ÿòæÛÿåÌ³ÿîãØÿôõõÿôõõÿóõõÿóôôÿòôôÿòóóÿñóóÿñòòÿğòòÿğññÿåÔÃÿÕ®†ÿëØÆÿªg:ÿ                        Æ—wîìÛÌÿèÓ¾ÿâÆ«ÿàÀ¢ÿß¿ ÿŞ½ÿİºšÿÜ¸–ÿÚ¶’ÿÙ³ÿØ°ŠÿÖ­†ÿÕ«‚ÿÖ°‰ÿß¿¡ÿãÊµÿ­j;é                        ÂoÒ­“úê×ÇÿïáÓÿïáÓÿïáÓÿïàÑÿîßĞÿîŞÏÿíİÎÿíİÌÿìÛËÿìÚÉÿëÙÇÿëØÆÿãËµÿÂkø«i8z                        ¿Ÿ€Äm…ÂŒhéÁŒgüÀ‹füÀ‰dı¿ˆaş¼…^ÿ¼‚[ÿº€Xÿ¹}Tÿ·yPÿµvKÿ²rFÿ±oAü±n@ä®j9tªU+                                                    ]2G`5ág9ôzCÿ~Eÿe8ôa6«                                                                        @@ _5na6Ã`5á_4{                                                                                                                               ÿÿÿ şÿ ø  à  à  à  à  à  à  à  À  €  €  €  €  €  À  à  à  à  à  ÿÀ ÿà ÿÿÿ (       @                                                                                                                                                                                                      @@ a5‘a5èa6Ê^4O                                                                                                            a6¦i9ôFÿyCÿc6ôa5Æ_5+                                                                                                `55b6ô…I ÿ‡J ÿ‡J ÿ†J ÿuAıa6öa6›c9                                                                    ’R$˜X*©•R%û”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ•R%û˜X*©’R$                                ˜X*«µ„^üâÉ±ÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿîİÍÿãÌ´ÿµ„^ü˜X*«                                ”R%ûİÀ¥ÿàÃ¨ÿàÃ§ÿàÃ§ÿàÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿßÂ¥ÿàÂ¥ÿàÃ§ÿàÃ§ÿàÃ¨ÿİÀ¥ÿ”R%û                                ”Q#ÿáÅªÿİ¾ŸÿØ´‘ÿÏ sÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÌ˜hÿÏ sÿØ´‘ÿİ¾ŸÿáÅªÿ”Q#ÿ                                ”Q#ÿßÂ¤ÿÚ¸–ÿÏ¡sÿàÍºÿìîíÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîíÿàÍºÿÏ¡sÿÚ¸–ÿßÂ¤ÿ”Q#ÿ                                ”Q#ÿŞÀ¡ÿØ´ÿË—eÿìííÿìîîÿìîîÿìîîÿåãàÿº‰ÿ¤z]ÿY3ÿY3ÿ¤z]ÿº‰ÿåãàÿìîîÿìîîÿìîîÿìííÿË—eÿØ´ÿŞÀ¡ÿ”Q#ÿh96                            ”Q#ÿßÂ¤ÿØ´ÿË—eÿìîîÿìîîÿìîîÿĞÁµÿ‘[5ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‘[5ÿĞÁµÿìîîÿìîîÿìîîÿË—eÿØ´ÿßÂ¤ÿ”Q#ÿn=õm=¨€@                     ”Q#ÿàÄ§ÿØ´ÿË—eÿìîîÿìîîÿĞÁ¶ÿˆK!ÿ‡J ÿ¡qPÿØÅ·ÿòìçÿòìçÿØÅ·ÿ¡qPÿ‡J ÿˆK!ÿĞÁ¶ÿìîîÿìîîÿË—eÿØ´ÿàÄ§ÿ”Q#ÿ†I ÿtAõo>‘                    ”Q#ÿáÅªÿØ´ÿË—eÿìîîÿæäâÿ“]7ÿ‡J ÿ¿ˆÿşşıÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşşıÿ¿ˆÿ‡J ÿ“]7ÿæäâÿìîîÿË—eÿØ´ÿáÅªÿ”Q#ÿ‡J ÿƒHÿq?ç                wD"”Q#ÿâÇ­ÿØ´ÿË—eÿìîîÿ»ŸŠÿ‡J ÿ¢rRÿşşıÿÿÿÿÿLLLÿİİİÿÿÿÿÿÿÿÿÿÿÿÿÿşşıÿ¢rRÿ‡J ÿ»ŸŠÿìîîÿË—eÿØ´ÿâÇ­ÿ”Q#ÿ‡J ÿ€Fÿr@Ä                tA•–R#ÿãÉ¯ÿØ´ÿË—eÿìîîÿ¤z]ÿ‡J ÿÛÈ¼ÿÿÿÿÿÿÿÿÿ   ÿÿÿ÷÷÷ÿÿÿÿÿÿÿÿÿÛÈ¼ÿ‡J ÿ¤z]ÿìîîÿË—eÿØ´ÿãÉ¯ÿ–R#ÿ‡J ÿuAôq@H            rC&vAö—S$ÿäË²ÿØ´ÿË—eÿìîîÿ“^9ÿS*ÿôîëÿÿÿÿÿÿÿÿÿÿ"""ÿÿ888ÿ¹¹¹ÿÿÿÿÿóîêÿ‰N$ÿ‘Z5ÿìîîÿË—eÿØ´ÿäË²ÿ—S$ÿGıvAÀ                xBÀGı[.ÿèÑ¼ÿŞ¿ ÿÕ«ƒÿğòòÿ©aÿ¢rRÿõğìÿÿÿÿÿÿÿÿÿ222ÿ///ÿ---ÿFFFÿ¿¿¿ÿÿÿÿÿôîêÿ”^8ÿšiFÿíïïÿÎœmÿÙ¶“ÿåÍµÿ˜S$ÿvBöyC&            xCHyDô‡J ÿµ^ÿìÜËÿãÈ®ÿÙ´ÿñóóÿ½‰ÿ§z[ÿâÔÊÿÿÿÿÿÿÿÿÿ<<<ÿ???ÿšššÿùùùÿÿÿÿÿÿÿÿÿŞÎÂÿ—c?ÿ¯ŠqÿîğğÿÏ rÿÛ¹—ÿçÑ»ÿY+ÿxC•                {EÅƒHÿ‡J ÿ¹ˆgÿîßÏÿäÌ³ÿÜ¸–ÿòóóÿĞ½¯ÿ¬‚eÿ½œ…ÿşşşÿÿÿÿÿ|||ÿæææÿÿÿÿÿÿÿÿÿÿÿÿÿşşıÿ²ŠoÿšgDÿÅ­›ÿîğğÿÑ¢uÿÛºšÿéÔ¿ÿ ^0ÿwD"                |Eè†IÿˆK ÿ¾oÿğâÔÿæÏ¸ÿŞ½ÿóôôÿïîìÿ¹–}ÿ°ˆlÿÔ¾¯ÿşşşÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿşşıÿÍ³¢ÿŸnMÿ¦z[ÿêèçÿïğğÿÒ¤xÿÜ¼œÿêÖÃÿ¤`4ÿ                    ~GGôˆK!ÿÃ–wÿñä×ÿèÒ¼ÿàÁ£ÿôõõÿôõõÿâÙÒÿµuÿ³ŒqÿÂ£ÿä×ÍÿöñïÿöñîÿâÔÊÿ¹–~ÿ¤uUÿ¢rQÿÙÍÄÿïññÿïññÿÒ¥zÿİ½ÿë×Åÿ¥c5ÿ                    €@ €G¦€HöÆœ~ÿòæÚÿéÕÁÿâÅªÿôööÿôõõÿôõõÿãÚÔÿ½œ…ÿ³rÿ±‰nÿ¯†iÿ¬‚eÿªaÿ§{\ÿ®†iÿÛÏÇÿğòòÿğññÿïññÿÓ¦{ÿİ½ÿëØÅÿ§e7ÿ                            ‚H5ÈÿòæÛÿê×ÃÿäÊ°ÿõöõÿõööÿôööÿôõõÿğïîÿÕÄ·ÿÄ©—ÿµ‘xÿ³tÿ¿¢ÿÎ¹ªÿìëéÿğòòÿğòòÿğññÿïğïÿÓ¦|ÿİ¾ÿëØÅÿ©f9ÿ                                ÈÿòæÚÿéÕÁÿåË²ÿíâ×ÿôõôÿôõõÿôõõÿóõõÿóôôÿóôôÿòôôÿòóóÿòóóÿñóóÿñòòÿğòòÿğòòÿğğğÿäÔÃÿÖ®ˆÿİ½ÿëØÅÿªf8ÿ                                Æ˜yÿñåØÿèÒ½ÿçÎ·ÿãÇ­ÿàÁ£ÿàÀ¢ÿß¿ ÿŞ½ÿİ»›ÿÜº˜ÿÜ¸–ÿÚ¶“ÿÙ´ÿØ²ÿ×°ŠÿÖ®‡ÿÕ¬„ÿÔ©€ÿ×°ŠÿÜ¹—ÿİ½ÿë×Åÿªf7ÿ                                Ã’oüîßÑÿçÑ»ÿæÏ¸ÿæÏ¸ÿæÏ¸ÿæÏ¸ÿåÎ¶ÿåÍµÿåÌ´ÿäË²ÿãÊ±ÿãÉ®ÿâÇ­ÿáÆ«ÿáÄ¨ÿàÃ§ÿßÂ¤ÿŞÀ¢ÿŞ¿ ÿİ½ÿŞ¿ ÿèÒ¾ÿ¬f6û                                ¾‡b¹Ú¸ŸıîŞÏÿğáÓÿğáÓÿğáÓÿïáÓÿïáÒÿïàÑÿïßÑÿïßĞÿîßÏÿîŞÎÿíİÍÿíİÌÿíÜËÿìÛÊÿìÚÉÿìÚÇÿëÙÆÿëØÅÿèÒ¾ÿË|ı¬f7¬                                ¿€X ¾„\·¿ˆaüÀ‰cÿÀ‰cÿÀ‰cÿ¿ˆbÿ¾‡aÿ¾…_ÿ½„]ÿ¼‚[ÿ»€Xÿº~Vÿ¹|Rÿ·yOÿ¶wKÿµuIÿ³rEÿ²oAÿ°l>ÿ¯i:ÿ®h7û®g6«ª^/                                                                    ˆD"€F•HöN!ı—S$ÿ˜S$ÿ—R$ÿ•R$ÿ‚Hó‚H5                                                                                                €J&‚HÀƒHôN"ÿ’P#ÿ†JôH¦                                                                                                            €GH‚HÄGè€H‘€@                                                                                                                                                                         ÿÿÿÿÿÁÿÿÿÀÿÿ€ÿğ  ğ  ğ  ğ  ğ  ğ  ğ  ğ  ğ  à  à  À  À  €  €  €  €  €  à  ğ  ğ  ğ  ğ  ğ  ÿøÿÿşÿÿÿƒÿÿÿÿÿ(   0   `                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      @@                                                                                                                                                                                         _5i_4ù`5õ`4¯a5                                                                                                                                                                        ^5Wb6ôGÿƒHÿq>ú_5öa6„f3
+                                                                                                                                                            U9	_5ë}Eÿ‡J ÿ‡J ÿ‡J ÿ‚Gÿk;õ`5ì_4Y                                                                                                                                                        a6„k;õ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ}Eÿe8ôb6Ñ]64                                                                                                                                            a5b6õ‚Hÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿwAşb6öb7§`5                                                                                                            ’P$#šX+°•R$ü”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ”Q#ÿ–S&ù˜W+¡’U$                                                                ˜X+½¹‹fşáÇ®ÿìÚÉÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿîŞÎÿíÜËÿŞÃ©ÿ±~Xú—W(˜                                                            ™M
+–U'úàÅ¬ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ«ÿâÆ¬ÿÚ» ÿ—V(ğ                                                            P ˜V)øãÈ­ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿàÂ¥ÿŞÁ¦ÿ–T&÷                                                            P ˜V)øáÅ©ÿİ¾Ÿÿİ¾ŸÿØ´ÿÎ sÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿË—eÿĞ¢wÿÚ¶“ÿİ¾Ÿÿİ¾ŸÿÜ¿¢ÿ–T&÷                                                            P ˜U)øàÃ¦ÿÛº™ÿÛº™ÿÎŸqÿàĞ¾ÿìîíÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿëíìÿİÆ¯ÿĞ£xÿÛº™ÿÛº™ÿÜ½ ÿ–T&÷                                                            P ˜U)øŞÀ¢ÿÙ¶“ÿØ´ÿÌšjÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿêèäÿÍšjÿÙ¶“ÿÙ¶“ÿÛ»ÿ•S&ık<&                                                        P —U)øŞÀ¡ÿØ´ÿ×²ÿÍ›kÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿÒÃ¸ÿ¶—ÿ¢uVÿV0ÿY2ÿ¤y[ÿ¹›…ÿÕÉ¿ÿìîîÿìîîÿìîîÿìîîÿìîîÿìîîÿêéåÿÌšjÿØ´ÿØ´ÿÛ»œÿ•S&ÿl<öl;’f3                                                P —V*øßÁ£ÿØ´ÿ×²ÿÍ›kÿìîîÿìîîÿìîîÿìîîÿìîîÿäàİÿ¨cÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ¬‡lÿåäáÿìîîÿìîîÿìîîÿìîîÿêéåÿÌšjÿØ´ÿØµ‘ÿÜ½ÿ•S&ÿ…IÿvAöm=ğn<]                                            P —V*øßÂ¥ÿØ´ÿ×²ÿÍ›kÿìîîÿìîîÿìîîÿìîîÿÓÅºÿX1ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‡J ÿ‘Z5ÿ×ÌÄÿìîîÿìîîÿìîîÿêéåÿÌšjÿØ´ÿØµ‘ÿÜ¾ ÿ•S&ÿ‡J ÿ‡J ÿ‚Hÿo>õk<L                                        P –V*ûàÄ§ÿØ´ÿ×²ÿÍ›kÿìîîÿìîîÿìîîÿäáŞÿX1ÿ‡J ÿ‡J ÿ‡J ÿ´tÿØÅ·ÿñêåÿîåàÿ×Â´ÿ°ˆmÿ‡J ÿ‡J ÿ‡J ÿ“]8ÿçæäÿìîîÿìîîÿêéåÿÌšjÿØ´ÿØµ‘ÿİ¿¢ÿ•S&ÿ‡J ÿ‡J ÿ‡J ÿEÿp>Ê                                        xK"—W*ÿáÅ©ÿØ´ÿ×²ÿÍ›kÿìîîÿìîîÿìîîÿª‚fÿ‡J ÿ‡J ÿX1ÿİÌÀÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿØÄ¶ÿU-ÿ‡J ÿ‡J ÿ¯ŒsÿìîîÿìîîÿêéåÿÌšjÿØ´ÿØµ‘ÿŞÁ¤ÿ•S&ÿ‡J ÿ‡J ÿ‡J ÿ~Eÿq?«                                        vB¢—W*ÿáÆ«ÿØ´ÿ×²ÿÍ›kÿìîîÿìîîÿÒÃ¸ÿ‡J ÿ‡J ÿ‡J ÿİÌÀÿÿÿÿÿğğğÿ___ÿïïïÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÕ¿°ÿ‡J ÿ‡J ÿ‡J ÿÙÏÇÿìîîÿêéåÿÌšjÿØ´ÿØµ‘ÿßÂ§ÿ•S&ÿ‡J ÿ‡J ÿ‡J ÿsAôrAC                                    q>-v@÷™X+ÿâÇ­ÿØ´ÿ×²ÿÍ›kÿìîîÿìîîÿµ”}ÿ‡J ÿ‡J ÿ¶‘wÿÿÿÿÿÿÿÿÿïïïÿ   ÿÿ´´´ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ«cÿ‡J ÿ‡J ÿ¾£ÿìîîÿêéåÿÌšjÿØ´ÿØµ‘ÿßÄ¨ÿ–T&ÿ‡J ÿ‡J ÿ}Eüu@¼                                        uAÈ€GıšX+ÿãÉ®ÿØ´ÿ×²ÿÍ›kÿìîîÿìîîÿ¡uVÿ‡J ÿ‡J ÿÚÇºÿÿÿÿÿÿÿÿÿğğğÿÿÿÿeeeÿïïïÿÿÿÿÿÿÿÿÿĞ¸¨ÿ‡J ÿ‡J ÿ©eÿìîîÿêéåÿÌšjÿØ´ÿØµ‘ÿàÅªÿ—T&ÿ‡J ÿ…I ÿu@öuB#                                    tBQwBôˆJ ÿ›Y,ÿãÊ°ÿØ´ÿ×²ÿÍœlÿíïïÿíïïÿšgEÿ–`;ÿ˜d@ÿòíèÿÿÿÿÿÿÿÿÿòòòÿ***ÿ)))ÿ'''ÿ%%%ÿ999ÿ½½½ÿÿÿÿÿêßØÿW0ÿS+ÿ™hDÿìîîÿêéåÿÌšjÿØ´ÿØµ‘ÿáÆ­ÿ˜U'ÿ‡J ÿ|D÷wB                                    mI$wBè‚Hÿ‰J ÿ¡a6ÿçĞ¹ÿŞ¿ ÿßÀ¢ÿÙ²ÿğòòÿğòòÿ©~`ÿ¢sSÿ¢rRÿóîêÿÿÿÿÿÿÿÿÿòòòÿ222ÿ000ÿ---ÿ+++ÿ???ÿ¿¿¿ÿÿÿÿÿëáÚÿ•_:ÿ”]8ÿŸqPÿîïïÿëëçÿÏ rÿÙ·”ÿÙ¶“ÿâÈ¯ÿ™U'ÿ„HÿwBğv;                                    xA}|Dõ‡J ÿ‹M#ÿµ„bÿëÙÈÿâÈ­ÿâÆ«ÿÚ¶’ÿñóóÿñòòÿºšƒÿ¦yZÿ¦xYÿãÕËÿÿÿÿÿÿÿÿÿóóóÿ999ÿ777ÿ444ÿ~~~ÿòòòÿÿÿÿÿÿÿÿÿ×Ãµÿ˜d?ÿ—a=ÿ´‘xÿîğğÿìëçÿĞ¢vÿÚ¹—ÿÚ¹—ÿäË³ÿœY+ÿ{DôyCc                                    zGzDõ…Iÿ‡J ÿ‹M#ÿº‰iÿíÜËÿãÊ±ÿãÉ¯ÿÜ¹—ÿòóóÿòóóÿË³£ÿªaÿ©~`ÿË°ÿÿÿÿÿÿÿÿÿóóóÿ@@@ÿQQQÿÅÅÅÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ¹—~ÿšgDÿ™eAÿÇ¯ŸÿîğğÿìëèÿÑ¤xÿÛº™ÿÛº˜ÿäÍ·ÿŸ\/ÿzCÙ€€                                     {E›€Fú‡J ÿ‡J ÿ‹N$ÿ¾oÿîŞÏÿåÌ´ÿäË³ÿİ¼œÿòôôÿòôôÿá×Ïÿ®„hÿ­ƒgÿ¬‚eÿçÛÓÿÿÿÿÿôôôÿ‹‹‹ÿóóóÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿŞÌÀÿlJÿœjGÿ›iFÿßÖĞÿïğğÿíìèÿÒ¥zÿÜ»šÿÛ»šÿæÏºÿ _2ÿyE;                                        |EÓ„IÿˆJ ÿˆK ÿ‹O$ÿÁ”uÿïàÒÿæÎ·ÿåÍ¶ÿß¿ ÿóôôÿóôôÿóôôÿÇ®ÿ°ˆmÿ¯‡kÿµuÿçÚÒÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿàÑÆÿ§z[ÿ pNÿmKÿ¾¡ÿïññÿïññÿíìéÿÒ¦|ÿÜ¼œÿÜ¼›ÿçÑ¼ÿ¢b5ı                                            ~FºƒHùˆK ÿ‰K ÿO%ÿÄ™|ÿğâÕÿçÑ»ÿçĞ¹ÿáÂ¥ÿóõõÿóõõÿóõõÿîíëÿ¹–~ÿ³Œqÿ±Šoÿ°ˆlÿË°ÿäÖÍÿõğìÿóíéÿáÒÇÿÄ¦ÿ¥wXÿ£uTÿ¡rQÿ«€cÿìëêÿïññÿïññÿíìéÿÓ§~ÿİ½ÿÜ½œÿèÓ¿ÿ¥d6ø                                            €F#~Fæ‚Hõ‰K!ÿP&ÿÇÿñä×ÿèÓ¾ÿèÒ½ÿâÅªÿôõõÿôõõÿôõõÿôõõÿæßÙÿ»™‚ÿ´sÿ²‹pÿ±‰nÿ¯†jÿ®„hÿ¬dÿªaÿ¨|]ÿ§z[ÿ¥wWÿ¬‚fÿáÙÓÿğññÿğññÿïññÿíìéÿÓ¨ÿİ½ÿÜ½ÿèÓ¿ÿ§f9ø                                                ‹F€Gˆ€Gõ‹N%ûÊ¡„ÿòåØÿéÕÁÿéÕÀÿäÈ®ÿõööÿõööÿôööÿôõõÿôõõÿïîëÿÊ± ÿ´tÿ²‹pÿ°ˆmÿ¯†iÿ­ƒfÿ«€bÿ©}_ÿ§z[ÿÂ¦’ÿìëêÿğòòÿğññÿğññÿïññÿííéÿÓ©€ÿİ¾ÿÜ¾ÿèÓÀÿ¨g:ø                                                        €H  †O%¼Ê¢†ÿòåÙÿêÖÂÿêÖÂÿåË²ÿõööÿõööÿõööÿôööÿôõõÿôõõÿôõõÿãÚÓÿÑ½¯ÿÂ¥‘ÿ´uÿ³sÿ¿¡ÿÍ¸¨ÿàØĞÿñòòÿñòòÿğòòÿğòòÿğññÿïññÿííéÿÓ©€ÿİ¾ÿÜ¾ÿèÓÀÿ©g:ø                                                            ¹‹]Ë£‡üòåØÿéÕÁÿéÕÁÿäÉ¯ÿõööÿõööÿõööÿôõõÿôõõÿôõõÿóõõÿóôôÿóôôÿóôôÿòôôÿòóóÿòóóÿñóóÿñóóÿñòòÿñòòÿğòòÿğòòÿğññÿïññÿíìèÿÔ©€ÿİ¾ÿÜ¾ÿèÓÀÿªg:ø                                                            ¹‹]Ë¡„ûñä×ÿèÓ¿ÿéÔ¿ÿãÈ®ÿíäÚÿôõõÿôõõÿôõõÿôõõÿóõõÿóôôÿóôôÿóôôÿòôôÿòôôÿòóóÿòóóÿñóóÿñòòÿñòòÿğòòÿğòòÿğññÿğññÿîğïÿâÏ¼ÿÖ¯‰ÿİ½ÿÜ½ÿèÓ¿ÿªg9ø                                                            ¹‹]É€ûğãÖÿçÑ¼ÿçÒ¼ÿåÍ¶ÿâÅªÿàÁ£ÿàÀ¢ÿß¿¡ÿß¿ ÿŞ½ÿŞ½ÿİ»šÿÜº˜ÿÜ¸—ÿÛ·•ÿÚ¶’ÿÚ´ÿÙ³ÿØ±Œÿ×°Šÿ×®‡ÿÖ­…ÿÕ«ƒÿÔ©€ÿÔ¨~ÿ×°ŠÿÛº˜ÿİ½ÿÜ½œÿèÓ¿ÿªf6ø                                                            ¶†UÈšzúğâÔÿæÏ¸ÿæÏ¸ÿæĞ¹ÿæĞ¹ÿæĞ¹ÿæÏ¸ÿæÏ¸ÿæÎ·ÿåÎ¶ÿåÍµÿåÌ´ÿäÌ³ÿäË²ÿãÊ°ÿãÉ¯ÿâÈ®ÿâÇ¬ÿáÆ«ÿáÅ©ÿàÄ¨ÿàÃ¦ÿßÂ¤ÿŞÀ¢ÿŞ¿¡ÿŞ¿ ÿİ½ÿÜ¼œÿÜ¼›ÿèÒ¾ÿ«f6÷                                                            ™f3
+ÁjûïßĞÿæÏ¸ÿåÍµÿåÍµÿåÍµÿåÍµÿåÍµÿåÍµÿåÌ´ÿäÌ³ÿäË²ÿäË²ÿãÊ°ÿãÉ¯ÿãÈ®ÿâÇ­ÿâÇ«ÿáÆªÿáÄ¨ÿàÄ§ÿàÃ¦ÿßÂ¤ÿßÁ£ÿŞÀ¡ÿŞ¿ ÿİ½ÿÜ½ÿÜ»›ÿİ¾ŸÿåÍ·ÿªe5ñ                                                                ¼‚ZÆÛ»£şîİÎÿïáÒÿïáÒÿïáÒÿïáÒÿïáÒÿïàÑÿïàÑÿïàÑÿïßĞÿïßĞÿîßĞÿîŞÏÿîŞÎÿíŞÍÿíİÍÿíİÌÿíÜËÿìÛÊÿìÛÊÿìÚÉÿìÚÈÿëÙÇÿëØÆÿëØÆÿë×Åÿê×ÃÿæĞ¼ÿÈ˜uû©a1˜                                                                ·|N'¹€V»»‚[ı¿‡aÿ¿ˆbÿ¿ˆbÿ¿ˆbÿ¿‡aÿ¾‡aÿ¾†`ÿ¾…_ÿ½„]ÿ½„\ÿ¼‚[ÿ»YÿºVÿº~Uÿ¹|Rÿ¸{Qÿ·yNÿ¶wKÿµuIÿ´sFÿ³qDÿ²oAÿ±m?ÿ¯j;ÿ®i9ÿ­f5ÿ¬c2ù¬b1¢¦Y&                                                                                                                €G2GĞ„Hó‘O#ÿ—R$ÿ—S$ÿ˜S$ÿ˜S$ÿ—S$ÿ—R$ÿ–R$ÿN!ıGÈ                                                                                                                                                    €HXGì‡K õ”Q#ÿ—S$ÿ—S$ÿ—R$ÿ—R$ÿ•Q$ÿHö€F,                                                                                                                                                        €M
+€G…HöŠL!û•R$ÿ–R$ÿ–R#ÿ‰K ø€G                                                                                                                                                                    €D"‚G³‚Hõ‰K!û‡J øGŞ†C                                                                                                                                                                            €I 8€GvH€M
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿßÿÿÿ  ÿÿƒÿÿÿ  ÿÿ ÿÿÿ  ÿş ÿÿ  ÿş ÿÿ  ÿü ÿÿ  ÿ    ÿ  ÿ    ÿ  ş    ÿ  ş    ÿ  ş    ÿ  ş    ÿ  ş      ş      ş      ş      ş      ş      ş      ü      ü      ø      ğ      ğ    ?  à    ?  à      à    ÿ  à    ÿ  à    ÿ  ğ    ÿ  ü    ÿ  ş    ÿ  ş    ÿ  ş    ÿ  ş    ÿ  ş    ÿ  ÿ    ÿ  ÿ    ÿ  ÿÿğ ÿ  ÿÿü ÿ  ÿÿş ÿÿ  ÿÿÿ€ÿÿ  ÿÿÿáÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ÿÿÿÿÿÿ  ‰PNG
+
+   IHDR         \r¨f  IIDATxÚí`UÖÇÏÌ«éÚRQ¤ˆR$DQ°,+ê*vÁ¾¢DX6€Øösuw-«ë*ºêªkCHi*( ‚$*Ò“÷ŞÜïŞymê›™÷&à9úx}Şdfş¿{Î¹çŞËÚoÖ8<hh 444  €††† @CCC  ¡¡! ĞĞĞ hhh 444  €††† @CCC  ¡¡! ĞĞĞ hhh 444  €††† @CCC  ¡¡! ĞĞĞ hhh ´VjİÆıùä ñ_Ìß8R%î áÈ!'8Ê~üè¾Ïñ! Ğ1Ë/¸³pÂ4 ÜôJ¢9à$—¡ÿè?ğ}y~ÅÊEğ¨! ĞÚ¸õvKzS²·˜p½[>Ç»^VLü$ĞûĞÉù.ú¡ì‘Cx hmÎ×¹ ˆ¶ød>|{‰>*~öXâ øI ì«3ö§Û¶­¸' ­X—±E£?yŒ^19 ‚çùˆğƒ÷¼ $H z 0‚@ øOeÙâ?àQE  µrë4~n®¹éaÈd | è¹ˆ QD< "Pñ"€[RYV20 ­Zşi3’ˆÇ1—#Üz•$³>ÜÒ~¨å& %ÁBäÌˆğ!À`  ÏÁ°=¥K6ãÑF  µ&ñÌº”€°^ù =»§Â<—	Ÿ“_QQHrQo€|R¹jñ<â ´ÖçŸ1kˆĞ,°8ÿ4yœÏîÁçaWŸ½¾„8½KŠ„“Qˆ B€şÎee‹ş…G€v”¬ÇØ»Ú7û›q¹4èÛóq~(Óéëßè"¡ÿ%=(è?åĞè[±ni	 Ú´şı‹İ‡ÚÕŞÁ	p'½Ò™ĞƒI>‡:ÎwóÉZ|³—OÑŞ  Á^şşÊ²‡şŒg€v¤ÜıÂ™çQí-¡W@OUœ/s÷ùh«Ï%rÙ„
+ƒÂ]ƒ‚4 Ôw¿Ÿ>| Ï ­­káìş£:#Æù‘n=‡<Ë—»oÄ€he` ¡^­,-™‚g€ÖÂygq¹ŠÚ)Ïì'çÇã„!àå„sp£ËW”¬Æ³… @³ËŠ‹ùüÒÚ›©äî¡ºÎÆùW_RÉg»oŞ I(@@ø¼²¬d0ıM‚'€–h«?zÖĞ³|¼¹8Z Õ×òô‚<L«X¹øoxö hqZ—1E=… YJÏî$yœ~KÆù–BP·` Á2a²·Rzí++®Å3‰ @³`íÇÏLq5sÅT]·ĞSë9:q¾/@;!HwmiyiÉíxF h&­SÁ¬k¨‚îç9è U¾{Dã|K^€F· šÀ*–—ìÂ3‹ @‹çy”Êhpìòİ#ç›e€º[0:XHø_EÙâ‰x† h–?fng"4.¡'p
+U9'/ßmq¾•P ””†lœ ç8«¼ô¡ğl# ĞBÖ½ Øëçëï$‚0“Š:%æ0]•ğ[á)g! H‚’qôÕ•yCÀ«Sxæ ¿yëR0ób*“…TÔİÚFœoÅ Ñ	C"%Â¬g€»½rUÉR<û€ß¬uwûÉ~?ÿ}8Rç‡Z}İaºmáG»£C†Ã rŞ@¯Š–Vá•€ øMY‡	sòœõÍéYºÂşaº­ÔĞêxª¼¬äz¼" †vÛÒuİ}õK&¡ H2Ç‡3àÁ*SS NöºòqVÇéÄº1% ùXú„ù‹DcÓò×HdNòç‘)û@úœHÙ¶‰ô1!’	ˆü=åëÑŸì‰6úág¡ÇÒ¿•È>JD>#H~ÄyÙ“à6j8ÿ†âõKzÚ6zÜüÛÿ}øÌr@´[KÖ7Ôøf;œ×éäÁåæÁáäÀÁg«Şdr—…ÈÑ†S>¿ZÏœ-Äz¦µ¶x£’|‡ÈA@@.±óMöY¹ˆ£‚U‚†D…Jˆâ7$Û"ò}"­»:$ô‘ì—ô·eğ~^úwÅßcÉé â”…B€@À/Ğ{æ}zw’³ø¥g–  ÚˆÍ{|}Cu¾×‰º½Nğzà¡7' O]f
+…èê—Á@*|e«Ïq¦¼ ÎÄá$í•fë¯ÈÄ§
+Ê–X!\¥ø¤½§#Réo",ıAÚòËZ{åöA½mKÿsÚ—xtg˜ğ~~_s Í®¸µŞç¥¯?0öG@+¶;©Ë_SØêpğiÉ).HI¡ HvÛEÅOo<mıy‡˜:Ó~T¶}M%xN!r;Q_˜Z@P¹Úš­°òsŠÏÈD«á	è]úºş¶":¢•‹<¢7B/Šm$ºo‰Ãˆ@  vkn„n~öüpr†ë¤cm ·<´v3å ÔT7¤¥» )™ É	N*|õ ø°˜yNÕâkÁ üXKğÊ¹/9İƒÊ™jùä.½ò¹f|¬ëzËE.Ûõ„®
+	l€€ ¢pİ‰ÖûzÛVz&
+EåmX/Ûó(aüÔh¢ h¬óCS=ë†„µï>zæH@+´?-şänc`~ZºÒ3İšæ¦î¿KtûYì/¶ú<4ÇÎ¸	/ xÏé
+^éÄ9A–vë¯¢‘3jı5½ÍøYÛU1|_Ğ7ôÂAè EˆËP.bÊQ °< ˆa@Sƒjè­®™…’³Õœ@›ÀŒ‡?é\wÈ¿+5İ”™å†ŒL$¥¸E×ßª…áÅî2i‹Ï©\}¹ûÏÉ…nÂ°$ÖZi¯håô\~¹°` Ú!UHİoõv¤ßÑsÿëxR/€Øà¨B,ºş4h@C­êjš ©.PŸœìèw,ö´Y Ü¼`Í3y8+ÇÙ¹^H£­¿Çã '[½Ê!mõå±¿ğ¥ÛFßÓó8U•©nı%’×kıe.kl?—&İâƒ€¦WŠÓÁ”€ãlõ´ON  €ß'Ğ  µ‡›¡îpË%İôşşĞJì†ûW/spÜ…¹í’ +;	RS]b·ÏG»û8e«¯ˆñe-~8' épªÜØ UKò¬¶¬õ×ñ”]u Ê,¹Ğm‚€Q> V( ÿø{ác(I  hğA]µj6Óğ€<÷Á_&\… h- ¸wõWŞ$GÿÜ¼
+ ˜üs±¤Ÿƒ“¹üZ^€¬u×¾¢¥ç8m/ @»æ‡‹éøË3Ğ ×úµg`±bı8  ht·YB<.¿E/À@”ÕøšPOPCĞÔØ¼ü¯†  Z‰M»{UMF–757Ï™Y^HJrœ¾Ë/s÷c_éÈ€ Óâs¦İ¨»ù¤ºWVÊ™jı#.w,hç! é®Ë[`P¸àæBè~
+’$ ÖcÓ^€^ıAœa mñÁ×,@}M³èÔnªùèoÓ ­Ä¦ß½ÊŸ•“ä`! x=¬Ø‡‡pÉoØå—ÅúÊVß¬ =§¨µçâ8ŠDQï«U¼c¦õWUÌ¢(ß%ñA@åş¸Ş ×egŞeÇ5Ê}ÓÀ
+ƒj©PÕ$æ>zz"‡ h5 XíÏÉõ:rÛ'Cz¦‹ÀIİ^ô ¤bW&ù´ƒ,T_3`è˜¾V=?Ñ¨¿'Ú5õzIÁ±;˜iá9 !|€…ø]»å7™ˆ^ñ Ôé§@Cj«èíP#À9€V“˜ÿ±?;ìdxÀíu€ƒgI@ñKZùèsIŒ¯!üX¢OÄ0×ú+ãm”õó!)˜ ‚#Çáö{Òº Í–ß./@ VTsz ‡š`ùS€V€œ Ò3½à	… <Cü²D §ªà]€ Í#yœô T+­¿º²Oš¥¹ÆˆI ˜s‚^€V€Õ ád  õÛóWS€… Ì  ğ2 8¢!@ñ«BY÷ –ğ5DÏi=–' u1Á=Ú¢Wñ¸ü&  ùv£î¹<$½Z-¿ôûVwzû(Ä‹a  õÛM Y¹^G^»d±
+0è8‚!€ñyZ0PˆãÒd€è@A=bÏ¨õ7º!´Üù8*öâô„ğñPµöú½ª@1HÈ–d   àŞÕb ¯½<ààÍŠ_ëë=W–K¯;D˜ÓÈôÆĞ_Ía¼úCwµ«ò :ãXuùu*HöG0›0!vSÉ@ƒ0 ğ[€^À”øåİ|²çFãT±Œ8@9¾_Ú½1†òjôÑƒNÒÎŠË¯tÿÕã–óÂ5BL÷][ìG$@ ´ Ü·ÆŸ“CC€öÉ¢ —0#~m/@[øª	C8£ÙƒôÜ}E8 º+Æ(>Ğí›×€) è„&Zn­\€õ®BûÂ€X0@ C ¸9€Ü Ø,@ÁB ¶À¬†àÍŠ_éî‹CDƒT
+ÁYj#ÑaÅ±ò± âKKàDGxD-"½×"ŸunCıAº!öç½ïªëmWşÜhÁß$²yx§/8\Iàò$ïpÙ[„ h# È¥! «`I@Í: ¹Èõ^-oš¿©^•–é)à-Ùn'¯:tœMG’h²ğ9¢s¥ëoW.íïõ„¤ªÉJ‰jûRÑjï«õ×kı°ç×jøñ—CP±ï0ìª8 ”HÉj/[ò €6€öIéÎ Äi…Ù~^Gü$ÀÆƒ×@’ÇÇuo™)î˜‡,ñR`ÃOÇØ±øºş6õÄjÚB6£}Ö>{öÕÁ‹Ë·Â¾ƒµ‘—/zÊØßr=  õÛ- Ùa d† À‡‡›uı5Ä/ ©î0ä·Ï†Ş2Åíé.û[}kĞº‘pbyZïë·öZŸ# 0ßâ› 	ßgÃPºqdvü8Ü^UÀR"Ğ6 ô ‚u ^ ¡: İÖ_blIï©ø;ç¦Cß.Ù-.|ëP°³µ7Ñ‹ªßŒ€D¼ 3 ¿÷úÚİğñßCvç^âIŠ;ˆ h ¸X
+œ×!œTIAÀë¸ş¼$Ûïoj €SÏ—´üfëıãšÄ–¼@bˆ×0†€ 0ç!_÷,xi-Ôù’İ!şD  õÛ­ ¬ ]6ĞCãuG¨ÀBë/MúÑ“ŞX{÷Í‡ÌTñ·Ä!ŒGf  '> êDa¬ï)Å®– ³ï©ƒ¥¯”Av~àXï àØ@ÄÈuÆì·ş<'wı…€<ĞCËWmñ·ô¡KDèÖŞ×‹Ñ’±²ÿ±óv@şŞÃË>…şdğ$§G» Ç  d9 G¤€—Ô ğz€,OÀ‰]~íÒ]Ğ¯k‰Ö_û°Å3@Ë Àj<M4Eh”üÓ€jÏXÜ7ë!Ğ«e;`ã÷‡!5«C|=€6 €B@ I lBgİıgĞhª¯>3¡SnšAëoO7 98$ÚÒ›qùÍÅıú^@¬®CrT °qçOğï•;!³cE±à˜@.›€€uzµê  PºÿR(4Ö‚¡};Aj²ÛRëo.7@â„@¢-½Ş6ŒŠ}ÌÆıÊÏ™ëŒU3` ö®ƒ{Ÿ_¹]ûÅ7& Ğv ô $ àc‰^+>oª;§ß<nW‚­b½Ö½ ˆÑ›uùZëXB´ Öà €¦¦&(úk)ävC Ë9€@nn/ 2)¨º€7ÿ³ÂŞF
+€áıóÁírš@bâ7Óz[ı¬•V•X€¶_>\l@÷~ñ! Z¯å§º¡®xòØóîÈÍK‚X 0“ äCï± áı;S ¸âtÿã=”VZx«-}¬3 0#F# è€ °&®SÁì«y ÷Ó'~?ö<8V`ÅÕ7º¹ä—ßœ`T«j€ Y×Â¢ q‰ã}éí÷…m@S=ÀñÁe3 ¤Ÿ±§°% 'JsİÆıÿÊÏ· f=]9]û" Ú2 :ÌÊ§gc1dŠÍ‹fşpÁè³l@8` =ñ›«	HtôŸ°‹½ªºjê›¡¾¡ê›¡–>®kŞ³[C³_„^²×	)InHò8éc7¤&» E¼wCûìê	9 @b„#ä¨`öß>†ì.½ m İŠ½~®a„™ìZe-~Pø¡{Îç€½ ÍõÕ " HDüÒÏYŸ”ÖZëßÔ€Š_«aÏ/‡èí0ø|ñBB«ÛÈ=€ ^Øò×Idö<<Ç_ç¼tèÓ-útÍœŒdS ŠÑLÿ¿ş€£Ä ĞÜÜ, «s/ìhk è2¦è!@Rñt»û¼ <œ;¢ò( ìª€y Î˜"·'óŸ jë}Tô‡EÁï=PA.r¹ „DNÂïBïK_ÏÉH‚¾ıºçB×âñ²âÄFË àÎ¬†Ì= m İÆòä1úp„è”KÄÎ  >‡°²) †–x Ö+¥£ y ÌµşÖcø»V’{÷ŞÿPY_ÿ¸R7_Kär1GßWµòB´:Ní)„Á òí†¶•ìuÁ ~áô“»Š!„Ù‰CÌ ñB €9Ï¬…ŒX	ØêĞaÂœ<G½ï!#—‹Á½†»¼çBóğı'?] ­± <ÇéO¦Èøj`øq4 `±ó‰„•ÔÅßºë8\Û¤µ 
+^ı
+Bt=Aê	êp@êQH!át: `pwno ı À³ í{àX€Ö
+€Áƒ§¹ö¦¥ßNÎ¡·&ô`’ÏIôq¡Ö><Ã''Y³{Òi ¹ ªÑ€ææPô5ÖŠ9 w(0:L-
+ 8\[¿ùö¬S´ä ãG[o…ëÃİ7ÊDÁ šK?µ'ëßY6{’•
+ÀXsÄ‡æfÜõÜ'Ş® 5 ëèÙ“,¡¿Ş;çk¹û|´ÕWÄä“N9 vÍàg Ğõ Ì@À¾CYSß_íŞ+¶üÑ–ZÍ˜«jıuD¯•ä#1ŞÓ'´sR¯#/+ÎÙNêİá( @şºÏÇ °Róºâ| ­	 İÆÍ;Îïox”şìbœ/éÖãd »ûª8$ ˆx Š¥Á´†ƒæãàv Fô§ p:MÇúf{¬ô|ıÃ>Øşı¯ äÓa«â{¢ßú+?§tÿ­Äÿ1sBßî9pÅ9ù+åÂö `îóŸBJn@k@~aÑİô¨Î£W½KÖâóúq¾–ğU °iN@c@Ç Ì¸ùñ$õş€ ·UÂOûªUsákÍµ¯¾Në¯åâÇrÿÍÄÿrx(¾KoYéI0ı‚ÁĞ¹]ZÂ ˆg:4€yÿ\É9ù€£€—9:ïÛğúCW€2»/iù8]w_Ë&J &å³;xNÖòƒN.@
+ëC p€şp`³óZ;´¬`gİ–=p¨¶1ºdVñ+]¢‘P?Wgÿµ\|bá=A×#aIB®œxœÜ·£ $ àÏ/l„¤ì8)èÑ ¸ãš7	pc9i|/&ü¢ ˆ.¯»Õ×€Åu´Ö4ÕÃÈ˜ °23°ùÃÊ|Ÿ~YMÍ~ÉŠ9æÄ¯åú³÷YbÅä¬Ë¹â)I®`µ}Ì^kòÑ‹ºU6Au}3}ÜÕuM°ÿP=Tî­¿*d0áşk½Gÿ’I£úÀ9#zK<Ÿ#€7ARVœüh ¿ ˆŠŸœ¿CŞê›t÷µìœSGBn^2ÈV uïÍ¯$4[@"a@Ø¾­¨‚/vş¬´Òm5?û/7#ºuÌ‚î2ÅÂ3BÑJÖ±²á?î‡ßï‡]{PXbºÿfBƒAÇu„kÎ(–kşÄ ½÷ü~¿ OF{ë=  ›Ä?îÏÀ×øS;}Tüì¾õİ€z í’µ—Ó[´–£@sœNàŒÄŞWÎÂß²í»_a;½I[üğÅ
+ÊuõtÄŸ™æ…ã×ºvÌ[wíì;Äx=öÄ >¿ »Ë«àó?Á–oöª’†ÑvÿµŞc`šyÙ©àu;M ŞéĞ îù×&pS Øµ4XíA€Å¤ßì×è‘œ‰õy§¼‹/ñ‹ 6
+rÛ%‰@º¤€“,.­ö“/®Xı—z £s Vºõ?û}åAØ¸­B²zMh•`ÅrV‘çŠ3“©K?ø¸NĞ»Kb´¡ŞUNt§3(ø„uI¾³zìÜ³_ƒ&ĞõNèÕn»äñ¼¨`ûÀKŸ;½ hD ˜µ…óúú yKïsá–Ÿ ˜íO\üA Œ„´kŸ$.âÖÔ±?( ~Oğ5X€•¼ '‹ùK7}'.g¹|%Â—¹ÿ‚|U`¶oûv€ã{´£+gJ±„®î0~•"¿½j§8 ‰è$‰¢@Zexæ©½à’3ûkx'ö øßŸƒ;-Ïzü¯ @@m " ÌY×±s¦ÓƒşWQ^R×_lıù„Å@nh0€'¼2VÒ¸sT+‡ŞXpB Ñı³ µMğÁ'»Ä|D!¬pK¯Z<ôş=ÛÁÉı:‚;ÒMIL
+…Äœ:Ì ”ßg-ı¦m?Ã«¾†šÚÆhFbPİc@àšóN†Ñƒº)¶ÏZÚÂf ¸÷•/À•šk=ş× @Øøğ¯ SÖ¹pÎ]GP&ÿÄp 8[æÑz I¡$`´P˜…€¸¬´O	 0ó=,ş`İ.8TÓmé%×·²Å†y5ƒ{@·™¦[p3±¿9ñ« ^ÕáxòµMğÓşjÍäŸ Q|Ä^g!À]W€>İrCÛ·¯õg¨À cİıG $n]ÆÌ)¡‡}&'‰ÿ#î8° Éb7`0)DñX¬áç‚¯FŸĞA ±@` ì\¹ñ;¨ÜW¹fe¦¢å'%ÙE]æŞba±€õZQk^¹™£¯56ûá™·>‡­ßìÙú+ëØ$÷__(vW¶ î}e8Sl@À¡FøàÉ³ ¦ P8çï„#×D< ‡8i™¯] U²$ Ç£¨_³@ıœø›L@-vã¿…eÑ·îÚ+»‰ªe
+=nŸ“*²	NSnÍ­7Ù3s†÷÷²ÔÃùV1–@{Cİ:¤Ã7¡m—øƒ!@ xu+ğÉYqŒÂÔÀû ÓÀ}ôÏ‹æ œŠÀ@¶4ˆ @Ñâkuıi<üPĞ¿CdB£Ãe¶ğ0‘ß¤â„ØÃ`	Ds =ó³¡pÈï"IKãØİ|NÀü,ÁÆ­¿ò3ë¾ÜÏşw´†'k”.³û©g€‰#{Û ?<ğŸ¯À‘”i j" Lôø¶‹B€! Ø˜<{Øê$Cn(Õ@,h?'4(Ğœ^CxÖcşğg?Ú°öü|X-v‰ë/}¯}v*Lİ—‚Œ· ~s9ØËˆÇş¬Ù¹ß§^À²åÛ4c­"V™øø¬3%uf’±áøáÁ×¶—”ßÅ… HÜòfo¥[Ì8Ca€}İ€g3 7)”ˆ&ƒî¤v!èÄÿâ94A! ùÃ¶÷@¼ıñ×rÑƒº&ü”‰`òØşäq™€µœ@ì~?{U ù6ÿşæç°æ‹=šc”{}â¨ŞpÅ9'ÚÒú³m²Àƒ¯ï Ş›? 
+ _ Õ,8Ø [·—u©,[T 0€™÷Ğ&¿XlõÅ0Àek  ' 1¬PĞHJ……LüÍA 8yK1,¼YºöVÕjKR‘pÑß½ °?äf&\üÚ"¯ªª‚¬¬lƒY¡k½n<¿?3ÖãñĞókÅ’bu2PİKàtpğxÑY—™’pëÏŞc5ß ¨Ç^ lÙ^úJeYÉÅ 3 3·3š¿¡¾l²Øò3ÀÆb 0 7\
+ì‰Ö€VµŸÆóD€ ½"	h\¬ Vçÿá§»õ/bE80aDø]ç¬X×¤Ş;â¿sçÎƒñãÇÃ¨Q#ƒÉVƒÀ
+ô ë³ÕµMpÏÓe’ÙŒ@³õ??}PW¸íâa	·şÌXâñÁ7¨àI³×Ø¶’ğ7jOiÉZ€	ë\0û>„y ©´« èìS‚!€4ÀKr *±KjÿCÏd …Œ‘y Ö]şğo°‹ú¥÷·Š	@#Ët‚'uµ(~¹h‹ŠŠÄmåççÃ”)B§N,UÿÅßúëäÛŠƒpÏSeª¡ÃªŒ¡×–Ü6B0­
+d XøÆNê¤Ú€F1°u[)ÛúæŠ²’¡ô\€‘pÚŒ$p;è™à»Dê¤]‚	xgŸ"÷ Ü âæG†kÉAÀ<€±:DÂˆø2ÿÁÏoûöW±ÜW_²Ñ'^®œtrd!+Â—~æ;îˆŒ+`6fÌ8ë¬3)Ğ\6´şÄ$ÔC|ÿ²l#¬Ù²GòI±ĞÀ¾íaş´Ñ	µşa <ôæ7À¹S@½˜`Ëö2v¡€ üµ?•-úÀT.`Ö¥ô”¼(ºş¼3Ú%È+«­íÊ„ ¢İ€¼t, HB•ğå‰@ñ½€Æˆ&ã› h¬õgcëõÅmA‡ô€“út4sUÆÄŒ3$C‰‰(‚¼¼<øã/^½z'ĞK@,'
+¥büµªîxd94‡,‰5y	ƒÀ“s&@~»tK­¿ ı÷ ; PÀÖÓ}°üÒ)½÷•×" Ì„£g~B[üÓ¢Ã‚¯˜0t„X €Uz¤ƒä=ZI?P€( ÆØÀCèÆã˜ÛÏ*ãŒ.0f©^Úú’Í¦k$z=ÏàOú“Lüa!°ç#FŒ€É“/€¤¤dn¾qœ¯h…Ï½½Ş]»[ÓõWÎZtù9'Â”qÇÇİú‡ÿî’·v¸’m X)ğ–k) üôØXXRYV2`ÂºŞ1X Üzê8"¹ $04X
+€ôI!‘¶¬Ÿ_ÖÚk½&P ˆÀHèzÂæ?AÙæÅÏlâ¨¾Ğ·{)Ñë‹?øÂ-·Üªò ¤HOO‡K.¹lZüf“‚Fë V×6ÃÍ%ï‰“h¹şÒğ w—lxäñqÅşR ,~ç[ gRB ğ±@­OLŠÀÎOD ˆ ¤‰¶_ıËW–|‹ 0•œù•åÀ+B8½€³†FC€tI!§›Tçdp  'z ¼å¸_:ÈË~	¿Të´çÑ••úN={ éqQF¥¿7İt³ Z`·ÂÔ©—Aff¦njNüJ!v²ğ?+wÀ¿?øJ×õ—N€òâ½çGf5²Úú‡ÿŞ% Än |ói Ì ğvåª’s &¬ÇØ»Úûü¬[O‹?‘nÁ0 rÚI{¸Èâ úñ¿"<C‚Ôq'¶“y ÒÏš160æ‰—×k¿Q\¨gïb3IÀ°İpÃ* „! |””S¦LÂÂÃŞ£×Ì®|¨¦	®¹ÿ-ÍéÊ•]‚·L*‹_û}ö7>ü¿ï( ¼6`ƒ˜ ´±s$ <áÇïYµh9ÀŒP8sGàA @İ-hn·ö$®	ß9:´K¡µSœ$C6@Ãå—{’¼ ñÃÀ¼Ë/µ/wÿ
+ÿ[³ÓÔ±¸ù¢ašä1{EBâúë¯×€Ø}Ÿ>}àºë®…;Z¿Që¯^ÜùøJqBy™°|°{<¨o{xğ¦±–Ê×E 8<¶ š`×Fú}#àyÂöŠÂÔP\,  ,´Øªø‰v  HËò@z¶’ÓÜ‘ê†ôd$»Àër¨êş£ATÍR¯€§4?Cô xq¿ö>¾¶b;|C/p#ë”—.vıÅ+z-‘N›6İT „€Óé„óÏ?Î;ïÜĞ|ˆÖÅ/£~â¥_ÃsïlQÕÅÌÂì¼öĞdqœ€ÕÖ?ü›KßûŞF T5ÀÖİ›ØÒ·A ü¢@¯…Û*ÊJE ˜°.…3Ï£Ç÷MİnA“8Q —+¸. ûš“Ş'{êqB
+½Or;d9¨ø£¿Á3à¤öàr˜ë–TN XüâZzÑe=fhqR7Kb•gvíµ×é¶şJh½Ö¥K>#n€Ş½{ÅtóµZŞØ“zJ9­¾«šDTkÁ“âé§ÃÈ“ºXxyï
+ ·- 8ÌB  ›E@ôB Â@¨rœ½ö¬Yx`EË	pãé<‰ [ Jc‹…¤„`JoÉn§¬ü@„=‘ãC€õ…?9±æÿ©ÿlÒMJ5sã…C!/+%aÑKíê«¯‰˜ ³³Ï —^zx½nƒ_éÄeŞ@ùŞÃ1V1
+>zö‰påÄ-¹şÒ÷}ÿG
+ —= 8Àr °e×gÁD®˜ d	AzÎŸ,/-¹`ÂºÎî /hüïäd 0Ÿ´ ¥ñ! ¤†@ó€3%!€U|³ç ¼ôş—ªo(/U–İ¾õâSm½Ô®¼ò*] ˜…@ø>77nºéF4h­âgöü;_À²¶«â~9LŞŠ¦f¹õ à
+ Îf ìşL|OØò" @ğóà>¹¼ìÁ¯ ¦B¢ÿ£ÇñY·`x¡PÓ ğBF Pª=•6xÓÆ±µî]šóÍùÏúÿÿ»Ê8x|\¸øÌÿ•Ÿ:õŠÈÅo6+AÈn£aúôi––¡±_ÄÔ¬CÊÜÁš-åğà3kTâW®cxÊñaÑ­ã,‹?üÛ}°Ç Ô³À–” @œÈA€yôòXQQZ2`ÆygVÀáßÍñ|¶¼[Ğ\Bp`/–  ÈI b˜ ~¸å¬à
+Õçu+ª¦1S×	”núVlüÎğw†Ğ&êWì¯ˆ°À¦N½<"v©ğ…@ZZL›6Æ«ú}£Ö_+q¸ıûıpÇ#êˆ?º=:gÂ³wŸkÉõ—~î‰ååÔ§sÚ€ªø‚ 2s“LJ!@½zÅ\P^¶èM€	Ë=óVºBx¸°æÌAÚ»i?  İC Pÿfdf!ÉM\ì4dÿ]õ5løª"fÍ »~ÇŸÖSœå7Ñk%æXÜ®'|³=z¯±ÇC††Ûn»:tho*¯=öÀÏûëàê{ßÒ,„„fãIOöÀ;\dIør TĞ3êh „şq_u· ßfìK=~Û¶âf€‘óù¥µ_RÕ¯ì4JÜ{°Ø‘ã¥ pQ 8ÀÍgv“ @¿µ—ƒ!8…ØÃ/®ƒ]å •^¸á‘}Z9€)gœ ƒú%>øGi_|‰LàzÂ×`=\}õÕ0yòïÅ¡×F#•âgÆMºıÍÕŠÙo°Ş¶T:{¾æoWÒcÉÇ¡_ù¨Ò Ä± ‡4Š‚>ßµY ‰ ë¤Ï9rWeéâ 3¡ÀèYgœğ¡ÕnA€t›pãønàvò†‡I—Ì}¾Úı«øØãrŠ+ô¦¦x =f÷lª¯ë~?X\ÒË(Ş7×èE?4eÊÅ*›¬xì¾oß¾pç³ gÏ¦Ä¯|}âŒ—ÅAS~?<…@€nW9i*³·¾:ç¥Å€ÿ³ Õ2 H½€pB0Ú-H¿\írºû|¿âÁ½ ÖytÑ[TT“¬Œm' ¸ñŒ®¢`vÅ_éçÆİğOÕô_ªß ÛşïÃ„î³dK•Y)7ÖƒÆş0EÖ§Õâ›ñŒº
+Ã™À†_sÍÕôØ+&%Š\€|ñÉ³^ƒ~>døWşãÏ“``Ÿöñ`ÅO |â ¨¡ ¨
+à% @7!H÷áŸ•«_ 0Ó#0¦¨'È6*x úİ‚R ¤„  ®
+/ 8
+€q]LŒÔÁğ«ş5õM†¿³êé«!;CŠ¤=Ê}
+ëjòä?è¶ìVB -Á3cmú|>hnnïÃ/¼ğ°pá‚PnnÆá«æ¿[w7OÌš §è \I@ø8õ\¥I	€Ïd PzÑº€Ğ8 çâO-_¾hÀŒPP´˜îÌÒÂ È²b Ôgˆí ¸al¾…Ñ€ò7ÆßüOøe¿ñüo,¾zuÉNøx"ÿ[÷»Á‘x^÷><c®ôŒ»ƒ÷ÊÇá›gŸİ¤Æ†ß{ï|¸üò©:ÙıÌıE¯Â_şÏŞ3	NìŸğ×ÒŸí W5h  btŠ	ÂuÔ 0ayÅ©¨ÛE¯êáID×'`? @gÅX ó ¸tŞàK­ÚÓsÏ…ÓNÌ×3ÕµôôŒ#v®&Mš%%‹ }ûö†½Z6êºç¡¾Ñgø;ï,½:æÆ7±ç“+ ¸–€A· ½ˆ/«([ô/€	ëT0ë„¿›™>lPß!Á’€¹öàú15™›ì¶%ïÃÊßşÎ}7ŒóúÅ-t½\@zzf‹ŸŸ:ˆÂŸ8ñ]÷ŞHülÈôˆk3¾0éq^÷ÌU1–j‹mAÀ “€°yçfıó ß-XM>ë–6  Œ=—_P´‘*~p¤[Pµ²pp··  ¦Éç¨7s¨”¿óà3«áå«@Ù0ài÷øÄğ Z ,/qÅ—ÃüùÅ¢ëo,~ı÷Ê÷ÖÀù3_1üÍ¬t/|ô—ËâŞç§Z  ›b F· Ï=P¹rÑ<€	ëZX4B d5õ¸XÓ‡î;”Àk3 :‹‡Ì,ù¥ÁÓ¯o†'–m0ü‹ÇŸ w]}zÜB?Ò èÕ«'<úè#0|øpS7*×ıâ›½pÍ}oşnßn9ğÒı$ €½ `3 6Å>g:ãèõ‚Ëİï§(G ˜K¾Lwì¢Xİ‚C( Ò³½Ér év  `ZaGqZ1ã¸_}èØX÷â§K§pHwxtæ{ü%É‘a/ \.Üzë-PT4S, 2+p£ª½¾‡Y¯0üı‘»À£wœ÷ş?]f ê$9€M_o2<!ºİ‚¼ZYZ2`
+ ³òéÁÜÉ±U…"ã\¡qA/`H?êØ€ëD p€ÑÃÈÖÂ»é¡ÿç9òÒàıÇ/KXğÊÖ'##Ë¶ã?xğ xì±Gáøã›WË}yüó[?wAa?˜wõÈ¸ÿ†¿­¢ ìÀF# ¨ºeÓ‡êÔ._Q²`ÂògÏ§GînõªBÁnÁ!Çµ  
+¤  K Ø]^“g-3õ[¯>4útÍI´ı—=³ ÉÉÉ0oŞ\q Ïó¶‹ŸÙù3—AùŞjÃÏİ0y0\{şÉ‰ÀNà€ ¨½ ˆxl*qá‹Ê²’A­iU¡V€îÅ^?©ÛIU×U@dmÁ`·àĞã†Ù
+ ^@ ˜+iuí³âÔ×FÆ&™şû!¶$ÿìÀØ±caéÒ%Ğ¥KËq½YñWy.¼ó?¦>ûÈíãaÔÉ]ãş{ş¾êWÛ  æ ÔÃ3 ĞJ$İ‚?½¢tÑÓ ÖeLÑ%D /iu;şT ¬ •%İ‰àšÓ;Äèˆd6ë±àƒu»ë¸îyğò‚É¶«x““< ^x¡eá[?³gŞÚyu£áç<æ+ÿ:¼ngÜÇãÛ €f
+€Z
+€ı,  Øa¶¨OÑ-' zdoRCcŸİë¯F ˜K®¡²¡œ>lXÿÓZ  í#I@³ë JíƒO¿…Ù™›!úÃ'.×°+	˜™i ljğ¼_„€õVßœg"µ©÷ü¶·Ïğs£uƒ‡gœ‘Ğ±ù;€pT õTÓ‡--/-¹`Âº)DİëÊU…†0Bœ(37É6 \=ª](°º hğPÖÖ7CÁõÏ‰£ÜŒlÎU£àâñımI `¾¼¸k×®ğğÃK¨Û?&.q[ŸÏì×ª:8û¶›*rºçºÓáÜÓû$tİücõ>› àà@¬ß±ÑÊVô»Òn8¡byÉ.€/`ôÌg8»JÚ-xÚ€Q °: · ¸* õ!2»İşÖm­0ü°lá…âtd‰$ÿ¢€1 Xb%øX¢%üZÚå—sıY`dìø3ï(3Í“Ğ5óŒ hnˆ‚0 ² ˆ=}w+V•œƒ 0a&ÌÉs6øvQ…g„C€á'Ø
+ ö½«F¶‹;	¶eË·ÃƒÏšëé™?}4œ7ú8Ó‰¾Xf€şıû‹=¬‹/^w>^ñ³ÖŸeÿ›¦Lg6¨_øÛÜ‰	_3Ï®± CÀ§Û7Zİ’Æ8èªBôJšPQVò>À„åÌœMï†W1°0ØpÄ `¿¬ƒ3o~Ñ”«Û.+Ş~ä1é•¨é€ñÌšU·Ür³XÜ_«Ÿ ŠŸ^o¯6çíÎøã0¸lÂ€„Ç3 ä¨ xÜ"uŠqô•yCÀ«S ®*”±îro ƒÆA¦ V
+ì¶ WŒÈ3Q
+û²ï^~Ï°u×¯¦¾}ó”SâêïV^ÜYYj °ò]Öê³r^íï¶\«¶]{ªàóŞ§ø2Ã8øï’‹ S^jÂ×Ë³«÷Ç?åª ÒÀºíâ€ş86qw{åª’¥ 3É«Ñ³'	\à-Ö-8jğx± Ë. ĞÛå" ¬ÇıÊ-½»vÌı¿•¦>’ä†ÿQ/ 3Ík1H ˆfòÙ€6p‡à‘Nq~$…Ü¢÷`İ—•¦>;vhwÕTàñÚskl@O¬`9€uÛ6Ä»ÅH·`dâèªB9o WÅK« f‚EÒ>cÔ³l ³+" "«Ûd­İ%w½..bÆş0ö8˜s€ñ¥ ªË†ì²¡»ñ¸ğ‰ºûR[»¥n]l.ÄeÓ¥½º`2tëhÏ¼Ï®Ù÷w[ ÊéÃ|‘JAz‰=]QZ2`Âº›w\À×¸eÔ)\™6àòáZ *³ÛÿdkÜôĞ»¦{şô‚„º¾úõ;^>›¬Ãjkow«Ïì§}µ0•†BlYp³œsåÛ~ÿ¹µ6 ÔğIÜ z’ID…P÷ 	×‰{V,Ø 0•,zâô¡gİ”™“d+ ¦Ï ë0¸~Áÿ`ıWæÜ_6ñÅßæM„“z·kß«««!--İ²èí>³†F\yï[°»ÜÜZ™I^¼µd
+d§'Ù¶Ï¯=` ‚IÀzX›  æôalfùòÒEw  LX÷‚Û2‡ŸrnUf¶—n .;5â›€F»WàëöÃç½n:á…İ÷{è`¢BPká‹×¢m®¾r»·/]ş£éïLÿı ˜vÁ [÷ãùOZ  _mHôè„A½¶ À•¥‹z  LÚ¥³Vú) ¬ Õ& \zjNÄà8Î–C;ïÉR1)hÖúvË…gï9’<N¡'.Z»[{¥=±l<ûö¦?ÏKe™ÿğßk—ıÓf ² a/@Ñ# Öì’V±rÑ€™ÖzöJ_F¶×™e# ş8,Ç–$ Ô~Ş_#Î‚Ûì3ßÕËFÁ±l¸õ-ÙÚ+íå·AÉë,}gîÕ#á÷…ılß—ÖÙ€5_n°éd„
+…<€ğrãôú]R¾báL€) ”¶  ²r ñmÿ…w¿„¥/}jé;lá‡gŒ‡vÙ)­ZôÌØØ‡E/|ÿYùµ¥ï±ª¿§î:'rh3 ¨j ¬·Ç‘d ¸ŠP¸;ı p«X¹`À î,õeÚ€KNÉ6™´&°º€÷>ùÖÒş0÷xÉŒ3LÏßÒî½–ªm„Y®€Í_ÿlé{lºïæŸ'NşÙöâ§6`=¬¶ ’¡Â!€^P‹*V,˜ 0aS[  [€… ×=ğ|¹ûWK[d‹cŞuÕ(Uá‘láõìÛŠ*˜ñğr¨ÜWcé{,ëÿìŸ'Aï®Ù-¶oÿ² Uv@£' ‚eÁìú™C=€… S (óeæx( ’ìÀĞ¬Ûªªá²»ß„½j-÷üÑ}á†?†ÜÌä£~ì™Ëÿzéx|Ù&S|È½&€%·!ùoIû×úƒö`_ƒX°zë§‰ª?Zìÿ—®"„ç¯¯\±à)€	»¼ pQ€Ù7{ªàê{ß‚†&¿åï²rşxV¸âœ“Ä‡´1¯ƒMzòäk› â×š¸¶qó”!pÕ¤-¾¯/Ù€Z„ ğqÜ  ı‡C€@Ôı{ˆÏÅ»z¿ò  m# ¦ 0[õÙpÇ#Ëã­–‘ê¡":	.:£?Gäxúemñ7Â×?ÄŸ]?{D/¸ïú‚#²¿ÿ¶ ã€Zü÷Ÿ„º qñç*W>tÕ‘ÖQÛÀ
+€l
+€<0äÈ €Ù²åÛ`Ñë ‘¼ë!`¡s§ûuÏ±}«ªéEÿÙx÷“İ°yÇÏ	mkø‰ùÔõ/æ4 6´  ¶|—ğCÒöõ‡ZÿHÿ??uNgß=-ü`Ò®àµ É<b `ÆÉ¸û©Uâzy‰«=¨+îƒûu×ÄclÕŞ²Í?ÒÛğåî}¦†ñ‚uÜñ0ó²SãŞ§xìå‡l@=¬2 "»Š_Úò!÷?*œ}äÙÊU‹¯>:j³ ¸ê®²` @šM øÃà# f;< –ÎşGbPÏÒ’=pBÏ\ÈËJœŒdzŸ,v)æÒÇ¬Ü¸®ÁûÕ‹·‡`ÿaúø`|ÿÓ!øáçC¶í‡ÓÉÃìË‡·H¡‘½²Ñ& T³^€± ,& ´„/mõÃå¿! „»{±2oè•GkRÀQ ³ƒÕ0ó±åğÅÎ½p¬ëß_tË8±ØçhØ‘€–»jñÅŒ¿BôA·xÂ=X¾ªdîÑ<O€V  f¬kmÁókáÍ²m^ü¬éŒ3ÄbŸ£eG î>‘L. 4˜@Ç“™¥Kú!€V€°½^ú5,}i½åşõÖbGö;¯nûàÖ€XÂ—¸û C/9®Y?®~ğçÖp¾ ­ ÌXöıé7>£0Ø	xW¸<Â6°O{¸õâapRïv­bZ 1Ü}I–?ú<4ÀzÜZ±ré†ÖtŞ ­ acù'–m„hµç¡G§L¸å¢¡-^Ù×: °N-|Îõ§¾ø~%áù9•+½ĞÏ  llüÀ#/¯oUIÂ¼Ìd¸~ò`˜tz“S© øbFœO"Ù}©@7p<<B÷U¬[ÚĞZu„ h ÛêÏ÷ÀËË·ÃÆí?µĞàw³à¼Ñ}Ä9üY¼³- ô‹µŠ8_ß3°åH8îuÁÁßşÓGíií:B ´! „­º®	Ö|QeŸı(N>ÚĞ‚	C6VÿD×³£‚Áİ¡Kûô6q}´ >[­İ­ó·p÷§ŠÒ’UmEG€6 ©5ûÑ#`•{ÌCØw¨>ám²–ı”:AÁ îpúÉ][lÌ~[ÀÊÍe²¬~ôüJ/œ{*W>ô•iKÇ	ĞÆ 4VİÇª
+Ùı¾ƒupàP°ÚoßÁz¨©o·Ó)+n—,V
+æf&‰Uƒ¹Iâø‚Nyi­2®?Ú X±ñ#	 ÄP ™*èIoCãİ»×?^İà ZËà£õ„ã|&÷‰Ãù§Ê¾iËÇ	€ @ ˜ÀºwYœ¿“#üŒŠU½w,'  ` Ë×½7³2oÈ#Gs5_  í(à¹…Ü±vœ cóğŠ€ øMàœéêE ­[}³ oo©F   ¬Ùğ)Ğ%Û…
+jãVyĞkv×!  Öì¸^81ß‹
+jã¶µ¢vüÜˆ @ X³viN(ì—Š
+jãV¶³öVû  ‹ƒ~· oª´¶iûjPº³&¡Ù– ¿Q 0Kõğpæ	iàÄî€6gl€äû_UCmSb#% ¿a 0ëÕÎƒ»%¡¢Ú˜}¾§¾ÙÛ”ğv ¿q 0ëİŞ#&Ñh-ÿÖ
+{Ä @ ÈÂ¡=’1'ĞÊcşß×%ìö#  º–G›ê„ì‡xKvc±ĞÑ2Väs°. è­ªÎ¿ÖøØ<€ @û €† @   Ğ    € @C    h   € @  !  GŞ®˜SæË¤ È¦ HMwÇãD  Ù
+€¦&?ÔÖøáà¾8HğüB@ëÀìÒæŒœ$Wv‡z p{À;x š- „z Ôn¢âo„C) 
+ ­Å®œSöKj†»}v.2=àñ:ÀÑ
+ÀI2'=Üœúà+÷NólµôŸHTÂO‰B(ß#Ÿ%ªMµr €¸øjsS ª5‹!@ÍÁ¦ƒ Ù€VbWÏ[µÊãuç…Œ,/x“œàp² eş$N*b‰x9¥¸5Ş“J™ãô!“¼Ø¹˜g‹Wêª—ˆˆâ	1Bôß¼§óú‘ö ~~
+€&8@C€ÆÚæõÏ.(<ĞJìÚ»Ëãyç-™¹^ÈÌöBr²œî `RGÇ{P¤'° œäMNCĞ*8è	SŸ®Xàâ—¾FKML¶ö!Ém`(ß'Š×¥¿Kb~È?Cì…ÿÓmù}Ô×ùàğÁF¨Ú×È^{úïóGMG ´›>õ%>y)=ËY9I’æ·ÇEÃ 5 8N.f}Ñs¡Ïê|O*v0˜İôoä p:§VéšÇƒÊ 1Zrı÷  %ô˜¯i}7 ¬ÀAlı@İÔÕøàPU½5‚Û×>uÏè  Z‰M[¸<ÃWãÚ”âÎÍÈ&“Ràr²\@PÈ<Ïi
+]ë¹ Ğò4Ä®€0D8|€^º§/pNïbÂ"fKŠˆ´E7)şØ¯É¿KBÿ˜p0~®÷÷Tü> ëıPSİ,z õ5şƒn·ĞçéâÂı€Vd7/ZaSƒï•Ô4—áz^¯\4àyoğ1ÅnƒXÂ×='Ù–\Ôš¯I ¶¦ø9¹ì9ÎŞ€Ê…'DÚB—ƒ!*:EËvµ%ßU&
+BôÁ`ô\	íÏÖòğhj@}m3 õ(¨gyù_î:õ8­ÍwkÜº`İk!“SR]’ê†äT§Xàrsàà¨ø¼¸Üg
+ Ñ–_WìœN( Û¦¢•—ÀA.xNáe¨_‹Â@;‘ÈiĞ€³"|¥ÈU.<‘ÅçÊ×U"W¼&y‘çyïGD¯	ùs}Ë¼¨î©øĞ~?c hì_Kİ–à€¼ıä¼‘çÂ1jm ³ŸÚ”Q·¿yÇsİ’’œâ‚¤$'¸İ.>˜àù7 ‡€2$‰^·_ú=‰ 9M¨½ İçJÁK  ıô<ˆÑÒë
+Z!~ ŠÏ)Zr¥èõŸË[uP\éhy zâ¥øÀ 0 °Œ¿ >Ÿ Vş5R 0á7Õ @Hyr
+7péíÃ« ­ØJş¹%å§½õoj.òxœ×Ë‚¼
+8yğN@°RPÃ}×jÑ¥Ş (Zn©ğ9N‘ıçÔ­¹Ôí—yR±Js’$´WCª(’™Š3ª×BQ%ø”É3U—!²VšÈm’ïÆò
+ÂÏ%¿!Ë©Àå  é{2HH¶§é!Hş	¸ÄíÓ_lıiÌïøÁ×L[ÿ&æø(qy¯¦pY×.šİ¯a;¦*›f”¬¿ ±Ş÷Wz²Û9iëïtR€ŞX… Ï
+ğòŒ¾*şWdè9½–—Ótùt¼÷_éÆKá G$ŠıĞ‚“ô÷ô["íP¸ÓR7H|R·]-zU‚O
+PlG’±×‚º6@î	èÃŠÈö‘uhõ
+‚å¾bÜO=€€? z„pû’3İ7>>óÔ×à7`Ç\icñ³¥Ş¿¸O‡ Œ¢îİ @ úÑ³šÉÆsÒ—p²L¾D@|D¼DYù~‰ğ´åHåB/©A¡ˆÙ9	t´<i†_‘å×	”ÉBéŞ™ˆFrÂ$ª¥7À:xG#ıi¿\tD<Ğòü G”P­$!ûeA"øĞIvºßc8"íu"ß¢û,pÁrßàFªy§s;m#6óç>­êãÇo=»	~#†•ó	X—ÑEĞëí.cP8°ÑˆôsˆİbĞÁµ•CLTê'‘à\¹î)Á{ö::ç;…ä…?”7â øMYşi3’ˆÇ±‹Š½s 4æ àÅ›¬‹ Í	ŸD…¾g³Ø´²Ôÿ
+Ç»fV¬| ¯ÀoÖ:™5•¶Šÿd-¿è„¼  ‹9Z±øIÔ¥¶ì¡–> @Ğæ69xşO?®|è<û 4‚™ŸR/`˜(z)8^ÒåÈµná‰Š]êæ‡îé£_€sÎı©tá3xÆ hÒP`ÌŒS àXÇº"¹  Pb°5@Àdœ/H…/‚„yÜçù{?\\‡g€¦é½@æeÀ;Z™ %|¹ôÒ8? iùÅ8Ÿeìßr¸3ö|´ğ;<Ã ´Ö½ ¨ƒÈ7Ç§‰ù ‡ Ô+pô¼€xâ|ñSÛx ·í)[üY šù\À\z@ïİ-x$»†ğeî¾¤ÅBá G¸ù…)âbÏ( Í‚õï_ì>œ[û5U~H· xï8Bİ‚fºõ”ıùì‚ŸçàiñÏı¡ì‘Cx& hqZşè™Ğ£úº˜ Åï’w¶ÌÆù‚ª[ ÷‘Óé¹õÇîßg€fŠVÒ#[xd‚ñÆùd7Ç¹î(/]ğ1 š 7{ ñ>£ñ¿³åººõÂÕ{a P!9LÿYĞ¾¦úáÍ›ŸöáÙB  µ€u)(ú+•ÜôH€…,À'€¸ËwôİIîY¿¼·`!4@KzgÎÈ&ün*ş¬p™pâãb¸û‘x? ç¯uòpë+K>Ã3ƒ† 8BÖytÑ#ƒæ8+İ‚úå»¡ZI>ØCúÎò•%ÿÆ³† 8Òvá2Gç}¿¤.ÿqAá;,&ã¦K xn‰‹$?ˆÃtÑ G3P8ûLŞ]I¨Bé)±ç‡ ¦Ë-£Û˜YY¶¨> 5ä
+f¾CïÎ‰TrQ/ :©§–‡éÂfãş´§´d-q4@kÀE½ÁG¾¤1€'
+8‚eÂ¡YD•sûÙäzúå»Ô~€›÷SÙCÏˆS_¡¡! ZŸu.˜uUğâ`/@œÖÄ!a„İşh¾b˜nı÷‰fH)ŞWV\‹GĞúCÇ©hoW+
+'¹ĞFÒ…
+t'èˆÓ}›~}FùÊ’oñ¨¢! ÚŒ.¿ è*ãóÄnÀpë û/:Ï®<îç·%°#ÜŒòK>Äc‰† hƒÖ½ Øë#µOÑ	mí]ÑD 'iıA™õ¯â8îŞŠ‚”Çq˜.à°cævóß]Tç—Sá{#î$ş?õÖ
+„¼êß¿p˜.àØô: éTàH6
+²¨ò³¨Wğ³ÏM–aÍ> €††† @CCC  ¡¡! ĞĞĞ hhh 444  €††† @CCC  ¡¡! ĞĞĞ hh 444  €††† @CCC  ¡¡! ĞĞĞ hhh 44´6oÿİıpî®›ŠÏ    IEND®B`‚
\ Brak znaku nowej linii na koÅ„cu pliku
diff -Naur mplayer-1.0_rc4_p20120109/ffmpeg/libavcodec/allcodecs.c mplayer-1.0_rc4_p20120109-new/ffmpeg/libavcodec/allcodecs.c
--- mplayer-1.0_rc4_p20120109/ffmpeg/libavcodec/allcodecs.c	2012-01-09 14:49:54.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/ffmpeg/libavcodec/allcodecs.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,465 +0,0 @@
-/*
- * Provide registration of all codecs, parsers and bitstream filters for libavcodec.
- * Copyright (c) 2002 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * Provide registration of all codecs, parsers and bitstream filters for libavcodec.
- */
-
-#include <libavcodec/avcodec.h>
-
-#define REGISTER_HWACCEL(X,x) { \
-          extern AVHWAccel ff_##x##_hwaccel; \
-          if(CONFIG_##X##_HWACCEL) av_register_hwaccel(&ff_##x##_hwaccel); }
-
-#define REGISTER_ENCODER(X,x) { \
-          extern AVCodec ff_##x##_encoder; \
-          if(CONFIG_##X##_ENCODER)  avcodec_register(&ff_##x##_encoder); }
-#define REGISTER_DECODER(X,x) { \
-          extern AVCodec ff_##x##_decoder; \
-          if(CONFIG_##X##_DECODER)  avcodec_register(&ff_##x##_decoder); }
-#define REGISTER_ENCDEC(X,x)  REGISTER_ENCODER(X,x); REGISTER_DECODER(X,x)
-
-#define REGISTER_PARSER(X,x) { \
-          extern AVCodecParser ff_##x##_parser; \
-          if(CONFIG_##X##_PARSER)  av_register_codec_parser(&ff_##x##_parser); }
-#define REGISTER_BSF(X,x) { \
-          extern AVBitStreamFilter ff_##x##_bsf; \
-          if(CONFIG_##X##_BSF)     av_register_bitstream_filter(&ff_##x##_bsf); }
-
-void avcodec_register_all(void)
-{
-    static int initialized;
-
-    if (initialized)
-        return;
-    initialized = 1;
-
-    /* hardware accelerators */
-    REGISTER_HWACCEL (H263_VAAPI, h263_vaapi);
-    REGISTER_HWACCEL (H264_DXVA2, h264_dxva2);
-    REGISTER_HWACCEL (H264_VAAPI, h264_vaapi);
-    REGISTER_HWACCEL (H264_VDA, h264_vda);
-    REGISTER_HWACCEL (MPEG1_VDPAU, mpeg1_vdpau);
-    REGISTER_HWACCEL (MPEG2_DXVA2, mpeg2_dxva2);
-    REGISTER_HWACCEL (MPEG2_VAAPI, mpeg2_vaapi);
-    REGISTER_HWACCEL (MPEG2_VDPAU, mpeg2_vdpau);
-    REGISTER_HWACCEL (MPEG4_VAAPI, mpeg4_vaapi);
-    REGISTER_HWACCEL (VC1_DXVA2, vc1_dxva2);
-    REGISTER_HWACCEL (VC1_VAAPI, vc1_vaapi);
-    REGISTER_HWACCEL (WMV3_DXVA2, wmv3_dxva2);
-    REGISTER_HWACCEL (WMV3_VAAPI, wmv3_vaapi);
-
-    /* video codecs */
-    REGISTER_ENCODER (A64MULTI, a64multi);
-    REGISTER_ENCODER (A64MULTI5, a64multi5);
-    REGISTER_DECODER (AASC, aasc);
-    REGISTER_ENCDEC  (AMV, amv);
-    REGISTER_DECODER (ANM, anm);
-    REGISTER_DECODER (ANSI, ansi);
-    REGISTER_ENCDEC  (ASV1, asv1);
-    REGISTER_ENCDEC  (ASV2, asv2);
-    REGISTER_DECODER (AURA, aura);
-    REGISTER_DECODER (AURA2, aura2);
-    REGISTER_DECODER (AVRP, avrp);
-    REGISTER_DECODER (AVS, avs);
-    REGISTER_DECODER (BETHSOFTVID, bethsoftvid);
-    REGISTER_DECODER (BFI, bfi);
-    REGISTER_DECODER (BINK, bink);
-    REGISTER_ENCDEC  (BMP, bmp);
-    REGISTER_DECODER (BMV_VIDEO, bmv_video);
-    REGISTER_DECODER (C93, c93);
-    REGISTER_DECODER (CAVS, cavs);
-    REGISTER_DECODER (CDGRAPHICS, cdgraphics);
-    REGISTER_DECODER (CINEPAK, cinepak);
-    REGISTER_ENCDEC  (CLJR, cljr);
-    REGISTER_DECODER (CSCD, cscd);
-    REGISTER_DECODER (CYUV, cyuv);
-    REGISTER_DECODER (DFA, dfa);
-    REGISTER_DECODER (DIRAC, dirac);
-    REGISTER_ENCDEC  (DNXHD, dnxhd);
-    REGISTER_ENCDEC  (DPX, dpx);
-    REGISTER_DECODER (DSICINVIDEO, dsicinvideo);
-    REGISTER_ENCDEC  (DVVIDEO, dvvideo);
-    REGISTER_DECODER (DXA, dxa);
-    REGISTER_DECODER (DXTORY, dxtory);
-    REGISTER_DECODER (EACMV, eacmv);
-    REGISTER_DECODER (EAMAD, eamad);
-    REGISTER_DECODER (EATGQ, eatgq);
-    REGISTER_DECODER (EATGV, eatgv);
-    REGISTER_DECODER (EATQI, eatqi);
-    REGISTER_DECODER (EIGHTBPS, eightbps);
-    REGISTER_DECODER (EIGHTSVX_EXP, eightsvx_exp);
-    REGISTER_DECODER (EIGHTSVX_FIB, eightsvx_fib);
-    REGISTER_DECODER (ESCAPE124, escape124);
-    REGISTER_DECODER (ESCAPE130, escape130);
-    REGISTER_ENCDEC  (FFV1, ffv1);
-    REGISTER_ENCDEC  (FFVHUFF, ffvhuff);
-    REGISTER_ENCDEC  (FLASHSV, flashsv);
-    REGISTER_ENCDEC  (FLASHSV2, flashsv2);
-    REGISTER_DECODER (FLIC, flic);
-    REGISTER_ENCDEC  (FLV, flv);
-    REGISTER_DECODER (FOURXM, fourxm);
-    REGISTER_DECODER (FRAPS, fraps);
-    REGISTER_DECODER (FRWU, frwu);
-    REGISTER_ENCDEC  (GIF, gif);
-    REGISTER_ENCDEC  (H261, h261);
-    REGISTER_ENCDEC  (H263, h263);
-    REGISTER_DECODER (H263I, h263i);
-    REGISTER_ENCODER (H263P, h263p);
-    REGISTER_DECODER (H264, h264);
-    REGISTER_DECODER (H264_CRYSTALHD, h264_crystalhd);
-    REGISTER_DECODER (H264_VDPAU, h264_vdpau);
-    REGISTER_ENCDEC  (HUFFYUV, huffyuv);
-    REGISTER_DECODER (IDCIN, idcin);
-    REGISTER_DECODER (IFF_BYTERUN1, iff_byterun1);
-    REGISTER_DECODER (IFF_ILBM, iff_ilbm);
-    REGISTER_DECODER (INDEO2, indeo2);
-    REGISTER_DECODER (INDEO3, indeo3);
-    REGISTER_DECODER (INDEO4, indeo4);
-    REGISTER_DECODER (INDEO5, indeo5);
-    REGISTER_DECODER (INTERPLAY_VIDEO, interplay_video);
-    REGISTER_ENCDEC  (JPEG2000, jpeg2000);
-    REGISTER_ENCDEC  (JPEGLS, jpegls);
-    REGISTER_DECODER (JV, jv);
-    REGISTER_DECODER (KGV1, kgv1);
-    REGISTER_DECODER (KMVC, kmvc);
-    REGISTER_DECODER (LAGARITH, lagarith);
-    REGISTER_ENCODER (LJPEG, ljpeg);
-    REGISTER_DECODER (LOCO, loco);
-    REGISTER_DECODER (MDEC, mdec);
-    REGISTER_DECODER (MIMIC, mimic);
-    REGISTER_ENCDEC  (MJPEG, mjpeg);
-    REGISTER_DECODER (MJPEGB, mjpegb);
-    REGISTER_DECODER (MMVIDEO, mmvideo);
-    REGISTER_DECODER (MOTIONPIXELS, motionpixels);
-    REGISTER_DECODER (MPEG_XVMC, mpeg_xvmc);
-    REGISTER_ENCDEC  (MPEG1VIDEO, mpeg1video);
-    REGISTER_ENCDEC  (MPEG2VIDEO, mpeg2video);
-    REGISTER_ENCDEC  (MPEG4, mpeg4);
-    REGISTER_DECODER (MPEG4_CRYSTALHD, mpeg4_crystalhd);
-    REGISTER_DECODER (MPEG4_VDPAU, mpeg4_vdpau);
-    REGISTER_DECODER (MPEGVIDEO, mpegvideo);
-    REGISTER_DECODER (MPEG_VDPAU, mpeg_vdpau);
-    REGISTER_DECODER (MPEG1_VDPAU, mpeg1_vdpau);
-    REGISTER_DECODER (MPEG2_CRYSTALHD, mpeg2_crystalhd);
-    REGISTER_DECODER (MSMPEG4_CRYSTALHD, msmpeg4_crystalhd);
-    REGISTER_DECODER (MSMPEG4V1, msmpeg4v1);
-    REGISTER_ENCDEC  (MSMPEG4V2, msmpeg4v2);
-    REGISTER_ENCDEC  (MSMPEG4V3, msmpeg4v3);
-    REGISTER_DECODER (MSRLE, msrle);
-    REGISTER_ENCDEC  (MSVIDEO1, msvideo1);
-    REGISTER_DECODER (MSZH, mszh);
-    REGISTER_DECODER (MXPEG, mxpeg);
-    REGISTER_DECODER (NUV, nuv);
-    REGISTER_ENCDEC  (PAM, pam);
-    REGISTER_ENCDEC  (PBM, pbm);
-    REGISTER_ENCDEC  (PCX, pcx);
-    REGISTER_ENCDEC  (PGM, pgm);
-    REGISTER_ENCDEC  (PGMYUV, pgmyuv);
-    REGISTER_DECODER (PICTOR, pictor);
-    REGISTER_ENCDEC  (PNG, png);
-    REGISTER_ENCDEC  (PPM, ppm);
-    REGISTER_ENCDEC  (PRORES, prores);
-    REGISTER_DECODER (PRORES_LGPL, prores_lgpl);
-    REGISTER_DECODER (PTX, ptx);
-    REGISTER_DECODER (QDRAW, qdraw);
-    REGISTER_DECODER (QPEG, qpeg);
-    REGISTER_ENCDEC  (QTRLE, qtrle);
-    REGISTER_DECODER (R10K,  r10k);
-    REGISTER_DECODER (R210,  r210);
-    REGISTER_ENCDEC  (RAWVIDEO, rawvideo);
-    REGISTER_DECODER (RL2, rl2);
-    REGISTER_ENCDEC  (ROQ, roq);
-    REGISTER_DECODER (RPZA, rpza);
-    REGISTER_ENCDEC  (RV10, rv10);
-    REGISTER_ENCDEC  (RV20, rv20);
-    REGISTER_DECODER (RV30, rv30);
-    REGISTER_DECODER (RV40, rv40);
-    REGISTER_DECODER (S302M, s302m);
-    REGISTER_ENCDEC  (SGI, sgi);
-    REGISTER_DECODER (SMACKER, smacker);
-    REGISTER_DECODER (SMC, smc);
-    REGISTER_ENCDEC  (SNOW, snow);
-    REGISTER_DECODER (SP5X, sp5x);
-    REGISTER_DECODER (SUNRAST, sunrast);
-    REGISTER_ENCDEC  (SVQ1, svq1);
-    REGISTER_DECODER (SVQ3, svq3);
-    REGISTER_ENCDEC  (TARGA, targa);
-    REGISTER_DECODER (THEORA, theora);
-    REGISTER_DECODER (THP, thp);
-    REGISTER_DECODER (TIERTEXSEQVIDEO, tiertexseqvideo);
-    REGISTER_ENCDEC  (TIFF, tiff);
-    REGISTER_DECODER (TMV, tmv);
-    REGISTER_DECODER (TRUEMOTION1, truemotion1);
-    REGISTER_DECODER (TRUEMOTION2, truemotion2);
-    REGISTER_DECODER (TSCC, tscc);
-    REGISTER_DECODER (TXD, txd);
-    REGISTER_DECODER (ULTI, ulti);
-    REGISTER_DECODER (UTVIDEO, utvideo);
-    REGISTER_ENCDEC  (V210,  v210);
-    REGISTER_DECODER (V210X, v210x);
-    REGISTER_ENCDEC  (V308, v308);
-    REGISTER_ENCDEC  (V410, v410);
-    REGISTER_DECODER (VB, vb);
-    REGISTER_DECODER (VBLE, vble);
-    REGISTER_DECODER (VC1, vc1);
-    REGISTER_DECODER (VC1_CRYSTALHD, vc1_crystalhd);
-    REGISTER_DECODER (VC1_VDPAU, vc1_vdpau);
-    REGISTER_DECODER (VC1IMAGE, vc1image);
-    REGISTER_DECODER (VCR1, vcr1);
-    REGISTER_DECODER (VMDVIDEO, vmdvideo);
-    REGISTER_DECODER (VMNC, vmnc);
-    REGISTER_DECODER (VP3, vp3);
-    REGISTER_DECODER (VP5, vp5);
-    REGISTER_DECODER (VP6, vp6);
-    REGISTER_DECODER (VP6A, vp6a);
-    REGISTER_DECODER (VP6F, vp6f);
-    REGISTER_DECODER (VP8, vp8);
-    REGISTER_DECODER (VQA, vqa);
-    REGISTER_ENCDEC  (WMV1, wmv1);
-    REGISTER_ENCDEC  (WMV2, wmv2);
-    REGISTER_DECODER (WMV3, wmv3);
-    REGISTER_DECODER (WMV3_CRYSTALHD, wmv3_crystalhd);
-    REGISTER_DECODER (WMV3_VDPAU, wmv3_vdpau);
-    REGISTER_DECODER (WMV3IMAGE, wmv3image);
-    REGISTER_DECODER (WNV1, wnv1);
-    REGISTER_DECODER (XAN_WC3, xan_wc3);
-    REGISTER_DECODER (XAN_WC4, xan_wc4);
-    REGISTER_DECODER (XL, xl);
-    REGISTER_ENCDEC  (Y41P, y41p);
-    REGISTER_DECODER (YOP, yop);
-    REGISTER_ENCDEC  (YUV4, yuv4);
-    REGISTER_ENCDEC  (ZLIB, zlib);
-    REGISTER_ENCDEC  (ZMBV, zmbv);
-
-    /* audio codecs */
-    REGISTER_ENCDEC  (AAC, aac);
-    REGISTER_DECODER (AAC_LATM, aac_latm);
-    REGISTER_ENCDEC  (AC3, ac3);
-    REGISTER_ENCODER (AC3_FIXED, ac3_fixed);
-    REGISTER_ENCDEC  (ALAC, alac);
-    REGISTER_DECODER (ALS, als);
-    REGISTER_DECODER (AMRNB, amrnb);
-    REGISTER_DECODER (AMRWB, amrwb);
-    REGISTER_DECODER (APE, ape);
-    REGISTER_DECODER (ATRAC1, atrac1);
-    REGISTER_DECODER (ATRAC3, atrac3);
-    REGISTER_DECODER (BINKAUDIO_DCT, binkaudio_dct);
-    REGISTER_DECODER (BINKAUDIO_RDFT, binkaudio_rdft);
-    REGISTER_DECODER (BMV_AUDIO, bmv_audio);
-    REGISTER_DECODER (COOK, cook);
-    REGISTER_ENCDEC  (DCA, dca);
-    REGISTER_DECODER (DSICINAUDIO, dsicinaudio);
-    REGISTER_ENCDEC  (EAC3, eac3);
-    REGISTER_DECODER (FFWAVESYNTH, ffwavesynth);
-    REGISTER_ENCDEC  (FLAC, flac);
-    REGISTER_ENCDEC  (G723_1, g723_1);
-    REGISTER_DECODER (G729, g729);
-    REGISTER_DECODER (GSM, gsm);
-    REGISTER_DECODER (GSM_MS, gsm_ms);
-    REGISTER_DECODER (IMC, imc);
-    REGISTER_DECODER (MACE3, mace3);
-    REGISTER_DECODER (MACE6, mace6);
-    REGISTER_DECODER (MLP, mlp);
-    REGISTER_DECODER (MP1, mp1);
-    REGISTER_DECODER (MP1FLOAT, mp1float);
-    REGISTER_ENCDEC  (MP2, mp2);
-    REGISTER_DECODER (MP2FLOAT, mp2float);
-    REGISTER_DECODER (MP3, mp3);
-    REGISTER_DECODER (MP3FLOAT, mp3float);
-    REGISTER_DECODER (MP3ADU, mp3adu);
-    REGISTER_DECODER (MP3ADUFLOAT, mp3adufloat);
-    REGISTER_DECODER (MP3ON4, mp3on4);
-    REGISTER_DECODER (MP3ON4FLOAT, mp3on4float);
-    REGISTER_DECODER (MPC7, mpc7);
-    REGISTER_DECODER (MPC8, mpc8);
-    REGISTER_ENCDEC  (NELLYMOSER, nellymoser);
-    REGISTER_DECODER (QCELP, qcelp);
-    REGISTER_DECODER (QDM2, qdm2);
-    REGISTER_ENCDEC  (RA_144, ra_144);
-    REGISTER_DECODER (RA_288, ra_288);
-    REGISTER_DECODER (SHORTEN, shorten);
-    REGISTER_DECODER (SIPR, sipr);
-    REGISTER_DECODER (SMACKAUD, smackaud);
-    REGISTER_ENCDEC  (SONIC, sonic);
-    REGISTER_ENCODER (SONIC_LS, sonic_ls);
-    REGISTER_DECODER (TRUEHD, truehd);
-    REGISTER_DECODER (TRUESPEECH, truespeech);
-    REGISTER_DECODER (TTA, tta);
-    REGISTER_DECODER (TWINVQ, twinvq);
-    REGISTER_DECODER (VMDAUDIO, vmdaudio);
-    REGISTER_ENCDEC  (VORBIS, vorbis);
-    REGISTER_DECODER (WAVPACK, wavpack);
-    REGISTER_DECODER (WMALOSSLESS, wmalossless);
-    REGISTER_DECODER (WMAPRO, wmapro);
-    REGISTER_ENCDEC  (WMAV1, wmav1);
-    REGISTER_ENCDEC  (WMAV2, wmav2);
-    REGISTER_DECODER (WMAVOICE, wmavoice);
-    REGISTER_DECODER (WS_SND1, ws_snd1);
-
-    /* PCM codecs */
-    REGISTER_ENCDEC  (PCM_ALAW, pcm_alaw);
-    REGISTER_DECODER (PCM_BLURAY, pcm_bluray);
-    REGISTER_DECODER (PCM_DVD, pcm_dvd);
-    REGISTER_ENCDEC  (PCM_F32BE, pcm_f32be);
-    REGISTER_ENCDEC  (PCM_F32LE, pcm_f32le);
-    REGISTER_ENCDEC  (PCM_F64BE, pcm_f64be);
-    REGISTER_ENCDEC  (PCM_F64LE, pcm_f64le);
-    REGISTER_DECODER (PCM_LXF, pcm_lxf);
-    REGISTER_ENCDEC  (PCM_MULAW, pcm_mulaw);
-    REGISTER_ENCDEC  (PCM_S8, pcm_s8);
-    REGISTER_DECODER (PCM_S8_PLANAR, pcm_s8_planar);
-    REGISTER_ENCDEC  (PCM_S16BE, pcm_s16be);
-    REGISTER_ENCDEC  (PCM_S16LE, pcm_s16le);
-    REGISTER_DECODER (PCM_S16LE_PLANAR, pcm_s16le_planar);
-    REGISTER_ENCDEC  (PCM_S24BE, pcm_s24be);
-    REGISTER_ENCDEC  (PCM_S24DAUD, pcm_s24daud);
-    REGISTER_ENCDEC  (PCM_S24LE, pcm_s24le);
-    REGISTER_ENCDEC  (PCM_S32BE, pcm_s32be);
-    REGISTER_ENCDEC  (PCM_S32LE, pcm_s32le);
-    REGISTER_ENCDEC  (PCM_U8, pcm_u8);
-    REGISTER_ENCDEC  (PCM_U16BE, pcm_u16be);
-    REGISTER_ENCDEC  (PCM_U16LE, pcm_u16le);
-    REGISTER_ENCDEC  (PCM_U24BE, pcm_u24be);
-    REGISTER_ENCDEC  (PCM_U24LE, pcm_u24le);
-    REGISTER_ENCDEC  (PCM_U32BE, pcm_u32be);
-    REGISTER_ENCDEC  (PCM_U32LE, pcm_u32le);
-    REGISTER_DECODER (PCM_ZORK , pcm_zork);
-
-    /* DPCM codecs */
-    REGISTER_DECODER (INTERPLAY_DPCM, interplay_dpcm);
-    REGISTER_ENCDEC  (ROQ_DPCM, roq_dpcm);
-    REGISTER_DECODER (SOL_DPCM, sol_dpcm);
-    REGISTER_DECODER (XAN_DPCM, xan_dpcm);
-
-    /* ADPCM codecs */
-    REGISTER_DECODER (ADPCM_4XM, adpcm_4xm);
-    REGISTER_ENCDEC  (ADPCM_ADX, adpcm_adx);
-    REGISTER_DECODER (ADPCM_CT, adpcm_ct);
-    REGISTER_DECODER (ADPCM_EA, adpcm_ea);
-    REGISTER_DECODER (ADPCM_EA_MAXIS_XA, adpcm_ea_maxis_xa);
-    REGISTER_DECODER (ADPCM_EA_R1, adpcm_ea_r1);
-    REGISTER_DECODER (ADPCM_EA_R2, adpcm_ea_r2);
-    REGISTER_DECODER (ADPCM_EA_R3, adpcm_ea_r3);
-    REGISTER_DECODER (ADPCM_EA_XAS, adpcm_ea_xas);
-    REGISTER_ENCDEC  (ADPCM_G722, adpcm_g722);
-    REGISTER_ENCDEC  (ADPCM_G726, adpcm_g726);
-    REGISTER_DECODER (ADPCM_IMA_AMV, adpcm_ima_amv);
-    REGISTER_DECODER (ADPCM_IMA_DK3, adpcm_ima_dk3);
-    REGISTER_DECODER (ADPCM_IMA_DK4, adpcm_ima_dk4);
-    REGISTER_DECODER (ADPCM_IMA_EA_EACS, adpcm_ima_ea_eacs);
-    REGISTER_DECODER (ADPCM_IMA_EA_SEAD, adpcm_ima_ea_sead);
-    REGISTER_DECODER (ADPCM_IMA_ISS, adpcm_ima_iss);
-    REGISTER_ENCDEC  (ADPCM_IMA_QT, adpcm_ima_qt);
-    REGISTER_DECODER (ADPCM_IMA_SMJPEG, adpcm_ima_smjpeg);
-    REGISTER_ENCDEC  (ADPCM_IMA_WAV, adpcm_ima_wav);
-    REGISTER_DECODER (ADPCM_IMA_WS, adpcm_ima_ws);
-    REGISTER_ENCDEC  (ADPCM_MS, adpcm_ms);
-    REGISTER_DECODER (ADPCM_SBPRO_2, adpcm_sbpro_2);
-    REGISTER_DECODER (ADPCM_SBPRO_3, adpcm_sbpro_3);
-    REGISTER_DECODER (ADPCM_SBPRO_4, adpcm_sbpro_4);
-    REGISTER_ENCDEC  (ADPCM_SWF, adpcm_swf);
-    REGISTER_DECODER (ADPCM_THP, adpcm_thp);
-    REGISTER_DECODER (ADPCM_XA, adpcm_xa);
-    REGISTER_ENCDEC  (ADPCM_YAMAHA, adpcm_yamaha);
-
-    /* subtitles */
-    REGISTER_ENCDEC  (ASS, ass);
-    REGISTER_ENCDEC  (DVBSUB, dvbsub);
-    REGISTER_ENCDEC  (DVDSUB, dvdsub);
-    REGISTER_DECODER (PGSSUB, pgssub);
-    REGISTER_ENCDEC  (SRT, srt);
-    REGISTER_ENCDEC  (XSUB, xsub);
-
-    /* external libraries */
-    REGISTER_ENCODER (LIBAACPLUS, libaacplus);
-    REGISTER_DECODER (LIBCELT, libcelt);
-    REGISTER_ENCDEC  (LIBDIRAC, libdirac);
-    REGISTER_ENCODER (LIBFAAC, libfaac);
-    REGISTER_ENCDEC  (LIBGSM, libgsm);
-    REGISTER_ENCDEC  (LIBGSM_MS, libgsm_ms);
-    REGISTER_ENCODER (LIBMP3LAME, libmp3lame);
-    REGISTER_ENCDEC  (LIBOPENCORE_AMRNB, libopencore_amrnb);
-    REGISTER_DECODER (LIBOPENCORE_AMRWB, libopencore_amrwb);
-    REGISTER_ENCDEC (LIBOPENJPEG, libopenjpeg);
-    REGISTER_ENCDEC  (LIBSCHROEDINGER, libschroedinger);
-    REGISTER_ENCDEC  (LIBSPEEX, libspeex);
-    REGISTER_DECODER (LIBSTAGEFRIGHT_H264, libstagefright_h264);
-    REGISTER_ENCODER (LIBTHEORA, libtheora);
-    REGISTER_DECODER (LIBUTVIDEO, libutvideo);
-    REGISTER_ENCODER (LIBVO_AACENC, libvo_aacenc);
-    REGISTER_ENCODER (LIBVO_AMRWBENC, libvo_amrwbenc);
-    REGISTER_ENCODER (LIBVORBIS, libvorbis);
-    REGISTER_ENCDEC  (LIBVPX, libvpx);
-    REGISTER_ENCODER (LIBX264, libx264);
-    REGISTER_ENCODER (LIBX264RGB, libx264rgb);
-    REGISTER_ENCODER (LIBXAVS, libxavs);
-    REGISTER_ENCODER (LIBXVID, libxvid);
-
-    /* text */
-    REGISTER_DECODER (BINTEXT, bintext);
-    REGISTER_DECODER  (XBIN, xbin);
-    REGISTER_DECODER  (IDF, idf);
-
-    /* parsers */
-    REGISTER_PARSER  (AAC, aac);
-    REGISTER_PARSER  (AAC_LATM, aac_latm);
-    REGISTER_PARSER  (AC3, ac3);
-    REGISTER_PARSER  (ADX, adx);
-    REGISTER_PARSER  (CAVSVIDEO, cavsvideo);
-    REGISTER_PARSER  (DCA, dca);
-    REGISTER_PARSER  (DIRAC, dirac);
-    REGISTER_PARSER  (DNXHD, dnxhd);
-    REGISTER_PARSER  (DVBSUB, dvbsub);
-    REGISTER_PARSER  (DVDSUB, dvdsub);
-    REGISTER_PARSER  (FLAC, flac);
-    REGISTER_PARSER  (H261, h261);
-    REGISTER_PARSER  (H263, h263);
-    REGISTER_PARSER  (H264, h264);
-    REGISTER_PARSER  (MJPEG, mjpeg);
-    REGISTER_PARSER  (MLP, mlp);
-    REGISTER_PARSER  (MPEG4VIDEO, mpeg4video);
-    REGISTER_PARSER  (MPEGAUDIO, mpegaudio);
-    REGISTER_PARSER  (MPEGVIDEO, mpegvideo);
-    REGISTER_PARSER  (PNM, pnm);
-    REGISTER_PARSER  (RV30, rv30);
-    REGISTER_PARSER  (RV40, rv40);
-    REGISTER_PARSER  (VC1, vc1);
-    REGISTER_PARSER  (VP3, vp3);
-    REGISTER_PARSER  (VP8, vp8);
-
-    /* bitstream filters */
-    REGISTER_BSF     (AAC_ADTSTOASC, aac_adtstoasc);
-    REGISTER_BSF     (CHOMP, chomp);
-    REGISTER_BSF     (DUMP_EXTRADATA, dump_extradata);
-    REGISTER_BSF     (H264_MP4TOANNEXB, h264_mp4toannexb);
-    REGISTER_BSF     (IMX_DUMP_HEADER, imx_dump_header);
-    REGISTER_BSF     (MJPEG2JPEG, mjpeg2jpeg);
-    REGISTER_BSF     (MJPEGA_DUMP_HEADER, mjpega_dump_header);
-    REGISTER_BSF     (MP3_HEADER_COMPRESS, mp3_header_compress);
-    REGISTER_BSF     (MP3_HEADER_DECOMPRESS, mp3_header_decompress);
-    REGISTER_BSF     (MOV2TEXTSUB, mov2textsub);
-    REGISTER_BSF     (NOISE, noise);
-    REGISTER_BSF     (REMOVE_EXTRADATA, remove_extradata);
-    REGISTER_BSF     (TEXT2MOVSUB, text2movsub);
-}
-
diff -Naur mplayer-1.0_rc4_p20120109/ffmpeg/libavfilter/allfilters.c mplayer-1.0_rc4_p20120109-new/ffmpeg/libavfilter/allfilters.c
--- mplayer-1.0_rc4_p20120109/ffmpeg/libavfilter/allfilters.c	2012-01-09 14:49:54.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/ffmpeg/libavfilter/allfilters.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/*
- * filter registration
- * Copyright (c) 2008 Vitor Sessak
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include <libavfilter/avfilter.h>
-
-
-#define REGISTER_FILTER(X,x,y) { \
-          extern AVFilter avfilter_##y##_##x ; \
-          if(CONFIG_##X##_FILTER )  avfilter_register(&avfilter_##y##_##x ); }
-
-void avfilter_register_all(void)
-{
-    static int initialized;
-
-    if (initialized)
-        return;
-    initialized = 1;
-
-    REGISTER_FILTER (ACONVERT,    aconvert,    af);
-    REGISTER_FILTER (AFORMAT,     aformat,     af);
-    REGISTER_FILTER (AMERGE,      amerge,      af);
-    REGISTER_FILTER (ANULL,       anull,       af);
-    REGISTER_FILTER (ARESAMPLE,   aresample,   af);
-    REGISTER_FILTER (ASHOWINFO,   ashowinfo,   af);
-    REGISTER_FILTER (ASPLIT,      asplit,      af);
-    REGISTER_FILTER (ASTREAMSYNC, astreamsync, af);
-    REGISTER_FILTER (EARWAX,      earwax,      af);
-    REGISTER_FILTER (PAN,         pan,         af);
-    REGISTER_FILTER (SILENCEDETECT, silencedetect, af);
-    REGISTER_FILTER (VOLUME,      volume,      af);
-
-    REGISTER_FILTER (ABUFFER,     abuffer,     asrc);
-    REGISTER_FILTER (AEVALSRC,    aevalsrc,    asrc);
-    REGISTER_FILTER (AMOVIE,      amovie,      asrc);
-    REGISTER_FILTER (ANULLSRC,    anullsrc,    asrc);
-
-    REGISTER_FILTER (ABUFFERSINK, abuffersink, asink);
-    REGISTER_FILTER (ANULLSINK,   anullsink,   asink);
-
-    REGISTER_FILTER (ASS,         ass,  vf);
-    REGISTER_FILTER (BLACKFRAME,  blackframe,  vf);
-    REGISTER_FILTER (BOXBLUR,     boxblur,     vf);
-    REGISTER_FILTER (COPY,        copy,        vf);
-    REGISTER_FILTER (CROP,        crop,        vf);
-    REGISTER_FILTER (CROPDETECT,  cropdetect,  vf);
-    REGISTER_FILTER (DELOGO,      delogo,      vf);
-    REGISTER_FILTER (DESHAKE,     deshake,     vf);
-    REGISTER_FILTER (DRAWBOX,     drawbox,     vf);
-    REGISTER_FILTER (DRAWTEXT,    drawtext,    vf);
-    REGISTER_FILTER (FADE,        fade,        vf);
-    REGISTER_FILTER (FIELDORDER,  fieldorder,  vf);
-    REGISTER_FILTER (FIFO,        fifo,        vf);
-    REGISTER_FILTER (FORMAT,      format,      vf);
-    REGISTER_FILTER (FREI0R,      frei0r,      vf);
-    REGISTER_FILTER (GRADFUN,     gradfun,     vf);
-    REGISTER_FILTER (HFLIP,       hflip,       vf);
-    REGISTER_FILTER (HQDN3D,      hqdn3d,      vf);
-    REGISTER_FILTER (LUT,         lut,         vf);
-    REGISTER_FILTER (LUTRGB,      lutrgb,      vf);
-    REGISTER_FILTER (LUTYUV,      lutyuv,      vf);
-    REGISTER_FILTER (MP,          mp,          vf);
-    REGISTER_FILTER (NEGATE,      negate,      vf);
-    REGISTER_FILTER (NOFORMAT,    noformat,    vf);
-    REGISTER_FILTER (NULL,        null,        vf);
-    REGISTER_FILTER (OCV,         ocv,         vf);
-    REGISTER_FILTER (OVERLAY,     overlay,     vf);
-    REGISTER_FILTER (PAD,         pad,         vf);
-    REGISTER_FILTER (PIXDESCTEST, pixdesctest, vf);
-    REGISTER_FILTER (SCALE,       scale,       vf);
-    REGISTER_FILTER (SELECT,      select,      vf);
-    REGISTER_FILTER (SETDAR,      setdar,      vf);
-    REGISTER_FILTER (SETPTS,      setpts,      vf);
-    REGISTER_FILTER (SETSAR,      setsar,      vf);
-    REGISTER_FILTER (SETTB,       settb,       vf);
-    REGISTER_FILTER (SHOWINFO,    showinfo,    vf);
-    REGISTER_FILTER (SLICIFY,     slicify,     vf);
-    REGISTER_FILTER (SPLIT,       split,       vf);
-    REGISTER_FILTER (THUMBNAIL,   thumbnail,   vf);
-    REGISTER_FILTER (TINTERLACE,  tinterlace,  vf);
-    REGISTER_FILTER (TRANSPOSE,   transpose,   vf);
-    REGISTER_FILTER (UNSHARP,     unsharp,     vf);
-    REGISTER_FILTER (VFLIP,       vflip,       vf);
-    REGISTER_FILTER (YADIF,       yadif,       vf);
-
-    REGISTER_FILTER (CELLAUTO,    cellauto,    vsrc);
-    REGISTER_FILTER (COLOR,       color,       vsrc);
-    REGISTER_FILTER (FREI0R,      frei0r_src,  vsrc);
-    REGISTER_FILTER (LIFE,        life,        vsrc);
-    REGISTER_FILTER (MANDELBROT,  mandelbrot,  vsrc);
-    REGISTER_FILTER (MOVIE,       movie,       vsrc);
-    REGISTER_FILTER (MPTESTSRC,   mptestsrc,   vsrc);
-    REGISTER_FILTER (NULLSRC,     nullsrc,     vsrc);
-    REGISTER_FILTER (RGBTESTSRC,  rgbtestsrc,  vsrc);
-    REGISTER_FILTER (TESTSRC,     testsrc,     vsrc);
-
-    REGISTER_FILTER (BUFFERSINK,  buffersink,  vsink);
-    REGISTER_FILTER (NULLSINK,    nullsink,    vsink);
-
-    /* vsrc_buffer is a part of public API => registered unconditionally */
-    {
-        extern AVFilter avfilter_vsrc_buffer;
-        avfilter_register(&avfilter_vsrc_buffer);
-    }
-}
diff -Naur mplayer-1.0_rc4_p20120109/ffmpeg/libavformat/allformats.c mplayer-1.0_rc4_p20120109-new/ffmpeg/libavformat/allformats.c
--- mplayer-1.0_rc4_p20120109/ffmpeg/libavformat/allformats.c	2012-01-09 14:49:54.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/ffmpeg/libavformat/allformats.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,283 +0,0 @@
-/*
- * Register all the formats and protocols
- * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-#include <libavformat/avformat.h>
-#include <libavformat/rtp.h>
-#include <libavformat/rdt.h>
-#include <libavformat/url.h>
-
-#define REGISTER_MUXER(X,x) { \
-    extern AVOutputFormat ff_##x##_muxer; \
-    if(CONFIG_##X##_MUXER) av_register_output_format(&ff_##x##_muxer); }
-
-#define REGISTER_DEMUXER(X,x) { \
-    extern AVInputFormat ff_##x##_demuxer; \
-    if(CONFIG_##X##_DEMUXER) av_register_input_format(&ff_##x##_demuxer); }
-
-#define REGISTER_MUXDEMUX(X,x)  REGISTER_MUXER(X,x); REGISTER_DEMUXER(X,x)
-
-#define REGISTER_PROTOCOL(X,x) { \
-    extern URLProtocol ff_##x##_protocol; \
-    if(CONFIG_##X##_PROTOCOL) ffurl_register_protocol(&ff_##x##_protocol, sizeof(ff_##x##_protocol)); }
-
-void av_register_all(void)
-{
-    static int initialized;
-
-    if (initialized)
-        return;
-    initialized = 1;
-
-    avcodec_register_all();
-
-    /* (de)muxers */
-    REGISTER_MUXER    (A64, a64);
-    REGISTER_DEMUXER  (AAC, aac);
-    REGISTER_MUXDEMUX (AC3, ac3);
-    REGISTER_DEMUXER  (ACT, act);
-    REGISTER_DEMUXER  (ADF, adf);
-    REGISTER_MUXER    (ADTS, adts);
-    REGISTER_MUXDEMUX (ADX, adx);
-    REGISTER_DEMUXER  (AEA, aea);
-    REGISTER_MUXDEMUX (AIFF, aiff);
-    REGISTER_MUXDEMUX (AMR, amr);
-    REGISTER_DEMUXER  (ANM, anm);
-    REGISTER_DEMUXER  (APC, apc);
-    REGISTER_DEMUXER  (APE, ape);
-    REGISTER_DEMUXER  (APPLEHTTP, applehttp);
-    REGISTER_MUXDEMUX (ASF, asf);
-    REGISTER_MUXDEMUX (ASS, ass);
-    REGISTER_MUXER    (ASF_STREAM, asf_stream);
-    REGISTER_MUXDEMUX (AU, au);
-    REGISTER_MUXDEMUX (AVI, avi);
-    REGISTER_DEMUXER  (AVISYNTH, avisynth);
-    REGISTER_MUXER    (AVM2, avm2);
-    REGISTER_DEMUXER  (AVS, avs);
-    REGISTER_DEMUXER  (BETHSOFTVID, bethsoftvid);
-    REGISTER_DEMUXER  (BFI, bfi);
-    REGISTER_DEMUXER  (BINTEXT, bintext);
-    REGISTER_DEMUXER  (BINK, bink);
-    REGISTER_MUXDEMUX (BIT, bit);
-    REGISTER_DEMUXER  (BMV, bmv);
-    REGISTER_DEMUXER  (C93, c93);
-    REGISTER_MUXDEMUX (CAF, caf);
-    REGISTER_MUXDEMUX (CAVSVIDEO, cavsvideo);
-    REGISTER_DEMUXER  (CDG, cdg);
-    REGISTER_MUXER    (CRC, crc);
-    REGISTER_MUXDEMUX (DAUD, daud);
-    REGISTER_DEMUXER  (DFA, dfa);
-    REGISTER_MUXDEMUX (DIRAC, dirac);
-    REGISTER_MUXDEMUX (DNXHD, dnxhd);
-    REGISTER_DEMUXER  (DSICIN, dsicin);
-    REGISTER_MUXDEMUX (DTS, dts);
-    REGISTER_MUXDEMUX (DV, dv);
-    REGISTER_DEMUXER  (DXA, dxa);
-    REGISTER_DEMUXER  (EA, ea);
-    REGISTER_DEMUXER  (EA_CDATA, ea_cdata);
-    REGISTER_MUXDEMUX (EAC3, eac3);
-    REGISTER_MUXDEMUX (FFM, ffm);
-    REGISTER_MUXDEMUX (FFMETADATA, ffmetadata);
-    REGISTER_MUXDEMUX (FILMSTRIP, filmstrip);
-    REGISTER_MUXDEMUX (FLAC, flac);
-    REGISTER_DEMUXER  (FLIC, flic);
-    REGISTER_MUXDEMUX (FLV, flv);
-    REGISTER_DEMUXER  (FOURXM, fourxm);
-    REGISTER_MUXER    (FRAMECRC, framecrc);
-    REGISTER_MUXER    (FRAMEMD5, framemd5);
-    REGISTER_MUXDEMUX (G722, g722);
-    REGISTER_MUXDEMUX (G723_1, g723_1);
-    REGISTER_DEMUXER  (G729, g729);
-    REGISTER_MUXER    (GIF, gif);
-    REGISTER_DEMUXER  (GSM, gsm);
-    REGISTER_MUXDEMUX (GXF, gxf);
-    REGISTER_MUXDEMUX (H261, h261);
-    REGISTER_MUXDEMUX (H263, h263);
-    REGISTER_MUXDEMUX (H264, h264);
-    REGISTER_DEMUXER  (ICO, ico);
-    REGISTER_DEMUXER  (IDCIN, idcin);
-    REGISTER_DEMUXER  (IDF, idf);
-    REGISTER_DEMUXER  (IFF, iff);
-    REGISTER_MUXDEMUX (IMAGE2, image2);
-    REGISTER_MUXDEMUX (IMAGE2PIPE, image2pipe);
-    REGISTER_DEMUXER  (INGENIENT, ingenient);
-    REGISTER_DEMUXER  (IPMOVIE, ipmovie);
-    REGISTER_MUXER    (IPOD, ipod);
-    REGISTER_DEMUXER  (ISS, iss);
-    REGISTER_DEMUXER  (IV8, iv8);
-    REGISTER_MUXDEMUX (IVF, ivf);
-    REGISTER_DEMUXER  (JV, jv);
-    REGISTER_MUXDEMUX (LATM, latm);
-    REGISTER_DEMUXER  (LMLM4, lmlm4);
-    REGISTER_DEMUXER  (LOAS, loas);
-    REGISTER_DEMUXER  (LXF, lxf);
-    REGISTER_MUXDEMUX (M4V, m4v);
-    REGISTER_MUXER    (MD5, md5);
-    REGISTER_MUXDEMUX (MATROSKA, matroska);
-    REGISTER_MUXER    (MATROSKA_AUDIO, matroska_audio);
-    REGISTER_MUXDEMUX (MICRODVD, microdvd);
-    REGISTER_MUXDEMUX (MJPEG, mjpeg);
-    REGISTER_MUXDEMUX (MLP, mlp);
-    REGISTER_DEMUXER  (MM, mm);
-    REGISTER_MUXDEMUX (MMF, mmf);
-    REGISTER_MUXDEMUX (MOV, mov);
-    REGISTER_MUXER    (MP2, mp2);
-    REGISTER_MUXDEMUX (MP3, mp3);
-    REGISTER_MUXER    (MP4, mp4);
-    REGISTER_DEMUXER  (MPC, mpc);
-    REGISTER_DEMUXER  (MPC8, mpc8);
-    REGISTER_MUXER    (MPEG1SYSTEM, mpeg1system);
-    REGISTER_MUXER    (MPEG1VCD, mpeg1vcd);
-    REGISTER_MUXER    (MPEG1VIDEO, mpeg1video);
-    REGISTER_MUXER    (MPEG2DVD, mpeg2dvd);
-    REGISTER_MUXER    (MPEG2SVCD, mpeg2svcd);
-    REGISTER_MUXER    (MPEG2VIDEO, mpeg2video);
-    REGISTER_MUXER    (MPEG2VOB, mpeg2vob);
-    REGISTER_DEMUXER  (MPEGPS, mpegps);
-    REGISTER_MUXDEMUX (MPEGTS, mpegts);
-    REGISTER_DEMUXER  (MPEGTSRAW, mpegtsraw);
-    REGISTER_DEMUXER  (MPEGVIDEO, mpegvideo);
-    REGISTER_MUXER    (MPJPEG, mpjpeg);
-    REGISTER_DEMUXER  (MSNWC_TCP, msnwc_tcp);
-    REGISTER_DEMUXER  (MTV, mtv);
-    REGISTER_DEMUXER  (MVI, mvi);
-    REGISTER_MUXDEMUX (MXF, mxf);
-    REGISTER_MUXER    (MXF_D10, mxf_d10);
-    REGISTER_DEMUXER  (MXG, mxg);
-    REGISTER_DEMUXER  (NC, nc);
-    REGISTER_DEMUXER  (NSV, nsv);
-    REGISTER_MUXER    (NULL, null);
-    REGISTER_MUXDEMUX (NUT, nut);
-    REGISTER_DEMUXER  (NUV, nuv);
-    REGISTER_MUXDEMUX (OGG, ogg);
-    REGISTER_MUXDEMUX (OMA, oma);
-    REGISTER_MUXDEMUX (PCM_ALAW,  pcm_alaw);
-    REGISTER_MUXDEMUX (PCM_MULAW, pcm_mulaw);
-    REGISTER_MUXDEMUX (PCM_F64BE, pcm_f64be);
-    REGISTER_MUXDEMUX (PCM_F64LE, pcm_f64le);
-    REGISTER_MUXDEMUX (PCM_F32BE, pcm_f32be);
-    REGISTER_MUXDEMUX (PCM_F32LE, pcm_f32le);
-    REGISTER_MUXDEMUX (PCM_S32BE, pcm_s32be);
-    REGISTER_MUXDEMUX (PCM_S32LE, pcm_s32le);
-    REGISTER_MUXDEMUX (PCM_S24BE, pcm_s24be);
-    REGISTER_MUXDEMUX (PCM_S24LE, pcm_s24le);
-    REGISTER_MUXDEMUX (PCM_S16BE, pcm_s16be);
-    REGISTER_MUXDEMUX (PCM_S16LE, pcm_s16le);
-    REGISTER_MUXDEMUX (PCM_S8,    pcm_s8);
-    REGISTER_MUXDEMUX (PCM_U32BE, pcm_u32be);
-    REGISTER_MUXDEMUX (PCM_U32LE, pcm_u32le);
-    REGISTER_MUXDEMUX (PCM_U24BE, pcm_u24be);
-    REGISTER_MUXDEMUX (PCM_U24LE, pcm_u24le);
-    REGISTER_MUXDEMUX (PCM_U16BE, pcm_u16be);
-    REGISTER_MUXDEMUX (PCM_U16LE, pcm_u16le);
-    REGISTER_MUXDEMUX (PCM_U8,    pcm_u8);
-    REGISTER_DEMUXER  (PMP, pmp);
-    REGISTER_MUXER    (PSP, psp);
-    REGISTER_DEMUXER  (PVA, pva);
-    REGISTER_DEMUXER  (QCP, qcp);
-    REGISTER_DEMUXER  (R3D, r3d);
-    REGISTER_MUXDEMUX (RAWVIDEO, rawvideo);
-    REGISTER_DEMUXER  (RL2, rl2);
-    REGISTER_MUXDEMUX (RM, rm);
-    REGISTER_MUXDEMUX (ROQ, roq);
-    REGISTER_DEMUXER  (RPL, rpl);
-    REGISTER_MUXDEMUX (RSO, rso);
-    REGISTER_MUXDEMUX (RTP, rtp);
-    REGISTER_MUXDEMUX (RTSP, rtsp);
-    REGISTER_MUXDEMUX (SAP, sap);
-    REGISTER_DEMUXER  (SBG, sbg);
-    REGISTER_DEMUXER  (SDP, sdp);
-#if CONFIG_RTPDEC
-    av_register_rtp_dynamic_payload_handlers();
-    av_register_rdt_dynamic_payload_handlers();
-#endif
-    REGISTER_DEMUXER  (SEGAFILM, segafilm);
-    REGISTER_MUXER    (SEGMENT, segment);
-    REGISTER_DEMUXER  (SHORTEN, shorten);
-    REGISTER_DEMUXER  (SIFF, siff);
-    REGISTER_DEMUXER  (SMACKER, smacker);
-    REGISTER_DEMUXER  (SMJPEG, smjpeg);
-    REGISTER_DEMUXER  (SOL, sol);
-    REGISTER_MUXDEMUX (SOX, sox);
-    REGISTER_MUXDEMUX (SPDIF, spdif);
-    REGISTER_MUXDEMUX (SRT, srt);
-    REGISTER_DEMUXER  (STR, str);
-    REGISTER_MUXDEMUX (SWF, swf);
-    REGISTER_MUXER    (TG2, tg2);
-    REGISTER_MUXER    (TGP, tgp);
-    REGISTER_DEMUXER  (THP, thp);
-    REGISTER_DEMUXER  (TIERTEXSEQ, tiertexseq);
-    REGISTER_MUXER    (MKVTIMESTAMP_V2, mkvtimestamp_v2);
-    REGISTER_DEMUXER  (TMV, tmv);
-    REGISTER_MUXDEMUX (TRUEHD, truehd);
-    REGISTER_DEMUXER  (TTA, tta);
-    REGISTER_DEMUXER  (TXD, txd);
-    REGISTER_DEMUXER  (TTY, tty);
-    REGISTER_DEMUXER  (VC1, vc1);
-    REGISTER_MUXDEMUX (VC1T, vc1t);
-    REGISTER_DEMUXER  (VMD, vmd);
-    REGISTER_MUXDEMUX (VOC, voc);
-    REGISTER_DEMUXER  (VQF, vqf);
-    REGISTER_DEMUXER  (W64, w64);
-    REGISTER_MUXDEMUX (WAV, wav);
-    REGISTER_DEMUXER  (WC3, wc3);
-    REGISTER_MUXER    (WEBM, webm);
-    REGISTER_DEMUXER  (WSAUD, wsaud);
-    REGISTER_DEMUXER  (WSVQA, wsvqa);
-    REGISTER_MUXDEMUX (WTV, wtv);
-    REGISTER_DEMUXER  (WV, wv);
-    REGISTER_DEMUXER  (XA, xa);
-    REGISTER_DEMUXER  (XBIN, xbin);
-    REGISTER_DEMUXER  (XMV, xmv);
-    REGISTER_DEMUXER  (XWMA, xwma);
-    REGISTER_DEMUXER  (YOP, yop);
-    REGISTER_MUXDEMUX (YUV4MPEGPIPE, yuv4mpegpipe);
-
-    /* external libraries */
-#if CONFIG_LIBMODPLUG
-    REGISTER_DEMUXER  (LIBMODPLUG, libmodplug);
-#endif
-    REGISTER_MUXDEMUX (LIBNUT, libnut);
-
-    /* protocols */
-    REGISTER_PROTOCOL (APPLEHTTP, applehttp);
-    REGISTER_PROTOCOL (CACHE, cache);
-    REGISTER_PROTOCOL (CONCAT, concat);
-    REGISTER_PROTOCOL (CRYPTO, crypto);
-    REGISTER_PROTOCOL (FILE, file);
-    REGISTER_PROTOCOL (GOPHER, gopher);
-    REGISTER_PROTOCOL (HTTP, http);
-    REGISTER_PROTOCOL (HTTPPROXY, httpproxy);
-    REGISTER_PROTOCOL (HTTPS, https);
-    REGISTER_PROTOCOL (MMSH, mmsh);
-    REGISTER_PROTOCOL (MMST, mmst);
-    REGISTER_PROTOCOL (MD5,  md5);
-    REGISTER_PROTOCOL (PIPE, pipe);
-    REGISTER_PROTOCOL (RTMP, rtmp);
-#if CONFIG_LIBRTMP
-    REGISTER_PROTOCOL (RTMP, rtmpt);
-    REGISTER_PROTOCOL (RTMP, rtmpe);
-    REGISTER_PROTOCOL (RTMP, rtmpte);
-    REGISTER_PROTOCOL (RTMP, rtmps);
-#endif
-    REGISTER_PROTOCOL (RTP, rtp);
-    REGISTER_PROTOCOL (TCP, tcp);
-    REGISTER_PROTOCOL (TLS, tls);
-    REGISTER_PROTOCOL (UDP, udp);
-}
diff -Naur mplayer-1.0_rc4_p20120109/ffmpeg/libavformat/internal.h mplayer-1.0_rc4_p20120109-new/ffmpeg/libavformat/internal.h
--- mplayer-1.0_rc4_p20120109/ffmpeg/libavformat/internal.h	2012-01-09 14:49:54.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/ffmpeg/libavformat/internal.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,309 +0,0 @@
-/*
- * copyright (c) 2001 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVFORMAT_INTERNAL_H
-#define AVFORMAT_INTERNAL_H
-
-#include <stdint.h>
-#include <libavformat/avformat.h>
-
-#define MAX_URL_SIZE 4096
-
-#ifdef DEBUG
-#    define hex_dump_debug(class, buf, size) av_hex_dump_log(class, AV_LOG_DEBUG, buf, size)
-#else
-#    define hex_dump_debug(class, buf, size)
-#endif
-
-typedef struct AVCodecTag {
-    enum CodecID id;
-    unsigned int tag;
-} AVCodecTag;
-
-#ifdef __GNUC__
-#define dynarray_add(tab, nb_ptr, elem)\
-do {\
-    __typeof__(tab) _tab = (tab);\
-    __typeof__(elem) _elem = (elem);\
-    (void)sizeof(**_tab == _elem); /* check that types are compatible */\
-    av_dynarray_add(_tab, nb_ptr, _elem);\
-} while(0)
-#else
-#define dynarray_add(tab, nb_ptr, elem)\
-do {\
-    av_dynarray_add((tab), nb_ptr, (elem));\
-} while(0)
-#endif
-
-struct tm *brktimegm(time_t secs, struct tm *tm);
-
-char *ff_data_to_hex(char *buf, const uint8_t *src, int size, int lowercase);
-
-/**
- * Parse a string of hexadecimal strings. Any space between the hexadecimal
- * digits is ignored.
- *
- * @param data if non-null, the parsed data is written to this pointer
- * @param p the string to parse
- * @return the number of bytes written (or to be written, if data is null)
- */
-int ff_hex_to_data(uint8_t *data, const char *p);
-
-void ff_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx);
-
-/**
- * Add packet to AVFormatContext->packet_buffer list, determining its
- * interleaved position using compare() function argument.
- * @return 0, or < 0 on error
- */
-int ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt,
-                              int (*compare)(AVFormatContext *, AVPacket *, AVPacket *));
-
-void ff_read_frame_flush(AVFormatContext *s);
-
-#define NTP_OFFSET 2208988800ULL
-#define NTP_OFFSET_US (NTP_OFFSET * 1000000ULL)
-
-/** Get the current time since NTP epoch in microseconds. */
-uint64_t ff_ntp_time(void);
-
-/**
- * Assemble a URL string from components. This is the reverse operation
- * of av_url_split.
- *
- * Note, this requires networking to be initialized, so the caller must
- * ensure ff_network_init has been called.
- *
- * @see av_url_split
- *
- * @param str the buffer to fill with the url
- * @param size the size of the str buffer
- * @param proto the protocol identifier, if null, the separator
- *              after the identifier is left out, too
- * @param authorization an optional authorization string, may be null.
- *                      An empty string is treated the same as a null string.
- * @param hostname the host name string
- * @param port the port number, left out from the string if negative
- * @param fmt a generic format string for everything to add after the
- *            host/port, may be null
- * @return the number of characters written to the destination buffer
- */
-int ff_url_join(char *str, int size, const char *proto,
-                const char *authorization, const char *hostname,
-                int port, const char *fmt, ...) av_printf_format(7, 8);
-
-/**
- * Append the media-specific SDP fragment for the media stream c
- * to the buffer buff.
- *
- * Note, the buffer needs to be initialized, since it is appended to
- * existing content.
- *
- * @param buff the buffer to append the SDP fragment to
- * @param size the size of the buff buffer
- * @param c the AVCodecContext of the media to describe
- * @param dest_addr the destination address of the media stream, may be NULL
- * @param dest_type the destination address type, may be NULL
- * @param port the destination port of the media stream, 0 if unknown
- * @param ttl the time to live of the stream, 0 if not multicast
- * @param fmt the AVFormatContext, which might contain options modifying
- *            the generated SDP
- */
-void ff_sdp_write_media(char *buff, int size, AVCodecContext *c,
-                        const char *dest_addr, const char *dest_type,
-                        int port, int ttl, AVFormatContext *fmt);
-
-/**
- * Write a packet to another muxer than the one the user originally
- * intended. Useful when chaining muxers, where one muxer internally
- * writes a received packet to another muxer.
- *
- * @param dst the muxer to write the packet to
- * @param dst_stream the stream index within dst to write the packet to
- * @param pkt the packet to be written
- * @param src the muxer the packet originally was intended for
- * @return the value av_write_frame returned
- */
-int ff_write_chained(AVFormatContext *dst, int dst_stream, AVPacket *pkt,
-                     AVFormatContext *src);
-
-/**
- * Get the length in bytes which is needed to store val as v.
- */
-int ff_get_v_length(uint64_t val);
-
-/**
- * Put val using a variable number of bytes.
- */
-void ff_put_v(AVIOContext *bc, uint64_t val);
-
-/**
- * Read a whole line of text from AVIOContext. Stop reading after reaching
- * either a \\n, a \\0 or EOF. The returned string is always \\0-terminated,
- * and may be truncated if the buffer is too small.
- *
- * @param s the read-only AVIOContext
- * @param buf buffer to store the read line
- * @param maxlen size of the buffer
- * @return the length of the string written in the buffer, not including the
- *         final \\0
- */
-int ff_get_line(AVIOContext *s, char *buf, int maxlen);
-
-#define SPACE_CHARS " \t\r\n"
-
-/**
- * Callback function type for ff_parse_key_value.
- *
- * @param key a pointer to the key
- * @param key_len the number of bytes that belong to the key, including the '='
- *                char
- * @param dest return the destination pointer for the value in *dest, may
- *             be null to ignore the value
- * @param dest_len the length of the *dest buffer
- */
-typedef void (*ff_parse_key_val_cb)(void *context, const char *key,
-                                    int key_len, char **dest, int *dest_len);
-/**
- * Parse a string with comma-separated key=value pairs. The value strings
- * may be quoted and may contain escaped characters within quoted strings.
- *
- * @param str the string to parse
- * @param callback_get_buf function that returns where to store the
- *                         unescaped value string.
- * @param context the opaque context pointer to pass to callback_get_buf
- */
-void ff_parse_key_value(const char *str, ff_parse_key_val_cb callback_get_buf,
-                        void *context);
-
-/**
- * Find stream index based on format-specific stream ID
- * @return stream index, or < 0 on error
- */
-int ff_find_stream_index(AVFormatContext *s, int id);
-
-/**
- * Internal version of av_index_search_timestamp
- */
-int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,
-                              int64_t wanted_timestamp, int flags);
-
-/**
- * Internal version of av_add_index_entry
- */
-int ff_add_index_entry(AVIndexEntry **index_entries,
-                       int *nb_index_entries,
-                       unsigned int *index_entries_allocated_size,
-                       int64_t pos, int64_t timestamp, int size, int distance, int flags);
-
-/**
- * Add a new chapter.
- *
- * @param s media file handle
- * @param id unique ID for this chapter
- * @param start chapter start time in time_base units
- * @param end chapter end time in time_base units
- * @param title chapter title
- *
- * @return AVChapter or NULL on error
- */
-AVChapter *avpriv_new_chapter(AVFormatContext *s, int id, AVRational time_base,
-                              int64_t start, int64_t end, const char *title);
-
-/**
- * Ensure the index uses less memory than the maximum specified in
- * AVFormatContext.max_index_size by discarding entries if it grows
- * too large.
- */
-void ff_reduce_index(AVFormatContext *s, int stream_index);
-
-/*
- * Convert a relative url into an absolute url, given a base url.
- *
- * @param buf the buffer where output absolute url is written
- * @param size the size of buf
- * @param base the base url, may be equal to buf.
- * @param rel the new url, which is interpreted relative to base
- */
-void ff_make_absolute_url(char *buf, int size, const char *base,
-                          const char *rel);
-
-enum CodecID ff_guess_image2_codec(const char *filename);
-
-/**
- * Convert a date string in ISO8601 format to Unix timestamp.
- */
-int64_t ff_iso8601_to_unix_time(const char *datestr);
-
-/**
- * Perform a binary search using av_index_search_timestamp() and
- * AVInputFormat.read_timestamp().
- *
- * @param target_ts target timestamp in the time base of the given stream
- * @param stream_index stream number
- */
-int ff_seek_frame_binary(AVFormatContext *s, int stream_index,
-                         int64_t target_ts, int flags);
-
-/**
- * Update cur_dts of all streams based on the given timestamp and AVStream.
- *
- * Stream ref_st unchanged, others set cur_dts in their native time base.
- * Only needed for timestamp wrapping or if (dts not set and pts!=dts).
- * @param timestamp new dts expressed in time_base of param ref_st
- * @param ref_st reference stream giving time_base of param timestamp
- */
-void ff_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp);
-
-/**
- * Perform a binary search using read_timestamp().
- *
- * @param target_ts target timestamp in the time base of the given stream
- * @param stream_index stream number
- */
-int64_t ff_gen_search(AVFormatContext *s, int stream_index,
-                      int64_t target_ts, int64_t pos_min,
-                      int64_t pos_max, int64_t pos_limit,
-                      int64_t ts_min, int64_t ts_max,
-                      int flags, int64_t *ts_ret,
-                      int64_t (*read_timestamp)(struct AVFormatContext *, int , int64_t *, int64_t ));
-
-/**
- * Set the pts for a given stream. If the new values would be invalid
- * (<= 0), it leaves the AVStream unchanged.
- *
- * @param s stream
- * @param pts_wrap_bits number of bits effectively used by the pts
- *        (used for wrap control, 33 is the value for MPEG)
- * @param pts_num numerator to convert to seconds (MPEG: 1)
- * @param pts_den denominator to convert to seconds (MPEG: 90000)
- */
-void avpriv_set_pts_info(AVStream *s, int pts_wrap_bits,
-                         unsigned int pts_num, unsigned int pts_den);
-
-/**
- * Add side data to a packet for changing parameters to the given values.
- * Parameters set to 0 aren't included in the change.
- */
-int ff_add_param_change(AVPacket *pkt, int32_t channels,
-                        uint64_t channel_layout, int32_t sample_rate,
-                        int32_t width, int32_t height);
-
-#endif /* AVFORMAT_INTERNAL_H */
diff -Naur mplayer-1.0_rc4_p20120109/ffmpeg/libavutil/x86_cpu.h mplayer-1.0_rc4_p20120109-new/ffmpeg/libavutil/x86_cpu.h
--- mplayer-1.0_rc4_p20120109/ffmpeg/libavutil/x86_cpu.h	2012-01-09 14:49:54.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/ffmpeg/libavutil/x86_cpu.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_X86_CPU_H
-#define AVUTIL_X86_CPU_H
-
-#include <stdint.h>
-#include <config.h>
-
-#if ARCH_X86_64
-#    define OPSIZE "q"
-#    define REG_a "rax"
-#    define REG_b "rbx"
-#    define REG_c "rcx"
-#    define REG_d "rdx"
-#    define REG_D "rdi"
-#    define REG_S "rsi"
-#    define PTR_SIZE "8"
-typedef int64_t x86_reg;
-
-#    define REG_SP "rsp"
-#    define REG_BP "rbp"
-#    define REGBP   rbp
-#    define REGa    rax
-#    define REGb    rbx
-#    define REGc    rcx
-#    define REGd    rdx
-#    define REGSP   rsp
-
-#elif ARCH_X86_32
-
-#    define OPSIZE "l"
-#    define REG_a "eax"
-#    define REG_b "ebx"
-#    define REG_c "ecx"
-#    define REG_d "edx"
-#    define REG_D "edi"
-#    define REG_S "esi"
-#    define PTR_SIZE "4"
-typedef int32_t x86_reg;
-
-#    define REG_SP "esp"
-#    define REG_BP "ebp"
-#    define REGBP   ebp
-#    define REGa    eax
-#    define REGb    ebx
-#    define REGc    ecx
-#    define REGd    edx
-#    define REGSP   esp
-#else
-typedef int x86_reg;
-#endif
-
-#define HAVE_7REGS (ARCH_X86_64 || (HAVE_EBX_AVAILABLE && HAVE_EBP_AVAILABLE))
-#define HAVE_6REGS (ARCH_X86_64 || (HAVE_EBX_AVAILABLE || HAVE_EBP_AVAILABLE))
-
-#if ARCH_X86_64 && defined(PIC)
-#    define BROKEN_RELOCATIONS 1
-#endif
-
-/*
- * If gcc is not set to support sse (-msse) it will not accept xmm registers
- * in the clobber list for inline asm. XMM_CLOBBERS takes a list of xmm
- * registers to be marked as clobbered and evaluates to nothing if they are
- * not supported, or to the list itself if they are supported. Since a clobber
- * list may not be empty, XMM_CLOBBERS_ONLY should be used if the xmm
- * registers are the only in the clobber list.
- * For example a list with "eax" and "xmm0" as clobbers should become:
- * : XMM_CLOBBERS("xmm0",) "eax"
- * and a list with only "xmm0" should become:
- * XMM_CLOBBERS_ONLY("xmm0")
- */
-#if HAVE_XMM_CLOBBERS
-#    define XMM_CLOBBERS(...)        __VA_ARGS__
-#    define XMM_CLOBBERS_ONLY(...) : __VA_ARGS__
-#else
-#    define XMM_CLOBBERS(...)
-#    define XMM_CLOBBERS_ONLY(...)
-#endif
-
-#endif /* AVUTIL_X86_CPU_H */
diff -Naur mplayer-1.0_rc4_p20120109/fmt-conversion.c mplayer-1.0_rc4_p20120109-new/fmt-conversion.c
--- mplayer-1.0_rc4_p20120109/fmt-conversion.c	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/fmt-conversion.c	2012-01-16 15:51:41.000000000 +0100
@@ -18,6 +18,7 @@
 
 #include "mp_msg.h"
 #include "libavutil/avutil.h"
+#include "libavcodec/avcodec.h"
 #include "libmpcodecs/img_format.h"
 #include "libavutil/pixfmt.h"
 #include "libavutil/samplefmt.h"
@@ -27,6 +28,7 @@
 static const struct {
     int fmt;
     enum PixelFormat pix_fmt;
+    enum CodecID codec_id;
 } conversion_map[] = {
     {IMGFMT_ARGB,    PIX_FMT_ARGB},
     {IMGFMT_BGRA,    PIX_FMT_BGRA},
@@ -118,6 +120,17 @@
     {IMGFMT_VDPAU_WMV3,      PIX_FMT_VDPAU_WMV3},
     {IMGFMT_VDPAU_VC1,       PIX_FMT_VDPAU_VC1},
     {IMGFMT_VDPAU_MPEG4,     PIX_FMT_VDPAU_MPEG4},
+
+    /* VA-API formats */
+    {IMGFMT_VAAPI_MPEG2,     PIX_FMT_VAAPI_VLD,  CODEC_ID_MPEG2VIDEO},
+    {IMGFMT_VAAPI_MPEG2_IDCT,PIX_FMT_VAAPI_IDCT, CODEC_ID_MPEG2VIDEO},
+    {IMGFMT_VAAPI_MPEG2_MOCO,PIX_FMT_VAAPI_MOCO, CODEC_ID_MPEG2VIDEO},
+    {IMGFMT_VAAPI_MPEG4,     PIX_FMT_VAAPI_VLD,  CODEC_ID_MPEG4},
+    {IMGFMT_VAAPI_H263,      PIX_FMT_VAAPI_VLD,  CODEC_ID_H263},
+    {IMGFMT_VAAPI_H264,      PIX_FMT_VAAPI_VLD,  CODEC_ID_H264},
+    {IMGFMT_VAAPI_WMV3,      PIX_FMT_VAAPI_VLD,  CODEC_ID_WMV3},
+    {IMGFMT_VAAPI_VC1,       PIX_FMT_VAAPI_VLD,  CODEC_ID_VC1},
+
     {0, PIX_FMT_NONE}
 };
 
@@ -134,12 +147,14 @@
     return pix_fmt;
 }
 
-int pixfmt2imgfmt(enum PixelFormat pix_fmt)
+int pixfmt2imgfmt(enum PixelFormat pix_fmt, int codec_id)
 {
     int i;
     int fmt;
     for (i = 0; conversion_map[i].pix_fmt != PIX_FMT_NONE; i++)
-        if (conversion_map[i].pix_fmt == pix_fmt)
+        if (conversion_map[i].pix_fmt == pix_fmt &&
+            (conversion_map[i].codec_id == 0 ||
+             conversion_map[i].codec_id == codec_id))
             break;
     fmt = conversion_map[i].fmt;
     if (!fmt)
diff -Naur mplayer-1.0_rc4_p20120109/fmt-conversion.h mplayer-1.0_rc4_p20120109-new/fmt-conversion.h
--- mplayer-1.0_rc4_p20120109/fmt-conversion.h	2012-01-09 14:46:49.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/fmt-conversion.h	2012-01-16 15:51:41.000000000 +0100
@@ -24,7 +24,7 @@
 #include "libavutil/samplefmt.h"
 
 enum PixelFormat imgfmt2pixfmt(int fmt);
-int pixfmt2imgfmt(enum PixelFormat pix_fmt);
+int pixfmt2imgfmt(enum PixelFormat pix_fmt, int codec_id);
 enum AVSampleFormat affmt2samplefmt(int fmt);
 int samplefmt2affmt(enum AVSampleFormat sample_fmt);
 
diff -Naur mplayer-1.0_rc4_p20120109/gui/app.c mplayer-1.0_rc4_p20120109-new/gui/app.c
--- mplayer-1.0_rc4_p20120109/gui/app.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/app.c	2012-01-16 15:51:41.000000000 +0100
@@ -79,6 +79,7 @@
     { evAbout,             "evAbout"             },
     { evPreferences,       "evPreferences"       },
     { evSkinBrowser,       "evSkinBrowser"       },
+    { evMenu,              "evMenu"              },
     { evIconify,           "evIconify"           },
     { evExit,              "evExit"              }
 };
diff -Naur mplayer-1.0_rc4_p20120109/gui/app.h mplayer-1.0_rc4_p20120109-new/gui/app.h
--- mplayer-1.0_rc4_p20120109/gui/app.h	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/app.h	2012-01-16 15:51:41.000000000 +0100
@@ -68,6 +68,7 @@
 #define evAbout             12
 #define evPreferences       14
 #define evSkinBrowser       15
+#define evMenu              33
 
 #define evIconify           11
 #define evExit              1000
@@ -88,6 +89,7 @@
 #define ivSetCDTrack      5014
 
 #define ivRedraw          7002
+#define ivPlayDVD         7003
 
 typedef struct {
     int message;
diff -Naur mplayer-1.0_rc4_p20120109/gui/cfg.c mplayer-1.0_rc4_p20120109-new/gui/cfg.c
--- mplayer-1.0_rc4_p20120109/gui/cfg.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/cfg.c	2012-01-16 15:51:41.000000000 +0100
@@ -47,10 +47,8 @@
 
 int gtkVfPP;
 
-#ifdef CONFIG_DXR3
 int gtkVfLAVC;
 char *gtkDXR3Device;
-#endif
 
 int gtkAutoSyncOn;
 int gtkAutoSync;
@@ -60,25 +58,17 @@
 int gtkAOExtraStereo;
 float gtkAOExtraStereoMul = 1.0f;
 
-#ifdef CONFIG_ALSA
 char *gtkAOALSAMixer;
 char *gtkAOALSAMixerChannel;
 char *gtkAOALSADevice;
-#endif
 
-#ifdef CONFIG_OSS_AUDIO
 char *gtkAOOSSMixer;
 char *gtkAOOSSMixerChannel;
 char *gtkAOOSSDevice;
-#endif
 
-#ifdef CONFIG_ESD
 char *gtkAOESDDevice;
-#endif
 
-#ifdef CONFIG_SDL
 char *gtkAOSDLDriver;
-#endif
 
 int gtkEnableAudioEqualizer;
 float gtkEquChannels[6][10];
@@ -86,9 +76,7 @@
 int gtkSubDumpMPSub;
 int gtkSubDumpSrt;
 
-#ifdef CONFIG_ASS
 gtkASS_t gtkASS;
-#endif
 
 int gtkEnablePlayBar = 1;
 int gtkLoadFullscreen;
diff -Naur mplayer-1.0_rc4_p20120109/gui/interface.c mplayer-1.0_rc4_p20120109-new/gui/interface.c
--- mplayer-1.0_rc4_p20120109/gui/interface.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/interface.c	2012-01-16 15:51:41.000000000 +0100
@@ -75,11 +75,8 @@
         cdrom_device = strdup(DEFAULT_CDROM_DEVICE);
     if (!dvd_device)
         dvd_device = strdup(DEFAULT_DVD_DEVICE);
-
-#ifdef CONFIG_DXR3
     if (!gtkDXR3Device)
         gtkDXR3Device = strdup("/dev/em8300-0");
-#endif
 
     if (stream_cache_size > 0) {
         gtkCacheOn   = 1;
@@ -92,12 +89,10 @@
         gtkAutoSync   = autosync;
     }
 
-#ifdef CONFIG_ASS
     gtkASS.enabled       = ass_enabled;
     gtkASS.use_margins   = ass_use_margins;
     gtkASS.top_margin    = ass_top_margin;
     gtkASS.bottom_margin = ass_bottom_margin;
-#endif
 
     gtkInit();
 
@@ -263,12 +258,10 @@
             gui_sub_pos_y  = guiApp.sub.y;
         }
 
-#ifdef CONFIG_ASS
         ass_enabled       = gtkASS.enabled;
         ass_use_margins   = gtkASS.use_margins;
         ass_top_margin    = gtkASS.top_margin;
         ass_bottom_margin = gtkASS.bottom_margin;
-#endif
 
         cfg_write();
         wsXDone();
@@ -390,7 +383,7 @@
     case GUI_RUN_MESSAGE:
         mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[interface] GUI_RUN_MESSAGE: %s\n", (const char *)data);
         msg = appFindMessage((const char *)data);
-        if (appFindItem(msg))
+        if ((msg == evMenu) || appFindItem(msg))
             uiEventHandling(msg, 0);
         break;
 
@@ -415,7 +408,6 @@
         case STREAMTYPE_STREAM:
             break;
 
-#ifdef CONFIG_CDDA
         case STREAMTYPE_CDDA:
         {
             char tmp[512];
@@ -424,9 +416,7 @@
             uiSetFileName(NULL, tmp, SAME_STREAMTYPE);
         }
         break;
-#endif
 
-#ifdef CONFIG_VCD
         case STREAMTYPE_VCD:
         {
             char tmp[512];
@@ -435,9 +425,7 @@
             uiSetFileName(NULL, tmp, SAME_STREAMTYPE);
         }
         break;
-#endif
 
-#ifdef CONFIG_DVDREAD
         case STREAMTYPE_DVD:
         {
             char tmp[512];
@@ -450,7 +438,6 @@
             dvd_angle   = guiInfo.Angle;
 
             break;
-#endif
         }
 
         // video opts
@@ -486,12 +473,10 @@
             }
         }
 
-#ifdef CONFIG_DXR3
         if (video_driver_list && !gstrcmp(video_driver_list[0], "dxr3"))
             if (guiInfo.StreamType != STREAMTYPE_DVD && guiInfo.StreamType != STREAMTYPE_VCD)
                 if (gtkVfLAVC)
                     add_vf("lavc");
-#endif
 
         if (gtkVfPP)
             add_vf("pp");
@@ -515,7 +500,6 @@
             free(name);
         }
 
-#ifdef CONFIG_OSS_AUDIO
         if (audio_driver_list && !gstrncmp(audio_driver_list[0], "oss", 3)) {
             char *tmp;
 
@@ -531,9 +515,7 @@
             gaddlist(&audio_driver_list, tmp);
             free(tmp);
         }
-#endif
 
-#ifdef CONFIG_ALSA
         if (audio_driver_list && !gstrncmp(audio_driver_list[0], "alsa", 4)) {
             char *tmp;
 
@@ -549,9 +531,7 @@
             gaddlist(&audio_driver_list, tmp);
             free(tmp);
         }
-#endif
 
-#ifdef CONFIG_SDL
         if (audio_driver_list && !gstrncmp(audio_driver_list[0], "sdl", 3)) {
             char *tmp;
 
@@ -564,9 +544,7 @@
             gaddlist(&audio_driver_list, tmp);
             free(tmp);
         }
-#endif
 
-#ifdef CONFIG_ESD
         if (audio_driver_list && !gstrncmp(audio_driver_list[0], "esd", 3)) {
             char *tmp;
 
@@ -579,7 +557,6 @@
             gaddlist(&audio_driver_list, tmp);
             free(tmp);
         }
-#endif
 
         // subtitle
 
@@ -612,12 +589,10 @@
 
         guiInfo.NewPlay = 0;
 
-#ifdef CONFIG_ASS
         ass_enabled       = gtkASS.enabled;
         ass_use_margins   = gtkASS.use_margins;
         ass_top_margin    = gtkASS.top_margin;
         ass_bottom_margin = gtkASS.bottom_margin;
-#endif
 
         break;
 
@@ -631,21 +606,16 @@
         case STREAMTYPE_STREAM:
             break;
 
-#ifdef CONFIG_CDDA
         case STREAMTYPE_CDDA:
             guiInfo.Tracks = 0;
             stream_control(stream, STREAM_CTRL_GET_NUM_TITLES, &guiInfo.Tracks);
             break;
-#endif
 
-#ifdef CONFIG_VCD
         case STREAMTYPE_VCD:
             guiInfo.Tracks = 0;
             stream_control(stream, STREAM_CTRL_GET_NUM_TITLES, &guiInfo.Tracks);
             break;
-#endif
 
-#ifdef CONFIG_DVDREAD
         case STREAMTYPE_DVD:
             guiInfo.Tracks = 0;
             stream_control(stream, STREAM_CTRL_GET_NUM_TITLES, &guiInfo.Tracks);
@@ -653,16 +623,17 @@
             stream_control(stream, STREAM_CTRL_GET_NUM_CHAPTERS, &guiInfo.Chapters);
             guiInfo.Angles = 0;
             stream_control(stream, STREAM_CTRL_GET_NUM_ANGLES, &guiInfo.Angles);
+#ifdef CONFIG_DVDREAD
             dvd = stream->priv;
             guiInfo.AudioStreams = dvd->nr_of_channels;
             memcpy(guiInfo.AudioStream, dvd->audio_streams, sizeof(dvd->audio_streams));
             guiInfo.Subtitles = dvd->nr_of_subtitles;
             memcpy(guiInfo.Subtitle, dvd->subtitles, sizeof(dvd->subtitles));
+#endif
             guiInfo.Track   = dvd_title + 1;
             guiInfo.Chapter = dvd_chapter + 1;
             guiInfo.Angle   = dvd_angle + 1;
             break;
-#endif
         }
 
         break;
@@ -686,12 +657,10 @@
         btnSet(evBackward10min, state);
         btnSet(evSetMoviePosition, state);
 
-#ifdef CONFIG_DXR3
         if (video_driver_list && !gstrcmp(video_driver_list[0], "dxr3") && (((demuxer_t *)mpctx_get_demuxer(guiInfo.mpcontext))->file_format != DEMUXER_TYPE_MPEG_PS) && !gtkVfLAVC) {
             gtkMessageBox(GTK_MB_FATAL, MSGTR_NEEDLAVC);
             return False;
         }
-#endif
 
         break;
 
@@ -799,14 +768,12 @@
             break;
         }
 
-#ifdef CONFIG_CDDA
         if (guiInfo.StreamType == STREAMTYPE_CDDA) {
             uiNext();
 
             if (guiInfo.Playing)
                 break;
         }
-#endif
 
         if (guiInfo.Playing && (next = listSet(gtkGetNextPlItem, NULL)) && (plLastPlayed != next)) {
             plLastPlayed = next;
@@ -823,11 +790,9 @@
             guiInfo.Position      = 0;
             guiInfo.AudioChannels = 0;
 
-#ifdef CONFIG_DVDREAD
             guiInfo.Track   = 1;
             guiInfo.Chapter = 1;
             guiInfo.Angle   = 1;
-#endif
 
             if (gtkShowVideoWindow) {
                 guiInfo.VideoWindow = True;
@@ -970,12 +935,11 @@
     switch (what) {
         // subtitle
 
-#ifndef CONFIG_FREETYPE
     case MPLAYER_SET_FONT_FACTOR:
         font_factor = value;
         mplayerLoadFont();
         break;
-#else
+
     case MPLAYER_SET_FONT_OUTLINE:
         subtitle_font_thickness = (8.0f / 100.0f) * value;
         mplayerLoadFont();
@@ -1006,14 +970,11 @@
         subtitle_autoscale = (int)value;
         mplayerLoadFont();
         break;
-#endif
 
-#ifdef CONFIG_ICONV
     case MPLAYER_SET_SUB_ENCODING:
         nfree(sub_cp);
         sub_cp = gstrdup((char *)data);
         break;
-#endif
 
     case MPLAYER_SET_EXTRA_STEREO:
         gtkAOExtraStereoMul = value;
diff -Naur mplayer-1.0_rc4_p20120109/gui/interface.h mplayer-1.0_rc4_p20120109-new/gui/interface.h
--- mplayer-1.0_rc4_p20120109/gui/interface.h	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/interface.h	2012-01-16 15:51:41.000000000 +0100
@@ -102,30 +102,22 @@
     int StreamType;
     int AudioChannels;
 
-#ifdef CONFIG_DVDREAD
     int AudioStreams;
     stream_language_t AudioStream[32];
 
     int Subtitles;
     stream_language_t Subtitle[32];
-#endif
 
     char *Filename;           // public, read access by MPlayer
     char *AudioFilename;
     char *SubtitleFilename;
 
-#if defined(CONFIG_VCD) || defined(CONFIG_DVDREAD)
     int Tracks;
-#endif
-
     int Track;                // public, read access by MPlayer
-
-#ifdef CONFIG_DVDREAD
     int Chapters;
     int Chapter;              // public, write access by MPlayer
     int Angles;
     int Angle;
-#endif
 
     int Playing;              // public, read access by MPlayer
 
diff -Naur mplayer-1.0_rc4_p20120109/gui/skin/skin.c mplayer-1.0_rc4_p20120109-new/gui/skin/skin.c
--- mplayer-1.0_rc4_p20120109/gui/skin/skin.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/skin/skin.c	2012-01-16 15:51:41.000000000 +0100
@@ -354,15 +354,11 @@
     mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[skin]     bitmap: %dx%d\n", currWin->width, currWin->height);
 
     if (!is_sub) {
-#ifdef CONFIG_XSHAPE
         if (!bpRenderMask(&currWin->Bitmap, &currWin->Mask)) {
             skin_error(MSGTR_SKIN_NotEnoughMemory);
             return 1;
         }
         mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[skin]     mask: %lux%lu\n", currWin->Mask.Width, currWin->Mask.Height);
-#else
-        currWin->Mask.Image = NULL;
-#endif
     }
 
     if (is_bar)
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/actions.c mplayer-1.0_rc4_p20120109-new/gui/ui/actions.c
--- mplayer-1.0_rc4_p20120109/gui/ui/actions.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/actions.c	2012-01-16 15:51:41.000000000 +0100
@@ -247,20 +247,10 @@
         return;
 
     switch (guiInfo.StreamType) {
-#ifdef CONFIG_CDDA
     case STREAMTYPE_CDDA:
-        break;
-#endif
-
-#ifdef CONFIG_VCD
     case STREAMTYPE_VCD:
-        break;
-#endif
-
-#ifdef CONFIG_DVDREAD
     case STREAMTYPE_DVD:
         break;
-#endif
 
     default:
 
@@ -291,25 +281,20 @@
         return;
 
     switch (guiInfo.StreamType) {
-#ifdef CONFIG_CDDA
     case STREAMTYPE_CDDA:
         if (--guiInfo.Track == 0) {
             guiInfo.Track = 1;
             stop = 1;
         }
         break;
-#endif
 
-#ifdef CONFIG_VCD
     case STREAMTYPE_VCD:
         if (--guiInfo.Track == 1) {
             guiInfo.Track = 2;
             stop = 1;
         }
         break;
-#endif
 
-#ifdef CONFIG_DVDREAD
     case STREAMTYPE_DVD:
 
         if (--guiInfo.Chapter == 0) {
@@ -322,7 +307,6 @@
         }
 
         break;
-#endif
 
     default:
 
@@ -354,7 +338,6 @@
         return;
 
     switch (guiInfo.StreamType) {
-#ifdef CONFIG_CDDA
     case STREAMTYPE_CDDA:
 
         if (++guiInfo.Track > guiInfo.Tracks) {
@@ -363,9 +346,7 @@
         }
 
         break;
-#endif
 
-#ifdef CONFIG_VCD
     case STREAMTYPE_VCD:
 
         if (++guiInfo.Track >= guiInfo.Tracks) {
@@ -374,9 +355,7 @@
         }
 
         break;
-#endif
 
-#ifdef CONFIG_DVDREAD
     case STREAMTYPE_DVD:
 
         if (guiInfo.Chapter++ == guiInfo.Chapters) {
@@ -389,7 +368,6 @@
         }
 
         break;
-#endif
 
     default:
 
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gmplayer.h mplayer-1.0_rc4_p20120109-new/gui/ui/gmplayer.h
--- mplayer-1.0_rc4_p20120109/gui/ui/gmplayer.h	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gmplayer.h	2012-01-16 15:51:41.000000000 +0100
@@ -46,9 +46,9 @@
 void uiMenuInit( void );
 void uiHideMenu( int mx, int my, int w );
 void uiShowMenu( int mx, int my );
-void uiMenuMouseHandle( int X, int Y, int RX, int RY );
+void uiMenuMouseHandle( int RX, int RY );
 
 void uiPlaybarInit( void );
-void uiPlaybarShow( int x, int y );
+void uiPlaybarShow( int y );
 
 #endif /* MPLAYER_GUI_GMPLAYER_H */
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/about.c mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/about.c
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/about.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/about.c	2012-01-16 15:51:41.000000000 +0100
@@ -35,7 +35,7 @@
  gtk_widget_show( About );
 }
 
-static void abWidgetDestroy( GtkWidget * widget, GtkWidget ** widget_pointer )
+static void abWidgetDestroy( GtkButton * button, gpointer user_data )
 { WidgetDestroy( NULL,&About ); }
 
 GtkWidget * create_About( void )
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/equalizer.c mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/equalizer.c
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/equalizer.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/equalizer.c	2012-01-16 15:51:41.000000000 +0100
@@ -249,8 +249,11 @@
   }
 }
 
-static void eqFocus( GtkWindow * window,GtkWidget * widget,gpointer user_data )
-{ eqSetBands( Channel ); }
+static gboolean eqFocus( GtkWidget * widget,GdkEvent * event,gpointer user_data )
+{
+ eqSetBands( Channel );
+ return FALSE;
+}
 
 static void eqSelectChannelsListRow( GtkCList * clist,gint row,gint column,GdkEvent * event,gpointer user_data )
 {
@@ -265,8 +268,8 @@
   }
 }
 
-static void eqNotebook( GtkNotebook * notebook, GtkNotebookPage * page,
-                        gint page_num, gpointer user_data )
+static void eqNotebook( GtkNotebook * notebook, gpointer page,
+                        guint page_num, gpointer user_data )
 {
  if ( page_num ) gtk_widget_hide( Config );
    else gtk_widget_show( Config );
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/fileselect.c mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/fileselect.c
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/fileselect.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/fileselect.c	2012-01-16 15:51:41.000000000 +0100
@@ -397,7 +397,7 @@
 }
 //-----------------------------------------------
 
-static void fs_fsFilterCombo_activate( GtkEditable * editable,
+static void fs_fsFilterCombo_activate( GtkEntry * entry,
                                        gpointer user_data )
 {
  fsFilter=gtk_entry_get_text( GTK_ENTRY( user_data ) );
@@ -444,7 +444,7 @@
  CheckDir( fsFNameList );
 }
 
-static void fs_fsPathCombo_activate( GtkEditable * editable,
+static void fs_fsPathCombo_activate( GtkEntry * entry,
                                      gpointer user_data )
 {
  const unsigned char * str;
@@ -538,28 +538,28 @@
  fs_PersistantHistory( get_current_dir_name_utf8() );      //totem, write into history file
 }
 
-static void fs_fsFNameList_select_row( GtkWidget * widget, gint row, gint column,
-                                       GdkEventButton *bevent, gpointer user_data)
+static void fs_fsFNameList_select_row( GtkCList * clist, gint row, gint column,
+                                       GdkEvent * event, gpointer user_data)
 {
  fsCurrFNameListSelected = row;
- gtk_clist_get_text( GTK_CLIST(widget ),row,1,&fsSelectedFile );
+ gtk_clist_get_text( clist,row,1,&fsSelectedFile );
  g_free( fsSelectedFileUtf8 );
  fsSelectedFileUtf8 = g_filename_from_utf8( fsSelectedFile, -1, NULL, NULL, NULL );
  if ( fsSelectedFileUtf8 ) fsSelectedFile = fsSelectedFileUtf8;
- if( bevent && bevent->type == GDK_BUTTON_PRESS )  gtk_button_released( GTK_BUTTON( fsOk ) );
+ if( event && event->type == GDK_BUTTON_PRESS )  gtk_button_released( GTK_BUTTON( fsOk ) );
 }
 
 static gboolean on_FileSelect_key_release_event( GtkWidget * widget,
-                                                 GdkEventKey * event,
+                                                 GdkEvent * event,
                                                  gpointer user_data )
 {
  if ( GTK_WIDGET_TYPE( widget ) == GTK_TYPE_BUTTON )
  {
-  if (event->keyval == GDK_Return) gtk_button_released( GTK_BUTTON( widget ) );
+  if (event->key.keyval == GDK_Return) gtk_button_released( GTK_BUTTON( widget ) );
  }
  else
  {
-  switch ( event->keyval )
+  switch ( event->key.keyval )
    {
     case GDK_Escape:
          gtk_button_released( GTK_BUTTON( fsCancel ) );
@@ -583,8 +583,6 @@
   GdkEventButton *bevent;
   gint row, col;
 
-  (void) user_data;
-
   bevent = (GdkEventButton *) event;
 
   if ( event->type == GDK_BUTTON_RELEASE && bevent->button == 2 )
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/menu.c mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/menu.c
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/menu.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/menu.c	2012-01-16 15:51:41.000000000 +0100
@@ -207,6 +207,7 @@
  const char * name;
 } Languages_t;
 
+#ifdef CONFIG_DVDREAD
 #define lng( a,b ) ( (int)(a) * 256 + b )
 static Languages_t Languages[] =
          {
@@ -384,12 +385,10 @@
          };
 #undef lng
 
-#ifdef CONFIG_DVDREAD
 static char * ChannelTypes[] =
 	{ "Dolby Digital","","Mpeg1","Mpeg2","PCM","","Digital Theatre System" };
 static char * ChannelNumbers[] =
 	{ "","Stereo","","","","5.1" };
-#endif
 
 static const char * GetLanguage( int language )
 {
@@ -398,6 +397,7 @@
   if ( Languages[i].id == language ) return Languages[i].name;
  return NULL;
 }
+#endif
 
 
 GtkWidget * DVDSubMenu;
@@ -598,7 +598,7 @@
          int aid = ((sh_audio_t *)demuxer->a_streams[i])->aid;
          char tmp[32];
          snprintf( tmp,32,MSGTR_MENU_Track,aid );
-         AddMenuItem( window1, (const char*)empty1px_xpm, SubMenu,tmp,( aid << 16 ) + ivSetAudio );
+         AddMenuCheckItem( window1, (const char*)empty1px_xpm, SubMenu,tmp,audio_id == aid,( aid << 16 ) + ivSetAudio );
         }
      }
 
@@ -614,7 +614,7 @@
          int vid = ((sh_video_t *)demuxer->v_streams[i])->vid;
          char tmp[32];
          snprintf( tmp,32,MSGTR_MENU_Track,vid );
-         AddMenuItem( window1, (const char*)empty1px_xpm, SubMenu,tmp,( vid << 16 ) + ivSetVideo );
+         AddMenuCheckItem( window1, (const char*)empty1px_xpm, SubMenu,tmp,video_id == vid,( vid << 16 ) + ivSetVideo );
         }
      }
    }
@@ -628,7 +628,7 @@
      {
       char tmp[32];
       snprintf( tmp, 32, MSGTR_MENU_Track, i );
-      AddMenuItem( window1,(const char*)empty1px_xpm,SubMenu,tmp,( i << 16 ) + ivSetSubtitle );
+      AddMenuCheckItem( window1,(const char*)empty1px_xpm,SubMenu,tmp,guiInfo.mpcontext->global_sub_pos == i,( i << 16 ) + ivSetSubtitle );
      }
    }
 
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/msgbox.c mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/msgbox.c
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/msgbox.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/msgbox.c	2012-01-16 15:51:41.000000000 +0100
@@ -35,7 +35,7 @@
 void ShowMessageBox( const char * msg )
 {
  if ( MessageBox ) { gtk_widget_hide( MessageBox ); gtk_widget_destroy( MessageBox ); }
- MessageBox=create_MessageBox( 0 );
+ MessageBox=create_MessageBox();
  if ( strlen( msg ) < 20 ) gtk_widget_set_usize( MessageBox,196,-1 );
 }
 
@@ -46,7 +46,7 @@
  MessageBox=NULL;
 }
 
-GtkWidget * create_MessageBox( int type )
+GtkWidget * create_MessageBox( void )
 {
  GtkWidget * vbox1;
  GtkWidget * hbox1;
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/msgbox.h mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/msgbox.h
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/msgbox.h	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/msgbox.h	2012-01-16 15:51:41.000000000 +0100
@@ -23,7 +23,7 @@
 
 extern GtkWidget * MessageBox;
 
-GtkWidget * create_MessageBox( int type );
+GtkWidget * create_MessageBox( void );
 void ShowMessageBox( const char * msg );
 
 #endif /* MPLAYER_GUI_MSGBOX_H */
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/playlist.c mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/playlist.c
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/playlist.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/playlist.c	2012-01-16 15:51:41.000000000 +0100
@@ -305,8 +305,6 @@
   GdkEventButton *bevent;
   gint row, col;
 
-  (void) user_data;
-
   bevent = (GdkEventButton *) event;
 
   if ( event->type == GDK_BUTTON_RELEASE && bevent->button == 2 )
@@ -439,14 +437,14 @@
   }
 }
 
-static void plCTRow(GtkWidget * widget, gint row, gint column, GdkEventButton * bevent, gpointer data)
+static void plCTRow(GtkCList * clist, gint row, gint column, GdkEvent * event, gpointer user_data)
 {
  DirNodeType  * DirNode;
  GtkCTreeNode * node;
- node=gtk_ctree_node_nth( GTK_CTREE( widget ),row );
- DirNode=gtk_ctree_node_get_row_data( GTK_CTREE( widget ),node );
+ node=gtk_ctree_node_nth( GTK_CTREE( clist ),row );
+ DirNode=gtk_ctree_node_get_row_data( GTK_CTREE( clist ),node );
  current_path=DirNode->path;
- gtk_ctree_expand( GTK_CTREE( widget ),node );
+ gtk_ctree_expand( GTK_CTREE( clist ),node );
  scan_dir( DirNode->path );
  free( CLFileSelected );
  CLFileSelected=calloc( 1,NrOfEntrys * sizeof( int ) );
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/preferences.c mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/preferences.c
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/preferences.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/preferences.c	2012-01-16 15:51:41.000000000 +0100
@@ -70,9 +70,11 @@
        GtkWidget * prEFontName;
        GtkWidget * prEDVDDevice;
        GtkWidget * prECDRomDevice;
+static GtkWidget * EVHW;
 static GtkWidget * EVFM;
 static GtkWidget * EAFM;
 
+static GtkWidget * CBVHW;
 static GtkWidget * CBVFM;
 static GtkWidget * CBAFM;
 static GtkWidget * CBAudioEqualizer;
@@ -184,18 +186,16 @@
 static char * vo_driver[3];
 static int    old_video_driver = 0;
 
-#ifdef CONFIG_DXR3
  void ShowDXR3Config( void );
  void HideDXR3Config( void );
-#endif
  void ShowAudioConfig( void );
  void HideAudioConfig( void );
 
-static gboolean prHScaler( GtkWidget * widget,GdkEventMotion  * event,gpointer user_data );
+static gboolean prHScaler( GtkWidget * widget,GdkEvent * event,gpointer user_data );
 static void prToggled( GtkToggleButton * togglebutton,gpointer user_data );
 static void prCListRow( GtkCList * clist,gint row,gint column,GdkEvent * event,gpointer user_data );
 #if defined(CONFIG_FREETYPE) || defined(CONFIG_ICONV)
-static void prEntry( GtkContainer * container,gpointer user_data );
+static void prEntry( GtkEditable * editable,gpointer user_data );
 #endif
 
 void ShowPreferences( void )
@@ -355,6 +355,26 @@
 // -- 5. page
  gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON( CBNonInterlaved ),force_ni );
  if ( index_mode == 1 ) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON( CBIndex ),1 );
+
+ {
+     int     i;
+     GList * Items = NULL;
+     char  * name  = NULL;
+
+     Items = g_list_append(Items, MSGTR_PREFERENCES_None);
+     for (i = 0; i < HWACCEL_COUNT; i++) {
+         const char *hwaccel_name = get_video_hwaccel_name(i);
+         if (!hwaccel_name)
+             continue;
+         Items = g_list_append(Items, hwaccel_name);
+         if (video_hwaccel_name && !gstrcmp(video_hwaccel_name, get_video_hwaccel_short_name(i) ) ) name = hwaccel_name;
+     }
+     gtk_combo_set_popdown_strings(GTK_COMBO(CBVHW), Items);
+     g_list_free(Items);
+     if (name)
+         gtk_entry_set_text(GTK_ENTRY(EVHW), name);
+ }
+
  {
   int     i;
   GList * Items = NULL;
@@ -491,7 +511,7 @@
 }
 
 #if defined(CONFIG_FREETYPE) || defined(CONFIG_ICONV)
-static void prEntry( GtkContainer * container,gpointer user_data )
+static void prEntry( GtkEditable * editable,gpointer user_data )
 {
  const char * comment;
  int    i;
@@ -597,6 +617,17 @@
 	if ( gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON( CBIndex ) ) ) index_mode=1;
 
 	{
+            int i;
+            const char *tmp = gtk_entry_get_text(GTK_ENTRY(EVHW));
+            for (i = 0; i < HWACCEL_COUNT; i++) {
+                if (!gstrcmp(tmp, get_video_hwaccel_name(i))) {
+                    video_hwaccel_name = get_video_hwaccel_short_name(i);
+                    break;
+                }
+            }
+        }
+
+	{
 	 int i;
 	 const char * tmp = gtk_entry_get_text( GTK_ENTRY( EVFM ) );
          for( i=0;mpcodecs_vd_drivers[i];i++ )
@@ -663,7 +694,7 @@
   }
 }
 
-static gboolean prHScaler( GtkWidget * widget,GdkEventMotion  * event,gpointer user_data )
+static gboolean prHScaler( GtkWidget * widget,GdkEvent * event,gpointer user_data )
 {
  switch ( (int)user_data )
   {
@@ -1193,6 +1224,20 @@
 
   hbox5=AddHBox( vbox602,1 );
 
+  AddLabel( MSGTR_PREFERENCES_VideoHardwareAcceleration,hbox5 );
+
+  CBVHW=gtk_combo_new();
+  gtk_widget_set_name( CBVHW,"CBVHW" );
+  gtk_widget_show( CBVHW );
+  gtk_box_pack_start( GTK_BOX( hbox5 ),CBVHW,TRUE,TRUE,0 );
+
+  EVHW=GTK_COMBO( CBVHW )->entry;
+  gtk_widget_set_name( EVHW,"CEVHW" );
+  gtk_entry_set_editable( GTK_ENTRY( EVHW ),FALSE );
+  gtk_widget_show( EVHW );
+
+  hbox5=AddHBox( vbox602,1 );
+
   AddLabel( MSGTR_PREFERENCES_VideoCodecFamily,hbox5 );
 
   CBVFM=gtk_combo_new();
@@ -1474,6 +1519,7 @@
 }
 #endif
 
+#if defined(CONFIG_OSS_AUDIO) || defined(CONFIG_ALSA) || defined(CONFIG_SDL) || defined (CONFIG_ESD)
 // Gets text string from a gtk entry, interpreting
 // MSGTR_PREFERENCES_DriverDefault as null string.
 static const char *getGtkEntryText(GtkWidget *from)
@@ -1494,6 +1540,7 @@
   }
   gtk_entry_set_text(GTK_ENTRY(dest),to);
 }
+#endif
 
        GtkWidget *AudioConfig;
 static GtkWidget *CEAudioDevice;
@@ -1706,7 +1753,6 @@
   return AudioConfig;
 }
 
-#ifdef CONFIG_DXR3
 // --- dxr3 config box
 
 static GtkWidget * DXR3Config;
@@ -1826,5 +1872,3 @@
 
  return DXR3Config;
 }
-
-#endif
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/gtk/skinbrowser.c mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/skinbrowser.c
--- mplayer-1.0_rc4_p20120109/gui/ui/gtk/skinbrowser.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/gtk/skinbrowser.c	2012-01-16 15:51:41.000000000 +0100
@@ -90,7 +90,7 @@
  return 1;
 }
 
-static void prButton( GtkObject * object,gpointer user_data )
+static void prButton( GtkButton * button,gpointer user_data )
 {
  if ( sbSelectedSkin )
  {
@@ -109,7 +109,7 @@
  HideSkinBrowser();
 }
 
-static void on_SkinList_select_row( GtkCList * clist,gint row,gint column,GdkEvent * bevent,gpointer user_data )
+static void on_SkinList_select_row( GtkCList * clist,gint row,gint column,GdkEvent * event,gpointer user_data )
 {
  gtk_clist_get_text( clist,row,0,&sbSelectedSkin );
  if ( strcmp( prev,sbSelectedSkin ) )
@@ -118,8 +118,8 @@
    uiChangeSkin( sbSelectedSkin );
    gtkActive( SkinBrowser );
   }
- if( !bevent ) return;
- if( bevent->type == GDK_2BUTTON_PRESS )
+ if( !event ) return;
+ if( event->type == GDK_2BUTTON_PRESS )
   {
    free( skinName );
    skinName=strdup( sbSelectedSkin );
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/main.c mplayer-1.0_rc4_p20120109-new/gui/ui/main.c
--- mplayer-1.0_rc4_p20120109/gui/ui/main.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/main.c	2012-01-16 15:51:41.000000000 +0100
@@ -114,11 +114,8 @@
     listSet(gtkDelPl, NULL);
   }
 
-#ifdef CONFIG_VCD
   if (what & CLEAR_VCD) guiInfo.Tracks = 0;
-#endif
 
-#ifdef CONFIG_DVDREAD
   if (what & CLEAR_DVD)
   {
     guiInfo.AudioStreams = 0;
@@ -127,7 +124,6 @@
     guiInfo.Chapters = 0;
     guiInfo.Angles = 0;
   }
-#endif
 }
 
 static unsigned last_redraw_time = 0;
@@ -150,13 +146,13 @@
 
    case ivSetAudio:
         if ( !mpctx_get_demuxer(guiInfo.mpcontext) || audio_id == iparam ) break;
-	audio_id=iparam;
-	goto play;
+	mp_property_do("switch_audio",M_PROPERTY_SET,&iparam,guiInfo.mpcontext);
+	break;
 
    case ivSetVideo:
         if ( !mpctx_get_demuxer(guiInfo.mpcontext) || video_id == iparam ) break;
-	video_id=iparam;
-	goto play;
+	mp_property_do("switch_video",M_PROPERTY_SET,&iparam,guiInfo.mpcontext);
+	break;
 
    case ivSetSubtitle:
         mp_property_do("sub",M_PROPERTY_SET,&iparam,guiInfo.mpcontext);
@@ -181,27 +177,27 @@
 #ifdef CONFIG_DVDREAD
    case ivSetDVDSubtitle:
         dvdsub_id=iparam;
-        goto play_dvd_2;
+        uiEventHandling( ivPlayDVD, 0 );
         break;
    case ivSetDVDAudio:
         audio_id=iparam;
-        goto play_dvd_2;
+        uiEventHandling( ivPlayDVD, 0 );
         break;
    case ivSetDVDChapter:
         guiInfo.Chapter=iparam;
-        goto play_dvd_2;
+        uiEventHandling( ivPlayDVD, 0 );
         break;
    case ivSetDVDTitle:
         guiInfo.Track=iparam;
         guiInfo.Chapter=1;
         guiInfo.Angle=1;
-        goto play_dvd_2;
+        uiEventHandling( ivPlayDVD, 0 );
         break;
    case evPlayDVD:
         guiInfo.Track=1;
         guiInfo.Chapter=1;
         guiInfo.Angle=1;
-play_dvd_2:
+   case ivPlayDVD:
  	guiInfoMediumClear( CLEAR_ALL - CLEAR_DVD );
         guiInfo.StreamType=STREAMTYPE_DVD;
 	goto play;
@@ -228,7 +224,7 @@
 	         guiInfo.Track=1;
 	       guiInfo.NewPlay=GUI_FILE_NEW;
 	       break;
-#ifdef CONFIG_CDDA
+
           case STREAMTYPE_CDDA:
 	       guiInfoMediumClear( CLEAR_ALL - CLEAR_VCD - CLEAR_FILE );
 	       if ( guiInfo.Playing != GUI_PAUSE )
@@ -238,8 +234,7 @@
                  guiInfo.NewPlay=GUI_FILE_SAME;
 		}
 	       break;
-#endif
-#ifdef CONFIG_VCD
+
           case STREAMTYPE_VCD:
 	       guiInfoMediumClear( CLEAR_ALL - CLEAR_VCD - CLEAR_FILE );
 	       if ( guiInfo.Playing != GUI_PAUSE )
@@ -249,8 +244,7 @@
                  guiInfo.NewPlay=GUI_FILE_SAME;
 		}
 	       break;
-#endif
-#ifdef CONFIG_DVDREAD
+
           case STREAMTYPE_DVD:
 	       guiInfoMediumClear( CLEAR_ALL - CLEAR_DVD - CLEAR_FILE );
 	       if ( guiInfo.Playing != GUI_PAUSE )
@@ -258,7 +252,6 @@
                  guiInfo.NewPlay=GUI_FILE_SAME;
 		}
                break;
-#endif
          }
         uiPlay();
         break;
@@ -332,6 +325,15 @@
         break;
 
 
+   case evMenu:
+        /*if (guiApp.menuIsPresent)   NOTE TO MYSELF: Uncomment only after mouse
+         {                                            pointer and cursor keys work
+          gtkShow( ivHidePopUpMenu,NULL );            with this menu from skin as
+          uiShowMenu( 0,0 );                          they do with normal menus.
+         }
+        else*/ gtkShow( ivShowPopUpMenu,NULL );
+        break;
+
    case evIconify:
         switch ( iparam )
          {
@@ -399,10 +401,9 @@
 	  default: movie_aspect=-1;
 	 }
 	wsClearWindow( guiApp.subWindow );
-#ifdef CONFIG_DVDREAD
-	if ( guiInfo.StreamType == STREAMTYPE_VCD || guiInfo.StreamType == STREAMTYPE_DVD ) goto play_dvd_2;
+	if ( guiInfo.StreamType == STREAMTYPE_VCD ) uiEventHandling( evPlayVCD, 0 );
+	 else if ( guiInfo.StreamType == STREAMTYPE_DVD ) uiEventHandling( ivPlayDVD, 0 );
 	 else
-#endif
 	 guiInfo.NewPlay=GUI_FILE_NEW;
 	break;
 
@@ -530,7 +531,7 @@
                  uiMainRender=0;
                  break;
             case itPRMButton:
-                 uiMenuMouseHandle( X,Y,RX,RY );
+                 uiMenuMouseHandle( RX,RY );
                  break;
             case itPotmeter:
                  item->value=(float)( X - item->x ) / item->width * 100.0f;
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/menu.c mplayer-1.0_rc4_p20120109-new/gui/ui/menu.c
--- mplayer-1.0_rc4_p20120109/gui/ui/menu.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/menu.c	2012-01-16 15:51:41.000000000 +0100
@@ -68,7 +68,7 @@
  wsPutImage( &guiApp.menuWindow );
 }
 
-void uiMenuMouseHandle( int X,int Y,int RX,int RY )
+void uiMenuMouseHandle( int RX,int RY )
 {
  int x,y,i;
 
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/playbar.c mplayer-1.0_rc4_p20120109-new/gui/ui/playbar.c
--- mplayer-1.0_rc4_p20120109/gui/ui/playbar.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/playbar.c	2012-01-16 15:51:41.000000000 +0100
@@ -207,7 +207,7 @@
 	switch ( itemtype )
 	 {
 	  case itPRMButton:
-	       uiMenuMouseHandle( X,Y,RX,RY );
+	       uiMenuMouseHandle( RX,RY );
 	       break;
 	  case itPotmeter:
 	       item->value=(float)( X - item->x ) / item->width * 100.0f;
@@ -227,7 +227,7 @@
   }
 }
 
-void uiPlaybarShow( int x, int y )
+void uiPlaybarShow( int y )
 {
  if ( !guiApp.playbarIsPresent || !gtkEnablePlayBar ) return;
  if ( !guiApp.subWindow.isFullScreen ) return;
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/render.c mplayer-1.0_rc4_p20120109-new/gui/ui/render.c
--- mplayer-1.0_rc4_p20120109/gui/ui/render.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/render.c	2012-01-16 15:51:41.000000000 +0100
@@ -206,23 +206,17 @@
                     av_strlcat(trbuf, "u", sizeof(trbuf));
                     break;
 
-#ifdef CONFIG_CDDA
                 case STREAMTYPE_CDDA:
                     av_strlcat(trbuf, "a", sizeof(trbuf));
                     break;
-#endif
 
-#ifdef CONFIG_VCD
                 case STREAMTYPE_VCD:
                     av_strlcat(trbuf, "v", sizeof(trbuf));
                     break;
-#endif
 
-#ifdef CONFIG_DVDREAD
                 case STREAMTYPE_DVD:
                     av_strlcat(trbuf, "d", sizeof(trbuf));
                     break;
-#endif
 
                 default:
                     av_strlcat(trbuf, " ", sizeof(trbuf));
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/sub.c mplayer-1.0_rc4_p20120109-new/gui/ui/sub.c
--- mplayer-1.0_rc4_p20120109/gui/ui/sub.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/sub.c	2012-01-16 15:51:41.000000000 +0100
@@ -57,7 +57,7 @@
  static int mplSubMoved = 0;
  static int msButton = 0;
 
- uiPlaybarShow( X,Y );
+ uiPlaybarShow( Y );
 
  switch( Button )
   {
@@ -94,9 +94,9 @@
                     }
                    break;
             case wsPMMouseButton:
-                   uiMenuMouseHandle( X,Y,RX,RY );
+                   uiMenuMouseHandle( RX,RY );
                    break;
-	    default: uiPlaybarShow( X,Y ); break;
+	    default: uiPlaybarShow( Y ); break;
            }
           break;
    case wsRLMouseButton:
diff -Naur mplayer-1.0_rc4_p20120109/gui/ui/widgets.c mplayer-1.0_rc4_p20120109-new/gui/ui/widgets.c
--- mplayer-1.0_rc4_p20120109/gui/ui/widgets.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/ui/widgets.c	2012-01-16 15:51:41.000000000 +0100
@@ -64,7 +64,7 @@
 #include "gtk/url.h"
 #include "gtk/equalizer.h"
 
-#include "pixmaps/mplayer.xpm"
+#define GUI_ICON_NAME "mplayer"
 
 #define THRESHOLD 128   // transparency values equal to or above this will become
                         // opaque, all values below this will become transparent
@@ -73,14 +73,51 @@
 
 guiIcon_t guiIcon;
 
+static void gtkLoadIcon(GtkIconTheme *theme, gint size, GdkPixmap **gdkIcon, GdkBitmap **gdkIconMask)
+{
+    GdkPixbuf *pixbuf;
+    guchar *data;
+    int csize, i;
+
+    pixbuf = gtk_icon_theme_load_icon(theme, GUI_ICON_NAME, size, 0, NULL);
+
+    if (pixbuf)
+        gdk_pixbuf_render_pixmap_and_mask_for_colormap(pixbuf, gdk_colormap_get_system(), gdkIcon, gdkIconMask, THRESHOLD);
+
+    if (pixbuf &&
+        gdk_pixbuf_get_colorspace(pixbuf) == GDK_COLORSPACE_RGB &&
+        gdk_pixbuf_get_n_channels(pixbuf) == 4 &&
+        gdk_pixbuf_get_bits_per_sample(pixbuf) == 8) {
+        csize = guiIcon.collection_size;
+        guiIcon.collection_size += 2 + gdk_pixbuf_get_width(pixbuf) * gdk_pixbuf_get_height(pixbuf);
+
+        guiIcon.collection = realloc(guiIcon.collection, guiIcon.collection_size * sizeof(*guiIcon.collection));
+
+        if (guiIcon.collection) {
+            guiIcon.collection[csize++] = gdk_pixbuf_get_width(pixbuf);
+            guiIcon.collection[csize++] = gdk_pixbuf_get_height(pixbuf);
+
+            data = gdk_pixbuf_get_pixels(pixbuf);
+
+            for (i = csize; i < guiIcon.collection_size; data += 4, i++)
+                guiIcon.collection[i] = (data[3] << 24) | AV_RB24(data);  // RGBA -> ARGB
+        }
+
+        g_object_unref(pixbuf);
+    } else
+        mp_msg(MSGT_GPLAYER, MSGL_WARN, MSGTR_ICONERROR, GUI_ICON_NAME, size);
+
+    // start up GTK which realizes the pixmaps
+    gtk_main_iteration_do(FALSE);
+}
+
 void gtkInit(void)
 {
-    int argc = 0, i;
+    int argc = 0;
     char *arg[3], **argv = arg;
-    GdkPixbuf *pixbuf;
+    GtkIconTheme *theme;
     GdkPixmap *gdkIcon;
     GdkBitmap *gdkIconMask;
-    guchar *data;
 
     mp_msg(MSGT_GPLAYER, MSGL_V, "GTK init.\n");
 
@@ -97,35 +134,18 @@
 
     gtk_init(&argc, &argv);
 
-    pixbuf = gdk_pixbuf_new_from_xpm_data((const char **)mplayer_xpm);
-
-    gdk_pixbuf_render_pixmap_and_mask_for_colormap(pixbuf, gdk_colormap_get_system(), &gdkIcon, &gdkIconMask, THRESHOLD);
-
-    if (gdk_pixbuf_get_colorspace(pixbuf) == GDK_COLORSPACE_RGB &&
-        gdk_pixbuf_get_n_channels(pixbuf) == 4 &&
-        gdk_pixbuf_get_bits_per_sample(pixbuf) == 8) {
-        guiIcon.collection_size = 2 + gdk_pixbuf_get_width(pixbuf) * gdk_pixbuf_get_height(pixbuf);
-
-        guiIcon.collection = malloc(guiIcon.collection_size * sizeof(*guiIcon.collection));
-
-        if (guiIcon.collection) {
-            guiIcon.collection[0] = gdk_pixbuf_get_width(pixbuf);
-            guiIcon.collection[1] = gdk_pixbuf_get_height(pixbuf);
-
-            data = gdk_pixbuf_get_pixels(pixbuf);
-
-            for (i = 2; i < guiIcon.collection_size; data += 4, i++)
-                guiIcon.collection[i] = (data[3] << 24) | AV_RB24(data);  // RGBA -> ARGB
-        }
-    } else
-        mp_msg(MSGT_GPLAYER, MSGL_WARN, MSGTR_ICONERROR, "mplayer");
+    theme = gtk_icon_theme_get_default();
 
-    // start up GTK which realizes the pixmaps
-    gtk_main_iteration_do(FALSE);
+    gtkLoadIcon(theme, 16, &gdkIcon, &gdkIconMask);
+    guiIcon.small      = GDK_PIXMAP_XID(gdkIcon);
+    guiIcon.small_mask = GDK_PIXMAP_XID(gdkIconMask);
 
+    gtkLoadIcon(theme, 32, &gdkIcon, &gdkIconMask);
     guiIcon.normal      = GDK_PIXMAP_XID(gdkIcon);
     guiIcon.normal_mask = GDK_PIXMAP_XID(gdkIconMask);
 
+    gtkLoadIcon(theme, 48, &gdkIcon, &gdkIconMask);
+
     gtkInitialized = 1;
 }
 
diff -Naur mplayer-1.0_rc4_p20120109/gui/util/bitmap.c mplayer-1.0_rc4_p20120109-new/gui/util/bitmap.c
--- mplayer-1.0_rc4_p20120109/gui/util/bitmap.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/util/bitmap.c	2012-01-16 15:51:41.000000000 +0100
@@ -78,7 +78,7 @@
     fread(data, len, 1, file);
     fclose(file);
 
-    avctx = avcodec_alloc_context();
+    avctx = avcodec_alloc_context3(NULL);
     frame = avcodec_alloc_frame();
 
     if (!(avctx && frame)) {
@@ -89,7 +89,7 @@
     }
 
     avcodec_register_all();
-    avcodec_open(avctx, avcodec_find_decoder(CODEC_ID_PNG));
+    avcodec_open2(avctx, avcodec_find_decoder(CODEC_ID_PNG), NULL);
 
     av_init_packet(&pkt);
     pkt.data = data;
diff -Naur mplayer-1.0_rc4_p20120109/gui/util/string.c mplayer-1.0_rc4_p20120109-new/gui/util/string.c
--- mplayer-1.0_rc4_p20120109/gui/util/string.c	2012-01-09 14:46:53.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/util/string.c	2012-01-16 15:51:41.000000000 +0100
@@ -283,26 +283,20 @@
         av_strlcpy(fname, guiInfo.Filename, maxlen);
         break;
 
-#ifdef CONFIG_CDDA
     case STREAMTYPE_CDDA:
         snprintf(fname, maxlen, MSGTR_Title, guiInfo.Track);
         break;
-#endif
 
-#ifdef CONFIG_VCD
     case STREAMTYPE_VCD:
         snprintf(fname, maxlen, MSGTR_Title, guiInfo.Track - 1);
         break;
-#endif
 
-#ifdef CONFIG_DVDREAD
     case STREAMTYPE_DVD:
         if (guiInfo.Chapter)
             snprintf(fname, maxlen, MSGTR_Chapter, guiInfo.Chapter);
         else
             av_strlcat(fname, MSGTR_NoChapter, maxlen);
         break;
-#endif
 
     default:
         av_strlcpy(fname, MSGTR_NoMediaOpened, maxlen);
diff -Naur mplayer-1.0_rc4_p20120109/gui/win32/dialogs.c mplayer-1.0_rc4_p20120109-new/gui/win32/dialogs.c
--- mplayer-1.0_rc4_p20120109/gui/win32/dialogs.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/win32/dialogs.c	2012-01-16 15:51:41.000000000 +0100
@@ -774,7 +774,6 @@
    UpdateWindow(hWnd);
 }
 
-#ifdef CONFIG_DVDREAD
 static LRESULT CALLBACK TitleChapterWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
 {
     static HWND title;
@@ -902,7 +901,6 @@
    ShowWindow(hWnd, SW_SHOW);
    UpdateWindow(hWnd);
 }
-#endif
 
 static LRESULT CALLBACK EqWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
 {
diff -Naur mplayer-1.0_rc4_p20120109/gui/win32/gui.c mplayer-1.0_rc4_p20120109-new/gui/win32/gui.c
--- mplayer-1.0_rc4_p20120109/gui/win32/gui.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/win32/gui.c	2012-01-16 15:51:41.000000000 +0100
@@ -451,11 +451,9 @@
                 case ID_NTRACK:
                     handlemsg(hWnd, evNext);
                     break;
-#ifdef CONFIG_DVDREAD
                 case ID_CHAPTERSEL:
                     display_chapterselwindow(gui);
                     break;
-#endif
                 case ID_FULLSCREEN:
                     mp_input_queue_cmd(mp_input_parse_cmd("vo_fullscreen"));
                     break;
@@ -847,10 +845,6 @@
             POINT point;
             char device[MAX_PATH];
             char searchpath[MAX_PATH];
-            char searchpath2[MAX_PATH];
-#ifdef CONFIG_CDDA
-            char searchpath3[MAX_PATH];
-#endif
             int len, pos = 0, cdromdrive = 0;
             UINT errmode;
             point.x = GET_X_LPARAM(lParam);
@@ -866,23 +860,22 @@
                 {
                     char volname[MAX_PATH];
                     char menuitem[MAX_PATH];
-                    int flags = MF_STRING;
+                    int flags = MF_STRING, enable = 0;
                     mp_msg(MSGT_GPLAYER, MSGL_V, "[GUI] checking %s for CD/VCD/SVCD/DVDs\n", device + pos);
+#ifdef CONFIG_DVDREAD
                     sprintf(searchpath, "%sVIDEO_TS", device + pos);
-                    sprintf(searchpath2, "%sMpegav", device + pos);
-#ifdef CONFIG_CDDA
-                    sprintf(searchpath3, "%sTrack01.cda", device + pos);
+                    if(GetFileAttributes(searchpath) != INVALID_FILE_ATTRIBUTES)
+                        enable = 1;
 #endif
+                    sprintf(searchpath, "%sMpegav", device + pos);
                     if(GetFileAttributes(searchpath) != INVALID_FILE_ATTRIBUTES)
-                        flags |= MF_ENABLED;
-                    else if(GetFileAttributes(searchpath2) != INVALID_FILE_ATTRIBUTES)
-                        flags |= MF_ENABLED;
+                        enable = 1;
 #ifdef CONFIG_CDDA
-                    else if(GetFileAttributes(searchpath3) != INVALID_FILE_ATTRIBUTES)
-                        flags |= MF_ENABLED;
+                    sprintf(searchpath, "%sTrack01.cda", device + pos);
+                    if(GetFileAttributes(searchpath) != INVALID_FILE_ATTRIBUTES)
+                        enable = 1;
 #endif
-                    else
-                        flags |= MF_GRAYED;
+                    flags |= (enable ? MF_ENABLED : MF_GRAYED);
                     volname[0] = 0;
                     strcpy(menuitem, device + pos);
                     menuitem[strlen(menuitem) - 1]=0;
@@ -1052,22 +1045,18 @@
                             sprintf(searchpath, "%sVIDEO_TS", device + pos);
                             if(GetFileAttributes(searchpath) != INVALID_FILE_ATTRIBUTES)
                             {
-#ifdef CONFIG_DVDREAD
                                 free(dvd_device);
                                 dvd_device = strdup(device + pos);
                                 handlemsg(hWnd, evPlayDVD);
-#endif
                             }
                             sprintf(searchpath, "%sTrack01.cda", device + pos);
                             if(GetFileAttributes(searchpath) != INVALID_FILE_ATTRIBUTES)
                             {
-#ifdef CONFIG_CDDA
                                 free(cdrom_device);
                                 cdrom_device = strdup(device + pos);
                                 /* mplayer doesn't seem to like the trailing \ after the device name */
                                 cdrom_device[2]=0;
                                 handlemsg(hWnd, evPlayCD);
-#endif
                             } else {
                                 HANDLE searchhndl;
                                 WIN32_FIND_DATA finddata;
@@ -1257,8 +1246,8 @@
     AppendMenu(gui->submenu, MF_SEPARATOR, 0, 0);
     AppendMenu(gui->submenu, MF_STRING | MF_POPUP, (UINT_PTR) gui->aspectmenu, acp(MSGTR_MENU_AspectRatio));
     AppendMenu(gui->submenu, MF_STRING | MF_POPUP, (UINT_PTR) gui->subtitlemenu, acp(MSGTR_MENU_Subtitles));
-    AppendMenu(gui->submenu, MF_STRING | MF_POPUP, (UINT_PTR) gui->dvdmenu, acp(MSGTR_MENU_DVD));
 #ifdef CONFIG_DVDREAD
+    AppendMenu(gui->submenu, MF_STRING | MF_POPUP, (UINT_PTR) gui->dvdmenu, acp(MSGTR_MENU_DVD));
     AppendMenu(gui->dvdmenu, MF_STRING | MF_GRAYED, ID_CHAPTERSEL, acp(MSGTR_SelectTitleChapter));
 #endif
     AppendMenu(gui->subtitlemenu, MF_STRING, IDSUB_TOGGLE, acp(MSGTR_MENU_SubtitlesOnOff));
diff -Naur mplayer-1.0_rc4_p20120109/gui/win32/interface.c mplayer-1.0_rc4_p20120109-new/gui/win32/interface.c
--- mplayer-1.0_rc4_p20120109/gui/win32/interface.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/win32/interface.c	2012-01-16 15:51:41.000000000 +0100
@@ -354,14 +354,12 @@
         {
             switch(guiInfo.StreamType)
             {
-#ifdef CONFIG_DVDREAD
                 case STREAMTYPE_DVD:
                 {
                     guiInfo.NewPlay = GUI_FILE_SAME;
                     gui(GUI_SET_STATE, (void *) GUI_PLAY);
                     break;
                 }
-#endif
                 default:
                 {
                     guiInfo.NewPlay = GUI_FILE_NEW;
@@ -415,13 +413,11 @@
     if(guiInfo.Playing == GUI_PAUSE) return;
     switch(guiInfo.StreamType)
     {
-#ifdef CONFIG_DVDREAD
         case STREAMTYPE_DVD:
             if(guiInfo.Chapter == (guiInfo.Chapters - 1))
                 return;
             guiInfo.Chapter++;
             break;
-#endif
         default:
             if(mygui->playlist->current == (mygui->playlist->trackcount - 1))
                 return;
@@ -437,13 +433,11 @@
     if(guiInfo.Playing == GUI_PAUSE) return;
     switch(guiInfo.StreamType)
     {
-#ifdef CONFIG_DVDREAD
         case STREAMTYPE_DVD:
             if(guiInfo.Chapter == 1)
                 return;
             guiInfo.Chapter--;
             break;
-#endif
         default:
             if(mygui->playlist->current == 0)
                 return;
@@ -596,7 +590,6 @@
                     uiSetFileName(NULL, mygui->playlist->tracks[mygui->playlist->current]->filename, SAME_STREAMTYPE);
                     guiInfo.Track = mygui->playlist->current + 1;
                     break;
-#ifdef CONFIG_DVDREAD
                 case STREAMTYPE_DVD:
                 {
                     char tmp[512];
@@ -606,7 +599,6 @@
                     uiSetFileName(NULL, tmp, SAME_STREAMTYPE);
                     break;
                 }
-#endif
             }
             guiInfo.VideoWindow = 1;
             if(gtkAONorm) greplace(&af_cfg.list, "volnorm", "volnorm");
@@ -665,21 +657,24 @@
             guiInfo.StreamType = stream->type;
             switch(stream->type)
             {
-#ifdef CONFIG_DVDREAD
                 case STREAMTYPE_DVD:
+                    guiInfo.Tracks = 0;
+                    stream_control(stream, STREAM_CTRL_GET_NUM_TITLES, &guiInfo.Tracks);
+                    guiInfo.Chapters = 0;
+                    stream_control(stream, STREAM_CTRL_GET_NUM_CHAPTERS, &guiInfo.Chapters);
+                    guiInfo.Angles = 0;
+                    stream_control(stream, STREAM_CTRL_GET_NUM_ANGLES, &guiInfo.Angles);
+#ifdef CONFIG_DVDREAD
                     dvdp = stream->priv;
-                    guiInfo.Tracks = dvdp->vmg_file->tt_srpt->nr_of_srpts;
-                    guiInfo.Chapters = dvdp->vmg_file->tt_srpt->title[dvd_title].nr_of_ptts;
-                    guiInfo.Angles = dvdp->vmg_file->tt_srpt->title[dvd_title].nr_of_angles;
                     guiInfo.AudioStreams = dvdp->nr_of_channels;
                     memcpy(guiInfo.AudioStream, dvdp->audio_streams, sizeof(dvdp->audio_streams));
                     guiInfo.Subtitles = dvdp->nr_of_subtitles;
                     memcpy(guiInfo.Subtitle, dvdp->subtitles, sizeof(dvdp->subtitles));
+#endif
                     guiInfo.Chapter = dvd_chapter + 1;
                     guiInfo.Angle = dvd_angle + 1;
                     guiInfo.Track = dvd_title + 1;
                     break;
-#endif
             }
             break;
         }
@@ -793,11 +788,9 @@
           guiInfo.Position = 0;
           guiInfo.AudioChannels = 0;
 
-#ifdef CONFIG_DVDREAD
           guiInfo.Track = 1;
           guiInfo.Chapter = 1;
           guiInfo.Angle = 1;
-#endif
 
           if (mygui->playlist->current == (mygui->playlist->trackcount - 1))
               mygui->playlist->current = 0;
diff -Naur mplayer-1.0_rc4_p20120109/gui/win32/skinload.c mplayer-1.0_rc4_p20120109-new/gui/win32/skinload.c
--- mplayer-1.0_rc4_p20120109/gui/win32/skinload.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/win32/skinload.c	2012-01-16 15:51:41.000000000 +0100
@@ -85,6 +85,7 @@
     {   evAbout,                "evAbout"               },
     {   evPreferences,          "evPreferences"         },
     {   evSkinBrowser,          "evSkinBrowser"         },
+    {   evMenu,                 "evMenu"                },
     {   evIconify,              "evIconify"             },
     {   evExit,                 "evExit"                }
 };
@@ -128,9 +129,7 @@
     for (i=0; i < skin->imagecount; i++)
         if(!strcmp(fname, skin->images[i]->name))
         {
-#ifdef DEBUG
-            mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[png] skinfile %s already exists\n", fname);
-#endif
+            mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[png] skinfile %s already exists\n", fname);
             free(filename);
             return skin->images[i];
         }
@@ -183,14 +182,12 @@
     free(skin->images);
 }
 
-#ifdef DEBUG
 static void dumpwidgets(skin_t *skin)
 {
     unsigned int i;
     for (i=0; i<skin->widgetcount; i++)
-        mp_msg(MSGT_GPLAYER, MSGL_V, "widget %p id %i\n", skin->widgets[i], skin->widgets[i]->id);
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "widget %p id %i\n", skin->widgets[i], skin->widgets[i]->id);
 }
-#endif
 
 static int counttonextchar(const char *s1, char c)
 {
@@ -245,9 +242,7 @@
         nfree(skin->fonts[i]);
     }
     nfree(skin->fonts);
-#ifdef DEBUG
-    mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN FREE] skin freed\n");
-#endif
+    mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN FREE] skin freed\n");
     nfree(skin);
 }
 
@@ -275,9 +270,7 @@
         (skin->widgetcount)--;
         free(skin->widgets);
         skin->widgets = temp;
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "removed widget %i\n", id);
-#endif
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "removed widget %i\n", id);
         return;
     }
     free(temp);
@@ -305,11 +298,9 @@
         mywidget->wwidth = mywidget->width = atoi(findnextstring(temp, desc, &base));
         mywidget->wheight = mywidget->height = atoi(findnextstring(temp, desc, &base));
         win->base = mywidget;
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [ITEM] [BASE] %s %i %i %i %i\n",
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [ITEM] [BASE] %s %i %i %i %i\n",
               (mywidget->bitmap[0]) ? mywidget->bitmap[0]->name : NULL,
                mywidget->x, mywidget->y, mywidget->width, mywidget->height);
-#endif
     }
     else if(!strncmp(desc, "button", 6))
     {
@@ -334,11 +325,9 @@
             }
         }
 
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [ITEM] [BUTTON] %s %i %i %i %i msg %i\n",
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [ITEM] [BUTTON] %s %i %i %i %i msg %i\n",
               (mywidget->bitmap[0]) ? mywidget->bitmap[0]->name : NULL,
                mywidget->x, mywidget->y, mywidget->width, mywidget->height, mywidget->msg);
-#endif
     }
     else if(!strncmp(desc, "hpotmeter", 9) || !strncmp(desc, "vpotmeter", 9))
     {
@@ -367,8 +356,7 @@
                 break;
             }
         }
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [ITEM] %s %s %i %i %s %i %f %i %i %i %i msg %i\n",
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [ITEM] %s %s %i %i %s %i %f %i %i %i %i msg %i\n",
                 (mywidget->type == tyHpotmeter) ? "[HPOTMETER]" : "[VPOTMETER]",
                 (mywidget->bitmap[0]) ? mywidget->bitmap[0]->name : NULL,
                 mywidget->width, mywidget->height,
@@ -376,7 +364,6 @@
                 mywidget->phases, mywidget->value,
                 mywidget->wx, mywidget->wy, mywidget->wwidth, mywidget->wwidth,
                 mywidget->msg);
-#endif
     }
     else if(!strncmp(desc, "potmeter", 8))
     {
@@ -401,14 +388,12 @@
                 break;
             }
         }
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [ITEM] [POTMETER] %s %i %i %i %f %i %i msg %i\n",
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [ITEM] [POTMETER] %s %i %i %i %f %i %i msg %i\n",
                 (mywidget->bitmap[0]) ? mywidget->bitmap[0]->name : NULL,
                 mywidget->width, mywidget->height,
                 mywidget->phases, mywidget->value,
                 mywidget->x, mywidget->y,
                 mywidget->msg);
-#endif
     }
     else if(!strncmp(desc, "menu", 4))
     {
@@ -430,17 +415,13 @@
                 break;
             }
         }
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [ITEM] [MENU] %i %i %i %i msg %i\n",
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [ITEM] [MENU] %i %i %i %i msg %i\n",
                mywidget->x, mywidget->y, mywidget->width, mywidget->height, mywidget->msg);
-#endif
     }
     else if(!strncmp(desc, "selected", 8))
     {
         win->base->bitmap[1] = pngRead(skin, (char *) desc + 9);
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [ITEM] [BASE] added image %s\n", win->base->bitmap[1]->name);
-#endif
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [ITEM] [BASE] added image %s\n", win->base->bitmap[1]->name);
     }
     else if(!strncmp(desc, "slabel",6))
     {
@@ -460,10 +441,8 @@
             }
         }
         mywidget->label = strdup(findnextstring(temp, desc, &base));
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [ITEM] [SLABEL] %i %i %s %s\n",
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [ITEM] [SLABEL] %i %i %s %s\n",
                mywidget->x, mywidget->y, mywidget->font->name, mywidget->label);
-#endif
     }
     else if(!strncmp(desc, "dlabel", 6))
     {
@@ -485,10 +464,8 @@
             }
         }
         mywidget->label=strdup(findnextstring(temp, desc, &base));
-#ifdef DEBUG
-        mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [ITEM] [DLABEL] %i %i %i %i %s \"%s\"\n",
+        mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [ITEM] [DLABEL] %i %i %i %i %s \"%s\"\n",
                mywidget->x, mywidget->y, mywidget->length, mywidget->align, mywidget->font->name, mywidget->label);
-#endif
     }
     free(temp);
 }
@@ -527,9 +504,7 @@
                 /* remove comments */
                 if((tmp[i] == ';') &&  ((i < 1) || (tmp[i-1] != '\"')))
                 {
-#ifdef DEBUG
-                    mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[FONT LOAD] Comment: %s", tmp + i + 1);
-#endif
+                    mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[FONT LOAD] Comment: %s", tmp + i + 1);
                     break;
                 }
                 desc[pos] = tmp[i];
@@ -540,9 +515,7 @@
             if(!strncmp(desc, "image", 5))
             {
                 skin->fonts[x]->image = pngRead(skin, desc + 6);
-#ifdef DEBUG
-                mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[FONT] [IMAGE] \"%s\"\n", desc + 6);
-#endif
+                mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[FONT] [IMAGE] \"%s\"\n", desc + 6);
             }
             else
             {
@@ -558,14 +531,12 @@
                 skin->fonts[x]->chars[skin->fonts[x]->charcount - 1]->y = atoi(findnextstring(tmp, desc, &base));
                 skin->fonts[x]->chars[skin->fonts[x]->charcount - 1]->width = atoi(findnextstring(tmp, desc, &base));
                 skin->fonts[x]->chars[skin->fonts[x]->charcount - 1]->height = atoi(findnextstring(tmp, desc, &base));
-#ifdef DEBUG
-                mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[FONT] [CHAR] %c %i %i %i %i\n",
+                mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[FONT] [CHAR] %c %i %i %i %i\n",
                         skin->fonts[x]->chars[skin->fonts[x]->charcount - 1]->c,
                         skin->fonts[x]->chars[skin->fonts[x]->charcount - 1]->x,
                         skin->fonts[x]->chars[skin->fonts[x]->charcount - 1]->y,
                         skin->fonts[x]->chars[skin->fonts[x]->charcount - 1]->width,
                         skin->fonts[x]->chars[skin->fonts[x]->charcount - 1]->height);
-#endif
             }
         }
         free(desc);
@@ -624,9 +595,7 @@
             /* remove comments */
             else if(tmp[i] == ';')
             {
-#ifdef DEBUG
-                mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN LOAD] Comment: %s", tmp + i + 1);
-#endif
+                mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN LOAD] Comment: %s", tmp + i + 1);
                 break;
             }
             desc[pos] = tmp[i];
@@ -638,15 +607,11 @@
         /* parse window specific info */
         if(!strncmp(desc, "section", 7))
         {
-#ifdef DEBUG
-            mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [SECTION] \"%s\"\n", desc + 8);
-#endif
+            mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [SECTION] \"%s\"\n", desc + 8);
         }
         else if(!strncmp(desc, "window", 6))
         {
-#ifdef DEBUG
-            mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [WINDOW] \"%s\"\n", desc + 7);
-#endif
+            mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [WINDOW] \"%s\"\n", desc + 7);
             reachedendofwindow = 0;
             (skin->windowcount)++;
             skin->windows = realloc(skin->windows, sizeof(window *) * skin->windowcount);
@@ -665,9 +630,7 @@
         else if(!strncmp(desc, "decoration", 10) && !strncmp(desc + 11, "enable", 6))
         {
             mywindow->decoration = 1;
-#ifdef DEBUG
-            mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [DECORATION] enabled decoration for window \"%s\"\n", mywindow->name);
-#endif
+            mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [DECORATION] enabled decoration for window \"%s\"\n", mywindow->name);
         }
         else if(!strncmp(desc, "background", 10))
         {
@@ -676,27 +639,21 @@
             mywindow->backgroundcolor[0] = atoi(findnextstring(temp, desc, &base));
             mywindow->backgroundcolor[1] = atoi(findnextstring(temp, desc, &base));
             mywindow->backgroundcolor[2] = atoi(findnextstring(temp, desc, &base));
-#ifdef DEBUG
-            mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [BACKGROUND] window \"%s\" has backgroundcolor (%i,%i,%i)\n", mywindow->name,
+            mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [BACKGROUND] window \"%s\" has backgroundcolor (%i,%i,%i)\n", mywindow->name,
                     mywindow->backgroundcolor[0],
                     mywindow->backgroundcolor[1],
                     mywindow->backgroundcolor[2]);
-#endif
         }
         else if(!strncmp(desc, "end", 3))
         {
             if(reachedendofwindow)
             {
-#ifdef DEBUG
-                mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [END] of section\n");
-#endif
+                mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [END] of section\n");
             }
             else
             {
                 reachedendofwindow = 1;
-#ifdef DEBUG
-                mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [END] of window \"%s\"\n", mywindow->name);
-#endif
+                mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [END] of window \"%s\"\n", mywindow->name);
             }
         }
         else if(!strncmp(desc, "font", 4))
@@ -724,9 +681,7 @@
                 skin->fonts[id]->name = strdup(temp);
                 skin->fonts[id]->id = strdup(findnextstring(temp, desc, &base));
             }
-#ifdef DEBUG
-            mp_msg(MSGT_GPLAYER, MSGL_DBG4, "[SKIN] [FONT] id  \"%s\" name \"%s\"\n", skin->fonts[id]->name, skin->fonts[id]->id);
-#endif
+            mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[SKIN] [FONT] id  \"%s\" name \"%s\"\n", skin->fonts[id]->name, skin->fonts[id]->id);
         }
         else
             skin->addwidget(skin, mywindow, desc);
@@ -738,6 +693,6 @@
     fclose(fp);
     loadfonts(skin);
     mp_msg(MSGT_GPLAYER, MSGL_V, "[SKIN LOAD] loaded skin \"%s\"\n", skin->skindir);
-    /* dumpwidgets(skin); */
+    dumpwidgets(skin);
     return skin;
 }
diff -Naur mplayer-1.0_rc4_p20120109/gui/win32/skinload.h mplayer-1.0_rc4_p20120109-new/gui/win32/skinload.h
--- mplayer-1.0_rc4_p20120109/gui/win32/skinload.h	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/win32/skinload.h	2012-01-16 15:51:41.000000000 +0100
@@ -175,6 +175,7 @@
 #define evAbout             12
 #define evPreferences       14
 #define evSkinBrowser       15
+#define evMenu              33
 
 #define evIconify           11
 #define evExit              1000
@@ -195,5 +196,6 @@
 #define ivSetCDTrack      5014
 
 #define ivRedraw          7002
+#define ivPlayDVD         7003
 
 #endif /* MPLAYER_GUI_SKINLOAD_H */
diff -Naur mplayer-1.0_rc4_p20120109/gui/win32/widgetrender.c mplayer-1.0_rc4_p20120109-new/gui/win32/widgetrender.c
--- mplayer-1.0_rc4_p20120109/gui/win32/widgetrender.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/win32/widgetrender.c	2012-01-16 15:51:41.000000000 +0100
@@ -163,10 +163,8 @@
 
     if(guiInfo.StreamType == 0)
         stringreplace(text, "$T", "f");
-#ifdef CONFIG_DVDREAD
     else if(guiInfo.StreamType == STREAMTYPE_DVD || guiInfo.StreamType == STREAMTYPE_DVDNAV)
         stringreplace(text, "$T", "d");
-#endif
     else stringreplace(text, "$T", "u");
 
     stringreplace(text, "$f", acp(TranslateFilename(1, tmp, sizeof(tmp))));
diff -Naur mplayer-1.0_rc4_p20120109/gui/wm/ws.c mplayer-1.0_rc4_p20120109-new/gui/wm/ws.c
--- mplayer-1.0_rc4_p20120109/gui/wm/ws.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/wm/ws.c	2012-01-16 15:51:41.000000000 +0100
@@ -54,16 +54,14 @@
 #include <X11/extensions/shape.h>
 #endif
 
-#ifdef CONFIG_XINERAMA
-#include <X11/extensions/Xinerama.h>
-#endif
-
 #ifdef CONFIG_XF86VM
 #include <X11/extensions/xf86vmode.h>
 #endif
 
 #include <sys/ipc.h>
+#ifdef HAVE_SHM
 #include <sys/shm.h>
+#endif
 
 #define MOUSEHIDE_DELAY 1000   // in milliseconds
 
@@ -270,21 +268,21 @@
             mp_msg(MSGT_GPLAYER, MSGL_INFO, MSGTR_WS_RemoteDisplay);
     }
 
-    if (!XShmQueryExtension(wsDisplay)) {
+#ifdef HAVE_SHM
+    if (!XShmQueryExtension(wsDisplay))
+#endif
+    wsUseXShm = 0;
+
+    if (!wsUseXShm)
         mp_msg(MSGT_GPLAYER, MSGL_INFO, MSGTR_WS_NoXshm);
-        wsUseXShm = 0;
-    }
 
 #ifdef CONFIG_XSHAPE
+    if (!XShapeQueryExtension(wsDisplay, &eventbase, &errorbase))
+#endif
+    wsUseXShape = 0;
 
-    if (!XShapeQueryExtension(wsDisplay, &eventbase, &errorbase)) {
+    if (!wsUseXShape)
         mp_msg(MSGT_GPLAYER, MSGL_WARN, MSGTR_WS_NoXshape);
-        wsUseXShape = 0;
-    }
-
-#else
-    wsUseXShape = 0;
-#endif
 
     XSynchronize(wsDisplay, True);
 
@@ -325,13 +323,14 @@
     mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[ws]  green mask: 0x%x\n", wsGreenMask);
     mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[ws]  blue mask: 0x%x\n", wsBlueMask);
 
-#ifdef MP_DEBUG
+#ifdef HAVE_SHM
     if (wsUseXShm) {
         int minor, major, shp;
 
         XShmQueryVersion(wsDisplay, &major, &minor, &shp);
         mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[ws] XShm version is %d.%d\n", major, minor);
     }
+#endif
 
 #ifdef CONFIG_XSHAPE
     if (wsUseXShape) {
@@ -341,7 +340,6 @@
         mp_msg(MSGT_GPLAYER, MSGL_DBG2, "[ws] XShape version is %d.%d\n", major, minor);
     }
 #endif
-#endif
 
     wsOutMask = wsGetOutMask();
 
@@ -690,7 +688,7 @@
             }
         } else {
             /* try to process DND events */
-            wsXDNDProcessClientMessage(wsWindowList[l], &Event->xclient);
+            wsXDNDProcessClientMessage(&Event->xclient);
         }
 
         break;
@@ -1079,12 +1077,15 @@
 
 void wsPutImage(wsTWindow *win)
 {
+#ifdef HAVE_SHM
     if (wsUseXShm) {
         XShmPutImage(wsDisplay, win->WindowID, win->wGC, win->xImage,
                      0, 0,
                      (win->Width - win->xImage->width) / 2, (win->Height - win->xImage->height) / 2,
                      win->xImage->width, win->xImage->height, 0);
-    } else {
+    } else
+#endif
+    {
         XPutImage(wsDisplay, win->WindowID, win->wGC, win->xImage,
                   0, 0,
                   (win->Width - win->xImage->width) / 2, (win->Height - win->xImage->height) / 2,
@@ -1408,10 +1409,12 @@
     if (win->xImage) {
         XDestroyImage(win->xImage);
 
+#ifdef HAVE_SHM
         if (wsUseXShm) {
             XShmDetach(wsDisplay, &win->Shminfo);
             shmdt(win->Shminfo.shmaddr);
         }
+#endif
     }
 
     win->xImage = NULL;
@@ -1419,6 +1422,7 @@
 
 void wsCreateImage(wsTWindow *win, int Width, int Height)
 {
+#ifdef HAVE_SHM
     if (wsUseXShm) {
         win->xImage = XShmCreateImage(wsDisplay, win->VisualInfo.visual,
                                       win->VisualInfo.depth, ZPixmap, NULL, &win->Shminfo, Width, Height);
@@ -1453,7 +1457,9 @@
         XShmAttach(wsDisplay, &win->Shminfo);
         XSync(wsDisplay, False);
         shmctl(win->Shminfo.shmid, IPC_RMID, 0);
-    } else {
+    } else
+#endif
+    {
         win->xImage = XCreateImage(wsDisplay, win->VisualInfo.visual, win->VisualInfo.depth,
                                    ZPixmap, 0, 0, Width, Height,
                                    (wsDepthOnScreen == 3) ? 32 : wsDepthOnScreen,
@@ -1518,7 +1524,6 @@
 void wsSetShape(wsTWindow *win, char *data)
 {
 #ifdef CONFIG_XSHAPE
-
     if (!wsUseXShape)
         return;
 
@@ -1528,7 +1533,6 @@
         XFreePixmap(wsDisplay, win->Mask);
     } else
         XShapeCombineMask(wsDisplay, win->WindowID, ShapeBounding, 0, 0, None, ShapeSet);
-
 #endif
 }
 
diff -Naur mplayer-1.0_rc4_p20120109/gui/wm/ws.h mplayer-1.0_rc4_p20120109-new/gui/wm/ws.h
--- mplayer-1.0_rc4_p20120109/gui/wm/ws.h	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/wm/ws.h	2012-01-16 15:51:41.000000000 +0100
@@ -28,7 +28,9 @@
 #include <X11/Xutil.h>
 #include <X11/keysym.h>
 #include <X11/Xatom.h>
+#ifdef HAVE_SHM
 #include <X11/extensions/XShm.h>
+#endif
 
 #define  wsKeyReleased   0
 #define  wsKeyPressed    1
@@ -158,7 +160,9 @@
     Atom AtomWMSizeHint;
     Atom AtomWMNormalHint;
 
+#ifdef HAVE_SHM
     XShmSegmentInfo Shminfo;
+#endif
     unsigned char *ImageData;
     unsigned short int *ImageDataw;
     unsigned int *ImageDatadw;
diff -Naur mplayer-1.0_rc4_p20120109/gui/wm/wsxdnd.c mplayer-1.0_rc4_p20120109-new/gui/wm/wsxdnd.c
--- mplayer-1.0_rc4_p20120109/gui/wm/wsxdnd.c	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/wm/wsxdnd.c	2012-01-16 15:51:41.000000000 +0100
@@ -150,7 +150,7 @@
 }
 
 Bool
-wsXDNDProcessClientMessage(wsTWindow* wnd, XClientMessageEvent *event)
+wsXDNDProcessClientMessage(XClientMessageEvent *event)
 {
   /* test */
   /*{
diff -Naur mplayer-1.0_rc4_p20120109/gui/wm/wsxdnd.h mplayer-1.0_rc4_p20120109-new/gui/wm/wsxdnd.h
--- mplayer-1.0_rc4_p20120109/gui/wm/wsxdnd.h	2012-01-09 14:46:52.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/gui/wm/wsxdnd.h	2012-01-16 15:51:41.000000000 +0100
@@ -23,7 +23,7 @@
 
 void wsXDNDInitialize(void);
 Bool wsXDNDProcessSelection(wsTWindow* wnd,XEvent *event);
-Bool wsXDNDProcessClientMessage(wsTWindow* wnd, XClientMessageEvent *event);
+Bool wsXDNDProcessClientMessage(XClientMessageEvent *event);
 void wsXDNDMakeAwareness(wsTWindow* window);
 void wsXDNDClearAwareness(wsTWindow* window);
 
diff -Naur mplayer-1.0_rc4_p20120109/help/help_mp-de.h mplayer-1.0_rc4_p20120109-new/help/help_mp-de.h
--- mplayer-1.0_rc4_p20120109/help/help_mp-de.h	2012-01-09 14:47:08.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/help/help_mp-de.h	2012-01-16 15:51:41.000000000 +0100
@@ -756,7 +756,7 @@
 #define MSGTR_NEMFMR "Sorry, nicht genug Speicher fÃ¼r MenÃ¼-Rendering."
 #define MSGTR_IDFGCVD "Sorry, es wurde kein GUI-kompatibler Ausgabetreiber gefunden.\n"
 #define MSGTR_NEEDLAVC "Sorry, du versuchst, Nicht-MPEG Dateien ohne erneute Encodierung abzuspielen.\nBitte aktiviere lavc in der DXR3/H+-Konfigurationsbox."
-#define MSGTR_ICONERROR "Icon '%s' wurde nicht gefunden oder das Format wird nicht unterstÃ¼tzt.\n"
+#define MSGTR_ICONERROR "Icon '%s' (GrÃ¶ÃŸe %d) wurde nicht gefunden oder das Format wird nicht unterstÃ¼tzt.\n"
 
 // --- skin loader error messages
 #define MSGTR_SKIN_ERRORMESSAGE "Fehler in Skin-Konfigurationsdatei in Zeile %d: %s"
diff -Naur mplayer-1.0_rc4_p20120109/help/help_mp-en.h mplayer-1.0_rc4_p20120109-new/help/help_mp-en.h
--- mplayer-1.0_rc4_p20120109/help/help_mp-en.h	2012-01-09 14:47:08.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/help/help_mp-en.h	2012-01-16 15:51:41.000000000 +0100
@@ -1,4 +1,4 @@
-// $Revision: 34475 $
+// $Revision: 34569 $
 // MASTER FILE. Use this file as base for translations.
 // Translated files should be sent to the mplayer-DOCS mailing list or
 // to the help messages maintainer, see DOCS/tech/MAINTAINERS.
@@ -562,7 +562,7 @@
 #define MSGTR_NEMFMR "Sorry, not enough memory for menu rendering."
 #define MSGTR_IDFGCVD "Sorry, no GUI-compatible video output driver found.\n"
 #define MSGTR_NEEDLAVC "Sorry, you cannot play non-MPEG files with your DXR3/H+ device without reencoding.\nPlease enable lavc in the DXR3/H+ configuration box."
-#define MSGTR_ICONERROR "Icon '%s' not found or unsupported format.\n"
+#define MSGTR_ICONERROR "Icon '%s' (size %d) not found or unsupported format.\n"
 
 // --- skin loader error messages
 #define MSGTR_SKIN_ERRORMESSAGE "Error in skin config file on line %d: %s"
@@ -713,6 +713,7 @@
 #define MSGTR_PREFERENCES_IDX "Rebuild index table, if needed"
 #define MSGTR_PREFERENCES_VideoCodecFamily "Video codec family:"
 #define MSGTR_PREFERENCES_AudioCodecFamily "Audio codec family:"
+#define MSGTR_PREFERENCES_VideoHardwareAcceleration "Video hardware acceleration:"
 #define MSGTR_PREFERENCES_FRAME_OSD_Level "OSD level"
 #define MSGTR_PREFERENCES_FRAME_Subtitle "Subtitle"
 #define MSGTR_PREFERENCES_FRAME_Font "Font"
@@ -1617,6 +1618,7 @@
 #define MSGTR_MPCODECS_UnexpectedInitVoError "[VD_FFMPEG] Unexpected init_vo error.\n"
 #define MSGTR_MPCODECS_UnrecoverableErrorRenderBuffersNotTaken "[VD_FFMPEG] Unrecoverable error, render buffers not taken.\n"
 #define MSGTR_MPCODECS_OnlyBuffersAllocatedByVoXvmcAllowed "[VD_FFMPEG] Only buffers allocated by vo_xvmc allowed.\n"
+#define MSGTR_MPCODECS_VAAPIAcceleratedCodec "[VD_FFMPEG] VA API accelerated codec.\n"
 
 // libmpcodecs/ve_lavc.c
 #define MSGTR_MPCODECS_HighQualityEncodingSelected "[VE_LAVC] High quality encoding selected (non-realtime)!\n"
diff -Naur mplayer-1.0_rc4_p20120109/help/help_mp-zh_CN.h mplayer-1.0_rc4_p20120109-new/help/help_mp-zh_CN.h
--- mplayer-1.0_rc4_p20120109/help/help_mp-zh_CN.h	2012-01-09 14:47:08.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/help/help_mp-zh_CN.h	2012-01-16 15:51:41.000000000 +0100
@@ -562,7 +562,6 @@
 #define MSGTR_NEMFMR "æŠ±æ­‰ï¼Œæ²¡æœ‰è¶³å¤Ÿçš„å†…å­˜ç”¨äºèœå•æ¸²æŸ“ã€‚"
 #define MSGTR_IDFGCVD "æŠ±æ­‰ï¼Œæœªæ‰¾åˆ°ä¸ GUI å…¼å®¹çš„è§†é¢‘è¾“å‡ºé©±åŠ¨ã€‚\n"
 #define MSGTR_NEEDLAVC "æŠ±æ­‰ï¼Œæœªé‡æ–°ç¼–ç å‰æ— æ³•ç”¨ä½ çš„ DXR3/H+ è®¾å¤‡æ’­æ”¾é MPEG æ–‡ä»¶ã€‚\nè¯·å¯ç”¨ DXR3/H+ é…ç½®ç›’ä¸­çš„ lavc ç¼–è§£ç å™¨ã€‚"
-#define MSGTR_ICONERROR "å›¾æ ‡â€˜%sâ€™æœªæ‰¾åˆ°æˆ–æ ¼å¼ä¸æ”¯æŒã€‚\n"
 
 // --- skin loader error messages
 #define MSGTR_SKIN_ERRORMESSAGE "ç•Œé¢å¤–è§‚é…ç½®æ–‡ä»¶é”™è¯¯ï¼Œè¡Œ %dï¼š%s"
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/dec_video.c mplayer-1.0_rc4_p20120109-new/libmpcodecs/dec_video.c
--- mplayer-1.0_rc4_p20120109/libmpcodecs/dec_video.c	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/dec_video.c	2012-01-16 15:51:41.000000000 +0100
@@ -53,9 +53,47 @@
 int field_dominance = -1;
 
 int divx_quality = 0;
+char *video_hwaccel_name=NULL;
 
 const vd_functions_t *mpvdec = NULL;
 
+int get_video_hwaccel(void)
+{
+    static int video_hwaccel = -1;
+    if (video_hwaccel < 0) {
+        video_hwaccel = HWACCEL_NONE;
+        if (video_hwaccel_name) {
+            if (!strcmp(video_hwaccel_name,"xvmc"))
+                video_hwaccel = HWACCEL_XVMC;
+            else if (!strcmp(video_hwaccel_name,"vaapi"))
+                video_hwaccel = HWACCEL_VAAPI;
+            else if (!strcmp(video_hwaccel_name,"vdpau"))
+                video_hwaccel = HWACCEL_VDPAU;
+        }
+    }
+    return video_hwaccel;
+}
+
+const char *get_video_hwaccel_name(int hwaccel)
+{
+    switch (hwaccel) {
+    case HWACCEL_XVMC:  return "XvMC";
+    case HWACCEL_VAAPI: return "VA API";
+    case HWACCEL_VDPAU: return "VDPAU";
+    }
+    return NULL;
+}
+
+const char *get_video_hwaccel_short_name(int hwaccel)
+{
+    switch (hwaccel) {
+    case HWACCEL_XVMC:  return "xvmc";
+    case HWACCEL_VAAPI: return "vaapi";
+    case HWACCEL_VDPAU: return "vdpau";
+    }
+    return NULL;
+}
+
 int get_video_quality_max(sh_video_t *sh_video)
 {
     vf_instance_t *vf = sh_video->vfilter;
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/dec_video.h mplayer-1.0_rc4_p20120109-new/libmpcodecs/dec_video.h
--- mplayer-1.0_rc4_p20120109/libmpcodecs/dec_video.h	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/dec_video.h	2012-01-16 15:51:41.000000000 +0100
@@ -21,6 +21,14 @@
 
 #include "libmpdemux/stheader.h"
 
+enum {
+  HWACCEL_NONE = 0,
+  HWACCEL_XVMC,
+  HWACCEL_VAAPI,
+  HWACCEL_VDPAU,
+  HWACCEL_COUNT
+};
+
 extern int field_dominance;
 
 // dec_video.c:
@@ -41,6 +49,11 @@
 void resync_video_stream(sh_video_t *sh_video);
 int get_current_video_decoder_lag(sh_video_t *sh_video);
 
+int get_video_hwaccel(void);
+const char *get_video_hwaccel_name(int hwaccel);
+const char *get_video_hwaccel_short_name(int hwaccel);
+
 extern int divx_quality;
+extern char *video_hwaccel_name;
 
 #endif /* MPLAYER_DEC_VIDEO_H */
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/img_format.c mplayer-1.0_rc4_p20120109-new/libmpcodecs/img_format.c
--- mplayer-1.0_rc4_p20120109/libmpcodecs/img_format.c	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/img_format.c	2012-01-16 15:51:41.000000000 +0100
@@ -116,6 +116,14 @@
     case IMGFMT_VDPAU_MPEG4:     return "MPEG-4 Part 2 VDPAU acceleration";
     case IMGFMT_VDPAU_WMV3:      return "WMV3 VDPAU acceleration";
     case IMGFMT_VDPAU_VC1:       return "VC1 VDPAU acceleration";
+    case IMGFMT_VAAPI_MPEG2:     return "MPEG-2 VA-API Acceleration";
+    case IMGFMT_VAAPI_MPEG2_IDCT: return "MPEG-2 VA-API Acceleration (Motion Compensation and IDCT)";
+    case IMGFMT_VAAPI_MPEG2_MOCO: return "MPEG-2 VA-API Acceleration (Motion Compensation)";
+    case IMGFMT_VAAPI_MPEG4:     return "MPEG-4 VA-API Acceleration";
+    case IMGFMT_VAAPI_H263:      return "H.263 VA-API Acceleration";
+    case IMGFMT_VAAPI_H264:      return "H.264 VA-API Acceleration";
+    case IMGFMT_VAAPI_WMV3:      return "WMV3 VA-API Acceleration";
+    case IMGFMT_VAAPI_VC1:       return "VC-1 VA-API Acceleration";
     }
     snprintf(unknown_format,20,"Unknown 0x%04x",format);
     return unknown_format;
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/img_format.h mplayer-1.0_rc4_p20120109-new/libmpcodecs/img_format.h
--- mplayer-1.0_rc4_p20120109/libmpcodecs/img_format.h	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/img_format.h	2012-01-16 15:51:41.000000000 +0100
@@ -209,6 +209,26 @@
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
 
+/* VA-API Formats */
+
+#define IMGFMT_VAAPI               0x56410000 /* 'VA'00 */
+#define IMGFMT_VAAPI_MASK          0xFFFF0000
+#define IMGFMT_IS_VAAPI(fmt)       (((fmt) & IMGFMT_VAAPI_MASK) == IMGFMT_VAAPI)
+#define IMGFMT_VAAPI_CODEC_MASK    0x000000F0
+#define IMGFMT_VAAPI_CODEC(fmt)    ((fmt) & IMGFMT_VAAPI_CODEC_MASK)
+#define IMGFMT_VAAPI_CODEC_MPEG2   (0x10)
+#define IMGFMT_VAAPI_CODEC_MPEG4   (0x20)
+#define IMGFMT_VAAPI_CODEC_H264    (0x30)
+#define IMGFMT_VAAPI_CODEC_VC1     (0x40)
+#define IMGFMT_VAAPI_MPEG2         (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG2)
+#define IMGFMT_VAAPI_MPEG2_IDCT    (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG2|1)
+#define IMGFMT_VAAPI_MPEG2_MOCO    (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG2|2)
+#define IMGFMT_VAAPI_MPEG4         (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG4)
+#define IMGFMT_VAAPI_H263          (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG4|1)
+#define IMGFMT_VAAPI_H264          (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_H264)
+#define IMGFMT_VAAPI_VC1           (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_VC1)
+#define IMGFMT_VAAPI_WMV3          (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_VC1|1)
+
 // VDPAU specific format.
 #define IMGFMT_VDPAU               0x1DC80000
 #define IMGFMT_VDPAU_MASK          0xFFFF0000
@@ -220,7 +240,9 @@
 #define IMGFMT_VDPAU_VC1           (IMGFMT_VDPAU|0x05)
 #define IMGFMT_VDPAU_MPEG4         (IMGFMT_VDPAU|0x06)
 
-#define IMGFMT_IS_HWACCEL(fmt) (IMGFMT_IS_VDPAU(fmt) || IMGFMT_IS_XVMC(fmt))
+#define IMGFMT_IS_HWACCEL(fmt)     (IMGFMT_IS_VAAPI(fmt) || \
+                                    IMGFMT_IS_VDPAU(fmt) || \
+                                    IMGFMT_IS_XVMC(fmt))
 
 typedef struct {
     void* data;
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/vd.c mplayer-1.0_rc4_p20120109-new/libmpcodecs/vd.c
--- mplayer-1.0_rc4_p20120109/libmpcodecs/vd.c	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/vd.c	2012-01-16 15:51:41.000000000 +0100
@@ -403,3 +403,12 @@
     if (vf->draw_slice)
         vf->draw_slice(vf, src, stride, w, h, x, y);
 }
+
+void *mpcodecs_get_hwaccel_context(sh_video_t *sh)
+{
+    void *ctx = NULL;
+    struct vf_instance *vf = sh->vfilter;
+    if (vf->control(vf, VFCTRL_GET_HWACCEL_CONTEXT, &ctx) == CONTROL_TRUE)
+        return ctx;
+    return NULL;
+}
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/vd_ffmpeg.c mplayer-1.0_rc4_p20120109-new/libmpcodecs/vd_ffmpeg.c
--- mplayer-1.0_rc4_p20120109/libmpcodecs/vd_ffmpeg.c	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/vd_ffmpeg.c	2012-01-16 15:51:41.000000000 +0100
@@ -33,6 +33,7 @@
 #include "fmt-conversion.h"
 
 #include "vd_internal.h"
+#include "dec_video.h"
 
 static const vd_info_t info = {
     "FFmpeg's libavcodec codec family",
@@ -192,7 +193,7 @@
     int imgfmt;
     if (fmt == PIX_FMT_NONE)
         return;
-    imgfmt = pixfmt2imgfmt(fmt);
+    imgfmt = pixfmt2imgfmt(fmt, avctx->codec_id);
     if (IMGFMT_IS_HWACCEL(imgfmt)) {
         sh_video_t *sh     = avctx->opaque;
         vd_ffmpeg_ctx *ctx = sh->context;
@@ -433,7 +434,7 @@
                         const AVFrame *src, int offset[4],
                         int y, int type, int height){
     sh_video_t *sh = s->opaque;
-    uint8_t *source[MP_MAX_PLANES]= {src->data[0] + offset[0], src->data[1] + offset[1], src->data[2] + offset[2]};
+    uint8_t *source[MP_MAX_PLANES]= {src->data[0] + offset[0], src->data[1] + offset[1], src->data[2] + offset[2], src->data[3] + offset[3]};
     int strides[MP_MAX_PLANES] = {src->linesize[0], src->linesize[1], src->linesize[2]};
 #if 0
     int start=0, i;
@@ -517,9 +518,10 @@
         sh->disp_w = width;
         sh->disp_h = height;
         ctx->pix_fmt = pix_fmt;
-        ctx->best_csp = pixfmt2imgfmt(pix_fmt);
+        ctx->best_csp = pixfmt2imgfmt(pix_fmt, avctx->codec_id);
         if (!mpcodecs_config_vo(sh, sh->disp_w, sh->disp_h, ctx->best_csp))
             return -1;
+        avctx->hwaccel_context = mpcodecs_get_hwaccel_context(sh);
         ctx->vo_initialized = 1;
     }
     return 0;
@@ -953,22 +955,60 @@
     return mpi;
 }
 
+static inline int is_hwaccel_format(int imgfmt)
+{
+    switch (get_video_hwaccel()) {
+    case HWACCEL_VAAPI: return IMGFMT_IS_VAAPI(imgfmt) != 0;
+    case HWACCEL_VDPAU: return IMGFMT_IS_VDPAU(imgfmt) != 0;
+    case HWACCEL_XVMC:  return IMGFMT_IS_XVMC(imgfmt)  != 0;
+    }
+    return 0;
+}
+
+static int query_format(sh_video_t *sh, int fmt)
+{
+    vd_ffmpeg_ctx * const ctx = sh->context;
+    AVCodecContext * const avctx = ctx->avctx;
+    int r, width, height;
+    /* XXX: some codecs have not initialized width and height yet at
+       this point, so we are faking the dimensions so that init_vo()
+       doesn't fail because of 0x0 size */
+    if ((width = avctx->width) == 0)
+        avctx->width = 64;
+    if ((height = avctx->height) == 0)
+        avctx->height = 64;
+    r = init_vo(sh, fmt);
+    avctx->width = width;
+    avctx->height = height;
+    return r;
+}
+
 static enum PixelFormat get_format(struct AVCodecContext *avctx,
-                                    const enum PixelFormat *fmt){
-    enum PixelFormat selected_format;
+                                   const enum PixelFormat *fmt){
+    enum PixelFormat selected_format = PIX_FMT_NONE;
     int imgfmt;
     sh_video_t *sh = avctx->opaque;
-    int i;
+    int i, try_hwaccel;
 
-    for(i=0;fmt[i]!=PIX_FMT_NONE;i++){
-        imgfmt = pixfmt2imgfmt(fmt[i]);
-        if(!IMGFMT_IS_HWACCEL(imgfmt)) continue;
-        mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_TryingPixfmt, i);
-        if(init_vo(sh, fmt[i]) >= 0) {
-            break;
+    for (try_hwaccel = 1; try_hwaccel >= 0; --try_hwaccel) {
+        for (i = 0; fmt[i] != PIX_FMT_NONE; i++) {
+            imgfmt = pixfmt2imgfmt(fmt[i], avctx->codec_id);
+            if ((try_hwaccel ^ is_hwaccel_format(imgfmt)) != 0)
+                continue;
+            mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_TryingPixfmt, i);
+            if (query_format(sh, fmt[i]) >= 0) {
+                if (try_hwaccel) {
+                    /* don't allow format conversion for HW acceleration */
+                    if (sh->codec->outfmt[sh->outfmtidx] != imgfmt)
+                        continue;
+                }
+                selected_format = fmt[i];
+                break;
+            }
         }
+        if (selected_format != PIX_FMT_NONE)
+            break;
     }
-    selected_format = fmt[i];
     if (selected_format == PIX_FMT_NONE)
         selected_format = avcodec_default_get_format(avctx, fmt);
     set_format_params(avctx, selected_format);
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/vd.h mplayer-1.0_rc4_p20120109-new/libmpcodecs/vd.h
--- mplayer-1.0_rc4_p20120109/libmpcodecs/vd.h	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/vd.h	2012-01-16 15:51:41.000000000 +0100
@@ -64,6 +64,7 @@
 int mpcodecs_config_vo(sh_video_t *sh, int w, int h, unsigned int preferred_outfmt);
 mp_image_t* mpcodecs_get_image(sh_video_t *sh, int mp_imgtype, int mp_imgflag, int w, int h);
 void mpcodecs_draw_slice(sh_video_t *sh, unsigned char** src, int* stride, int w,int h, int x, int y);
+void *mpcodecs_get_hwaccel_context(sh_video_t *sh);
 
 #define VDFLAGS_DROPFRAME 3
 
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/vf.h mplayer-1.0_rc4_p20120109-new/libmpcodecs/vf.h
--- mplayer-1.0_rc4_p20120109/libmpcodecs/vf.h	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/vf.h	2012-01-16 15:51:41.000000000 +0100
@@ -111,6 +111,7 @@
 #define VFCTRL_GET_PTS         17 /* Return last pts value that reached vf_vo*/
 #define VFCTRL_SET_DEINTERLACE 18 /* Set deinterlacing status */
 #define VFCTRL_GET_DEINTERLACE 19 /* Get deinterlacing status */
+#define VFCTRL_GET_HWACCEL_CONTEXT 20 /* Get HW accelerator context */
 
 #include "vfcap.h"
 
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/vf_lavc.c mplayer-1.0_rc4_p20120109-new/libmpcodecs/vf_lavc.c
--- mplayer-1.0_rc4_p20120109/libmpcodecs/vf_lavc.c	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/vf_lavc.c	2012-01-16 15:51:41.000000000 +0100
@@ -115,7 +115,7 @@
 
     dmpi->planes[0]=(unsigned char*)&vf->priv->pes;
 
-    return vf_next_put_image(vf,dmpi, MP_NOPTS_VALUE);
+    return vf_next_put_image(vf,dmpi, pts);
 }
 
 //===========================================================================//
diff -Naur mplayer-1.0_rc4_p20120109/libmpcodecs/vf_vo.c mplayer-1.0_rc4_p20120109-new/libmpcodecs/vf_vo.c
--- mplayer-1.0_rc4_p20120109/libmpcodecs/vf_vo.c	2012-01-09 14:46:46.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libmpcodecs/vf_vo.c	2012-01-16 15:51:41.000000000 +0100
@@ -136,6 +136,12 @@
 	*(double *)data = vf->priv->pts;
 	return CONTROL_TRUE;
     }
+    case VFCTRL_GET_HWACCEL_CONTEXT:
+    {
+        if(!video_out) return CONTROL_FALSE; // vo not configured?
+        return(video_out->control(VOCTRL_GET_HWACCEL_CONTEXT, data)
+               == VO_TRUE) ? CONTROL_TRUE : CONTROL_FALSE;
+    }
     }
     // return video_out->control(request,data);
     return CONTROL_UNKNOWN;
diff -Naur mplayer-1.0_rc4_p20120109/libvo/gl_common.c mplayer-1.0_rc4_p20120109-new/libvo/gl_common.c
--- mplayer-1.0_rc4_p20120109/libvo/gl_common.c	2012-01-09 14:46:56.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libvo/gl_common.c	2012-01-16 15:51:41.000000000 +0100
@@ -139,7 +139,6 @@
 void (GLAPIENTRY *mpglFreeMemoryMESA)(void *, int, void *);
 /** \} */ // end of glextfunctions group
 
-
 void (GLAPIENTRY *mpglVertexPointer)(GLint, GLenum, GLsizei, const GLvoid *);
 void (GLAPIENTRY *mpglTexCoordPointer)(GLint, GLenum, GLsizei, const GLvoid *);
 void (GLAPIENTRY *mpglClientActiveTexture)(GLenum);
@@ -147,6 +146,12 @@
 void (GLAPIENTRY *mpglDisableClientState)(GLenum);
 void (GLAPIENTRY *mpglDrawArrays)(GLenum, GLint, GLsizei);
 
+
+void (GLAPIENTRY *mpglXBindTexImage)(Display *, GLXDrawable, int, const int *);
+void (GLAPIENTRY *mpglXReleaseTexImage)(Display *, GLXDrawable, int);
+GLXPixmap (GLAPIENTRY *mpglXCreatePixmap)(Display *, GLXFBConfig, Pixmap, const int *);
+void (GLAPIENTRY *mpglXDestroyPixmap)(Display *, GLXPixmap);
+
 //! \defgroup glgeneral OpenGL general helper functions
 
 //! \defgroup glcontext OpenGL context management helper functions
@@ -486,6 +491,12 @@
   {&mpglEnableClientState, NULL, {"glEnableClientState", NULL}},
   {&mpglDisableClientState, NULL, {"glDisableClientState", NULL}},
   {&mpglDrawArrays, NULL, {"glDrawArrays", NULL}},
+
+  {&mpglXBindTexImage, "GLX_EXT_texture_from_pixmap", {"glXBindTexImageEXT", NULL}},
+  {&mpglXReleaseTexImage, "GLX_EXT_texture_from_pixmap", {"glXReleaseTexImageEXT", NULL}},
+  {&mpglXCreatePixmap, "GLX_EXT_texture_from_pixmap", {"glXCreatePixmap", NULL}},
+  {&mpglXDestroyPixmap, "GLX_EXT_texture_from_pixmap", {"glXDestroyPixmap", NULL}},
+
   {NULL}
 };
 
@@ -1034,7 +1045,9 @@
   "TEX b.g, coord2.zwzw, texture[%c], %s;\n"
   "DP3 b, b, {0.25, 0.25, 0.25};\n"
   "SUB b.r, a.r, b.r;\n"
-  "MAD yuv.%c, b.r, {%e}, a.r;\n";
+  // NOTE: destination component is only write mask, not swizzle
+  // so calculate result in all three components
+  "MAD yuv.%c, b.rrrr, {%e, %e, %e}, a.rrrr;\n";
 
 static const char unsharp_filt_template2[] =
   "PARAM dcoord%c = {%e, %e, %e, %e};\n"
@@ -1058,7 +1071,9 @@
   "TEX b.g, coord2.zwzw, texture[%c], %s;\n"
   "DP4 b.r, b, {-0.1171875, -0.1171875, -0.1171875, -0.09765625};\n"
   "MAD b.r, a.r, {0.859375}, b.r;\n"
-  "MAD yuv.%c, b.r, {%e}, a.r;\n";
+  // NOTE: destination component is only write mask, not swizzle
+  // so calculate result in all three components
+  "MAD yuv.%c, b.rrrr, {%e, %e, %e}, a.rrrr;\n";
 
 static const char yuv_prog_template[] =
   "PARAM ycoef = {%e, %e, %e};\n"
@@ -1258,7 +1273,7 @@
                out_comp, 0.5 * ptw, 0.5 * pth, 0.5 * ptw, -0.5 * pth,
                in_tex, out_comp, in_tex, out_comp, in_tex,
                in_tex, ttype, in_tex, ttype, in_tex, ttype, in_tex, ttype,
-               in_tex, ttype, out_comp, strength);
+               in_tex, ttype, out_comp, strength, strength, strength);
       break;
     case YUV_SCALER_UNSHARP2:
       snprintf(*prog_pos, *remain, unsharp_filt_template2,
@@ -1268,7 +1283,7 @@
                in_tex, ttype, in_tex, ttype, in_tex, ttype, in_tex, ttype,
                in_tex, ttype, in_tex, out_comp, in_tex, out_comp,
                in_tex, ttype, in_tex, ttype, in_tex, ttype,
-               in_tex, ttype, out_comp, strength);
+               in_tex, ttype, out_comp, strength, strength, strength);
       break;
   }
   *remain -= strlen(*prog_pos);
diff -Naur mplayer-1.0_rc4_p20120109/libvo/gl_common.h mplayer-1.0_rc4_p20120109-new/libvo/gl_common.h
--- mplayer-1.0_rc4_p20120109/libvo/gl_common.h	2012-01-09 14:46:56.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libvo/gl_common.h	2012-01-16 15:51:41.000000000 +0100
@@ -532,4 +532,9 @@
 extern void* (GLAPIENTRY *mpglAllocateMemoryMESA)(void *, int, size_t, float, float, float);
 extern void (GLAPIENTRY *mpglFreeMemoryMESA)(void *, int, void *);
 
+extern void (GLAPIENTRY *mpglXBindTexImage)(Display *, GLXDrawable, int, const int *);
+extern void (GLAPIENTRY *mpglXReleaseTexImage)(Display *, GLXDrawable, int);
+extern GLXPixmap (GLAPIENTRY *mpglXCreatePixmap)(Display *, GLXFBConfig, Pixmap, const int *);
+extern void (GLAPIENTRY *mpglXDestroyPixmap)(Display *, GLXPixmap);
+
 #endif /* MPLAYER_GL_COMMON_H */
diff -Naur mplayer-1.0_rc4_p20120109/libvo/sdl_common.c mplayer-1.0_rc4_p20120109-new/libvo/sdl_common.c
--- mplayer-1.0_rc4_p20120109/libvo/sdl_common.c	2012-01-09 14:46:56.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libvo/sdl_common.c	2012-01-16 15:51:41.000000000 +0100
@@ -31,6 +31,26 @@
 static int mode_flags;
 static int reinit;
 
+/**
+ * Update vo_screenwidth and vo_screenheight.
+ *
+ * This function only works with SDL since 1.2.10 and
+ * even then only when called before the first
+ * SDL_SetVideoMode.
+ * Once there's a better way available implement an
+ * update_xinerama_info function.
+ */
+static void get_screensize(void) {
+    const SDL_VideoInfo *vi;
+    // TODO: better to use a check that gets the runtime version instead?
+    if (!SDL_VERSION_ATLEAST(1, 2, 10)) return;
+    // Keep user-provided settings
+    if (vo_screenwidth > 0 || vo_screenheight > 0) return;
+    vi = SDL_GetVideoInfo();
+    vo_screenwidth  = vi->current_w;
+    vo_screenheight = vi->current_h;
+}
+
 int vo_sdl_init(void)
 {
     reinit = 0;
@@ -50,6 +70,9 @@
     SDL_EventState(SDL_SYSWMEVENT, SDL_IGNORE);
     SDL_EventState(SDL_USEREVENT, SDL_IGNORE);
 
+    // Try to get a sensible default for fullscreen.
+    get_screensize();
+
     return 1;
 }
 
diff -Naur mplayer-1.0_rc4_p20120109/libvo/stats.c mplayer-1.0_rc4_p20120109-new/libvo/stats.c
--- mplayer-1.0_rc4_p20120109/libvo/stats.c	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libvo/stats.c	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,217 @@
+#include "config.h"
+#include "stats.h"
+#include <time.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <locale.h>
+#include <inttypes.h>
+
+#if CONFIG_LIBGTOP
+#include <glibtop/cpu.h>
+#include <glibtop/proctime.h>
+#include <glibtop/procstate.h>
+#endif
+
+// Process statistics
+struct proc_stats {
+    uint64_t utime;
+    uint64_t stime;
+    uint64_t cutime;
+    uint64_t cstime;
+    uint64_t frequency;
+    uint64_t cpu_time;
+    uint64_t start_time;
+    uint64_t current_time;
+};
+
+// Get current process stats
+static int get_proc_stats(struct proc_stats *pstats);
+
+void stats_init(void)
+{
+#if CONFIG_LIBGTOP
+    glibtop_init();
+#endif
+}
+
+void stats_exit(void)
+{
+#if CONFIG_LIBGTOP
+    glibtop_close();
+#endif
+}
+
+// Get CPU frequency
+unsigned int get_cpu_frequency(void)
+{
+    unsigned int freq = 0;
+#if defined __linux__
+    {
+        FILE *proc_file = fopen("/proc/cpuinfo", "r");
+        if (proc_file) {
+            char line[256];
+            char *old_locale = setlocale(LC_NUMERIC, NULL);
+            setlocale(LC_NUMERIC, "C");
+            while(fgets(line, sizeof(line), proc_file)) {
+                float f;
+                int len = strlen(line);
+                if (len == 0)
+                    continue;
+                line[len - 1] = 0;
+                if (sscanf(line, "cpu MHz : %f", &f) == 1)
+                    freq = (unsigned int)f;
+            }
+            setlocale(LC_NUMERIC, old_locale);
+            fclose(proc_file);
+        }
+    }
+#endif
+    return freq;
+}
+
+// Get CPU usage in percent
+static float get_cpu_usage_1(void)
+{
+    static struct proc_stats prev_stats;
+    struct proc_stats curr_stats;
+    uint64_t prev_proc_time = 0, curr_proc_time = 0;
+    float pcpu = 0.0f;
+
+    if (get_proc_stats(&curr_stats) == 0) {
+        prev_proc_time += prev_stats.utime;
+        prev_proc_time += prev_stats.stime;
+        prev_proc_time += prev_stats.cutime;
+        prev_proc_time += prev_stats.cstime;
+        curr_proc_time += curr_stats.utime;
+        curr_proc_time += curr_stats.stime;
+        curr_proc_time += curr_stats.cutime;
+        curr_proc_time += curr_stats.cstime;
+        if (prev_stats.start_time > 0)
+            pcpu = 100.0 * ((float)(curr_proc_time - prev_proc_time) /
+                            (float)(curr_stats.cpu_time - prev_stats.cpu_time));
+        prev_stats = curr_stats;
+    }
+    return pcpu;
+}
+
+float get_cpu_usage(enum CpuUsageType type)
+{
+    static float pcpu_total = 0.0;
+    static unsigned int n_samples;
+    float pcpu;
+
+    pcpu        = get_cpu_usage_1();
+    pcpu_total += pcpu / 100.0;
+    ++n_samples;
+
+    if (type == CPU_USAGE_AVERAGE)
+        pcpu = 100.0 * (pcpu_total / n_samples);
+    return pcpu;
+}
+
+// For ELF executable, notes are pushed before environment and args
+static int find_elf_note(unsigned long match, unsigned long *pval)
+{
+    unsigned long *ep = (unsigned long *)__environ;
+    while (*ep++);
+    for (; *ep != 0; ep += 2) {
+        if (ep[0] == match) {
+            *pval = ep[1];
+            return 0;
+        }
+    }
+    return -1;
+}
+
+#ifndef AT_CLKTCK
+#define AT_CLKTCK 17
+#endif
+
+// Get current process stats
+int get_proc_stats(struct proc_stats *pstats)
+{
+    int error = -1;
+    char line[256], *str, *end;
+    char vc;
+    int vi;
+    unsigned long vul;
+    unsigned long long vull;
+    float vf;
+#if defined __linux__
+    {
+        FILE *proc_file = fopen("/proc/self/stat", "r");
+        if (proc_file) {
+            if (fgets(line, sizeof(line), proc_file)) {
+                unsigned long utime, stime, cutime, cstime, start_time;
+                str = strrchr(line, ')');
+                if (str && sscanf(str + 2,
+                                  "%c "
+                                  "%d %d %d %d %d "
+                                  "%lu %lu %lu %lu %lu %lu %lu "
+                                  "%ld %ld %ld %ld %ld %ld "
+                                  "%lu %lu ",
+                                  &vc,
+                                  &vi, &vi, &vi, &vi, &vi, 
+                                  &vul, &vul, &vul, &vul, &vul, &utime, &stime,
+                                  &cutime, &cstime, &vul, &vul, &vul, &vul,
+                                  &start_time, &vul) == 21) {
+                    pstats->utime      = utime;
+                    pstats->stime      = stime;
+                    pstats->cutime     = cutime;
+                    pstats->cstime     = cstime;
+                    pstats->start_time = start_time;
+                    error = 0;
+                }
+            }
+            fclose(proc_file);
+        }
+        if (error)
+            return error;
+        error = -1;
+
+        if (find_elf_note(AT_CLKTCK, &vul) == 0) {
+            pstats->frequency = vul;
+            error = 0;
+        }
+        if (error)
+            return error;
+        error = -1;
+
+        proc_file = fopen("/proc/uptime", "r");
+        if (proc_file) {
+            if (fgets(line, sizeof(line), proc_file)) {
+                char *old_locale = setlocale(LC_NUMERIC, NULL);
+                setlocale(LC_NUMERIC, "C");
+                if (sscanf(line, "%f", &vf) == 1) {
+                    pstats->cpu_time = (uint64_t)(vf * (float)pstats->frequency);
+                    error = 0;
+                }
+                setlocale(LC_NUMERIC, old_locale);
+            }
+            fclose(proc_file);
+        }
+    }
+#elif CONFIG_LIBGTOP
+    {
+        glibtop_cpu cpu;
+        glibtop_proc_time proc_time;
+        glibtop_proc_state proc_state;
+
+        glibtop_get_cpu(&cpu);
+        glibtop_get_proc_state(&proc_state, getpid());
+        pstats->cpu_time   = cpu.xcpu_total[proc_state.processor];
+
+        glibtop_get_proc_time(&proc_time, getpid());
+        pstats->utime      = proc_time.utime;
+        pstats->stime      = proc_time.stime;
+        pstats->cutime     = proc_time.cutime;
+        pstats->cstime     = proc_time.cstime;
+        pstats->start_time = proc_time.start_time;
+        pstats->frequency  = proc_time.frequency;
+
+        error = 0;
+    }
+#endif
+    return error;
+}
diff -Naur mplayer-1.0_rc4_p20120109/libvo/stats.h mplayer-1.0_rc4_p20120109-new/libvo/stats.h
--- mplayer-1.0_rc4_p20120109/libvo/stats.h	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libvo/stats.h	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,21 @@
+#ifndef MPLAYER_STATS_H
+#define MPLAYER_STATS_H
+
+#include <stdint.h>
+
+void stats_init(void);
+void stats_exit(void);
+
+/// CPU usage model
+enum CpuUsageType {
+    CPU_USAGE_QUANTUM = 1, ///< CPU usage since the last call to cpu_get_usage()
+    CPU_USAGE_AVERAGE      ///< CPU usage average'd since program start
+};
+
+/// Get CPU frequency
+unsigned int get_cpu_frequency(void);
+
+/// Get CPU usage in percent
+float get_cpu_usage(enum CpuUsageType type);
+
+#endif /* MPLAYER_STATS_H */
diff -Naur mplayer-1.0_rc4_p20120109/libvo/video_out.c mplayer-1.0_rc4_p20120109-new/libvo/video_out.c
--- mplayer-1.0_rc4_p20120109/libvo/video_out.c	2012-01-09 14:46:56.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libvo/video_out.c	2012-01-16 15:51:41.000000000 +0100
@@ -94,6 +94,7 @@
 extern const vo_functions_t video_out_xmga;
 extern const vo_functions_t video_out_x11;
 extern const vo_functions_t video_out_xvmc;
+extern const vo_functions_t video_out_vaapi;
 extern const vo_functions_t video_out_vdpau;
 extern const vo_functions_t video_out_xv;
 extern const vo_functions_t video_out_gl_nosw;
@@ -295,6 +296,9 @@
 #ifdef CONFIG_MNG
         &video_out_mng,
 #endif
+#if CONFIG_VAAPI
+        &video_out_vaapi,
+#endif
         NULL
 };
 
diff -Naur mplayer-1.0_rc4_p20120109/libvo/video_out.h mplayer-1.0_rc4_p20120109-new/libvo/video_out.h
--- mplayer-1.0_rc4_p20120109/libvo/video_out.h	2012-01-09 14:46:56.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libvo/video_out.h	2012-01-16 15:51:41.000000000 +0100
@@ -80,6 +80,10 @@
 
 #define VOCTRL_UPDATE_SCREENINFO 32
 
+// Return current HW acceleration context
+// void *get_hwaccel_context(void);
+#define VOCTRL_GET_HWACCEL_CONTEXT 33
+
 // Vo can be used by xover
 #define VOCTRL_XOVERLAY_SUPPORT 22
 
diff -Naur mplayer-1.0_rc4_p20120109/libvo/vo_vaapi.c mplayer-1.0_rc4_p20120109-new/libvo/vo_vaapi.c
--- mplayer-1.0_rc4_p20120109/libvo/vo_vaapi.c	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/libvo/vo_vaapi.c	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,2728 @@
+/*
+ * VA API output module
+ *
+ * Copyright (C) 2008-2009 Splitted-Desktop Systems
+ *
+ * This file is part of MPlayer.
+ *
+ * MPlayer is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * MPlayer is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with MPlayer; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+#include "mp_msg.h"
+#include "help_mp.h"
+#include "subopt-helper.h"
+#include "video_out.h"
+#include "video_out_internal.h"
+#include "fastmemcpy.h"
+#include "sub/sub.h"
+#include "sub/eosd.h"
+#include "x11_common.h"
+#include "libavutil/common.h"
+#include "libavcodec/vaapi.h"
+#include "gui/interface.h"
+#include "stats.h"
+#include <stdarg.h>
+
+#if CONFIG_GL
+#include "gl_common.h"
+#include <GL/glu.h>
+#include <GL/glx.h>
+#endif
+
+#include <assert.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <va/va_x11.h>
+#if CONFIG_VAAPI_GLX
+#include <va/va_glx.h>
+#endif
+
+#if CONFIG_XRENDER
+#include <X11/extensions/Xrender.h>
+#endif
+
+/* Compatibility glue with upstream libva */
+#ifndef VA_SDS_VERSION
+#define VA_SDS_VERSION          0
+#endif
+
+/* Compatibility glue with VA-API >= 0.30 */
+#ifndef VA_INVALID_ID
+#define VA_INVALID_ID           0xffffffff
+#endif
+#ifndef VA_FOURCC
+#define VA_FOURCC(ch0, ch1, ch2, ch3)           \
+    ((uint32_t)(uint8_t)(ch0) |                 \
+     ((uint32_t)(uint8_t)(ch1) << 8) |          \
+     ((uint32_t)(uint8_t)(ch2) << 16) |         \
+     ((uint32_t)(uint8_t)(ch3) << 24 ))
+#endif
+#if defined VA_SRC_BT601 && defined VA_SRC_BT709
+# define USE_VAAPI_COLORSPACE 1
+#else
+# define USE_VAAPI_COLORSPACE 0
+#endif
+
+/* Defined to 1 if VA/GLX 'bind' API is available */
+#define USE_VAAPI_GLX_BIND                                \
+    (VA_MAJOR_VERSION == 0 &&                             \
+     ((VA_MINOR_VERSION == 30 &&                          \
+       VA_MICRO_VERSION == 4 && VA_SDS_VERSION >= 5) ||   \
+      (VA_MINOR_VERSION == 31 &&                          \
+       VA_MICRO_VERSION == 0 && VA_SDS_VERSION >= 1 && VA_SDS_VERSION < 5)))
+
+/* Compatibility glue with VA-API >= 0.31 */
+#if defined VA_CHECK_VERSION
+#if VA_CHECK_VERSION(0,31,0)
+#define vaPutImage2             vaPutImage
+#define vaAssociateSubpicture2  vaAssociateSubpicture
+#endif
+#endif
+
+/* Compatibility glue with VA-API >= 0.31.1 */
+#ifndef VA_SRC_SMPTE_240
+#define VA_SRC_SMPTE_240        0x00000040
+#endif
+#if defined VA_FILTER_SCALING_MASK
+# define USE_VAAPI_SCALING 1
+#else
+# define USE_VAAPI_SCALING 0
+#endif
+
+static vo_info_t info = {
+    "VA API with X11",
+    "vaapi",
+    "Gwenole Beauchesne <gbeauchesne@splitted-desktop.com>",
+    ""
+};
+
+const LIBVO_EXTERN(vaapi)
+
+/* Numbers of video surfaces */
+#define MAX_OUTPUT_SURFACES       2 /* Maintain synchronisation points in flip_page() */
+#define MAX_VIDEO_SURFACES       21 /* Maintain free surfaces in a queue (use least-recently-used) */
+#define NUM_VIDEO_SURFACES_MPEG2  3 /* 1 decode frame, up to  2 references */
+#define NUM_VIDEO_SURFACES_MPEG4  3 /* 1 decode frame, up to  2 references */
+#define NUM_VIDEO_SURFACES_H264  21 /* 1 decode frame, up to 20 references */
+#define NUM_VIDEO_SURFACES_VC1    3 /* 1 decode frame, up to  2 references */
+
+static void ensure_osd(void);
+static int reset_xrender_specific(void);
+
+typedef void (*draw_alpha_func)(int x0, int y0, int w, int h,
+                                unsigned char *src, unsigned char *srca,
+                                int stride);
+
+typedef void (*eosd_draw_alpha_func)(unsigned char *src,
+                                     int src_w, int src_h, int src_stride,
+                                     int dst_x, int dst_y,
+                                     uint32_t color);
+
+struct vaapi_surface {
+    VASurfaceID id;
+    VAImage     image;
+    int         is_bound; /* Flag: image bound to the surface? */
+};
+
+struct vaapi_equalizer {
+    VADisplayAttribute brightness;
+    VADisplayAttribute contrast;
+    VADisplayAttribute hue;
+    VADisplayAttribute saturation;
+};
+
+static int                      g_is_visible;
+static int                      g_is_paused;
+static uint32_t                 g_image_width;
+static uint32_t                 g_image_height;
+static uint32_t                 g_image_format;
+static uint32_t                 g_image_fields;
+static Pixmap                   g_image_pixmap;
+static struct vo_rect           g_output_rect;
+static struct vaapi_surface    *g_output_surfaces[MAX_OUTPUT_SURFACES];
+static unsigned int             g_output_surface;
+static int                      g_deint;
+static int                      g_deint_type;
+static int                      g_colorspace;
+static unsigned int             g_scaling;
+
+static int                      gl_enabled;
+static int                      gl_use_tfp;
+#if CONFIG_GL
+static MPGLContext              gl_context;
+static int                      gl_binding;
+static int                      gl_reflect;
+static int                      gl_finish;
+static GLuint                   gl_texture;
+static GLuint                   gl_font_base;
+static Pixmap                   gl_pixmap;
+static int                      gl_visual_attr[] = {
+    GLX_RGBA,
+    GLX_RED_SIZE, 1,
+    GLX_GREEN_SIZE, 1,
+    GLX_BLUE_SIZE, 1,
+    GLX_DOUBLEBUFFER,
+    GL_NONE
+};
+#endif
+
+#if CONFIG_VAAPI_GLX
+static void                    *gl_surface;
+#endif
+
+static int                      xr_enabled;
+#if CONFIG_XRENDER
+static Picture                  xr_video_picture;
+static Picture                  xr_window_picture;
+#endif
+
+static struct vaapi_context    *va_context;
+static VAProfile               *va_profiles;
+static int                      va_num_profiles;
+static VAEntrypoint            *va_entrypoints;
+static int                      va_num_entrypoints;
+static VASurfaceID             *va_surface_ids;
+static int                      va_num_surfaces;
+static struct vaapi_surface   **va_free_surfaces;
+static int                      va_free_surfaces_head_index;
+static int                      va_free_surfaces_tail_index;
+static VAImageFormat           *va_image_formats;
+static int                      va_num_image_formats;
+static VAImageFormat           *va_subpic_formats;
+static unsigned int            *va_subpic_flags;
+static int                      va_num_subpic_formats;
+static VAImage                  va_osd_image;
+static uint8_t                 *va_osd_image_data;
+static VASubpictureID           va_osd_subpicture;
+static int                      va_osd_associated;
+static draw_alpha_func          va_osd_draw_alpha;
+static uint8_t                 *va_osd_palette;
+static struct vaapi_equalizer   va_equalizer;
+static VAImage                  va_eosd_image;
+static uint8_t                 *va_eosd_image_data;
+static VASubpictureID           va_eosd_subpicture;
+static int                      va_eosd_associated;
+static eosd_draw_alpha_func     va_eosd_draw_alpha;
+
+///< Flag: direct surface mapping: use mpi->number to select free VA surface?
+static int                      va_dm;
+
+///< Flag: gather run-time statistics (CPU usage, frequency)
+static int                      cpu_stats;
+static unsigned int             cpu_frequency;
+static float                    cpu_usage;
+
+// X error trap
+static int x11_error_code = 0;
+static int (*old_error_handler)(Display *, XErrorEvent *);
+
+static int error_handler(Display *dpy, XErrorEvent *error)
+{
+    x11_error_code = error->error_code;
+    return 0;
+}
+
+static void x11_trap_errors(void)
+{
+    x11_error_code    = 0;
+    old_error_handler = XSetErrorHandler(error_handler);
+}
+
+static int x11_untrap_errors(void)
+{
+    XSetErrorHandler(old_error_handler);
+    return x11_error_code;
+}
+
+static int check_status(VAStatus status, const char *msg)
+{
+    if (status != VA_STATUS_SUCCESS) {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] %s: %s\n", msg, vaErrorStr(status));
+        return 0;
+    }
+    return 1;
+}
+
+static const char *string_of_VAImageFormat(VAImageFormat *imgfmt)
+{
+    static char str[5];
+    str[0] = imgfmt->fourcc;
+    str[1] = imgfmt->fourcc >> 8;
+    str[2] = imgfmt->fourcc >> 16;
+    str[3] = imgfmt->fourcc >> 24;
+    str[4] = '\0';
+    return str;
+}
+
+static const char *string_of_VAProfile(VAProfile profile)
+{
+    switch (profile) {
+#define PROFILE(profile) \
+        case VAProfile##profile: return "VAProfile" #profile
+        PROFILE(MPEG2Simple);
+        PROFILE(MPEG2Main);
+        PROFILE(MPEG4Simple);
+        PROFILE(MPEG4AdvancedSimple);
+        PROFILE(MPEG4Main);
+        PROFILE(H264Baseline);
+        PROFILE(H264Main);
+        PROFILE(H264High);
+        PROFILE(VC1Simple);
+        PROFILE(VC1Main);
+        PROFILE(VC1Advanced);
+#undef PROFILE
+    }
+    return "<unknown>";
+}
+
+static const char *string_of_VAEntrypoint(VAEntrypoint entrypoint)
+{
+    switch (entrypoint) {
+#define ENTRYPOINT(entrypoint) \
+        case VAEntrypoint##entrypoint: return "VAEntrypoint" #entrypoint
+        ENTRYPOINT(VLD);
+        ENTRYPOINT(IZZ);
+        ENTRYPOINT(IDCT);
+        ENTRYPOINT(MoComp);
+        ENTRYPOINT(Deblocking);
+#undef ENTRYPOINT
+    }
+    return "<unknown>";
+}
+
+static int has_profile(VAProfile profile)
+{
+    if (va_profiles && va_num_profiles > 0) {
+        int i;
+        for (i = 0; i < va_num_profiles; i++) {
+            if (va_profiles[i] == profile)
+                return 1;
+        }
+    }
+    return 0;
+}
+
+static int VAProfile_from_imgfmt(uint32_t format)
+{
+    static const int mpeg2_profiles[] =
+        { VAProfileMPEG2Main, VAProfileMPEG2Simple, -1 };
+    static const int mpeg4_profiles[] =
+        { VAProfileMPEG4Main, VAProfileMPEG4AdvancedSimple, VAProfileMPEG4Simple, -1 };
+    static const int h264_profiles[] =
+        { VAProfileH264High, VAProfileH264Main, VAProfileH264Baseline, -1 };
+    static const int wmv3_profiles[] =
+        { VAProfileVC1Main, VAProfileVC1Simple, -1 };
+    static const int vc1_profiles[] =
+        { VAProfileVC1Advanced, -1 };
+
+    const int *profiles = NULL;
+    switch (IMGFMT_VAAPI_CODEC(format)) {
+    case IMGFMT_VAAPI_CODEC_MPEG2:
+        profiles = mpeg2_profiles;
+        break;
+    case IMGFMT_VAAPI_CODEC_MPEG4:
+        profiles = mpeg4_profiles;
+        break;
+    case IMGFMT_VAAPI_CODEC_H264:
+        profiles = h264_profiles;
+        break;
+    case IMGFMT_VAAPI_CODEC_VC1:
+        switch (format) {
+        case IMGFMT_VAAPI_WMV3:
+            profiles = wmv3_profiles;
+            break;
+        case IMGFMT_VAAPI_VC1:
+            profiles = vc1_profiles;
+            break;
+        }
+        break;
+    }
+
+    if (profiles) {
+        for (int i = 0; profiles[i] != -1; i++) {
+            if (has_profile(profiles[i]))
+                return profiles[i];
+        }
+    }
+    return -1;
+}
+
+static int has_entrypoint(VAEntrypoint entrypoint)
+{
+    if (va_entrypoints && va_num_entrypoints > 0) {
+        int i;
+        for (i = 0; i < va_num_entrypoints; i++) {
+            if (va_entrypoints[i] == entrypoint)
+                return 1;
+        }
+    }
+    return 0;
+}
+
+static int VAEntrypoint_from_imgfmt(uint32_t format)
+{
+    int entrypoint = 0;
+    switch (format) {
+    case IMGFMT_VAAPI_MPEG2:
+    case IMGFMT_VAAPI_MPEG4:
+    case IMGFMT_VAAPI_H263:
+    case IMGFMT_VAAPI_H264:
+    case IMGFMT_VAAPI_WMV3:
+    case IMGFMT_VAAPI_VC1:
+        entrypoint = VAEntrypointVLD;
+        break;
+    case IMGFMT_VAAPI_MPEG2_IDCT:
+        entrypoint = VAEntrypointIDCT;
+        break;
+    case IMGFMT_VAAPI_MPEG2_MOCO:
+        entrypoint = VAEntrypointMoComp;
+        break;
+    }
+
+    if (entrypoint)
+        return has_entrypoint(entrypoint);
+
+    return -1;
+}
+
+static VAImageFormat *find_image_format(uint32_t fourcc)
+{
+    if (va_image_formats && va_num_image_formats > 0) {
+        int i;
+        for (i = 0; i < va_num_image_formats; i++) {
+            if (va_image_formats[i].fourcc == fourcc)
+                return &va_image_formats[i];
+        }
+    }
+    return NULL;
+}
+
+static VAImageFormat *VAImageFormat_from_imgfmt(uint32_t format)
+{
+    uint32_t fourcc = 0;
+
+    switch (format) {
+    case IMGFMT_NV12: fourcc = VA_FOURCC('N','V','1','2'); break;
+    case IMGFMT_YV12: fourcc = VA_FOURCC('Y','V','1','2'); break;
+    case IMGFMT_I420: fourcc = VA_FOURCC('I','4','2','0'); break;
+    case IMGFMT_IYUV: fourcc = VA_FOURCC('I','Y','U','V'); break;
+    }
+
+    if (fourcc)
+        return find_image_format(fourcc);
+
+    return NULL;
+}
+
+static struct vaapi_surface *alloc_vaapi_surface(unsigned int width,
+                                                 unsigned int height,
+                                                 unsigned int format)
+{
+    struct vaapi_surface *surface = NULL;
+    struct vaapi_surface **surfaces;
+    VASurfaceID *surface_ids;
+    VAStatus status;
+
+    surface = calloc(1, sizeof(*surface));
+    if (!surface)
+        goto error;
+
+    surfaces = realloc(va_free_surfaces,
+                       (1 + va_num_surfaces) * sizeof(surfaces[0]));
+    if (!surfaces)
+        goto error;
+
+    surface_ids = realloc(va_surface_ids,
+                          (1 + va_num_surfaces) * sizeof(surface_ids[0]));
+    if (!surface_ids)
+        goto error;
+
+    status = vaCreateSurfaces(va_context->display, width, height, format,
+                              1, &surface->id);
+    if (!check_status(status, "vaCreateSurfaces()"))
+        goto error;
+
+    va_surface_ids                    = surface_ids;
+    va_surface_ids[va_num_surfaces]   = surface->id;
+    va_free_surfaces                  = surfaces;
+    va_free_surfaces[va_num_surfaces] = surface;
+    surface->image.image_id           = VA_INVALID_ID;
+    surface->image.buf                = VA_INVALID_ID;
+    ++va_num_surfaces;
+    return surface;
+error:
+    free(surface);
+    return NULL;
+}
+
+static void resize(void)
+{
+    struct vo_rect src;
+
+    calc_src_dst_rects(g_image_width, g_image_height,
+                       &src, &g_output_rect, NULL, NULL);
+
+    ensure_osd();
+
+    vo_x11_clearwindow(mDisplay, vo_window);
+
+#if CONFIG_GL
+#define FOVY     60.0f
+#define ASPECT   1.0f
+#define Z_NEAR   0.1f
+#define Z_FAR    100.0f
+#define Z_CAMERA 0.869f
+
+    if (gl_enabled) {
+        glViewport(0, 0, vo_dwidth, vo_dheight);
+        glMatrixMode(GL_PROJECTION);
+        glLoadIdentity();
+        gluPerspective(FOVY, ASPECT, Z_NEAR, Z_FAR);
+        glMatrixMode(GL_MODELVIEW);
+        glLoadIdentity();
+
+        glTranslatef(-0.5f, -0.5f, -Z_CAMERA);
+        glScalef(1.0f / (GLfloat)vo_dwidth,
+                 -1.0f / (GLfloat)vo_dheight,
+                 1.0f / (GLfloat)vo_dwidth);
+        glTranslatef(0.0f, -1.0f * (GLfloat)vo_dheight, 0.0f);
+    }
+#endif
+
+#if CONFIG_XRENDER
+    if (xr_enabled)
+        reset_xrender_specific();
+#endif
+
+    if (g_is_visible)
+        flip_page();
+}
+
+#if CONFIG_GL
+static int gl_build_font(void)
+{
+    XFontStruct *fi;
+
+    gl_font_base = glGenLists(96);
+
+    fi = XLoadQueryFont(mDisplay, "-adobe-helvetica-medium-r-normal--16-*-*-*-p-*-iso8859-1" );
+    if (!fi) {
+        fi = XLoadQueryFont(mDisplay, "fixed");
+        if (!fi)
+            return -1;
+    }
+
+    glXUseXFont(fi->fid, 32, 96, gl_font_base);
+    XFreeFont(mDisplay, fi);
+    return 0;
+}
+
+static void gl_printf(const char *format, ...)
+{
+    va_list args;
+    char *text;
+    int textlen;
+
+    va_start(args, format);
+    textlen = vsnprintf(NULL, 0, format, args);
+    va_end(args);
+
+    text = malloc(textlen + 1);
+    if (!text)
+        return;
+
+    va_start(args, format);
+    vsprintf(text, format, args);
+    va_end(args);
+
+    glPushAttrib(GL_LIST_BIT);
+    glListBase(gl_font_base - 32);
+    glCallLists(textlen, GL_UNSIGNED_BYTE, text);
+    glPopAttrib();
+    free(text);
+}
+
+static void gl_draw_rectangle(int x, int y, int w, int h, unsigned int rgba)
+{
+    glColor4f((GLfloat)((rgba >> 24) & 0xff) / 255.0,
+              (GLfloat)((rgba >> 16) & 0xff) / 255.0,
+              (GLfloat)((rgba >> 8) & 0xff) / 255.0,
+              (GLfloat)(rgba & 0xff) / 255.0);
+
+    glTranslatef((GLfloat)x, (GLfloat)y, 0.0f);
+    glBegin(GL_QUADS);
+    {
+        glVertex2i(0, 0);
+        glVertex2i(w, 0);
+        glVertex2i(w, h);
+        glVertex2i(0, h);
+    }
+    glEnd();
+}
+#endif
+
+#if CONFIG_XRENDER
+static int init_xrender(void)
+{
+    int dummy;
+
+    return XRenderQueryExtension(mDisplay, &dummy, &dummy);
+}
+
+static void uninit_xrender(void)
+{
+}
+#endif
+
+static inline unsigned char *get_osd_image_data(int x0, int y0)
+{
+    return (va_osd_image_data +
+            va_osd_image.offsets[0] +
+            va_osd_image.pitches[0] * y0 +
+            x0 * ((va_osd_image.format.bits_per_pixel + 7) / 8));
+}
+
+static void draw_alpha_rgb32(int x0, int y0, int w, int h,
+                             unsigned char *src, unsigned char *srca,
+                             int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    for (y = 0; y < h; y++, dst += dststride, src += stride, srca += stride)
+        for (x = 0; x < w; x++) {
+            const unsigned char c = src[x];
+            dst[4*x + 0] = c;
+            dst[4*x + 1] = c;
+            dst[4*x + 2] = c;
+            dst[4*x + 3] = -srca[x];
+        }
+}
+
+static void draw_alpha_IA44(int x0, int y0, int w, int h,
+                            unsigned char *src, unsigned char *srca,
+                            int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    for (y = 0; y < h; y++, dst += dststride)
+        for (x = 0; x < w; x++)
+            dst[x] = (src[y*stride + x] >> 4) | (-srca[y*stride + x] & 0xf0);
+}
+
+static void draw_alpha_AI44(int x0, int y0, int w, int h,
+                            unsigned char *src, unsigned char *srca,
+                            int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    for (y = 0; y < h; y++, dst += dststride)
+        for (x = 0; x < w; x++)
+            dst[x] = (src[y*stride + x] & 0xf0) | (-srca[y*stride + x] >> 4);
+}
+
+static void draw_alpha_IA88(int x0, int y0, int w, int h,
+                            unsigned char *src, unsigned char *srca,
+                            int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    for (y = 0; y < h; y++, dst += dststride)
+        for (x = 0; x < w; x++) {
+            dst[2*x + 0] =  src [y*stride + x];
+            dst[2*x + 1] = -srca[y*stride + x];
+        }
+}
+
+static void draw_alpha_AI88(int x0, int y0, int w, int h,
+                            unsigned char *src, unsigned char *srca,
+                            int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    for (y = 0; y < h; y++, dst += dststride)
+        for (x = 0; x < w; x++) {
+            dst[2*x + 0] = -srca[y*stride + x];
+            dst[2*x + 1] =  src [y*stride + x];
+        }
+}
+
+///< List of subpicture formats in preferred order
+static const struct {
+    uint32_t format;
+    draw_alpha_func draw_alpha;
+}
+va_osd_info[] = {
+    { VA_FOURCC('I','A','4','4'), draw_alpha_IA44  },
+    { VA_FOURCC('A','I','4','4'), draw_alpha_AI44  },
+    { VA_FOURCC('I','A','8','8'), draw_alpha_IA88  },
+    { VA_FOURCC('A','I','8','8'), draw_alpha_AI88  },
+    { VA_FOURCC('B','G','R','A'), draw_alpha_rgb32 },
+    { VA_FOURCC('R','G','B','A'), draw_alpha_rgb32 },
+    { 0, NULL }
+};
+
+static uint8_t *gen_osd_palette(const VAImage *image)
+{
+    uint8_t *palette;
+    int i, is_rgb;
+    int r_idx = -1, g_idx = -1, b_idx = -1;
+    int y_idx = -1, u_idx = -1, v_idx = -1;
+    int i_idx = -1, a_idx = -1;
+
+    if (image->num_palette_entries < 1)
+        return NULL;
+
+    palette = malloc(image->num_palette_entries * image->entry_bytes);
+    if (!palette)
+        return NULL;
+
+    for (i = 0; i < image->entry_bytes; i++) {
+        switch (image->component_order[i]) {
+        case 'R': r_idx = i; is_rgb = 1; break;
+        case 'G': g_idx = i; is_rgb = 1; break;
+        case 'B': b_idx = i; is_rgb = 1; break;
+        case 'Y': y_idx = i; is_rgb = 0; break;
+        case 'U': u_idx = i; is_rgb = 0; break;
+        case 'V': v_idx = i; is_rgb = 0; break;
+        case 'I': i_idx = i; break;
+        case 'A': a_idx = i; break;
+        }
+    }
+
+    if (r_idx != -1 && g_idx != -1 && b_idx != -1) {      /* RGB format */
+        for (i = 0; i < image->num_palette_entries; i++) {
+            const int n = i * image->entry_bytes;
+            palette[n + r_idx] = i * 0xff / (image->num_palette_entries - 1);
+            palette[n + g_idx] = i * 0xff / (image->num_palette_entries - 1);
+            palette[n + b_idx] = i * 0xff / (image->num_palette_entries - 1);
+        }
+    }
+    else if (y_idx != -1 && u_idx != -1 && v_idx != -1) { /* YUV format */
+        for (i = 0; i < image->num_palette_entries; i++) {
+            const int n = i * image->entry_bytes;
+            palette[n + y_idx] = i * 0xff / (image->num_palette_entries - 1);
+            palette[n + u_idx] = 0x80;
+            palette[n + v_idx] = 0x80;
+        }
+    }
+    else if (i_idx != -1 && a_idx != -1) {/* AYUV format (GMA500 "psb" bug) */
+        for (i = 0; i < image->num_palette_entries; i++) {
+            const int n = i * image->entry_bytes;
+            palette[n + 0] = 0x80;
+            palette[n + 1] = 0x80;
+            palette[n + 2] = 16 + i * 220 / (image->num_palette_entries - 1);
+            palette[n + 3] = 0;
+        }
+    }
+    else {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] Could not set up subpicture palette\n");
+        free(palette);
+        palette = NULL;
+    }
+    return palette;
+}
+
+static void disable_osd(void)
+{
+    if (!va_osd_associated)
+        return;
+
+    vaDeassociateSubpicture(va_context->display,
+                            va_osd_subpicture,
+                            va_surface_ids, va_num_surfaces);
+
+    va_osd_associated = 0;
+}
+
+static int enable_osd(void)
+{
+    VAStatus status;
+
+    disable_osd();
+
+    status = vaAssociateSubpicture2(va_context->display,
+                                    va_osd_subpicture,
+                                    va_surface_ids, va_num_surfaces,
+                                    0, 0,
+                                    va_osd_image.width, va_osd_image.height,
+                                    0, 0,
+                                    g_image_width, g_image_height,
+                                    0);
+    if (!check_status(status, "vaAssociateSubpicture()"))
+        return -1;
+
+    va_osd_associated = 1;
+    return 0;
+}
+
+static void destroy_osd(void)
+{
+    disable_osd();
+
+    if (va_osd_subpicture != VA_INVALID_ID) {
+        vaDestroySubpicture(va_context->display, va_osd_subpicture);
+        va_osd_subpicture = VA_INVALID_ID;
+    }
+
+    if (va_osd_image.image_id != VA_INVALID_ID) {
+        vaDestroyImage(va_context->display, va_osd_image.image_id);
+        va_osd_image.image_id = VA_INVALID_ID;
+        va_osd_image.width    = 0;
+        va_osd_image.height   = 0;
+    }
+}
+
+static void create_osd(void)
+{
+    VAStatus status;
+    int i, j;
+
+    for (i = 0; va_osd_info[i].format; i++) {
+        for (j = 0; j < va_num_subpic_formats; j++)
+            if (va_subpic_formats[j].fourcc == va_osd_info[i].format)
+                break;
+        if (j < va_num_subpic_formats &&
+            vaCreateImage(va_context->display, &va_subpic_formats[j],
+                          g_output_rect.width, g_output_rect.height,
+                          &va_osd_image) == VA_STATUS_SUCCESS) {
+            va_osd_palette = gen_osd_palette(&va_osd_image);
+            if (((!va_osd_image.num_palette_entries) ^ (!va_osd_palette)) == 0)
+                break;
+            vaDestroyImage(va_context->display, va_osd_image.image_id);
+            va_osd_image.image_id = VA_INVALID_ID;
+        }
+    }
+
+    if (va_osd_info[i].format &&
+        vaCreateSubpicture(va_context->display, va_osd_image.image_id,
+                           &va_osd_subpicture) == VA_STATUS_SUCCESS) {
+        va_osd_draw_alpha = va_osd_info[i].draw_alpha;
+        if (va_osd_palette) {
+            status = vaSetImagePalette(va_context->display,
+                                       va_osd_image.image_id, va_osd_palette);
+            check_status(status, "vaSetImagePalette()");
+        }
+        mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] Using %s surface for OSD\n",
+               string_of_VAImageFormat(&va_osd_image.format));
+    }
+}
+
+static void ensure_osd(void)
+{
+    if (g_output_rect.width  == va_osd_image.width &&
+        g_output_rect.height == va_osd_image.height)
+        return;
+
+    destroy_osd();
+    create_osd();
+}
+
+static inline unsigned char *get_eosd_image_data(int x0, int y0)
+{
+    return (va_eosd_image_data +
+            va_eosd_image.offsets[0] +
+            va_eosd_image.pitches[0] * y0 +
+            x0 * ((va_eosd_image.format.bits_per_pixel + 7) / 8));
+}
+
+static void eosd_draw_alpha_bgra(unsigned char *src,
+                                 int src_w, int src_h, int src_stride,
+                                 int dst_x, int dst_y,
+                                 uint32_t color)
+{
+    int x, y;
+    const unsigned int dst_stride = va_eosd_image.pitches[0];
+    unsigned char *dst = get_eosd_image_data(dst_x, dst_y);
+    const unsigned int r = (color >> 24) & 0xff;
+    const unsigned int g = (color >> 16) & 0xff;
+    const unsigned int b = (color >>  8) & 0xff;
+    const unsigned int a = 0xff - (color & 0xff);
+
+    for (y = 0; y < src_h; y++, dst += dst_stride, src += src_stride)
+        for (x = 0; x < src_w; x++) {
+            const unsigned int v = src[x];
+            dst[4*x + 0] = (b * v + dst[4*x + 0] * (0xff - v)) / 255;
+            dst[4*x + 1] = (g * v + dst[4*x + 1] * (0xff - v)) / 255;
+            dst[4*x + 2] = (r * v + dst[4*x + 2] * (0xff - v)) / 255;
+            dst[4*x + 3] = (a * v + dst[4*x + 3] * (0xff - v)) / 255;
+        }
+}
+
+static void eosd_draw_alpha_rgba(unsigned char *src,
+                                 int src_w, int src_h, int src_stride,
+                                 int dst_x, int dst_y,
+                                 uint32_t color)
+{
+    int x, y;
+    const unsigned int dst_stride = va_eosd_image.pitches[0];
+    unsigned char *dst = get_eosd_image_data(dst_x, dst_y);
+    const unsigned int r = (color >> 24) & 0xff;
+    const unsigned int g = (color >> 16) & 0xff;
+    const unsigned int b = (color >>  8) & 0xff;
+    const unsigned int a = 0xff - (color & 0xff);
+
+    for (y = 0; y < src_h; y++, dst += dst_stride, src += src_stride)
+        for (x = 0; x < src_w; x++) {
+            const unsigned int v = src[x];
+            dst[4*x + 0] = (r * v + dst[4*x + 0] * (0xff - v)) / 255;
+            dst[4*x + 1] = (g * v + dst[4*x + 1] * (0xff - v)) / 255;
+            dst[4*x + 2] = (b * v + dst[4*x + 2] * (0xff - v)) / 255;
+            dst[4*x + 3] = (a * v + dst[4*x + 3] * (0xff - v)) / 255;
+        }
+}
+
+static void disable_eosd(void)
+{
+    if (!va_eosd_associated)
+        return;
+
+    vaDeassociateSubpicture(va_context->display,
+                            va_eosd_subpicture,
+                            va_surface_ids, va_num_surfaces);
+
+    va_eosd_associated = 0;
+}
+
+static int enable_eosd(void)
+{
+    VAStatus status;
+
+    if (va_eosd_associated)
+        return 0;
+
+    status = vaAssociateSubpicture2(va_context->display,
+                                    va_eosd_subpicture,
+                                    va_surface_ids, va_num_surfaces,
+                                    0, 0, g_image_width, g_image_height,
+                                    0, 0, g_image_width, g_image_height,
+                                    0);
+    if (!check_status(status, "vaAssociateSubpicture()"))
+        return -1;
+
+    va_eosd_associated = 1;
+    return 0;
+}
+
+///< List of subpicture formats in preferred order
+static const struct {
+    uint32_t format;
+    eosd_draw_alpha_func draw_alpha;
+}
+va_eosd_info[] = {
+    { VA_FOURCC('B','G','R','A'), eosd_draw_alpha_bgra },
+    { VA_FOURCC('R','G','B','A'), eosd_draw_alpha_rgba },
+    { 0, NULL }
+};
+
+static int is_direct_mapping_init(void)
+{
+    VADisplayAttribute attr;
+    VAStatus status;
+
+    if (va_dm < 2)
+        return va_dm;
+
+    /* If the driver doesn't make a copy of the VA surface for
+       display, then we have to retain it until it's no longer the
+       visible surface. In other words, if the driver is using
+       DirectSurface mode, we don't want to decode the new surface
+       into the previous one that was used for display. */
+    attr.type  = VADisplayAttribDirectSurface;
+    attr.flags = VA_DISPLAY_ATTRIB_GETTABLE;
+
+    status = vaGetDisplayAttributes(va_context->display, &attr, 1);
+    if (status == VA_STATUS_SUCCESS)
+        return !attr.value;
+    return 0;
+}
+
+static inline int is_direct_mapping(void)
+{
+    static int dm = -1;
+    if (dm < 0) {
+        dm = is_direct_mapping_init();
+        if (dm)
+            mp_msg(MSGT_VO, MSGL_INFO,
+                   "[vo_vaapi] Using 1:1 VA surface mapping\n");
+    }
+    return dm;
+}
+
+static int int_012(int *n)
+{
+    return *n >= 0 && *n <= 2;
+}
+
+#if USE_VAAPI_SCALING
+static strarg_t g_scaling_arg = { 0, NULL };
+
+static int test_scaling_arg(void *arg)
+{
+    strarg_t * const strarg = arg;
+
+    return (strargcmp(strarg, "default") == 0 ||
+            strargcmp(strarg, "fast") == 0 ||
+            strargcmp(strarg, "hq") == 0);
+}
+
+static void setup_scaling(const char *scaling)
+{
+    if (strcmp(scaling, "default") == 0)
+        g_scaling = VA_FILTER_SCALING_DEFAULT;
+    else if (strcmp(scaling, "fast") == 0)
+        g_scaling = VA_FILTER_SCALING_FAST;
+    else if (strcmp(scaling, "hq") == 0)
+        g_scaling = VA_FILTER_SCALING_HQ;
+    else if (strcmp(scaling, "nla") == 0)
+        g_scaling = VA_FILTER_SCALING_NL_ANAMORPHIC;
+}
+#endif
+
+static const opt_t subopts[] = {
+    { "dm",          OPT_ARG_INT,  &va_dm,        (opt_test_f)int_012 },
+    { "stats",       OPT_ARG_BOOL, &cpu_stats,    NULL },
+    { "deint",       OPT_ARG_INT,  &g_deint,      (opt_test_f)int_012 },
+#if USE_VAAPI_COLORSPACE
+    { "colorspace",  OPT_ARG_INT,  &g_colorspace, (opt_test_f)int_012 },
+#endif
+#if USE_VAAPI_SCALING
+    { "scaling",     OPT_ARG_STR,  &g_scaling_arg, test_scaling_arg },
+#endif
+#if CONFIG_GL
+    { "gl",          OPT_ARG_BOOL, &gl_enabled,   NULL },
+    { "glfinish",    OPT_ARG_BOOL, &gl_finish,    NULL },
+#if USE_VAAPI_GLX_BIND
+    { "bind",        OPT_ARG_BOOL, &gl_binding,   NULL },
+#endif
+    { "reflect",     OPT_ARG_BOOL, &gl_reflect,   NULL },
+    { "tfp",         OPT_ARG_BOOL, &gl_use_tfp,   NULL },
+#endif
+#if CONFIG_XRENDER
+    { "xrender",     OPT_ARG_BOOL, &xr_enabled,   NULL },
+#endif
+    { NULL, }
+};
+
+static int preinit(const char *arg)
+{
+    VADisplayAttribute *display_attrs;
+    VAStatus status;
+    int va_major_version, va_minor_version;
+    int i, max_image_formats, max_subpic_formats, max_profiles;
+    int num_display_attrs, max_display_attrs;
+
+    va_dm = 2;
+    g_deint = 0;
+    g_deint_type = 2;
+    g_colorspace = 1;
+    g_scaling = 0;
+    if (subopt_parse(arg, subopts) != 0) {
+        mp_msg(MSGT_VO, MSGL_FATAL,
+               "\n-vo vaapi command line help:\n"
+               "Example: mplayer -vo vaapi:gl\n"
+               "\nOptions:\n"
+               "  dm\n"
+               "    0: use least-recently-used VA surface\n"
+               "    1: identify VA surface with MPI index\n"
+               "    2: auto-detect use of direct surface mapping (default)\n"
+               "  deint (all modes > 0 respect -field-dominance)\n"
+               "    0: no deinterlacing (default)\n"
+               "    1: only show first field\n"
+               "    2: bob deinterlacing\n"
+#if USE_VAAPI_COLORSPACE
+               "  colorspace\n"
+               "    0: guess based on video resolution\n"
+               "    1: ITU-R BT.601 (default)\n"
+               "    2: ITU-R BT.709\n"
+               "    3: SMPTE-240M\n"
+#endif
+#if USE_VAAPI_SCALING
+               "  scaling\n"
+               "    default: use implementation default (default)\n"
+               "    fast:    use fast scaling, but possibly with less quality\n"
+               "    hq:      use high-quality scaling, but possibly slower\n"
+               "    nla:     use non-linear anamorphic scaling\n"
+#endif
+#if CONFIG_GL
+               "  gl\n"
+               "    Enable OpenGL rendering\n"
+               "  glfinish\n"
+               "    Call glFinish() before swapping buffers\n"
+               "  tfp\n"
+               "    Use GLX texture-from-pixmap instead of VA/GLX extensions\n"
+#if USE_VAAPI_GLX_BIND
+               "  bind\n"
+               "    Use VA surface binding instead of copy\n"
+#endif
+               "  reflect\n"
+               "    Enable OpenGL reflection effects\n"
+#endif
+#if CONFIG_XRENDER
+               "  xrender\n"
+               "    Enable Xrender rendering, thus vaPutSurface() to a Pixmap\n"
+#endif
+               "\n" );
+        return -1;
+    }
+    if (gl_enabled && xr_enabled) {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] User requested both Xrender and OpenGL rendering\n");
+        return -1;
+    }
+    if (g_deint)
+        g_deint_type = g_deint;
+#if CONFIG_GL
+    if (gl_enabled)
+        mp_msg(MSGT_VO, MSGL_INFO, "[vo_vaapi] Using OpenGL rendering%s\n",
+               gl_reflect ? ", with reflection effects" : "");
+#endif
+#if CONFIG_XRENDER
+    if (xr_enabled)
+        mp_msg(MSGT_VO, MSGL_INFO, "[vo_vaapi] Using Xrender rendering\n");
+#endif
+#if USE_VAAPI_SCALING
+    if (g_scaling_arg.str) {
+        mp_msg(MSGT_VO, MSGL_INFO, "[vo_vaapi] Using '%s' scaling\n", g_scaling_arg.str);
+        setup_scaling(g_scaling_arg.str);
+    }
+#endif
+
+    stats_init();
+
+#if CONFIG_GL
+    if (gl_enabled && !init_mpglcontext(&gl_context, GLTYPE_X11))
+        return -1;
+    else
+#endif
+    if (!vo_init())
+        return -1;
+#if CONFIG_XRENDER
+    if (xr_enabled && !init_xrender())
+        return -1;
+#endif
+
+    va_context = calloc(1, sizeof(*va_context));
+    if (!va_context)
+        return -1;
+
+#if CONFIG_VAAPI_GLX
+    if (gl_enabled)
+        va_context->display = vaGetDisplayGLX(mDisplay);
+    else
+#endif
+        va_context->display = vaGetDisplay(mDisplay);
+    if (!va_context->display)
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): VA display %p\n", va_context->display);
+
+    status = vaInitialize(va_context->display, &va_major_version, &va_minor_version);
+    if (!check_status(status, "vaInitialize()"))
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): VA API version %d.%d\n",
+           va_major_version, va_minor_version);
+
+    max_image_formats = vaMaxNumImageFormats(va_context->display);
+    va_image_formats = calloc(max_image_formats, sizeof(*va_image_formats));
+    if (!va_image_formats)
+        return -1;
+    status = vaQueryImageFormats(va_context->display, va_image_formats, &va_num_image_formats);
+    if (!check_status(status, "vaQueryImageFormats()"))
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): %d image formats available\n",
+           va_num_image_formats);
+    for (i = 0; i < va_num_image_formats; i++)
+        mp_msg(MSGT_VO, MSGL_DBG2, "  %s\n", string_of_VAImageFormat(&va_image_formats[i]));
+
+    max_subpic_formats = vaMaxNumSubpictureFormats(va_context->display);
+    va_subpic_formats = calloc(max_subpic_formats, sizeof(*va_subpic_formats));
+    if (!va_subpic_formats)
+        return -1;
+    va_subpic_flags = calloc(max_subpic_formats, sizeof(*va_subpic_flags));
+    if (!va_subpic_flags)
+        return -1;
+    status = vaQuerySubpictureFormats(va_context->display, va_subpic_formats, va_subpic_flags, &va_num_subpic_formats);
+    if (!check_status(status, "vaQuerySubpictureFormats()"))
+        va_num_subpic_formats = 0; /* XXX: don't error out for IEGD */
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): %d subpicture formats available\n",
+           va_num_subpic_formats);
+    for (i = 0; i < va_num_subpic_formats; i++)
+        mp_msg(MSGT_VO, MSGL_DBG2, "  %s, flags 0x%x\n", string_of_VAImageFormat(&va_subpic_formats[i]), va_subpic_flags[i]);
+
+    max_profiles = vaMaxNumProfiles(va_context->display);
+    va_profiles = calloc(max_profiles, sizeof(*va_profiles));
+    if (!va_profiles)
+        return -1;
+    status = vaQueryConfigProfiles(va_context->display, va_profiles, &va_num_profiles);
+    if (!check_status(status, "vaQueryConfigProfiles()"))
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): %d profiles available\n",
+           va_num_profiles);
+    for (i = 0; i < va_num_profiles; i++)
+        mp_msg(MSGT_VO, MSGL_DBG2, "  %s\n", string_of_VAProfile(va_profiles[i]));
+
+    va_osd_subpicture      = VA_INVALID_ID;
+    va_osd_image.image_id  = VA_INVALID_ID;
+    va_eosd_subpicture     = VA_INVALID_ID;
+    va_eosd_image.image_id = VA_INVALID_ID;
+
+    max_display_attrs = vaMaxNumDisplayAttributes(va_context->display);
+    display_attrs = calloc(max_display_attrs, sizeof(*display_attrs));
+    if (display_attrs) {
+        num_display_attrs = 0;
+        status = vaQueryDisplayAttributes(va_context->display,
+                                          display_attrs, &num_display_attrs);
+        if (check_status(status, "vaQueryDisplayAttributes()")) {
+            for (i = 0; i < num_display_attrs; i++) {
+                VADisplayAttribute *attr;
+                switch (display_attrs[i].type) {
+                case VADisplayAttribBrightness:
+                    attr = &va_equalizer.brightness;
+                    break;
+                case VADisplayAttribContrast:
+                    attr = &va_equalizer.contrast;
+                    break;
+                case VADisplayAttribHue:
+                    attr = &va_equalizer.hue;
+                    break;
+                case VADisplayAttribSaturation:
+                    attr = &va_equalizer.saturation;
+                    break;
+                default:
+                    attr = NULL;
+                    break;
+                }
+                if (attr)
+                    *attr = display_attrs[i];
+            }
+        }
+        free(display_attrs);
+    }
+    return 0;
+}
+
+static void free_video_specific(void)
+{
+    int i;
+
+#if CONFIG_VAAPI_GLX
+    if (gl_surface) {
+        VAStatus status;
+        status = vaDestroySurfaceGLX(va_context->display, gl_surface);
+        check_status(status, "vaDestroySurfaceGLX()");
+        gl_surface = NULL;
+    }
+#endif
+
+    if (va_context && va_context->context_id) {
+        vaDestroyContext(va_context->display, va_context->context_id);
+        va_context->context_id = 0;
+    }
+
+    if (va_free_surfaces) {
+        for (i = 0; i < va_num_surfaces; i++) {
+            if (!va_free_surfaces[i])
+                continue;
+            if (va_free_surfaces[i]->image.image_id != VA_INVALID_ID) {
+                vaDestroyImage(va_context->display,
+                               va_free_surfaces[i]->image.image_id);
+                va_free_surfaces[i]->image.image_id = VA_INVALID_ID;
+            }
+            free(va_free_surfaces[i]);
+            va_free_surfaces[i] = NULL;
+        }
+        free(va_free_surfaces);
+        va_free_surfaces = NULL;
+        va_free_surfaces_head_index = 0;
+        va_free_surfaces_tail_index = 0;
+    }
+
+    g_output_surface = 0;
+    memset(g_output_surfaces, 0, sizeof(g_output_surfaces));
+
+    if (va_osd_palette) {
+        free(va_osd_palette);
+        va_osd_palette = NULL;
+    }
+
+    disable_eosd();
+    disable_osd();
+
+    if (va_eosd_subpicture != VA_INVALID_ID) {
+        vaDestroySubpicture(va_context->display, va_eosd_subpicture);
+        va_eosd_subpicture = VA_INVALID_ID;
+    }
+
+    if (va_eosd_image.image_id != VA_INVALID_ID) {
+        vaDestroyImage(va_context->display, va_eosd_image.image_id);
+        va_eosd_image.image_id = VA_INVALID_ID;
+    }
+
+    destroy_osd();
+
+    if (va_surface_ids) {
+        vaDestroySurfaces(va_context->display, va_surface_ids, va_num_surfaces);
+        free(va_surface_ids);
+        va_surface_ids = NULL;
+        va_num_surfaces = 0;
+    }
+
+    if (va_context && va_context->config_id) {
+        vaDestroyConfig(va_context->display, va_context->config_id);
+        va_context->config_id = 0;
+    }
+
+    if (va_entrypoints) {
+        free(va_entrypoints);
+        va_entrypoints = NULL;
+    }
+
+#if CONFIG_GL
+    if (gl_pixmap) {
+        x11_trap_errors();
+        mpglXDestroyPixmap(mDisplay, gl_pixmap);
+        XSync(mDisplay, False);
+        x11_untrap_errors();
+        gl_pixmap = None;
+    }
+
+    if (g_image_pixmap) {
+        XFreePixmap(mDisplay, g_image_pixmap);
+        g_image_pixmap = None;
+    }
+
+    if (gl_texture) {
+        glDeleteTextures(1, &gl_texture);
+        gl_texture = GL_NONE;
+    }
+#endif
+
+#if CONFIG_XRENDER
+    if (xr_window_picture) {
+        XRenderFreePicture(mDisplay, xr_window_picture);
+        xr_window_picture = None;
+    }
+#endif
+
+    g_is_visible = 0;
+}
+
+static void uninit(void)
+{
+    if (!vo_config_count)
+        return;
+
+    free_video_specific();
+
+    if (va_profiles) {
+        free(va_profiles);
+        va_profiles = NULL;
+    }
+
+    if (va_subpic_flags) {
+        free(va_subpic_flags);
+        va_subpic_flags = NULL;
+    }
+
+    if (va_subpic_formats) {
+        free(va_subpic_formats);
+        va_subpic_formats = NULL;
+    }
+
+    if (va_image_formats) {
+        free(va_image_formats);
+        va_image_formats = NULL;
+    }
+
+    if (va_context && va_context->display) {
+        vaTerminate(va_context->display);
+        va_context->display = NULL;
+    }
+
+    if (va_context) {
+        free(va_context);
+        va_context = NULL;
+    }
+
+#ifdef CONFIG_XF86VM
+    vo_vm_close();
+#endif
+#if CONFIG_XRENDER
+    if (xr_enabled)
+        uninit_xrender();
+#endif
+#if CONFIG_GL
+    if (gl_enabled)
+        uninit_mpglcontext(&gl_context);
+    else
+#endif
+    vo_x11_uninit();
+
+    stats_exit();
+}
+
+static int config_x11(uint32_t width, uint32_t height,
+                      uint32_t display_width, uint32_t display_height,
+                      uint32_t flags, char *title)
+{
+    Colormap cmap;
+    XVisualInfo visualInfo;
+    XVisualInfo *vi;
+    XSetWindowAttributes xswa;
+    unsigned long xswa_mask;
+    XWindowAttributes wattr;
+    int depth;
+
+#ifdef CONFIG_GUI
+    if (use_gui)
+        guiGetEvent(guiSetShVideo, 0);  // the GUI will set up / resize our window
+    else
+#endif
+    {
+#ifdef CONFIG_XF86VM
+        if (flags & VOFLAG_MODESWITCHING)
+            vo_vm_switch();
+#endif
+        XGetWindowAttributes(mDisplay, DefaultRootWindow(mDisplay), &wattr);
+        depth = wattr.depth;
+        if (depth != 15 && depth != 16 && depth != 24 && depth != 32)
+            depth = 24;
+        XMatchVisualInfo(mDisplay, mScreen, depth, TrueColor, &visualInfo);
+
+#if CONFIG_GL
+        if (gl_enabled) {
+            vi = glXChooseVisual(mDisplay, mScreen, gl_visual_attr);
+            if (!vi)
+                return -1;
+            cmap = XCreateColormap(mDisplay, mRootWin, vi->visual, AllocNone);
+            if (cmap == None)
+                return -1;
+        }
+        else
+#endif
+        {
+            vi = &visualInfo;
+            XMatchVisualInfo(mDisplay, mScreen, depth, TrueColor, vi);
+            cmap = CopyFromParent;
+        }
+
+        vo_x11_create_vo_window(vi,
+                                vo_dx, vo_dy, display_width, display_height,
+                                flags, cmap, "vaapi", title);
+
+        if (vi != &visualInfo)
+            XFree(vi);
+
+        xswa_mask             = CWBorderPixel | CWBackPixel;
+        xswa.border_pixel     = 0;
+        xswa.background_pixel = 0;
+        XChangeWindowAttributes(mDisplay, vo_window, xswa_mask, &xswa);
+
+#ifdef CONFIG_XF86VM
+        if (flags & VOFLAG_MODESWITCHING) {
+            /* Grab the mouse pointer in our window */
+            if (vo_grabpointer)
+                XGrabPointer(mDisplay, vo_window, True, 0,
+                             GrabModeAsync, GrabModeAsync,
+                             vo_window, None, CurrentTime);
+            XSetInputFocus(mDisplay, vo_window, RevertToNone, CurrentTime);
+        }
+#endif
+    }
+    return 0;
+}
+
+#if CONFIG_GL
+static GLXFBConfig *get_fbconfig_for_depth(int depth)
+{
+    GLXFBConfig *fbconfigs, *ret = NULL;
+    int          n_elements, i, found;
+    int          db, stencil, alpha, mipmap, rgba, value;
+
+    static GLXFBConfig *cached_config = NULL;
+    static int          have_cached_config = 0;
+
+    if (have_cached_config)
+        return cached_config;
+
+    fbconfigs = glXGetFBConfigs(mDisplay, mScreen, &n_elements);
+
+    db      = SHRT_MAX;
+    stencil = SHRT_MAX;
+    mipmap  = 0;
+    rgba    = 0;
+
+    found = n_elements;
+
+    for (i = 0; i < n_elements; i++) {
+        XVisualInfo *vi;
+        int          visual_depth;
+
+        vi = glXGetVisualFromFBConfig(mDisplay, fbconfigs[i]);
+        if (!vi)
+            continue;
+
+        visual_depth = vi->depth;
+        XFree(vi);
+
+        if (visual_depth != depth)
+            continue;
+
+        glXGetFBConfigAttrib(mDisplay, fbconfigs[i], GLX_ALPHA_SIZE, &alpha);
+        glXGetFBConfigAttrib(mDisplay, fbconfigs[i], GLX_BUFFER_SIZE, &value);
+        if (value != depth && (value - alpha) != depth)
+            continue;
+
+        value = 0;
+        if (depth == 32) {
+            glXGetFBConfigAttrib(mDisplay, fbconfigs[i],
+                                 GLX_BIND_TO_TEXTURE_RGBA_EXT, &value);
+            if (value)
+                rgba = 1;
+        }
+
+        if (!value) {
+            if (rgba)
+                continue;
+
+            glXGetFBConfigAttrib(mDisplay, fbconfigs[i],
+                                 GLX_BIND_TO_TEXTURE_RGB_EXT, &value);
+            if (!value)
+                continue;
+        }
+
+        glXGetFBConfigAttrib(mDisplay, fbconfigs[i], GLX_DOUBLEBUFFER, &value);
+        if (value > db)
+            continue;
+        db = value;
+
+        glXGetFBConfigAttrib(mDisplay, fbconfigs[i], GLX_STENCIL_SIZE, &value);
+        if (value > stencil)
+            continue;
+        stencil = value;
+
+        found = i;
+    }
+
+    if (found != n_elements) {
+        ret = malloc(sizeof(*ret));
+        *ret = fbconfigs[found];
+    }
+
+    if (n_elements)
+        XFree(fbconfigs);
+
+    have_cached_config = 1;
+    cached_config = ret;
+    return ret;
+}
+
+static int config_tfp(unsigned int width, unsigned int height)
+{
+    GLXFBConfig *fbconfig;
+    int attribs[7], i = 0;
+    const int depth = 24;
+
+    if (!mpglXBindTexImage || !mpglXReleaseTexImage) {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] No GLX texture-from-pixmap extension available\n");
+        return -1;
+    }
+
+    if (depth != 24 && depth != 32)
+        return -1;
+
+    g_image_pixmap = XCreatePixmap(mDisplay, vo_window, width, height, depth);
+    if (!g_image_pixmap) {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] Could not create X11 pixmap\n");
+        return -1;
+    }
+
+    fbconfig = get_fbconfig_for_depth(depth);
+    if (!fbconfig) {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] Could not find an FBConfig for 32-bit pixmap\n");
+        return -1;
+    }
+
+    attribs[i++] = GLX_TEXTURE_TARGET_EXT;
+    attribs[i++] = GLX_TEXTURE_2D_EXT;
+    attribs[i++] = GLX_TEXTURE_FORMAT_EXT;
+    if (depth == 24)
+        attribs[i++] = GLX_TEXTURE_FORMAT_RGB_EXT;
+    else if (depth == 32)
+        attribs[i++] = GLX_TEXTURE_FORMAT_RGBA_EXT;
+    attribs[i++] = GLX_MIPMAP_TEXTURE_EXT;
+    attribs[i++] = GL_FALSE;
+    attribs[i++] = None;
+
+    x11_trap_errors();
+    gl_pixmap = mpglXCreatePixmap(mDisplay, *fbconfig, g_image_pixmap, attribs);
+    XSync(mDisplay, False);
+    if (x11_untrap_errors()) {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] Could not create GLX pixmap\n");
+        return -1;
+    }
+    return 0;
+}
+
+static int config_glx(unsigned int width, unsigned int height)
+{
+    if (gl_context.setGlWindow(&gl_context) == SET_WINDOW_FAILED)
+        return -1;
+
+    glDisable(GL_DEPTH_TEST);
+    glDepthMask(GL_FALSE);
+    glDisable(GL_CULL_FACE);
+    glEnable(GL_TEXTURE_2D);
+    glDrawBuffer(vo_doublebuffering ? GL_BACK : GL_FRONT);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+    /* Create TFP resources */
+    if (gl_use_tfp && config_tfp(width, height) == 0)
+        mp_msg(MSGT_VO, MSGL_INFO, "[vo_vaapi] Using GLX texture-from-pixmap extension\n");
+    else
+        gl_use_tfp = 0;
+
+    /* Create OpenGL texture */
+    /* XXX: assume GL_ARB_texture_non_power_of_two is available */
+    glEnable(GL_TEXTURE_2D);
+    glGenTextures(1, &gl_texture);
+    mpglBindTexture(GL_TEXTURE_2D, gl_texture);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    if (!gl_use_tfp) {
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
+        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0,
+                     GL_BGRA, GL_UNSIGNED_BYTE, NULL);
+    }
+    mpglBindTexture(GL_TEXTURE_2D, 0);
+    glDisable(GL_TEXTURE_2D);
+
+    glClearColor(0.0, 0.0, 0.0, 1.0);
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    if (gl_build_font() < 0)
+        return -1;
+    return 0;
+}
+#endif
+
+#if CONFIG_XRENDER
+static XRenderPictFormat *get_xrender_argb32_format(void)
+{
+    static XRenderPictFormat *pictformat = NULL;
+    XRenderPictFormat templ;
+
+    const unsigned long mask =
+        PictFormatType      |
+        PictFormatDepth     |
+        PictFormatRed       |
+        PictFormatRedMask   |
+        PictFormatGreen     |
+        PictFormatGreenMask |
+        PictFormatBlue      |
+        PictFormatBlueMask  |
+        PictFormatAlphaMask;
+
+    if (pictformat)
+        return pictformat;
+
+    /* First, look for a 32-bit format which ignores the alpha component */
+    templ.depth            = 32;
+    templ.type             = PictTypeDirect;
+    templ.direct.red       = 16;
+    templ.direct.green     = 8;
+    templ.direct.blue      = 0;
+    templ.direct.redMask   = 0xff;
+    templ.direct.greenMask = 0xff;
+    templ.direct.blueMask  = 0xff;
+    templ.direct.alphaMask = 0;
+
+    pictformat = XRenderFindFormat(mDisplay, mask, &templ, 0);
+
+    if (!pictformat) {
+        /* Not all X servers support xRGB32 formats. However, the
+         * XRENDER spec says that they must support an ARGB32 format,
+         * so we can always return that.
+         */
+        pictformat = XRenderFindStandardFormat(mDisplay, PictStandardARGB32);
+        if (!pictformat)
+            mp_msg(MSGT_VO, MSGL_ERR, "XRENDER ARGB32 format not supported\n");
+    }
+    return pictformat;
+}
+
+static int create_xrender_specific(void)
+{
+    XRenderPictFormat *pictformat;
+
+    if (g_output_rect.width == 0 && g_output_rect.height == 0)
+        return 0;
+
+    g_image_pixmap = XCreatePixmap(mDisplay, vo_window, g_output_rect.width,
+                                   g_output_rect.height, 32);
+    if (!g_image_pixmap) {
+        mp_msg(MSGT_VO, MSGL_ERR, "Could not create video pixmap\n");
+        return -1;
+    }
+
+    pictformat = get_xrender_argb32_format();
+    if (!pictformat)
+        return -1;
+    xr_video_picture = XRenderCreatePicture(mDisplay, g_image_pixmap,
+                                            pictformat, 0, NULL);
+    if (!xr_video_picture) {
+        mp_msg(MSGT_VO, MSGL_ERR, "Could not create XRENDER backing picture for Pixmap\n");
+        return -1;
+    }
+    return 0;
+}
+
+static void free_xrender_specific(void)
+{
+    if (xr_video_picture) {
+        XRenderFreePicture(mDisplay, xr_video_picture);
+        xr_video_picture = None;
+    }
+
+    if (g_image_pixmap) {
+        XFreePixmap(mDisplay, g_image_pixmap);
+        g_image_pixmap = None;
+    }
+}
+
+static int reset_xrender_specific(void)
+{
+    free_xrender_specific();
+    return create_xrender_specific();
+}
+
+/* XXX: create a Pixmap as large as the display rect */
+static int config_xrender(unsigned int width, unsigned int height)
+{
+    XWindowAttributes wattr;
+    XRenderPictFormat *pictformat;
+
+    XGetWindowAttributes(mDisplay, vo_window, &wattr);
+    pictformat = XRenderFindVisualFormat(mDisplay, wattr.visual);
+    if (!pictformat) {
+        mp_msg(MSGT_VO, MSGL_ERR, "XRENDER does not support Window visual\n");
+        return -1;
+    }
+
+    xr_window_picture = XRenderCreatePicture(mDisplay, vo_window, pictformat,
+                                             0, NULL);
+    if (!xr_window_picture) {
+        mp_msg(MSGT_VO, MSGL_ERR, "Could not create XRENDER backing picture for Window\n");
+        return -1;
+    }
+    return reset_xrender_specific();
+}
+#endif
+
+static int config_vaapi(uint32_t width, uint32_t height, uint32_t format)
+{
+    VAConfigAttrib attrib;
+    VAStatus status;
+    int i, j, profile, entrypoint, max_entrypoints, num_surfaces;
+
+    /* Create video surfaces */
+    if (!IMGFMT_IS_VAAPI(format))
+        num_surfaces = MAX_OUTPUT_SURFACES;
+    else {
+        switch (IMGFMT_VAAPI_CODEC(format)) {
+        case IMGFMT_VAAPI_CODEC_MPEG2:
+            num_surfaces = NUM_VIDEO_SURFACES_MPEG2;
+            break;
+        case IMGFMT_VAAPI_CODEC_MPEG4:
+            num_surfaces = NUM_VIDEO_SURFACES_MPEG4;
+            break;
+        case IMGFMT_VAAPI_CODEC_H264:
+            num_surfaces = NUM_VIDEO_SURFACES_H264;
+            break;
+        case IMGFMT_VAAPI_CODEC_VC1:
+            num_surfaces = NUM_VIDEO_SURFACES_VC1;
+            break;
+        default:
+            num_surfaces = 0;
+            break;
+        }
+        if (num_surfaces == 0)
+            return -1;
+        if (!is_direct_mapping())
+            num_surfaces = FFMIN(2 * num_surfaces, MAX_VIDEO_SURFACES);
+    }
+    for (i = 0; i < num_surfaces; i++) {
+        struct vaapi_surface *surface;
+        surface = alloc_vaapi_surface(width, height, VA_RT_FORMAT_YUV420);
+        if (!surface)
+            return -1;
+    }
+    assert(va_num_surfaces == num_surfaces);
+
+#if CONFIG_VAAPI_GLX
+    /* Create GLX surfaces */
+    if (gl_enabled && !gl_use_tfp) {
+        status = vaCreateSurfaceGLX(va_context->display,
+                                    GL_TEXTURE_2D, gl_texture,
+                                    &gl_surface);
+        if (!check_status(status, "vaCreateSurfaceGLX()"))
+            return -1;
+    }
+#endif
+
+    /* Create OSD data */
+    va_osd_draw_alpha     = NULL;
+    va_osd_image.image_id = VA_INVALID_ID;
+    va_osd_image.buf      = VA_INVALID_ID;
+    va_osd_subpicture     = VA_INVALID_ID;
+    ensure_osd();
+
+    /* Create EOSD data */
+    va_eosd_draw_alpha     = NULL;
+    va_eosd_image.image_id = VA_INVALID_ID;
+    va_eosd_image.buf      = VA_INVALID_ID;
+    va_eosd_subpicture     = VA_INVALID_ID;
+    for (i = 0; va_eosd_info[i].format; i++) {
+        for (j = 0; j < va_num_subpic_formats; j++)
+            if (va_subpic_formats[j].fourcc == va_eosd_info[i].format)
+                break;
+        if (j < va_num_subpic_formats &&
+            vaCreateImage(va_context->display, &va_subpic_formats[j],
+                          width, height, &va_eosd_image) == VA_STATUS_SUCCESS)
+            break;
+    }
+    if (va_eosd_info[i].format &&
+        vaCreateSubpicture(va_context->display, va_eosd_image.image_id,
+                           &va_eosd_subpicture) == VA_STATUS_SUCCESS) {
+        va_eosd_draw_alpha = va_eosd_info[i].draw_alpha;
+        mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] Using %s surface for EOSD\n",
+               string_of_VAImageFormat(&va_eosd_image.format));
+    }
+
+    /* Allocate VA images */
+    if (!IMGFMT_IS_VAAPI(format)) {
+        VAImageFormat *image_format = VAImageFormat_from_imgfmt(format);
+        if (!image_format)
+            return -1;
+        for (i = 0; i < va_num_surfaces; i++) {
+            struct vaapi_surface * const s = va_free_surfaces[i];
+            s->is_bound = 0;
+            status = vaDeriveImage(va_context->display, s->id, &s->image);
+            if (status == VA_STATUS_SUCCESS) {
+                /* vaDeriveImage() is supported, check format */
+                if (s->image.format.fourcc != image_format->fourcc) {
+                    vaDestroyImage(va_context->display, s->image.image_id);
+                    return -1;
+                }
+                if (s->image.width == width && s->image.height == height) {
+                    s->is_bound = 1;
+                    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] Using vaDeriveImage()\n");
+                }
+                else {
+                    vaDestroyImage(va_context->display, s->image.image_id);
+                    status = VA_STATUS_ERROR_OPERATION_FAILED;
+                }
+                
+            }
+            if (status != VA_STATUS_SUCCESS) {
+                status = vaCreateImage(va_context->display, image_format,
+                                       width, height, &s->image);
+                if (!check_status(status, "vaCreateImage()"))
+                    return -1;
+            }
+        }
+        return 0;
+    }
+
+    /* Check profile */
+    profile = VAProfile_from_imgfmt(format);
+    if (profile < 0)
+        return -1;
+
+    /* Check entry-point (only VLD for now) */
+    max_entrypoints = vaMaxNumEntrypoints(va_context->display);
+    va_entrypoints = calloc(max_entrypoints, sizeof(*va_entrypoints));
+    if (!va_entrypoints)
+        return -1;
+
+    status = vaQueryConfigEntrypoints(va_context->display, profile,
+                                      va_entrypoints, &va_num_entrypoints);
+    if (!check_status(status, "vaQueryConfigEntrypoints()"))
+        return -1;
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] config_vaapi(%s): %d entrypoints available\n",
+           string_of_VAProfile(profile), va_num_entrypoints);
+    for (i = 0; i < va_num_entrypoints; i++)
+        mp_msg(MSGT_VO, MSGL_DBG2, "  %s\n", string_of_VAEntrypoint(va_entrypoints[i]));
+
+    entrypoint = VAEntrypoint_from_imgfmt(format);
+    if (entrypoint != VAEntrypointVLD)
+        return -1;
+
+    /* Check chroma format (only 4:2:0 for now) */
+    attrib.type = VAConfigAttribRTFormat;
+    status = vaGetConfigAttributes(va_context->display, profile, entrypoint, &attrib, 1);
+    if (!check_status(status, "vaGetConfigAttributes()"))
+        return -1;
+    if ((attrib.value & VA_RT_FORMAT_YUV420) == 0)
+        return -1;
+
+    /* Create a configuration for the decode pipeline */
+    status = vaCreateConfig(va_context->display, profile, entrypoint, &attrib, 1, &va_context->config_id);
+    if (!check_status(status, "vaCreateConfig()"))
+        return -1;
+
+    /* Create a context for the decode pipeline */
+    status = vaCreateContext(va_context->display, va_context->config_id,
+                             width, height, VA_PROGRESSIVE,
+                             va_surface_ids, va_num_surfaces,
+                             &va_context->context_id);
+    if (!check_status(status, "vaCreateContext()"))
+        return -1;
+    return 0;
+}
+
+static int config(uint32_t width, uint32_t height,
+                  uint32_t display_width, uint32_t display_height,
+                  uint32_t flags, char *title, uint32_t format)
+{
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] config(): size %dx%d, display size %dx%d, flags %x, title '%s', format %x (%s)\n",
+           width, height, display_width, display_height, flags, title, format, vo_format_name(format));
+
+    free_video_specific();
+
+    if (config_x11(width, height, display_width, display_height, flags, title) < 0)
+        return -1;
+
+#if CONFIG_GL
+    if (gl_enabled && config_glx(width, height) < 0)
+        return -1;
+#endif
+
+#if CONFIG_XRENDER
+    if (xr_enabled && config_xrender(width, height) < 0)
+        return -1;
+#endif
+
+    if (config_vaapi(width, height, format) < 0)
+        return -1;
+
+    g_is_visible   = 0;
+    g_is_paused    = 0;
+    g_image_width  = width;
+    g_image_height = height;
+    g_image_format = format;
+    resize();
+    return 0;
+}
+
+static int query_format(uint32_t format)
+{
+    const int default_caps = (VFCAP_CSP_SUPPORTED |
+                              VFCAP_CSP_SUPPORTED_BY_HW |
+                              VFCAP_HWSCALE_UP |
+                              VFCAP_HWSCALE_DOWN |
+                              VFCAP_OSD |
+                              VFCAP_EOSD);
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] query_format(): format %x (%s)\n",
+           format, vo_format_name(format));
+
+    switch (format) {
+    case IMGFMT_VAAPI_MPEG2:
+    case IMGFMT_VAAPI_MPEG4:
+    case IMGFMT_VAAPI_H263:
+    case IMGFMT_VAAPI_H264:
+    case IMGFMT_VAAPI_WMV3:
+    case IMGFMT_VAAPI_VC1:
+        return default_caps | VOCAP_NOSLICES;
+    case IMGFMT_NV12:
+    case IMGFMT_YV12:
+    case IMGFMT_I420:
+    case IMGFMT_IYUV:
+        if (VAImageFormat_from_imgfmt(format))
+            return default_caps;
+        break;
+    }
+    return 0;
+}
+
+static inline int get_field_flags(int i)
+{
+    return (g_deint && (g_image_fields & MP_IMGFIELD_INTERLACED) ? 
+            (((!!(g_image_fields & MP_IMGFIELD_TOP_FIRST)) ^ i) == 0 ?
+             VA_BOTTOM_FIELD : VA_TOP_FIELD) : VA_FRAME_PICTURE);
+}
+
+static inline int get_colorspace_flags(void)
+{
+    int csp = 0;
+#if USE_VAAPI_COLORSPACE
+    switch (g_colorspace) {
+    case 0:
+        csp = ((g_image_width >= 1280 || g_image_height > 576) ?
+               VA_SRC_BT709 : VA_SRC_BT601);
+        break;
+    case 1:
+        csp = VA_SRC_BT601;
+        break;
+    case 2:
+        csp = VA_SRC_BT709;
+        break;
+    case 3:
+        csp = VA_SRC_SMPTE_240;
+        break;
+    default:
+        assert(0);
+        break;
+    }
+#endif
+    return csp;
+}
+
+static void put_surface_x11(struct vaapi_surface *surface)
+{
+    VAStatus status;
+    int i;
+
+    for (i = 0; i <= !!(g_deint > 1); i++) {
+        const unsigned int flags = (get_field_flags(i) |
+                                    get_colorspace_flags() |
+                                    g_scaling);
+        status = vaPutSurface(va_context->display,
+                              surface->id,
+                              vo_window,
+                              0, 0, g_image_width, g_image_height,
+                              g_output_rect.left,
+                              g_output_rect.top,
+                              g_output_rect.width,
+                              g_output_rect.height,
+                              NULL, 0,
+                              flags);
+        if (!check_status(status, "vaPutSurface()"))
+            return;
+    }
+}
+
+#if CONFIG_GL
+static void put_surface_glx(struct vaapi_surface *surface)
+{
+    VAStatus status;
+    int i;
+
+    if (gl_use_tfp) {
+        for (i = 0; i <= !!(g_deint > 1); i++) {
+            const unsigned int flags = (get_field_flags(i) |
+                                        get_colorspace_flags() |
+                                        g_scaling);
+            status = vaPutSurface(va_context->display,
+                                  surface->id,
+                                  g_image_pixmap,
+                                  0, 0, g_image_width, g_image_height,
+                                  0, 0, g_image_width, g_image_height,
+                                  NULL, 0,
+                                  flags);
+            if (!check_status(status, "vaPutSurface()"))
+                return;
+        }
+        g_output_surfaces[g_output_surface] = surface;
+        return;
+    }
+
+#if CONFIG_VAAPI_GLX
+    if (gl_binding) {
+#if USE_VAAPI_GLX_BIND
+        for (i = 0; i <= !!(g_deint > 1); i++) {
+            const unsigned int flags = (get_field_flags(i) |
+                                        get_colorspace_flags() |
+                                        g_scaling);
+            status = vaAssociateSurfaceGLX(va_context->display,
+                                           gl_surface,
+                                           surface->id,
+                                           flags);
+            if (!check_status(status, "vaAssociateSurfaceGLX()"))
+                return;
+        }
+#else
+        mp_msg(MSGT_VO, MSGL_WARN, "vaAssociateSurfaceGLX() is not implemented\n");
+        gl_binding = 0;
+#endif
+    }
+
+    if (!gl_binding) {
+        for (i = 0; i <= !!(g_deint > 1); i++) {
+            const unsigned int flags = (get_field_flags(i) |
+                                        get_colorspace_flags() |
+                                        g_scaling);
+            status = vaCopySurfaceGLX(va_context->display,
+                                      gl_surface,
+                                      surface->id,
+                                      flags);
+
+            if (status == VA_STATUS_ERROR_UNIMPLEMENTED) {
+                mp_msg(MSGT_VO, MSGL_WARN,
+                       "[vo_vaapi] vaCopySurfaceGLX() is not implemented\n");
+                gl_binding = 1;
+            }
+            else {
+                if (!check_status(status, "vaCopySurfaceGLX()"))
+                    return;
+            }
+        }
+    }
+#endif
+    g_output_surfaces[g_output_surface] = surface;
+}
+
+static int glx_bind_texture(void)
+{
+    glEnable(GL_TEXTURE_2D);
+    mpglBindTexture(GL_TEXTURE_2D, gl_texture);
+
+    if (gl_use_tfp) {
+        x11_trap_errors();
+        mpglXBindTexImage(mDisplay, gl_pixmap, GLX_FRONT_LEFT_EXT, NULL);
+        XSync(mDisplay, False);
+        if (x11_untrap_errors())
+            mp_msg(MSGT_VO, MSGL_WARN, "[vo_vaapi] Update bind_tex_image failed\n");
+    }
+
+#if USE_VAAPI_GLX_BIND
+    if (gl_binding) {
+        VAStatus status;
+        status = vaBeginRenderSurfaceGLX(va_context->display, gl_surface);
+        if (!check_status(status, "vaBeginRenderSurfaceGLX()"))
+            return -1;
+    }
+#endif
+    return 0;
+}
+
+static int glx_unbind_texture(void)
+{
+    if (gl_use_tfp) {
+        x11_trap_errors();
+        mpglXReleaseTexImage(mDisplay, gl_pixmap, GLX_FRONT_LEFT_EXT);
+        if (x11_untrap_errors())
+            mp_msg(MSGT_VO, MSGL_WARN, "[vo_vaapi] Failed to release?\n");
+    }
+
+#if USE_VAAPI_GLX_BIND
+    if (gl_binding) {
+        VAStatus status;
+        status = vaEndRenderSurfaceGLX(va_context->display, gl_surface);
+        if (!check_status(status, "vaEndRenderSurfaceGLX()"))
+            return -1;
+    }
+#endif
+
+    mpglBindTexture(GL_TEXTURE_2D, 0);
+    glDisable(GL_TEXTURE_2D);
+    return 0;
+}
+
+static void render_background(void)
+{
+    /* Original code from Mirco Muller (MacSlow):
+       <http://cgit.freedesktop.org/~macslow/gl-gst-player/> */
+    GLfloat fStartX = 0.0f;
+    GLfloat fStartY = 0.0f;
+    GLfloat fWidth  = (GLfloat)vo_dwidth;
+    GLfloat fHeight = (GLfloat)vo_dheight;
+
+    glBegin(GL_QUADS);
+    {
+        /* top third, darker grey to white */
+        glColor3f(0.85f, 0.85f, 0.85f);
+        glVertex3f(fStartX, fStartY, 0.0f);
+        glColor3f(0.85f, 0.85f, 0.85f);
+        glVertex3f(fStartX + fWidth, fStartY, 0.0f);
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX + fWidth, fStartY + fHeight / 3.0f, 0.0f);
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX, fStartY + fHeight / 3.0f, 0.0f);
+
+        /* middle third, just plain white */
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX, fStartY + fHeight / 3.0f, 0.0f);
+        glVertex3f(fStartX + fWidth, fStartY + fHeight / 3.0f, 0.0f);
+        glVertex3f(fStartX + fWidth, fStartY + 2.0f * fHeight / 3.0f, 0.0f);
+        glVertex3f(fStartX, fStartY + 2.0f * fHeight / 3.0f, 0.0f);
+
+        /* bottom third, white to lighter grey */
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX, fStartY + 2.0f * fHeight / 3.0f, 0.0f);
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX + fWidth, fStartY + 2.0f * fHeight / 3.0f, 0.0f);
+        glColor3f(0.62f, 0.66f, 0.69f);
+        glVertex3f(fStartX + fWidth, fStartY + fHeight, 0.0f);
+        glColor3f(0.62f, 0.66f, 0.69f);
+        glVertex3f(fStartX, fStartY + fHeight, 0.0f);
+    }
+    glEnd();
+}
+
+static void render_frame(void)
+{
+    struct vo_rect * const r = &g_output_rect;
+
+    if (glx_bind_texture() < 0)
+        return;
+    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+    glBegin(GL_QUADS);
+    {
+        glTexCoord2f(0.0f, 0.0f); glVertex2i(r->left, r->top);
+        glTexCoord2f(0.0f, 1.0f); glVertex2i(r->left, r->bottom);
+        glTexCoord2f(1.0f, 1.0f); glVertex2i(r->right, r->bottom);
+        glTexCoord2f(1.0f, 0.0f); glVertex2i(r->right, r->top);
+    }
+    glEnd();
+    if (glx_unbind_texture() < 0)
+        return;
+}
+
+static void render_reflection(void)
+{
+    struct vo_rect * const r = &g_output_rect;
+    const unsigned int rh  = g_output_rect.height / 5;
+    GLfloat ry = 1.0f - (GLfloat)rh / (GLfloat)r->height;
+
+    if (glx_bind_texture() < 0)
+        return;
+    glBegin(GL_QUADS);
+    {
+        glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+        glTexCoord2f(0.0f, 1.0f); glVertex2i(r->left, r->top);
+        glTexCoord2f(1.0f, 1.0f); glVertex2i(r->right, r->top);
+
+        glColor4f(1.0f, 1.0f, 1.0f, 0.0f);
+        glTexCoord2f(1.0f, ry); glVertex2i(r->right, r->top + rh);
+        glTexCoord2f(0.0f, ry); glVertex2i(r->left, r->top + rh);
+    }
+    glEnd();
+    if (glx_unbind_texture() < 0)
+        return;
+}
+
+static void flip_page_glx(void)
+{
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    if (gl_reflect) {
+        render_background();
+
+        glPushMatrix();
+        glRotatef(20.0f, 0.0f, 1.0f, 0.0f);
+        glTranslatef(50.0f, 0.0f, 0.0f);
+    }
+
+    render_frame();
+
+    if (gl_reflect) {
+        glPushMatrix();
+        glTranslatef(0.0, (GLfloat)g_output_rect.height + 5.0f, 0.0f);
+        render_reflection();
+        glPopMatrix();
+        glPopMatrix();
+    }
+
+    if (cpu_stats) {
+        gl_draw_rectangle(0, 0, vo_dwidth, 32, 0x000000ff);
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glRasterPos2i(16, 20);
+        gl_printf("MPlayer: %.1f%% of CPU @ %u MHz", cpu_usage, cpu_frequency);
+    }
+
+    if (gl_finish)
+        mpglFinish();
+    gl_context.swapGlBuffers(&gl_context);
+
+    if (vo_fs) /* avoid flickering borders in fullscreen mode */
+        glClear(GL_COLOR_BUFFER_BIT);
+}
+#endif
+
+#if CONFIG_XRENDER
+static void put_surface_xrender(struct vaapi_surface *surface)
+{
+    VAStatus status;
+    int i;
+
+    for (i = 0; i <= !!(g_deint > 1); i++) {
+        const unsigned int flags = (get_field_flags(i) |
+                                    get_colorspace_flags() |
+                                    g_scaling);
+        status = vaPutSurface(va_context->display,
+                              surface->id,
+                              g_image_pixmap,
+                              0, 0, g_image_width, g_image_height,
+                              0, 0, g_output_rect.width, g_output_rect.height,
+                              NULL, 0,
+                              flags);
+        if (!check_status(status, "vaPutSurface()"))
+            return;
+        XRenderComposite(mDisplay,
+                         PictOpSrc, xr_video_picture, 0, xr_window_picture,
+                         0, 0,
+                         0, 0,
+                         g_output_rect.left, g_output_rect.top,
+                         g_output_rect.width, g_output_rect.height);
+    }
+}
+#endif
+
+static void put_surface(struct vaapi_surface *surface)
+{
+    if (!surface || surface->id == VA_INVALID_SURFACE)
+        return;
+
+#if CONFIG_GL
+    if (gl_enabled)
+        put_surface_glx(surface);
+    else
+#endif
+#if CONFIG_XRENDER
+    if (xr_enabled)
+        put_surface_xrender(surface);
+    else
+#endif
+        put_surface_x11(surface);
+}
+
+static int draw_slice(uint8_t * image[], int stride[],
+                      int w, int h, int x, int y)
+{
+    struct vaapi_surface * const surface = va_free_surfaces[g_output_surface];
+    VAImage * const va_image = &surface->image;
+    VAStatus status;
+    uint8_t *image_data = NULL;
+    uint8_t *dst[3] = { 0, };
+    unsigned int dst_stride[3];
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] draw_slice(): location (%d,%d), size %dx%d\n", x, y, w, h);
+
+    status = vaMapBuffer(va_context->display, va_image->buf,
+                         (void *)&image_data);
+    if (!check_status(status, "vaMapBuffer()"))
+        return VO_FALSE;
+
+    dst_stride[0] = va_image->pitches[0];
+    dst[0] = image_data + va_image->offsets[0] + y * dst_stride[0] + x;
+
+    memcpy_pic(dst[0], image[0], w, h, dst_stride[0], stride[0]);
+
+    x /= 2;
+    y /= 2;
+    w /= 2;
+    h /= 2;
+
+    if (g_image_format == IMGFMT_YV12) {
+        /* MPlayer's YV12 is actually I420, so swap U/V components */
+        dst_stride[1] = va_image->pitches[2];
+        dst[1] = image_data + va_image->offsets[2] + y * dst_stride[1] + x;
+        dst_stride[2] = va_image->pitches[1];
+        dst[2] = image_data + va_image->offsets[1] + y * dst_stride[2] + x;
+    }
+    else {
+        if (image[1]) {
+            dst_stride[1] = va_image->pitches[1];
+            dst[1] = image_data + va_image->offsets[1] + y * dst_stride[1] + x;
+        }
+        if (image[2]) {
+            dst_stride[2] = va_image->pitches[2];
+            dst[2] = image_data + va_image->offsets[2] + y * dst_stride[2] + x;
+        }
+    }
+
+    if (image[1]) /* RGBA only has a single plane */
+        memcpy_pic(dst[1], image[1], w, h, dst_stride[1], stride[1]);
+
+    if (image[2]) /* NV12 only has two planes */
+        memcpy_pic(dst[2], image[2], w, h, dst_stride[2], stride[2]);
+
+    status = vaUnmapBuffer(va_context->display, surface->image.buf);
+    if (!check_status(status, "vaUnmapBuffer()"))
+        return VO_FALSE;
+
+    return VO_TRUE;
+}
+
+static int draw_frame(uint8_t * src[])
+{
+    mp_msg(MSGT_VO,MSGL_INFO, MSGTR_LIBVO_X11_DrawFrameCalled);
+
+    return -1;
+}
+
+static void draw_osd(void)
+{
+    VAStatus status;
+    const int osd_width  = va_osd_image.width;
+    const int osd_height = va_osd_image.height;
+
+    ensure_osd();
+    if (va_osd_image.image_id == VA_INVALID_ID)
+        return;
+
+    if (!va_osd_draw_alpha)
+        return;
+
+    if (!vo_update_osd(osd_width, osd_height))
+        return;
+ 
+    if (!vo_osd_check_range_update(0, 0, osd_width, osd_height)) {
+        disable_osd();
+        return;
+    }
+
+    status = vaMapBuffer(va_context->display, va_osd_image.buf,
+                         (void *)&va_osd_image_data);
+    if (!check_status(status, "vaMapBuffer()"))
+        return;
+
+    memset(va_osd_image_data, 0, va_osd_image.data_size);
+
+    vo_draw_text(osd_width, osd_height, va_osd_draw_alpha);
+
+    status = vaUnmapBuffer(va_context->display, va_osd_image.buf);
+    if (!check_status(status, "vaUnmapBuffer()"))
+        return;
+    va_osd_image_data = NULL;
+
+    enable_osd();
+}
+
+static void draw_eosd(struct mp_eosd_image_list *imgs)
+{
+    struct mp_eosd_image *img = eosd_image_first(imgs);
+    struct mp_eosd_image *i;
+    VAStatus status;
+
+    if (!va_eosd_draw_alpha)
+        return;
+
+    // Nothing changed, no need to redraw
+    if (imgs->changed == 0)
+        return;
+
+    // There's nothing to render!
+    if (!img) {
+        disable_eosd();
+        return;
+    }
+
+    if (imgs->changed == 1)
+        goto eosd_skip_upload;
+
+    status = vaMapBuffer(va_context->display, va_eosd_image.buf,
+                         (void *)&va_eosd_image_data);
+    if (!check_status(status, "vaMapBuffer()"))
+        return;
+
+    memset(va_eosd_image_data, 0, va_eosd_image.data_size);
+
+    for (i = img; i; i = i->next)
+        va_eosd_draw_alpha(i->bitmap, i->w, i->h, i->stride,
+                           i->dst_x, i->dst_y, i->color);
+
+    status = vaUnmapBuffer(va_context->display, va_eosd_image.buf);
+    if (!check_status(status, "vaUnmapBuffer()"))
+        return;
+    va_eosd_image_data = NULL;
+
+eosd_skip_upload:
+    enable_eosd();
+}
+
+static void flip_page(void)
+{
+    struct vaapi_surface *surface;
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] flip_page()\n");
+
+    surface = g_output_surfaces[g_output_surface];
+    if (!surface)
+        return;
+
+    put_surface(surface);
+    g_output_surface = (g_output_surface + 1) % MAX_OUTPUT_SURFACES;
+    g_is_visible     = 1;
+
+#if CONFIG_GL
+    if (gl_enabled)
+        flip_page_glx();
+#endif
+}
+
+static struct vaapi_surface *get_surface(mp_image_t *mpi)
+{
+    struct vaapi_surface *surface;
+
+    if (mpi->type == MP_IMGTYPE_NUMBERED && is_direct_mapping()) {
+        assert(mpi->number < va_num_surfaces);
+        surface = va_free_surfaces[mpi->number];
+        return surface;
+    }
+
+    /* Push current surface to a free slot */
+    if (mpi->priv) {
+        assert(!va_free_surfaces[va_free_surfaces_tail_index]);
+        va_free_surfaces[va_free_surfaces_tail_index] = mpi->priv;
+        va_free_surfaces_tail_index = (va_free_surfaces_tail_index + 1) % va_num_surfaces;
+    }
+
+    /* Pop the least recently used free surface */
+    assert(va_free_surfaces[va_free_surfaces_head_index]);
+    surface = va_free_surfaces[va_free_surfaces_head_index];
+    va_free_surfaces[va_free_surfaces_head_index] = NULL;
+    va_free_surfaces_head_index = (va_free_surfaces_head_index + 1) % va_num_surfaces;
+    return surface;
+}
+
+static uint32_t get_image(mp_image_t *mpi)
+{
+    struct vaapi_surface *surface;
+
+    if (mpi->type != MP_IMGTYPE_NUMBERED)
+        return VO_FALSE;
+
+    if (!IMGFMT_IS_VAAPI(g_image_format))
+        return VO_FALSE;
+
+    surface = get_surface(mpi);
+    if (!surface)
+        return VO_FALSE;
+
+    mpi->flags |= MP_IMGFLAG_DIRECT;
+    mpi->stride[0] = mpi->stride[1] = mpi->stride[2] = mpi->stride[3] = 0;
+    mpi->planes[0] = mpi->planes[1] = mpi->planes[2] = mpi->planes[3] = NULL;
+    mpi->planes[0] = (char *)surface;
+    mpi->planes[3] = (char *)(uintptr_t)surface->id;
+    mpi->num_planes = 1;
+    mpi->priv = surface;
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] get_image(): surface 0x%08x\n", surface->id);
+
+    return VO_TRUE;
+}
+
+static int put_image(mp_image_t *mpi, struct vaapi_surface *surface)
+{
+    VAStatus status;
+ 
+    if ((mpi->flags & (MP_IMGFLAG_PLANAR|MP_IMGFLAG_YUV)) != (MP_IMGFLAG_PLANAR|MP_IMGFLAG_YUV))
+        return VO_FALSE;
+
+    if (!(mpi->flags & MP_IMGFLAG_DRAW_CALLBACK)) {
+        if (!draw_slice(mpi->planes, mpi->stride, mpi->w, mpi->h, 0, 0))
+            return VO_FALSE;
+    }
+
+    if (!surface->is_bound) {
+        status = vaPutImage2(va_context->display,
+                             surface->id,
+                             surface->image.image_id,
+                             mpi->x, mpi->y, mpi->w, mpi->h,
+                             mpi->x, mpi->y, mpi->w, mpi->h);
+        if (!check_status(status, "vaPutImage()"))
+            return VO_FALSE;
+    }
+
+    return VO_TRUE;
+}
+
+static uint32_t draw_image(mp_image_t *mpi)
+{
+    struct vaapi_surface *surface = (struct vaapi_surface *)mpi->priv;
+
+    g_image_fields = mpi->fields;
+
+    if (!IMGFMT_IS_VAAPI(mpi->imgfmt)) {
+        /* XXX: no direct rendering in non-accelerated mode */
+        surface = va_free_surfaces[g_output_surface];
+        if (!put_image(mpi, surface))
+            return VO_FALSE;
+    }
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] draw_image(): surface 0x%08x\n", surface->id);
+
+    g_output_surfaces[g_output_surface] = surface;
+
+    if (cpu_stats) {
+        static uint64_t ticks;
+        if ((ticks++ % 30) == 0) {
+            cpu_frequency = get_cpu_frequency();
+            cpu_usage = get_cpu_usage(CPU_USAGE_QUANTUM);
+        }
+    }
+    return VO_TRUE;
+}
+
+static void check_events(void)
+{
+    int events = vo_x11_check_events(mDisplay);
+
+    if (events & VO_EVENT_RESIZE)
+        resize();
+
+    if ((events & (VO_EVENT_EXPOSE|VO_EVENT_RESIZE)) && g_is_paused) {
+        /* Redraw the last visible buffer  */
+        if (g_is_visible) {
+            struct vaapi_surface *surface = g_output_surfaces[g_output_surface];
+            if (surface)
+                put_surface(surface);
+        }
+    }
+}
+
+static VADisplayAttribute *get_display_attribute(const char *name)
+{
+    VADisplayAttribute *attr;
+    if (!strcasecmp(name, "brightness"))
+        attr = &va_equalizer.brightness;
+    else if (!strcasecmp(name, "contrast"))
+        attr = &va_equalizer.contrast;
+    else if (!strcasecmp(name, "saturation"))
+        attr = &va_equalizer.saturation;
+    else if (!strcasecmp(name, "hue"))
+        attr = &va_equalizer.hue;
+    else
+        attr = NULL;
+    return attr;
+}
+
+static int get_equalizer(const char *name, int *value)
+{
+    VADisplayAttribute * const attr = get_display_attribute(name);
+    int r;
+
+    if (!attr || !(attr->flags & VA_DISPLAY_ATTRIB_GETTABLE))
+        return VO_NOTIMPL;
+
+    /* normalize to -100 .. 100 range */
+    r = attr->max_value - attr->min_value;
+    if (r == 0)
+        return VO_NOTIMPL;
+    *value = ((attr->value - attr->min_value) * 200) / r - 100;
+    return VO_TRUE;
+}
+
+static int set_equalizer(const char *name, int value)
+{
+    VADisplayAttribute * const attr = get_display_attribute(name);
+    VAStatus status;
+    int r;
+
+    if (!attr || !(attr->flags & VA_DISPLAY_ATTRIB_SETTABLE))
+        return VO_NOTIMPL;
+
+    /* normalize to attribute value range */
+    r = attr->max_value - attr->min_value;
+    if (r == 0)
+        return VO_NOTIMPL;
+    attr->value = ((value + 100) * r) / 200 + attr->min_value;
+
+    status = vaSetDisplayAttributes(va_context->display, attr, 1);
+    if (!check_status(status, "vaSetDisplayAttributes()"))
+        return VO_FALSE;
+    return VO_TRUE;
+}
+
+static int control(uint32_t request, void *data)
+{
+    switch (request) {
+    case VOCTRL_GET_DEINTERLACE:
+        *(int*)data = g_deint;
+        return VO_TRUE;
+    case VOCTRL_SET_DEINTERLACE:
+        g_deint = *(int*)data;
+        if (g_deint)
+            g_deint = g_deint_type;
+        return VO_TRUE;
+    case VOCTRL_PAUSE:
+        return (g_is_paused = 1);
+    case VOCTRL_RESUME:
+        return (g_is_paused = 0);
+    case VOCTRL_QUERY_FORMAT:
+        return query_format(*((uint32_t *)data));
+    case VOCTRL_GET_IMAGE:
+        return get_image(data);
+    case VOCTRL_DRAW_IMAGE:
+        return draw_image(data);
+    case VOCTRL_GUISUPPORT:
+        return VO_TRUE;
+    case VOCTRL_BORDER:
+        vo_x11_border();
+        resize();
+        return VO_TRUE;
+    case VOCTRL_FULLSCREEN:
+        vo_x11_fullscreen();
+        resize();
+        return VO_TRUE;
+    case VOCTRL_SET_EQUALIZER: {
+        vf_equalizer_t *eq = data;
+        if (g_image_format == IMGFMT_BGRA)
+            return VO_NOTIMPL;
+
+        return set_equalizer(eq->item, eq->value);
+    }
+    case VOCTRL_GET_EQUALIZER: {
+        vf_equalizer_t *eq = data;
+        return get_equalizer(eq->item, &eq->value);
+    }
+    case VOCTRL_ONTOP:
+        vo_x11_ontop();
+        return VO_TRUE;
+    case VOCTRL_UPDATE_SCREENINFO:
+        update_xinerama_info();
+        return VO_TRUE;
+    case VOCTRL_GET_PANSCAN:
+        return VO_TRUE;
+    case VOCTRL_SET_PANSCAN:
+        resize();
+        return VO_TRUE;
+    case VOCTRL_GET_HWACCEL_CONTEXT:
+        *((void **)data) = va_context;
+        return VO_TRUE;
+    case VOCTRL_DRAW_EOSD:
+        if (!data)
+            return VO_FALSE;
+        draw_eosd(data);
+        return VO_TRUE;
+    case VOCTRL_GET_EOSD_RES: {
+        struct mp_eosd_settings *r = data;
+        r->mt = r->mb = r->ml = r->mr = 0;
+        r->srcw = g_image_width;
+        r->srch = g_image_height;
+        r->w    = g_image_width;
+        r->h    = g_image_height;
+        return VO_TRUE;
+    }
+    }
+    return VO_NOTIMPL;
+}
diff -Naur mplayer-1.0_rc4_p20120109/Makefile mplayer-1.0_rc4_p20120109-new/Makefile
--- mplayer-1.0_rc4_p20120109/Makefile	2012-01-09 14:46:51.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/Makefile	2012-01-16 15:51:41.000000000 +0100
@@ -599,6 +599,7 @@
 SRCS_MPLAYER-$(TGA)           += libvo/vo_tga.c
 SRCS_MPLAYER-$(V4L2)          += libvo/vo_v4l2.c
 SRCS_MPLAYER-$(V4L2)          += libao2/ao_v4l2.c
+SRCS_MPLAYER-$(VAAPI)         += libvo/vo_vaapi.c
 SRCS_MPLAYER-$(VDPAU)         += libvo/vo_vdpau.c
 SRCS_MPLAYER-$(VESA)          += libvo/gtf.c libvo/vo_vesa.c libvo/vesa_lvo.c
 SRCS_MPLAYER-$(VIDIX)         += libvo/vo_cvidix.c \
@@ -652,6 +653,7 @@
                libao2/audio_out.c \
                libvo/aspect.c \
                libvo/geometry.c \
+               libvo/stats.c \
                libvo/video_out.c \
                libvo/vo_mpegpes.c \
                libvo/vo_null.c \
@@ -759,6 +761,9 @@
 ADD_ALL_DIRS    = $(call ADDSUFFIXES,$(1),$(ALL_DIRS))
 ADD_ALL_EXESUFS = $(1) $(call ADDSUFFIXES,$(EXESUFS_ALL),$(1))
 
+GUI_ICONSIZES = 16x16 22x22 24x24 32x32 48x48 256x256
+
+
 
 ###### generic rules #######
 
@@ -905,12 +910,12 @@
 install-%: %$(EXESUF) install-dirs
 	$(INSTALL) -m 755 $(INSTALLSTRIP) $< $(BINDIR)
 
-install-gui: install-mplayer
+install-gui: install-mplayer install-gui-icons
 	-ln -sf mplayer$(EXESUF) $(BINDIR)/gmplayer$(EXESUF)
-	$(INSTALL) -d $(DATADIR)/skins $(prefix)/share/pixmaps $(prefix)/share/applications
-	$(INSTALL) -m 644 etc/mplayer.png $(prefix)/share/pixmaps/
+	$(INSTALL) -d $(DATADIR)/skins $(prefix)/share/applications
 	$(INSTALL) -m 644 etc/mplayer.desktop $(prefix)/share/applications/
 
+install-gui-icons:    $(foreach size,$(GUI_ICONSIZES),install-gui-icon-$(size))
 install-gui-man:      $(foreach lang,$(MAN_LANGS),install-gui-man-$(lang))
 install-mencoder-man: $(foreach lang,$(MAN_LANGS),install-mencoder-man-$(lang))
 install-mplayer-man:  $(foreach lang,$(MAN_LANGS),install-mplayer-man-$(lang))
@@ -925,6 +930,12 @@
 	$(INSTALL) -d $(MANDIR)/man1
 	$(INSTALL) -m 644 DOCS/man/en/mplayer.1 $(MANDIR)/man1/
 
+define GUI_ICON_RULE
+install-gui-icon-$(size):
+	$(INSTALL) -d $(prefix)/share/icons/hicolor/$(size)/apps
+	$(INSTALL) -m 644 etc/mplayer$(size).png $(prefix)/share/icons/hicolor/$(size)/apps/mplayer.png
+endef
+
 define GUI_MAN_RULE
 install-gui-man-$(lang): install-mplayer-man-$(lang)
 	cd $(MANDIR)/$(lang)/man1/ && ln -sf mplayer.1 gmplayer.1
@@ -941,6 +952,7 @@
 	$(INSTALL) -m 644 DOCS/man/$(lang)/mplayer.1 $(MANDIR)/$(lang)/man1/
 endef
 
+$(foreach size,$(GUI_ICONSIZES),$(eval $(GUI_ICON_RULE)))
 $(foreach lang,$(filter-out en,$(MAN_LANG_ALL)),$(eval $(GUI_MAN_RULE)))
 $(foreach lang,$(filter-out en,$(MAN_LANG_ALL)),$(eval $(MENCODER_MAN_RULE)))
 $(foreach lang,$(filter-out en,$(MAN_LANG_ALL)),$(eval $(MPLAYER_MAN_RULE)))
@@ -949,7 +961,7 @@
 	rm -f $(BINDIR)/mplayer$(EXESUF) $(BINDIR)/gmplayer$(EXESUF)
 	rm -f $(BINDIR)/mencoder$(EXESUF)
 	rm -f $(MANDIR)/man1/mencoder.1 $(MANDIR)/man1/mplayer.1
-	rm -f $(prefix)/share/pixmaps/mplayer.png
+	rm -f $(foreach size,$(GUI_ICONSIZES),$(prefix)/share/icons/hicolor/$(size)/apps/mplayer.png)
 	rm -f $(prefix)/share/applications/mplayer.desktop
 	rm -f $(MANDIR)/man1/mplayer.1 $(MANDIR)/man1/mencoder.1
 	rm -f $(foreach lang,$(MAN_LANGS),$(foreach man,mplayer.1 mencoder.1,$(MANDIR)/$(lang)/man1/$(man)))
diff -Naur mplayer-1.0_rc4_p20120109/rpm/mplayer.spec mplayer-1.0_rc4_p20120109-new/rpm/mplayer.spec
--- mplayer-1.0_rc4_p20120109/rpm/mplayer.spec	2012-01-09 14:47:03.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/rpm/mplayer.spec	2012-01-16 15:51:41.000000000 +0100
@@ -253,9 +253,24 @@
 ln -s Blue $RPM_BUILD_ROOT%{_datadir}/mplayer/skins/default
 
 # Icons
+install -dm 755 $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/16x16/apps
+install -pm 644 etc/mplayer16x16.png \
+    $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/16x16/apps/mplayer.png
+install -dm 755 $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/22x22/apps
+install -pm 644 etc/mplayer22x22.png \
+    $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/22x22/apps/mplayer.png
+install -dm 755 $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/24x24/apps
+install -pm 644 etc/mplayer24x24.png \
+    $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/24x24/apps/mplayer.png
+install -dm 755 $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/32x32/apps
+install -pm 644 etc/mplayer32x32.png \
+    $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/32x32/apps/mplayer.png
 install -dm 755 $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/48x48/apps
-install -pm 644 etc/mplayer.png \
-    $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/48x48/apps
+install -pm 644 etc/mplayer48x48.png \
+    $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/48x48/apps/mplayer.png
+install -dm 755 $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/256x256/apps
+install -pm 644 etc/mplayer256x256.png \
+    $RPM_BUILD_ROOT%{_datadir}/icons/hicolor/256x256/apps/mplayer.png
 
 # Desktop file
 desktop-file-install \
@@ -306,7 +321,12 @@
 %defattr(-, root, root, -)
 %{_bindir}/gmplayer
 %{_datadir}/applications/*mplayer.desktop
+%{_datadir}/icons/hicolor/16x16/apps/mplayer.png
+%{_datadir}/icons/hicolor/22x22/apps/mplayer.png
+%{_datadir}/icons/hicolor/24x24/apps/mplayer.png
+%{_datadir}/icons/hicolor/32x32/apps/mplayer.png
 %{_datadir}/icons/hicolor/48x48/apps/mplayer.png
+%{_datadir}/icons/hicolor/256x256/apps/mplayer.png
 %{_datadir}/mplayer/skins/
 
 %files -n mencoder
diff -Naur mplayer-1.0_rc4_p20120109/snapshot_version mplayer-1.0_rc4_p20120109-new/snapshot_version
--- mplayer-1.0_rc4_p20120109/snapshot_version	2012-01-09 14:49:54.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/snapshot_version	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-34537
\ Brak znaku nowej linii na koÅ„cu pliku
diff -Naur mplayer-1.0_rc4_p20120109/stream/cache2.c mplayer-1.0_rc4_p20120109-new/stream/cache2.c
--- mplayer-1.0_rc4_p20120109/stream/cache2.c	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/stream/cache2.c	2012-01-16 15:51:41.000000000 +0100
@@ -269,6 +269,8 @@
   int needs_flush = 0;
   static unsigned last;
   int quit = s->control == -2;
+  uint64_t old_pos = s->stream->pos;
+  int old_eof = s->stream->eof;
   if (quit || !s->stream->control) {
     s->stream_time_length = 0;
     s->stream_time_pos = MP_NOPTS_VALUE;
@@ -320,11 +322,13 @@
       s->control_res = STREAM_UNSUPPORTED;
       break;
   }
-  if (needs_flush) {
+  if (s->control_res == STREAM_OK && needs_flush) {
     s->read_filepos = s->stream->pos;
     s->eof = s->stream->eof;
     cache_flush(s);
-  }
+  } else if (needs_flush &&
+             (old_pos != s->stream->pos || old_eof != s->stream->eof))
+    mp_msg(MSGT_STREAM, MSGL_ERR, "STREAM_CTRL changed stream pos but returned error, this is not allowed!\n");
   s->control = -1;
   return 1;
 }
@@ -644,14 +648,19 @@
       return STREAM_UNSUPPORTED;
     }
   }
-  // to avoid unnecessary differences with non-cache behaviour,
-  // do this also on failure.
+  if (s->control_res != STREAM_OK)
+    return s->control_res;
+  // We cannot do this on failure, since this would cause the
+  // stream position to jump when e.g. STREAM_CTRL_SEEK_TO_TIME
+  // is unsupported - but in that case we need the old value
+  // to do the fallback seek.
+  // This unfortunately can lead to slightly different behaviour
+  // with and without cache if the protocol changes pos even
+  // when an error happened.
   if (pos_change) {
     stream->pos = s->read_filepos;
     stream->eof = s->eof;
   }
-  if (s->control_res != STREAM_OK)
-    return s->control_res;
   switch (cmd) {
     case STREAM_CTRL_GET_TIME_LENGTH:
     case STREAM_CTRL_GET_CURRENT_TIME:
diff -Naur mplayer-1.0_rc4_p20120109/stream/stream_cdda.c mplayer-1.0_rc4_p20120109-new/stream/stream_cdda.c
--- mplayer-1.0_rc4_p20120109/stream/stream_cdda.c	2012-01-09 14:46:48.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/stream/stream_cdda.c	2012-01-16 15:51:41.000000000 +0100
@@ -267,7 +267,10 @@
       track += start_track;
       if (track > end_track) {
         seek(stream, (p->end_sector + 1) * CD_FRAMESIZE_RAW);
-        return STREAM_ERROR;
+        // seeking beyond EOF should not be an error,
+        // the cache cannot handle changing stream pos and
+        // returning error.
+        return STREAM_OK;
       }
       seek_sector = track <= 0 ? p->start_sector
                                : p->cd->disc_toc[track].dwStartSector;
diff -Naur mplayer-1.0_rc4_p20120109/sub/ass_mp.c mplayer-1.0_rc4_p20120109-new/sub/ass_mp.c
--- mplayer-1.0_rc4_p20120109/sub/ass_mp.c	2012-01-09 14:46:54.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/sub/ass_mp.c	2012-01-16 15:51:41.000000000 +0100
@@ -54,6 +54,41 @@
 char* ass_styles_file = NULL;
 int ass_hinting = ASS_HINTING_NATIVE + 4; // native hinting for unscaled osd
 
+static void init_style(ASS_Style *style, const char *name, double playres)
+{
+	double fs;
+	uint32_t c1, c2;
+	style->Name = strdup(name);
+	style->FontName = (font_fontconfig >= 0 && sub_font_name) ? strdup(sub_font_name) : (font_fontconfig >= 0 && font_name) ? strdup(font_name) : strdup("Sans");
+	style->treat_fontname_as_pattern = 1;
+
+	fs = playres * text_font_scale_factor / 100.;
+	// approximate autoscale coefficients
+	if (subtitle_autoscale == 2)
+		fs *= 1.3;
+	else if (subtitle_autoscale == 3)
+		fs *= 1.4;
+	style->FontSize = fs;
+
+	if (ass_color) c1 = strtoll(ass_color, NULL, 16);
+	else c1 = 0xFFFF0000;
+	if (ass_border_color) c2 = strtoll(ass_border_color, NULL, 16);
+	else c2 = 0x00000000;
+
+	style->PrimaryColour = c1;
+	style->SecondaryColour = c1;
+	style->OutlineColour = c2;
+	style->BackColour = 0x00000000;
+	style->BorderStyle = 1;
+	style->Alignment = 2;
+	style->Outline = 2;
+	style->MarginL = 10;
+	style->MarginR = 10;
+	style->MarginV = 5;
+	style->ScaleX = 1.;
+	style->ScaleY = 1.;
+}
+
 ASS_Track* ass_default_track(ASS_Library* library) {
 	ASS_Track* track = ass_new_track(library);
 
@@ -62,46 +97,21 @@
 	track->PlayResY = 288;
 	track->WrapStyle = 0;
 
+	if (track->n_styles == 0) {
+		// stupid hack to stop libass to add a default track
+		// in front in ass_read_styles - this makes it impossible
+		// to completely override the "Default" track.
+		int sid = ass_alloc_style(track);
+		init_style(track->styles + sid, "MPlayerDummy", track->PlayResY);
+	}
+
 	if (ass_styles_file)
 		ass_read_styles(track, ass_styles_file, sub_cp);
 
-	if (track->n_styles == 0) {
-		ASS_Style* style;
-		int sid;
-		double fs;
-		uint32_t c1, c2;
-
-		sid = ass_alloc_style(track);
-		style = track->styles + sid;
-		style->Name = strdup("Default");
-		style->FontName = (font_fontconfig >= 0 && sub_font_name) ? strdup(sub_font_name) : (font_fontconfig >= 0 && font_name) ? strdup(font_name) : strdup("Sans");
-		style->treat_fontname_as_pattern = 1;
-
-		fs = track->PlayResY * text_font_scale_factor / 100.;
-		// approximate autoscale coefficients
-		if (subtitle_autoscale == 2)
-			fs *= 1.3;
-		else if (subtitle_autoscale == 3)
-			fs *= 1.4;
-		style->FontSize = fs;
-
-		if (ass_color) c1 = strtoll(ass_color, NULL, 16);
-		else c1 = 0xFFFF0000;
-		if (ass_border_color) c2 = strtoll(ass_border_color, NULL, 16);
-		else c2 = 0x00000000;
-
-		style->PrimaryColour = c1;
-		style->SecondaryColour = c1;
-		style->OutlineColour = c2;
-		style->BackColour = 0x00000000;
-		style->BorderStyle = 1;
-		style->Alignment = 2;
-		style->Outline = 2;
-		style->MarginL = 10;
-		style->MarginR = 10;
-		style->MarginV = 5;
-		style->ScaleX = 1.;
-		style->ScaleY = 1.;
+	if (track->default_style <= 0) {
+		int sid = ass_alloc_style(track);
+		init_style(track->styles + sid, "Default", track->PlayResY);
+		track->default_style = sid;
 	}
 
 	ass_process_force_style(track);
@@ -142,7 +152,7 @@
 
 	event->Start = sub->start * 10;
 	event->Duration = (sub->end - sub->start) * 10;
-	event->Style = 0;
+	event->Style = track->default_style;
 
 	for (j = 0; j < sub->lines; ++j)
 		len += sub->text[j] ? strlen(sub->text[j]) : 0;
diff -Naur mplayer-1.0_rc4_p20120109/sub/subreader.c mplayer-1.0_rc4_p20120109-new/sub/subreader.c
--- mplayer-1.0_rc4_p20120109/sub/subreader.c	2012-01-09 14:46:54.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/sub/subreader.c	2012-01-16 15:51:41.000000000 +0100
@@ -50,8 +50,8 @@
 
 #ifdef CONFIG_ICONV
 #include <iconv.h>
-char *sub_cp=NULL;
 #endif
+char *sub_cp=NULL;
 #ifdef CONFIG_FRIBIDI
 #include <fribidi/fribidi.h>
 char *fribidi_charset = NULL;   ///character set that will be passed to FriBiDi
@@ -652,6 +652,7 @@
 	     line3[LINE_LEN+1],
 	     *line2;
 	char *tmp;
+	const char *brace;
 
 	do {
 		if (!stream_read_line (st, line, LINE_LEN, utf16)) return NULL;
@@ -669,11 +670,13 @@
 
         line2=strchr(line3, ',');
         if (!line2) return NULL;
+        brace = strchr(line2, '{');
 
         for (comma = 4; comma < max_comma; comma ++)
           {
             tmp = line2;
             if(!(tmp=strchr(++tmp, ','))) break;
+            if(brace && brace < tmp) break; // comma inside command
             if(*(++tmp) == ' ') break;
                   /* a space after a comma means we're already in a sentence */
             line2 = tmp;
@@ -2562,6 +2565,16 @@
   if (sub->lines < SUB_MAX_TEXT &&
       strlen(sub->text[sub->lines]))
     sub->lines++;
+  if (sub->lines > 1 &&
+      strcmp(sub->text[sub->lines-1], sub->text[sub->lines-2]) == 0) {
+    // remove duplicate lines. These can happen with some
+    // "clever" ASS effects.
+    sub->lines--;
+    sub->endpts[sub->lines-1] =
+      FFMAX(sub->endpts[sub->lines-1],
+            sub->endpts[sub->lines]);
+    free(sub->text[sub->lines]);
+  }
 #ifdef CONFIG_FRIBIDI
   sub = sub_fribidi(sub, sub_utf8, orig_lines);
 #endif
diff -Naur mplayer-1.0_rc4_p20120109/t.0000.38551 mplayer-1.0_rc4_p20120109-new/t.0000.38551
--- mplayer-1.0_rc4_p20120109/t.0000.38551	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-1.0_rc4_p20120109-new/t.0000.38551	2012-01-16 15:51:41.000000000 +0100
@@ -0,0 +1,3546 @@
+==========va_TraceInitialize
+==========va_TraceMaxNumDisplayAttributes
+	max_display_attributes = 4
+	num_attributes = 0
+==========va_TraceGetDisplayAttributes
+	num_attributes = 1
+	attr_list[1] =
+	  typ = 0x00000005
+	  min_value = 144
+	  max_value = 0
+	  value = 0
+	  flags = 1
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000000
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000001
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000002
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000003
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000004
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000005
+==========va_TraceCreateConfig
+	profile = 10
+	entrypoint = 1
+	num_attribs = 1
+		attrib_list[0].type = 0x00000000
+		attrib_list[0].value = 0x00000001
+==========va_TraceCreateContext
+	width = 176
+	height = 144
+	flag = 0x00000001
+	num_render_targets = 6
+		render_targets[0] = 0x04000000
+		render_targets[1] = 0x04000001
+		render_targets[2] = 0x04000002
+		render_targets[3] = 0x04000003
+		render_targets[4] = 0x04000004
+		render_targets[5] = 0x04000005
+	context = 0x02000000
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000000
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000001
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000002
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000003
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000004
+==========va_TraceCreateSurface
+	width = 176
+	height = 144
+	format = 1
+	num_surfaces = 1
+		surfaces[0] = 0x04000005
+==========va_TraceCreateConfig
+	profile = 10
+	entrypoint = 1
+	num_attribs = 1
+		attrib_list[0].type = 0x00000000
+		attrib_list[0].value = 0x00000001
+==========va_TraceCreateContext
+	width = 176
+	height = 144
+	flag = 0x00000001
+	num_render_targets = 6
+		render_targets[0] = 0x04000000
+		render_targets[1] = 0x04000001
+		render_targets[2] = 0x04000002
+		render_targets[3] = 0x04000003
+		render_targets[4] = 0x04000004
+		render_targets[5] = 0x04000005
+	context = 0x02000000
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000000
+	frame_count  = #0
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0xffffffff
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 0
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 0
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 0
+	direct_mb = 0
+	skip_mb = 0
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 0
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 8
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 2
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2892
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 36
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 2892
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x0a2a2287
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000001
+	frame_count  = #1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 0
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 1
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 0
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 3
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 0
+	pic_quantizer_scale = 3
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 7
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2295
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 37
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 2295
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xc5324ef0
+==========va_TracePutSurface
+	surface = 0x04000000
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000002
+	frame_count  = #2
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0x04000001
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 1
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 3
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 7
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 3272
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 3272
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xfecde836
+==========va_TracePutSurface
+	surface = 0x04000002
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000003
+	frame_count  = #3
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0x04000001
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 3
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 7
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 3309
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 3309
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x287c0b4a
+==========va_TracePutSurface
+	surface = 0x04000003
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000004
+	frame_count  = #4
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 1
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 3
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 0
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 8
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2114
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 37
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 2114
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xe6041b22
+==========va_TracePutSurface
+	surface = 0x04000001
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000005
+	frame_count  = #5
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0x04000004
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 1
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 8
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2923
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 2923
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x64e066e1
+==========va_TracePutSurface
+	surface = 0x04000005
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000002
+	frame_count  = #6
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0x04000004
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 8
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2968
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 2968
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xc6ca5fb1
+==========va_TracePutSurface
+	surface = 0x04000002
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000000
+	frame_count  = #7
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000004
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 4
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 8
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 1
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 6
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 1
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x00f300f3
+==========va_TracePutSurface
+	surface = 0x04000004
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000003
+	frame_count  = #8
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000004
+	backward_reference_picture = 0x04000000
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 1
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 8
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2984
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 2984
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xe21a53aa
+==========va_TracePutSurface
+	surface = 0x04000003
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000005
+	frame_count  = #9
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000004
+	backward_reference_picture = 0x04000000
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 8
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2989
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 2989
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x73028242
+==========va_TracePutSurface
+	surface = 0x04000005
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000001
+	frame_count  = #10
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 1
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 3
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 3
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 7
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2686
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 37
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 2686
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x45171b33
+==========va_TracePutSurface
+	surface = 0x04000000
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000002
+	frame_count  = #11
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0x04000001
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 1
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 0
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 7
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 3373
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 3373
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xf40c4ea9
+==========va_TracePutSurface
+	surface = 0x04000002
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000003
+	frame_count  = #12
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0x04000001
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 0
+	pic_quantizer_scale = 4
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 7
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 3437
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 3437
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xe6c420b8
+==========va_TracePutSurface
+	surface = 0x04000003
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000004
+	frame_count  = #13
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 1
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 3
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 0
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 1945
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 37
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 1945
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x6b5fa291
+==========va_TracePutSurface
+	surface = 0x04000001
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000005
+	frame_count  = #14
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0x04000004
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 1
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2682
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 2682
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xc07dcdaa
+==========va_TracePutSurface
+	surface = 0x04000005
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000002
+	frame_count  = #15
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0x04000004
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2692
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 2692
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xe133d747
+==========va_TracePutSurface
+	surface = 0x04000002
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000000
+	frame_count  = #16
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000004
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 4
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 1
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 6
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 1
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x00f300f3
+==========va_TracePutSurface
+	surface = 0x04000004
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000003
+	frame_count  = #17
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000004
+	backward_reference_picture = 0x04000000
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 1
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 3023
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 3023
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x1b7a5e86
+==========va_TracePutSurface
+	surface = 0x04000003
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000005
+	frame_count  = #18
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000004
+	backward_reference_picture = 0x04000000
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 3044
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 40
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 3044
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xb0677a1a
+==========va_TracePutSurface
+	surface = 0x04000005
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000001
+	frame_count  = #19
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 4
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 1
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 6
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 1
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x00f300f3
+==========va_TracePutSurface
+	surface = 0x04000000
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000002
+	frame_count  = #20
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0x04000001
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 1
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 3034
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 40
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 3034
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x519e7ff6
+==========va_TracePutSurface
+	surface = 0x04000002
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000003
+	frame_count  = #21
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000000
+	backward_reference_picture = 0x04000001
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 3098
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 40
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 3098
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xc4598f0b
+==========va_TracePutSurface
+	surface = 0x04000003
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000004
+	frame_count  = #22
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0xffffffff
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 1
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 3
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 0
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 1
+	pic_quantizer_scale = 5
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2453
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 37
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 2453
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x2f6cb707
+==========va_TracePutSurface
+	surface = 0x04000001
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000005
+	frame_count  = #23
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000004
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0x04000004
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 1
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 1
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 0
+	pic_quantizer_scale = 6
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2780
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000002
+	  type = VASliceDataBufferType
+	  size = 2780
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0x1d1a2d68
+==========va_TracePutSurface
+	surface = 0x04000005
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceBeginPicture
+	context = 0x02000000
+	render_targets = 0x04000002
+	frame_count  = #24
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 1
+	---------------------------
+	buffers[0] = 0x08000002
+	  type = VAPictureParameterBufferType
+	  size = 72
+	  num_elements = 1
+	---------------------------
+	element[0] = VAPictureParameterBufferVC1
+	forward_reference_picture = 0x04000001
+	backward_reference_picture = 0x04000004
+	inloop_decoded_picture = 0xffffffff
+	pulldown = 1
+	interlace = 0
+	tfcntrflag = 0
+	finterpflag = 0
+	psf = 0
+	multires = 0
+	overlap = 1
+	syncmarker = 0
+	rangered = 0
+	max_b_frames = 7
+	profile = 3
+	coded_width = 176
+	coded_height = 144
+	closed_entry = 0
+	broken_link = 0
+	closed_entry = 0
+	panscan_flag = 0
+	loopfilter = 1
+	conditional_overlap_flag = 2
+	fast_uvmc_flag = 0
+	range_mapping_luma_flag = 1
+	range_mapping_luma = 0
+	range_mapping_chroma_flag = 1
+	range_mapping_chroma = 0
+	b_picture_fraction = 2
+	cbp_table = 0
+	mb_mode_table = 0
+	range_reduction_frame = 0
+	rounding_control = 0
+	post_processing = 0
+	picture_resolution_index = 0
+	luma_scale = 0
+	luma_shift = 0
+	picture_type = 2
+	frame_coding_mode = 0
+	top_field_first = 0
+	is_first_field = 1
+	intensity_compensation = 0
+	mv_type_mb = 1
+	direct_mb = 1
+	skip_mb = 1
+	field_tx = 0
+	forward_mb = 0
+	ac_pred = 1
+	overflags = 1
+	bp_mv_type_mb = 0
+	bp_direct_mb = 0
+	bp_skip_mb = 0
+	bp_field_tx = 0
+	bp_forward_mb = 0
+	bp_ac_pred = 0
+	bp_overflags = 0
+	reference_distance_flag = 1
+	reference_distance = 0
+	num_reference_pictures = 0
+	reference_field_pic_indicator = 0
+	mv_mode = 0
+	mv_mode2 = 0
+	mv_table = 0
+	two_mv_block_pattern_table = 0
+	four_mv_switch = 0
+	four_mv_block_pattern_table = 0
+	extended_mv_flag = 1
+	extended_mv_range = 1
+	extended_dmv_flag = 1
+	extended_dmv_range = 0
+	dquant = 1
+	quantizer = 0
+	half_qp = 0
+	pic_quantizer_scale = 6
+	pic_quantizer_type = 1
+	dq_frame = 1
+	dq_profile = 3
+	dq_sb_edge = 0
+	dq_db_edge = 0
+	dq_binary_level = 1
+	alt_pic_quantizer = 9
+	variable_sized_transform_flag = 1
+	mb_level_transform_type_flag = 0
+	frame_level_transform_type = 0
+	transform_ac_codingset_idx1 = 0
+	transform_ac_codingset_idx2 = 1
+	intra_transform_dc_table = 1
+==========va_TraceRenderPicture
+	context = 0x02000000
+	num_buffers = 2
+	---------------------------
+	buffers[0] = 0x08000003
+	  type = VASliceParameterBufferType
+	  size = 20
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceParameterBufferVC1
+	slice_data_size = 2786
+	slice_data_offset = 0
+	slice_data_flag = 0
+	macroblock_offset = 41
+	slice_vertical_position = 0
+	---------------------------
+	buffers[1] = 0x08000004
+	  type = VASliceDataBufferType
+	  size = 2786
+	  num_elements = 1
+	---------------------------
+	element[0] = VASliceDataBufferType
+	checksum = 0xe3b7177b
+==========va_TracePutSurface
+	surface = 0x04000002
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TracePutSurface
+	surface = 0x04000004
+	draw = 0x04000001
+	srcx = 0
+	srcy = 0
+	srcw = 176
+	srch = 144
+	destx = 0
+	desty = 0
+	destw = 176
+	desth = 144
+	cliprects = 0x00000000
+	number_cliprects = 0
+	flags = 0x00000010
+==========va_TraceTerminate
