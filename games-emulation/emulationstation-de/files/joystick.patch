diff --git a/es-core/src/InputConfig.cpp b/es-core/src/InputConfig.cpp
index 2322e813..0332068f 100644
--- a/es-core/src/InputConfig.cpp
+++ b/es-core/src/InputConfig.cpp
@@ -26,6 +26,8 @@ std::string InputConfig::inputTypeToString(InputType type)
             return "axis";
         case TYPE_BUTTON:
             return "button";
+        case TYPE_HAT:
+            return "hat";
         case TYPE_KEY:
             return "key";
         case TYPE_CEC_BUTTON:
@@ -43,6 +45,8 @@ InputType InputConfig::stringToInputType(const std::string& type)
         return TYPE_BUTTON;
     if (type == "key")
         return TYPE_KEY;
+    if(type == "hat")
+        return TYPE_HAT;
     if (type == "cec-button")
         return TYPE_CEC_BUTTON;
     return TYPE_COUNT;
@@ -75,6 +79,9 @@ bool InputConfig::isMappedTo(const std::string& name, Input input)
         return false;
 
     if (comp.configured && comp.type == input.type && comp.id == input.id) {
+        if(comp.type == TYPE_HAT)
+            return (input.value == 0 || input.value & comp.value);
+
         if (comp.type == TYPE_AXIS)
             return input.value == 0 || comp.value == input.value;
         else
@@ -128,6 +135,12 @@ std::vector<std::string> InputConfig::getMappedTo(Input input)
             continue;
 
         if (chk.device == input.device && chk.type == input.type && chk.id == input.id) {
+	   if(chk.type == TYPE_HAT) {
+                if(input.value == 0 || input.value & chk.value) {
+                    maps.push_back(it->first);
+                }
+                continue;
+            }
             if (input.type == TYPE_AXIS) {
                 if (input.value == 0 || chk.value == input.value)
                     maps.push_back(it->first);
diff --git a/es-core/src/InputConfig.h b/es-core/src/InputConfig.h
index be7a06ee..1d4163e0 100644
--- a/es-core/src/InputConfig.h
+++ b/es-core/src/InputConfig.h
@@ -22,6 +22,7 @@
 enum InputType {
     TYPE_AXIS, // Replace with AllowShortEnumsOnASingleLine: false (clang-format >=11.0).
     TYPE_BUTTON,
+    TYPE_HAT,
     TYPE_KEY,
     TYPE_CEC_BUTTON,
     TYPE_COUNT
@@ -58,6 +59,19 @@ public:
     {
     }
 
+
+    std::string getHatDir(int val) {
+        if(val & SDL_HAT_UP)
+            return "up";
+        else if(val & SDL_HAT_DOWN)
+            return "down";
+        else if(val & SDL_HAT_LEFT)
+            return "left";
+        else if(val & SDL_HAT_RIGHT)
+            return "right";
+        return "neutral?";
+    }
+
     std::string getCECButtonName(int keycode) { return CECInput::getKeyCodeString(keycode); }
 
     std::string string()
@@ -77,6 +91,9 @@ public:
                 stream << "Button " << id;
                 break;
             }
+            case TYPE_HAT:
+                stream << "Hat " << id << " " << getHatDir(value);
+                break;
             case TYPE_KEY: {
                 stream << "Key " << SDL_GetKeyName((SDL_Keycode)id);
                 break;
diff --git a/es-core/src/InputManager.cpp b/es-core/src/InputManager.cpp
index e1514c06..5ed4691a 100644
--- a/es-core/src/InputManager.cpp
+++ b/es-core/src/InputManager.cpp
@@ -1,737 +1,509 @@
-//  SPDX-License-Identifier: MIT
-//
-//  EmulationStation Desktop Edition
-//  InputManager.cpp
-//
-//  Low-level input handling.
-//  Initiates and maps the keyboard and controllers.
-//  Reads and writes the es_input.xml configuration file.
-//
-
 #include "InputManager.h"
 
+#include "utils/FileSystemUtil.h"
 #include "CECInput.h"
 #include "Log.h"
 #include "Platform.h"
 #include "Scripting.h"
 #include "Window.h"
-#include "resources/ResourceManager.h"
-#include "utils/FileSystemUtil.h"
-#include "utils/StringUtil.h"
-
-#include <iostream>
 #include <pugixml.hpp>
+#include <SDL.h>
+#include <iostream>
+#include <assert.h>
 
 #define KEYBOARD_GUID_STRING "-1"
-#define CEC_GUID_STRING "-2"
-
+#define CEC_GUID_STRING      "-2"
+
+// SO HEY POTENTIAL POOR SAP WHO IS TRYING TO MAKE SENSE OF ALL THIS (by which I mean my future self)
+// There are like four distinct IDs used for joysticks (crazy, right?)
+// 1. Device index - this is the "lowest level" identifier, and is just the Nth joystick plugged in to the system (like /dev/js#).
+//    It can change even if the device is the same, and is only used to open joysticks (required to receive SDL events).
+// 2. SDL_JoystickID - this is an ID for each joystick that is supposed to remain consistent between plugging and unplugging.
+//    ES doesn't care if it does, though.
+// 3. "Device ID" - this is something I made up and is what InputConfig's getDeviceID() returns.
+//    This is actually just an SDL_JoystickID (also called instance ID), but -1 means "keyboard" instead of "error."
+// 4. Joystick GUID - this is some squashed version of joystick vendor, version, and a bunch of other device-specific things.
+//    It should remain the same across runs of the program/system restarts/device reordering and is what I use to identify which joystick to load.
+
+// hack for cec support
 int SDL_USER_CECBUTTONDOWN = -1;
-int SDL_USER_CECBUTTONUP = -1;
-
-// Save button states for combo-button exit support and predefine exit option-function map.
-static bool sAltDown = false;
-static bool sLguiDown = false;
+int SDL_USER_CECBUTTONUP   = -1;
 
-InputManager* InputManager::sInstance = nullptr;
+InputManager* InputManager::mInstance = NULL;
 
-InputManager::InputManager()
-    : mKeyboardInputConfig(nullptr)
+InputManager::InputManager() : mKeyboardInputConfig(NULL)
 {
 }
 
 InputManager::~InputManager()
 {
-    // Deinit when destroyed.
-    deinit();
+	deinit();
 }
 
 InputManager* InputManager::getInstance()
 {
-    if (!sInstance)
-        sInstance = new InputManager();
+	if(!mInstance)
+		mInstance = new InputManager();
 
-    return sInstance;
+	return mInstance;
 }
 
 void InputManager::init()
 {
-    if (initialized())
-        deinit();
-
-    mConfigFileExists = false;
-
-    LOG(LogInfo) << "Setting up InputManager...";
-
-    SDL_InitSubSystem(SDL_INIT_GAMECONTROLLER);
-    SDL_GameControllerEventState(SDL_ENABLE);
-
-    if (!Utils::FileSystem::exists(getConfigPath())) {
-        LOG(LogInfo) << "No input configuration file found, default mappings will be applied";
-    }
-    else {
-        mConfigFileExists = true;
-    }
-
-    mKeyboardInputConfig =
-        std::make_unique<InputConfig>(DEVICE_KEYBOARD, "Keyboard", KEYBOARD_GUID_STRING);
-
-    bool customConfig = loadInputConfig(mKeyboardInputConfig.get());
-
-    if (customConfig) {
-        LOG(LogInfo) << "Added keyboard with custom configuration";
-    }
-    else {
+	if(initialized())
+		deinit();
+
+	SDL_SetHint(SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS,
+		Settings::getInstance()->getBool("BackgroundJoystickInput") ? "1" : "0");
+	// Don't enable the HIDAPI drivers by default, it will break the existing configurations
+	// for a few controller types, since the names and the input mappings are different.
+#if !defined(_WIN32)
+#if	SDL_VERSION_ATLEAST(2,0,9)
+	SDL_SetHint(SDL_HINT_JOYSTICK_HIDAPI, "0");
+#endif
+#endif
+	SDL_InitSubSystem(SDL_INIT_JOYSTICK);
+	SDL_JoystickEventState(SDL_ENABLE);
+
+	// first, open all currently present joysticks
+	int numJoysticks = SDL_NumJoysticks();
+	for(int i = 0; i < numJoysticks; i++)
+	{
+		addJoystickByDeviceIndex(i);
+	}
+
+	mKeyboardInputConfig = new InputConfig(DEVICE_KEYBOARD, "Keyboard", KEYBOARD_GUID_STRING);
+	loadInputConfig(mKeyboardInputConfig);
         loadDefaultKBConfig();
-        LOG(LogInfo) << "Added keyboard with default configuration";
-    }
-
-    // Load optional controller mappings. Normally the supported controllers should be compiled
-    // into SDL as a header file, but if a user has a very rare controller that is not supported,
-    // the bundled mapping is incorrect, or the SDL version is a bit older, it makes sense to be
-    // able to customize this. If a controller GUID is present in the mappings file that is
-    // already present inside SDL, the custom mapping will overwrite the bundled one.
-    std::string mappingsFile =
-        Utils::FileSystem::getHomePath() + "/.emulationstation/" + "es_controller_mappings.cfg";
-
-    if (!Utils::FileSystem::exists(mappingsFile))
-        mappingsFile = ResourceManager::getInstance()->getResourcePath(
-            ":/controllers/es_controller_mappings.cfg");
-
-    int controllerMappings = SDL_GameControllerAddMappingsFromFile(mappingsFile.c_str());
-
-    if (controllerMappings != -1 && controllerMappings != 0) {
-        LOG(LogInfo) << "Loaded " << controllerMappings << " controller "
-                     << (controllerMappings == 1 ? "mapping" : "mappings");
-    }
-
-    int numJoysticks = SDL_NumJoysticks();
-
-    // Make sure that every joystick is actually supported by the GameController API.
-    for (int i = 0; i < numJoysticks; ++i)
-        if (!SDL_IsGameController(i))
-            --numJoysticks;
-
-    for (int i = 0; i < numJoysticks; ++i)
-        addControllerByDeviceIndex(nullptr, i);
-
-    SDL_USER_CECBUTTONDOWN = SDL_RegisterEvents(2);
-    SDL_USER_CECBUTTONUP = SDL_USER_CECBUTTONDOWN + 1;
-    CECInput::init();
-    mCECInputConfig = std::make_unique<InputConfig>(DEVICE_CEC, "CEC", CEC_GUID_STRING);
-    loadInputConfig(mCECInputConfig.get());
+
+	SDL_USER_CECBUTTONDOWN = SDL_RegisterEvents(2);
+	SDL_USER_CECBUTTONUP   = SDL_USER_CECBUTTONDOWN + 1;
+	CECInput::init();
+	mCECInputConfig = new InputConfig(DEVICE_CEC, "CEC", CEC_GUID_STRING);
+	loadInputConfig(mCECInputConfig);
 }
 
-void InputManager::deinit()
+void InputManager::addJoystickByDeviceIndex(int id)
 {
-    if (!initialized())
-        return;
-
-    for (auto it = mControllers.cbegin(); it != mControllers.cend(); ++it)
-        SDL_GameControllerClose(it->second);
-
-    mControllers.clear();
-    mJoysticks.clear();
-    mPrevAxisValues.clear();
-    mPrevButtonValues.clear();
-    mInputConfigs.clear();
-
-    mKeyboardInputConfig.reset();
-    mCECInputConfig.reset();
-
-    CECInput::deinit();
-
-    SDL_GameControllerEventState(SDL_DISABLE);
-    SDL_QuitSubSystem(SDL_INIT_GAMECONTROLLER);
-
-    if (sInstance) {
-        delete sInstance;
-        sInstance = nullptr;
-    }
+	assert(id >= 0 && id < SDL_NumJoysticks());
+
+	// open joystick & add to our list
+	SDL_Joystick* joy = SDL_JoystickOpen(id);
+	assert(joy);
+
+	// add it to our list so we can close it again later
+	SDL_JoystickID joyId = SDL_JoystickInstanceID(joy);
+	mJoysticks[joyId] = joy;
+
+	char guid[65];
+	SDL_JoystickGetGUIDString(SDL_JoystickGetGUID(joy), guid, 65);
+
+	// create the InputConfig
+	mInputConfigs[joyId] = new InputConfig(joyId, SDL_JoystickName(joy), guid);
+	if(!loadInputConfig(mInputConfigs[joyId]))
+	{
+		LOG(LogInfo) << "Added unconfigured joystick " << SDL_JoystickName(joy) << " (GUID: " << guid << ", instance ID: " << joyId << ", device index: " << id << ").";
+	}else{
+		LOG(LogInfo) << "Added known joystick " << SDL_JoystickName(joy) << " (instance ID: " << joyId << ", device index: " << id << ")";
+	}
+
+	// set up the prevAxisValues
+	int numAxes = SDL_JoystickNumAxes(joy);
+	mPrevAxisValues[joyId] = new int[numAxes];
+	std::fill(mPrevAxisValues[joyId], mPrevAxisValues[joyId] + numAxes, 0); //initialize array to 0
 }
 
-void InputManager::writeDeviceConfig(InputConfig* config)
+void InputManager::removeJoystickByJoystickID(SDL_JoystickID joyId)
 {
-    assert(initialized());
-
-    std::string path = getConfigPath();
-
-    LOG(LogDebug) << "InputManager::writeDeviceConfig(): "
-                     "Saving input configuration file to \""
-                  << path << "\"";
-
-    pugi::xml_document doc;
-
-    if (Utils::FileSystem::exists(path)) {
-        // Merge files.
-
-#if defined(_WIN64)
-        pugi::xml_parse_result result =
-            doc.load_file(Utils::String::stringToWideString(path).c_str());
-#else
-        pugi::xml_parse_result result = doc.load_file(path.c_str());
-#endif
-        if (!result) {
-            LOG(LogError) << "Couldn't parse input configuration file: " << result.description();
-        }
-        else {
-            // Successfully loaded, delete the old entry if it exists.
-            pugi::xml_node root = doc.child("inputList");
-            if (root) {
-                // If inputAction @type=onfinish is set, let doOnFinish command take care of
-                // creating input configuration. We just put the input configuration into a
-                // temporary input config file.
-                pugi::xml_node actionnode =
-                    root.find_child_by_attribute("inputAction", "type", "onfinish");
-                if (actionnode) {
-                    path = getTemporaryConfigPath();
-                    doc.reset();
-                    root = doc.append_child("inputList");
-                    root.append_copy(actionnode);
-                }
-                else {
-                    pugi::xml_node oldEntry = root.find_child_by_attribute(
-                        "inputConfig", "deviceGUID", config->getDeviceGUIDString().c_str());
-                    if (oldEntry)
-                        root.remove_child(oldEntry);
-                    oldEntry = root.find_child_by_attribute("inputConfig", "deviceName",
-                                                            config->getDeviceName().c_str());
-                    if (oldEntry)
-                        root.remove_child(oldEntry);
-                }
-            }
-        }
-    }
-
-    pugi::xml_node root = doc.child("inputList");
-    if (!root)
-        root = doc.append_child("inputList");
-
-    config->writeToXML(root);
-
-#if defined(_WIN64)
-    doc.save_file(Utils::String::stringToWideString(path).c_str());
-#else
-    doc.save_file(path.c_str());
-#endif
-
-    Scripting::fireEvent("config-changed");
-    Scripting::fireEvent("controls-changed");
-
-    // Execute any doOnFinish commands and reload the config for changes.
-    doOnFinish();
-    mConfigFileExists = true;
-    loadInputConfig(config);
+	assert(joyId != -1);
+
+	// delete old prevAxisValues
+	auto axisIt = mPrevAxisValues.find(joyId);
+	delete[] axisIt->second;
+	mPrevAxisValues.erase(axisIt);
+
+	// delete old InputConfig
+	auto it = mInputConfigs.find(joyId);
+	delete it->second;
+	mInputConfigs.erase(it);
+
+	// close the joystick
+	auto joyIt = mJoysticks.find(joyId);
+	if(joyIt != mJoysticks.cend())
+	{
+		SDL_JoystickClose(joyIt->second);
+		mJoysticks.erase(joyIt);
+	}else{
+		LOG(LogError) << "Could not find joystick to close (instance ID: " << joyId << ")";
+	}
 }
 
-void InputManager::doOnFinish()
+void InputManager::deinit()
 {
-    assert(initialized());
-    std::string path = getConfigPath();
-    pugi::xml_document doc;
-
-    if (Utils::FileSystem::exists(path)) {
-#if defined(_WIN64)
-        pugi::xml_parse_result result =
-            doc.load_file(Utils::String::stringToWideString(path).c_str());
-#else
-        pugi::xml_parse_result result = doc.load_file(path.c_str());
-#endif
-
-        if (!result) {
-            LOG(LogError) << "Couldn't parse input configuration file: " << result.description();
-        }
-        else {
-            pugi::xml_node root = doc.child("inputList");
-            if (root) {
-                root = root.find_child_by_attribute("inputAction", "type", "onfinish");
-                if (root) {
-                    for (pugi::xml_node command = root.child("command"); command;
-                         command = command.next_sibling("command")) {
-                        std::string tocall = command.text().get();
-
-                        LOG(LogInfo) << "	" << tocall;
-                        std::cout << "==============================================\n"
-                                     "input config finish command:\n";
-                        int exitCode = runSystemCommand(tocall);
-                        std::cout << "==============================================\n";
-
-                        if (exitCode != 0) {
-                            LOG(LogWarning) << "...launch terminated with nonzero exit code "
-                                            << exitCode << "!";
-                        }
-                    }
-                }
-            }
-        }
-    }
+	if(!initialized())
+		return;
+
+	for(auto iter = mJoysticks.cbegin(); iter != mJoysticks.cend(); iter++)
+	{
+		SDL_JoystickClose(iter->second);
+	}
+	mJoysticks.clear();
+
+	for(auto iter = mInputConfigs.cbegin(); iter != mInputConfigs.cend(); iter++)
+	{
+		delete iter->second;
+	}
+	mInputConfigs.clear();
+
+	for(auto iter = mPrevAxisValues.cbegin(); iter != mPrevAxisValues.cend(); iter++)
+	{
+		delete[] iter->second;
+	}
+	mPrevAxisValues.clear();
+
+	if(mKeyboardInputConfig != NULL)
+	{
+		delete mKeyboardInputConfig;
+		mKeyboardInputConfig = NULL;
+	}
+
+	if(mCECInputConfig != NULL)
+	{
+		delete mCECInputConfig;
+		mCECInputConfig = NULL;
+	}
+
+	CECInput::deinit();
+
+	SDL_JoystickEventState(SDL_DISABLE);
+	SDL_QuitSubSystem(SDL_INIT_JOYSTICK);
 }
 
-std::string InputManager::getConfigPath()
+int InputManager::getNumJoysticks() { return (int)mJoysticks.size(); }
+
+int InputManager::getAxisCountByDevice(SDL_JoystickID id)
 {
-    std::string path = Utils::FileSystem::getHomePath();
-    path += "/.emulationstation/es_input.xml";
-    return path;
+	return SDL_JoystickNumAxes(mJoysticks[id]);
 }
 
-std::string InputManager::getTemporaryConfigPath()
+int InputManager::getButtonCountByDevice(SDL_JoystickID id)
 {
-    std::string path = Utils::FileSystem::getHomePath();
-    path += "/.emulationstation/es_temporaryinput.xml";
-    return path;
+	if(id == DEVICE_KEYBOARD)
+		return 120; //it's a lot, okay.
+	else if(id == DEVICE_CEC)
+#ifdef HAVE_CECLIB
+		return CEC::CEC_USER_CONTROL_CODE_MAX;
+#else // HAVE_LIBCEF
+		return 0;
+#endif // HAVE_CECLIB
+	else
+		return SDL_JoystickNumButtons(mJoysticks[id]);
 }
 
-int InputManager::getNumConfiguredDevices()
+InputConfig* InputManager::getInputConfigByDevice(int device)
 {
-    int num = 0;
-    for (auto it = mInputConfigs.cbegin(); it != mInputConfigs.cend(); ++it)
-        if (it->second->isConfigured())
-            ++num;
-
-    if (mKeyboardInputConfig->isConfigured())
-        ++num;
-
-    if (mCECInputConfig->isConfigured())
-        ++num;
-
-    return num;
+	if(device == DEVICE_KEYBOARD)
+		return mKeyboardInputConfig;
+	else if(device == DEVICE_CEC)
+		return mCECInputConfig;
+	else
+		return mInputConfigs[device];
 }
 
-int InputManager::getAxisCountByDevice(SDL_JoystickID id)
+bool InputManager::parseEvent(const SDL_Event& ev, Window* window)
 {
-    return SDL_JoystickNumAxes(mJoysticks[id]);
+	bool causedEvent = false;
+	switch(ev.type)
+	{
+	case SDL_JOYAXISMOTION:
+		//if it switched boundaries
+		//printf("InputManager::parseEvent, SDL_JOYAXISMOTION: %d, J1: %d, J2: %d\n", ev.type, ev.jaxis.axis, ev.jaxis.which);
+		if((abs(ev.jaxis.value) > DEADZONE) != (abs(mPrevAxisValues[ev.jaxis.which][ev.jaxis.axis]) > DEADZONE))
+		{
+			int normValue;
+			if(abs(ev.jaxis.value) <= DEADZONE)
+				normValue = 0;
+			else
+				if(ev.jaxis.value > 0)
+					normValue = 1;
+				else
+					normValue = -1;
+
+			window->input(getInputConfigByDevice(ev.jaxis.which), Input(ev.jaxis.which, TYPE_AXIS, ev.jaxis.axis, normValue, false));
+			causedEvent = true;
+		}
+
+		mPrevAxisValues[ev.jaxis.which][ev.jaxis.axis] = ev.jaxis.value;
+		return causedEvent;
+
+	case SDL_JOYBUTTONDOWN:
+	case SDL_JOYBUTTONUP:
+		//printf("InputManager::parseEvent, SDL_JOYBUTTONUP: %d, J1: %d, J2: %d\n", ev.type, ev.jbutton.button, ev.jbutton.which);
+		window->input(getInputConfigByDevice(ev.jbutton.which), Input(ev.jbutton.which, TYPE_BUTTON, ev.jbutton.button, ev.jbutton.state == SDL_PRESSED, false));
+		return true;
+
+	case SDL_JOYHATMOTION:
+		//printf("InputManager::parseEvent, SDL_JOYHATMOTION: %d, J1: %d, J2: %d, J3: %d\n", ev.type, ev.jhat.hat, ev.jhat.which, ev.jhat.value);
+		window->input(getInputConfigByDevice(ev.jhat.which), Input(ev.jhat.which, TYPE_HAT, ev.jhat.hat, ev.jhat.value, false));
+		return true;
+
+	case SDL_KEYDOWN:
+		if(ev.key.keysym.sym == SDLK_BACKSPACE && SDL_IsTextInputActive())
+		{
+			window->textInput("\b");
+		}
+
+		if(ev.key.repeat)
+			return false;
+
+		if(ev.key.keysym.sym == SDLK_F4)
+		{
+			SDL_Event* quit = new SDL_Event();
+			quit->type = SDL_QUIT;
+			SDL_PushEvent(quit);
+			return false;
+		}
+
+		window->input(getInputConfigByDevice(DEVICE_KEYBOARD), Input(DEVICE_KEYBOARD, TYPE_KEY, ev.key.keysym.sym, 1, false));
+		return true;
+
+	case SDL_KEYUP:
+		window->input(getInputConfigByDevice(DEVICE_KEYBOARD), Input(DEVICE_KEYBOARD, TYPE_KEY, ev.key.keysym.sym, 0, false));
+		return true;
+
+	case SDL_TEXTINPUT:
+		window->textInput(ev.text.text);
+		break;
+
+	case SDL_JOYDEVICEADDED:
+		addJoystickByDeviceIndex(ev.jdevice.which); // ev.jdevice.which is a device index
+		return true;
+
+	case SDL_JOYDEVICEREMOVED:
+		removeJoystickByJoystickID(ev.jdevice.which); // ev.jdevice.which is an SDL_JoystickID (instance ID)
+		return false;
+	}
+
+	if((ev.type == (unsigned int)SDL_USER_CECBUTTONDOWN) || (ev.type == (unsigned int)SDL_USER_CECBUTTONUP))
+	{
+		window->input(getInputConfigByDevice(DEVICE_CEC), Input(DEVICE_CEC, TYPE_CEC_BUTTON, ev.user.code, ev.type == (unsigned int)SDL_USER_CECBUTTONDOWN, false));
+		return true;
+	}
+
+	return false;
 }
 
-int InputManager::getButtonCountByDevice(SDL_JoystickID id)
+bool InputManager::loadInputConfig(InputConfig* config)
 {
-    if (id == DEVICE_KEYBOARD)
-        return -1;
-    else if (id == DEVICE_CEC)
-#if defined(HAVE_CECLIB)
-        return CEC::CEC_USER_CONTROL_CODE_MAX;
-#else
-        return 0;
-#endif
-    else
-        return SDL_JoystickNumButtons(mJoysticks[id]);
+	std::string path = getConfigPath();
+	if(!Utils::FileSystem::exists(path))
+		return false;
+
+	pugi::xml_document doc;
+	pugi::xml_parse_result res = doc.load_file(path.c_str());
+
+	if(!res)
+	{
+		LOG(LogError) << "Error parsing input config: " << res.description();
+		return false;
+	}
+
+	pugi::xml_node root = doc.child("inputList");
+	if(!root)
+		return false;
+
+	pugi::xml_node configNode = root.find_child_by_attribute("inputConfig", "deviceGUID", config->getDeviceGUIDString().c_str());
+	if(!configNode)
+		configNode = root.find_child_by_attribute("inputConfig", "deviceName", config->getDeviceName().c_str());
+	if(!configNode)
+		return false;
+
+	config->loadFromXML(configNode);
+	return true;
 }
 
-std::string InputManager::getDeviceGUIDString(int deviceId)
+//used in an "emergency" where no keyboard config could be loaded from the inputmanager config file
+//allows the user to select to reconfigure in menus if this happens without having to delete es_input.cfg manually
+void InputManager::loadDefaultKBConfig()
 {
-    if (deviceId == DEVICE_KEYBOARD)
-        return KEYBOARD_GUID_STRING;
+	InputConfig* cfg = getInputConfigByDevice(DEVICE_KEYBOARD);
 
-    if (deviceId == DEVICE_CEC)
-        return CEC_GUID_STRING;
+	cfg->clear();
+	cfg->mapInput("up", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_UP, 1, true));
+	cfg->mapInput("down", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_DOWN, 1, true));
+	cfg->mapInput("left", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_LEFT, 1, true));
+	cfg->mapInput("right", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_RIGHT, 1, true));
 
-    auto it = mJoysticks.find(deviceId);
-    if (it == mJoysticks.cend()) {
-        LOG(LogError) << "getDeviceGUIDString - deviceId " << deviceId << " not found!";
-        return "Something went horribly wrong";
-    }
+	cfg->mapInput("a", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_RETURN, 1, true));
+	cfg->mapInput("b", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_ESCAPE, 1, true));
+	cfg->mapInput("start", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_F1, 1, true));
+	cfg->mapInput("select", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_F2, 1, true));
 
-    char guid[65];
-    SDL_JoystickGetGUIDString(SDL_JoystickGetGUID(it->second), guid, 65);
-    return std::string(guid);
+	cfg->mapInput("leftshoulder", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_LEFTBRACKET, 1, true));
+	cfg->mapInput("rightshoulder", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_RIGHTBRACKET, 1, true));
 }
 
-InputConfig* InputManager::getInputConfigByDevice(int device)
+void InputManager::writeDeviceConfig(InputConfig* config)
 {
-    if (device == DEVICE_KEYBOARD)
-        return mKeyboardInputConfig.get();
-    else if (device == DEVICE_CEC)
-        return mCECInputConfig.get();
-    else
-        return mInputConfigs[device].get();
+	assert(initialized());
+
+	std::string path = getConfigPath();
+
+	pugi::xml_document doc;
+
+	if(Utils::FileSystem::exists(path))
+	{
+		// merge files
+		pugi::xml_parse_result result = doc.load_file(path.c_str());
+		if(!result)
+		{
+			LOG(LogError) << "Error parsing input config: " << result.description();
+		}
+		else
+		{
+			// successfully loaded, delete the old entry if it exists
+			pugi::xml_node root = doc.child("inputList");
+			if(root)
+			{
+				// if inputAction @type=onfinish is set, let onfinish command take care for creating input configuration.
+				// we just put the input configuration into a temporary input config file.
+				pugi::xml_node actionnode = root.find_child_by_attribute("inputAction", "type", "onfinish");
+				if(actionnode)
+				{
+					path = getTemporaryConfigPath();
+					doc.reset();
+					root = doc.append_child("inputList");
+					root.append_copy(actionnode);
+				}
+				else
+				{
+					pugi::xml_node oldEntry = root.find_child_by_attribute("inputConfig", "deviceGUID",
+											  config->getDeviceGUIDString().c_str());
+					if(oldEntry)
+					{
+						root.remove_child(oldEntry);
+					}
+					oldEntry = root.find_child_by_attribute("inputConfig", "deviceName",
+															config->getDeviceName().c_str());
+					if(oldEntry)
+					{
+						root.remove_child(oldEntry);
+					}
+				}
+			}
+		}
+	}
+
+	pugi::xml_node root = doc.child("inputList");
+	if(!root)
+		root = doc.append_child("inputList");
+
+	config->writeToXML(root);
+	doc.save_file(path.c_str());
+
+	Scripting::fireEvent("config-changed");
+	Scripting::fireEvent("controls-changed");
+
+	// execute any onFinish commands and re-load the config for changes
+	doOnFinish();
+	loadInputConfig(config);
 }
 
-bool InputManager::parseEvent(const SDL_Event& event, Window* window)
+void InputManager::doOnFinish()
 {
-    bool causedEvent = false;
-    int32_t axisValue;
-
-    switch (event.type) {
-        case SDL_CONTROLLERAXISMOTION: {
-            // Whether to only accept input from the first controller.
-            if (Settings::getInstance()->getBool("InputOnlyFirstController"))
-                if (mInputConfigs.begin()->first != event.cdevice.which)
-                    return false;
-
-            // This is needed for a situation which sometimes occur when a game is launched,
-            // some axis input is generated and then the controller is disconnected before
-            // leaving the game. In this case, events for the old device index could be received
-            // when returning from the game. If this happens we simply delete the configuration
-            // map entry.
-            if (!mInputConfigs[event.caxis.which]) {
-                auto it = mInputConfigs.find(event.cdevice.which);
-                mInputConfigs.erase(it);
-                return false;
-            }
-
-            axisValue = event.caxis.value;
-            int deadzone = 0;
-
-            if (event.caxis.axis == SDL_CONTROLLER_AXIS_TRIGGERLEFT ||
-                event.caxis.axis == SDL_CONTROLLER_AXIS_TRIGGERRIGHT) {
-                deadzone = DEADZONE_TRIGGERS;
-            }
-            else {
-                deadzone = DEADZONE_THUMBSTICKS;
-            }
-
-            // Check if the input value switched boundaries.
-            if ((abs(axisValue) > deadzone) !=
-                (abs(mPrevAxisValues[std::make_pair(event.caxis.which, event.caxis.axis)]) >
-                 deadzone)) {
-                int normValue;
-                if (abs(axisValue) <= deadzone) {
-                    normValue = 0;
-                }
-                else {
-                    if (axisValue > 0)
-                        normValue = 1;
-                    else
-                        normValue = -1;
-                }
-
-                window->input(
-                    getInputConfigByDevice(event.caxis.which),
-                    Input(event.caxis.which, TYPE_AXIS, event.caxis.axis, normValue, false));
-                causedEvent = true;
-            }
-
-            mPrevAxisValues[std::make_pair(event.caxis.which, event.caxis.axis)] = axisValue;
-            return causedEvent;
-        }
-        case SDL_CONTROLLERBUTTONDOWN: {
-        }
-        case SDL_CONTROLLERBUTTONUP: {
-            // Whether to only accept input from the first controller.
-            if (Settings::getInstance()->getBool("InputOnlyFirstController"))
-                if (mInputConfigs.begin()->first != event.cdevice.which)
-                    return false;
-
-            // The event filtering below is required as some controllers send button presses
-            // starting with the state 0 when using the D-pad. I consider this invalid behavior
-            // and the more popular controllers such as those from Microsoft and Sony do not show
-            // this strange behavior.
-            int buttonState =
-                mPrevButtonValues[std::make_pair(event.cbutton.which, event.cbutton.button)];
-
-            if ((buttonState == -1 || buttonState == 0) && event.cbutton.state == 0)
-                return false;
-
-            mPrevButtonValues[std::make_pair(event.cbutton.which, event.cbutton.button)] =
-                event.cbutton.state;
-
-            window->input(getInputConfigByDevice(event.cbutton.which),
-                          Input(event.cbutton.which, TYPE_BUTTON, event.cbutton.button,
-                                event.cbutton.state == SDL_PRESSED, false));
-
-            return true;
-        }
-        case SDL_KEYDOWN: {
-
-            // Save button states for alt and command.
-            if (event.key.keysym.sym == SDLK_LALT)
-                sAltDown = true;
-            if (event.key.keysym.sym == SDLK_LGUI)
-                sLguiDown = true;
-
-            if (event.key.keysym.sym == SDLK_BACKSPACE && SDL_IsTextInputActive())
-                window->textInput("\b");
-
-            if (event.key.repeat)
-                return false;
-
-            // Handle application exit.
-            bool exitState;
-            std::string exitOption = Settings::getInstance()->getString("ExitButtonCombo");
-            if (exitOption == "AltF4")
-                exitState = event.key.keysym.sym == SDLK_F4 && sAltDown;
-            else if (exitOption == "CmdQ")
-                exitState = event.key.keysym.sym == SDLK_q && sLguiDown;
-            else if (exitOption == "AltQ")
-                exitState = event.key.keysym.sym == SDLK_q && sAltDown;
-            else
-                exitState = event.key.keysym.sym == SDLK_F4;
-            if (exitState) {
-                SDL_Event quit;
-                quit.type = SDL_QUIT;
-                SDL_PushEvent(&quit);
-                return false;
-            }
-
-            window->input(getInputConfigByDevice(DEVICE_KEYBOARD),
-                          Input(DEVICE_KEYBOARD, TYPE_KEY, event.key.keysym.sym, 1, false));
-            return true;
-        }
-        case SDL_KEYUP: {
-
-            // Release button states.
-            if (event.key.keysym.sym == SDLK_LALT)
-                sAltDown = false;
-            if (event.key.keysym.sym == SDLK_LGUI)
-                sLguiDown = false;
-
-            window->input(getInputConfigByDevice(DEVICE_KEYBOARD),
-                          Input(DEVICE_KEYBOARD, TYPE_KEY, event.key.keysym.sym, 0, false));
-            return true;
-        }
-        case SDL_TEXTINPUT: {
-            window->textInput(event.text.text);
-            break;
-        }
-        case SDL_CONTROLLERDEVICEADDED: {
-            addControllerByDeviceIndex(window, event.cdevice.which);
-            return true;
-        }
-        case SDL_CONTROLLERDEVICEREMOVED: {
-            removeControllerByJoystickID(window, event.cdevice.which);
-            return false;
-        }
-    }
-
-    if ((event.type == static_cast<unsigned int>(SDL_USER_CECBUTTONDOWN)) ||
-        (event.type == static_cast<unsigned int>(SDL_USER_CECBUTTONUP))) {
-        window->input(getInputConfigByDevice(DEVICE_CEC),
-                      Input(DEVICE_CEC, TYPE_CEC_BUTTON, event.user.code,
-                            event.type == static_cast<unsigned int>(SDL_USER_CECBUTTONDOWN),
-                            false));
-        return true;
-    }
-
-    return false;
+	assert(initialized());
+	std::string path = getConfigPath();
+	pugi::xml_document doc;
+
+	if(Utils::FileSystem::exists(path))
+	{
+		pugi::xml_parse_result result = doc.load_file(path.c_str());
+		if(!result)
+		{
+			LOG(LogError) << "Error parsing input config: " << result.description();
+		}
+		else
+		{
+			pugi::xml_node root = doc.child("inputList");
+			if(root)
+			{
+				root = root.find_child_by_attribute("inputAction", "type", "onfinish");
+				if(root)
+				{
+					for(pugi::xml_node command = root.child("command"); command;
+							command = command.next_sibling("command"))
+					{
+						std::string tocall = command.text().get();
+
+						LOG(LogInfo) << "	" << tocall;
+						std::cout << "==============================================\ninput config finish command:\n";
+						int exitCode = runSystemCommand(tocall);
+						std::cout << "==============================================\n";
+
+						if(exitCode != 0)
+						{
+							LOG(LogWarning) << "...launch terminated with nonzero exit code " << exitCode << "!";
+						}
+					}
+				}
+			}
+		}
+	}
 }
 
-bool InputManager::loadInputConfig(InputConfig* config)
+std::string InputManager::getConfigPath()
 {
-    if (!mConfigFileExists)
-        return false;
-
-    std::string path = getConfigPath();
-
-    pugi::xml_document doc;
-#if defined(_WIN64)
-    pugi::xml_parse_result res = doc.load_file(Utils::String::stringToWideString(path).c_str());
-#else
-    pugi::xml_parse_result res = doc.load_file(path.c_str());
-#endif
-
-    if (!res) {
-        LOG(LogError) << "Couldn't parse the input configuration file: " << res.description();
-        return false;
-    }
-
-    pugi::xml_node root = doc.child("inputList");
-    if (!root)
-        return false;
-
-    pugi::xml_node configNode = root.find_child_by_attribute("inputConfig", "deviceGUID",
-                                                             config->getDeviceGUIDString().c_str());
-
-    // Enabling this will match an entry in es_input.xml based on the device name if there
-    // was no GUID match. This is probably not a good idea as many controllers share the same
-    // name even though the GUID differ and potentially the button configuration could be
-    // different between them. Keeping the code for now though.
-    //    if (!configNode)
-    //        configNode = root.find_child_by_attribute("inputConfig",
-    //                "deviceName", config->getDeviceName().c_str());
-
-    // With the move to the SDL GameController API the button layout changed quite a lot, so
-    // es_input.xml files generated using the old API will end up with a completely unusable
-    // controller configuration. These older files had the configuration entry type set to
-    // "joystick", so it's easy to ignore such entries by only accepting entries with the
-    // type set to "controller" (which is now applied when saving the es_input.xml file).
-    if (configNode && config->getDeviceName() != "Keyboard")
-        if (!root.find_child_by_attribute("inputConfig", "type", "controller"))
-            return false;
-
-    if (!configNode)
-        return false;
-
-    config->loadFromXML(configNode);
-    return true;
+	std::string path = Utils::FileSystem::getHomePath();
+	path += "/.emulationstation/es_input.cfg";
+	return path;
 }
 
-void InputManager::loadDefaultKBConfig()
+std::string InputManager::getTemporaryConfigPath()
 {
-    InputConfig* cfg = getInputConfigByDevice(DEVICE_KEYBOARD);
-
-    if (cfg->isConfigured())
-        return;
-
-    cfg->clear();
-    cfg->mapInput("Up", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_UP, 1, true));
-    cfg->mapInput("Down", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_DOWN, 1, true));
-    cfg->mapInput("Left", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_LEFT, 1, true));
-    cfg->mapInput("Right", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_RIGHT, 1, true));
-
-    cfg->mapInput("A", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_RETURN, 1, true));
-    cfg->mapInput("B", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_BACKSPACE, 1, true));
-    cfg->mapInput("X", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_DELETE, 1, true));
-#if defined(__APPLE__)
-    cfg->mapInput("Y", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_PRINTSCREEN, 1, true));
-#else
-    cfg->mapInput("Y", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_INSERT, 1, true));
-#endif
-    cfg->mapInput("Start", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_ESCAPE, 1, true));
-    cfg->mapInput("Back", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_F1, 1, true));
-
-    cfg->mapInput("LeftShoulder", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_PAGEUP, 1, true));
-    cfg->mapInput("RightShoulder", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_PAGEDOWN, 1, true));
-    cfg->mapInput("LeftTrigger", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_HOME, 1, true));
-    cfg->mapInput("RightTrigger", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_END, 1, true));
-
-    cfg->mapInput("LeftThumbstickClick", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_F2, 1, true));
-    cfg->mapInput("RightThumbstickClick", Input(DEVICE_KEYBOARD, TYPE_KEY, SDLK_F3, 1, true));
+	std::string path = Utils::FileSystem::getHomePath();
+	path += "/.emulationstation/es_temporaryinput.cfg";
+	return path;
 }
 
-void InputManager::loadDefaultControllerConfig(SDL_JoystickID deviceIndex)
+bool InputManager::initialized() const
 {
-    InputConfig* cfg = getInputConfigByDevice(deviceIndex);
-
-    if (cfg->isConfigured())
-        return;
-
-    // clang-format off
-    cfg->mapInput("Up", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_DPAD_UP, 1, true));
-    cfg->mapInput("Down", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_DPAD_DOWN, 1, true));
-    cfg->mapInput("Left", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_DPAD_LEFT, 1, true));
-    cfg->mapInput("Right", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_DPAD_RIGHT, 1, true));
-    cfg->mapInput("Start", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_START, 1, true));
-    cfg->mapInput("Back", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_BACK, 1, true));
-    cfg->mapInput("A", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_A, 1, true));
-    cfg->mapInput("B", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_B, 1, true));
-    cfg->mapInput("X", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_X, 1, true));
-    cfg->mapInput("Y", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_Y, 1, true));
-    cfg->mapInput("LeftShoulder", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_LEFTSHOULDER, 1, true));
-    cfg->mapInput("RightShoulder", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_RIGHTSHOULDER, 1, true));
-    cfg->mapInput("LeftTrigger", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_TRIGGERLEFT, 1, true));
-    cfg->mapInput("RightTrigger", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_TRIGGERRIGHT, 1, true));
-    cfg->mapInput("LeftThumbstickUp", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_LEFTY, -1, true));
-    cfg->mapInput("LeftThumbstickDown", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_LEFTY, 1, true));
-    cfg->mapInput("LeftThumbstickLeft", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_LEFTX, -1, true));
-    cfg->mapInput("LeftThumbstickRight", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_LEFTX, 1, true));
-    cfg->mapInput("LeftThumbstickClick", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_LEFTSTICK, 1, true));
-    cfg->mapInput("RightThumbstickUp", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_RIGHTY, -1, true));
-    cfg->mapInput("RightThumbstickDown", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_RIGHTY, 1, true));
-    cfg->mapInput("RightThumbstickLeft", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_RIGHTX, -1, true));
-    cfg->mapInput("RightThumbstickRight", Input(deviceIndex, TYPE_AXIS, SDL_CONTROLLER_AXIS_RIGHTX, 1, true));
-    cfg->mapInput("RightThumbstickClick", Input(deviceIndex, TYPE_BUTTON, SDL_CONTROLLER_BUTTON_RIGHTSTICK, 1, true));
-    // clang-format on
+	return mKeyboardInputConfig != NULL;
 }
 
-void InputManager::addControllerByDeviceIndex(Window* window, int deviceIndex)
+int InputManager::getNumConfiguredDevices()
 {
-    // Open joystick and add it to our list.
-    SDL_GameController* controller = SDL_GameControllerOpen(deviceIndex);
-
-    if (controller == nullptr) {
-        LOG(LogError) << "Couldn't add controller with device index " << deviceIndex;
-        return;
-    }
-
-    SDL_Joystick* joy = SDL_GameControllerGetJoystick(controller);
-
-    // Add it to our list so we can close it again later.
-    SDL_JoystickID joyID = SDL_JoystickInstanceID(joy);
-    mJoysticks[joyID] = joy;
-    mControllers[joyID] = controller;
-
-    char guid[65];
-    SDL_JoystickGetGUIDString(SDL_JoystickGetGUID(joy), guid, 65);
-
-    mInputConfigs[joyID] =
-        std::make_unique<InputConfig>(joyID, SDL_GameControllerName(mControllers[joyID]), guid);
-
-    bool customConfig = loadInputConfig(mInputConfigs[joyID].get());
-
-    if (customConfig) {
-        LOG(LogInfo) << "Added controller with custom configuration: \""
-                     << SDL_GameControllerName(mControllers[joyID]) << "\" (GUID: " << guid
-                     << ", instance ID: " << joyID << ", device index: " << deviceIndex << ")";
-    }
-    else {
-        loadDefaultControllerConfig(joyID);
-        LOG(LogInfo) << "Added controller with default configuration: \""
-                     << SDL_GameControllerName(mControllers[joyID]) << "\" (GUID: " << guid
-                     << ", instance ID: " << joyID << ", device index: " << deviceIndex << ")";
-    }
-
-    if (window != nullptr) {
-        window->queueInfoPopup(
-            "ADDED INPUT DEVICE '" +
-                Utils::String::toUpper(std::string(SDL_GameControllerName(mControllers[joyID]))) +
-                "'",
-            4000);
-    }
-
-    int numAxes = SDL_JoystickNumAxes(joy);
-    int numButtons = SDL_JoystickNumButtons(joy);
-
-    for (int axis = 0; axis < numAxes; ++axis)
-        mPrevAxisValues[std::make_pair(joyID, axis)] = 0;
-
-    for (int button = 0; button < numButtons; ++button)
-        mPrevButtonValues[std::make_pair(joyID, button)] = -1;
+	int num = 0;
+	for(auto it = mInputConfigs.cbegin(); it != mInputConfigs.cend(); it++)
+	{
+		if(it->second->isConfigured())
+			num++;
+	}
+
+	if(mKeyboardInputConfig->isConfigured())
+		num++;
+
+	if(mCECInputConfig->isConfigured())
+		num++;
+
+	return num;
 }
 
-void InputManager::removeControllerByJoystickID(Window* window, SDL_JoystickID joyID)
+std::string InputManager::getDeviceGUIDString(int deviceId)
 {
-    assert(joyID != -1);
-
-    char guid[65];
-    SDL_Joystick* joy = SDL_JoystickFromInstanceID(joyID);
-    SDL_JoystickGetGUIDString(SDL_JoystickGetGUID(joy), guid, 65);
-
-    LOG(LogInfo) << "Removed controller \"" << SDL_GameControllerName(mControllers[joyID])
-                 << "\" (GUID: " << guid << ", instance ID: " << joyID << ")";
-
-    if (window != nullptr) {
-        window->queueInfoPopup(
-            "REMOVED INPUT DEVICE '" +
-                Utils::String::toUpper(std::string(SDL_GameControllerName(mControllers[joyID]))) +
-                "'",
-            4000);
-    }
-
-    // Delete mPrevAxisValues for the device.
-    int axisEntries = static_cast<int>(mPrevAxisValues.size());
-    for (int i = 0; i < axisEntries; ++i) {
-        auto entry = mPrevAxisValues.find(std::make_pair(joyID, i));
-        if (entry != mPrevAxisValues.end()) {
-            mPrevAxisValues.erase(entry);
-        }
-    }
-
-    // Delete mPrevButtonValues for the device.
-    int buttonEntries = static_cast<int>(mPrevButtonValues.size());
-    for (int i = 0; i < buttonEntries; ++i) {
-        auto entry = mPrevButtonValues.find(std::make_pair(joyID, i));
-        if (entry != mPrevButtonValues.end()) {
-            mPrevButtonValues.erase(entry);
-        }
-    }
-
-    auto it = mInputConfigs.find(joyID);
-    mInputConfigs.erase(it);
-
-    // Close the controller and remove its entry.
-    auto controllerIt = mControllers.find(joyID);
-    if (controllerIt != mControllers.cend()) {
-        SDL_GameControllerClose(controllerIt->second);
-        mControllers.erase(controllerIt);
-    }
-    else {
-        LOG(LogError) << "Couldn't find controller to close (instance ID: " << joyID << ")";
-    }
-
-    // Remove the joystick entry.
-    auto joystickIt = mJoysticks.find(joyID);
-    if (joystickIt != mJoysticks.cend()) {
-        mJoysticks.erase(joystickIt);
-    }
-    else {
-        LOG(LogError) << "Couldn't find joystick entry to remove (instance ID: " << joyID << ")";
-    }
+	if(deviceId == DEVICE_KEYBOARD)
+		return KEYBOARD_GUID_STRING;
+
+	if(deviceId == DEVICE_CEC)
+		return CEC_GUID_STRING;
+
+	auto it = mJoysticks.find(deviceId);
+	if(it == mJoysticks.cend())
+	{
+		LOG(LogError) << "getDeviceGUIDString - deviceId " << deviceId << " not found!";
+		return "something went horribly wrong";
+	}
+
+	char guid[65];
+	SDL_JoystickGetGUIDString(SDL_JoystickGetGUID(it->second), guid, 65);
+	return std::string(guid);
 }
diff --git a/es-core/src/InputManager.h b/es-core/src/InputManager.h
index f8a19710..388358d2 100644
--- a/es-core/src/InputManager.h
+++ b/es-core/src/InputManager.h
@@ -1,78 +1,63 @@
-//  SPDX-License-Identifier: MIT
-//
-//  EmulationStation Desktop Edition
-//  InputManager.h
-//
-//  Low-level input handling.
-//  Initiates and maps the keyboard and controllers.
-//  Reads and writes the es_input.xml configuration file.
-//
-
+#pragma once
 #ifndef ES_CORE_INPUT_MANAGER_H
 #define ES_CORE_INPUT_MANAGER_H
 
-#include <SDL2/SDL.h>
-#include <SDL2/SDL_joystick.h>
-
+#include <SDL_joystick.h>
 #include <map>
-#include <memory>
 #include <string>
 
 class InputConfig;
 class Window;
 union SDL_Event;
 
+//you should only ever instantiate one of these, by the way
 class InputManager
 {
-public:
-    InputManager();
-    virtual ~InputManager();
-    static InputManager* getInstance();
+private:
+	InputManager();
 
-    void init();
-    void deinit();
+	static InputManager* mInstance;
 
-    void writeDeviceConfig(InputConfig* config);
-    void doOnFinish();
+	static const int DEADZONE = 23000;
 
-    static std::string getConfigPath();
-    static std::string getTemporaryConfigPath();
+	void loadDefaultKBConfig();
 
-    int getNumConfiguredDevices();
-    int getAxisCountByDevice(int deviceId);
-    int getButtonCountByDevice(int deviceId);
+	std::map<SDL_JoystickID, SDL_Joystick*> mJoysticks;
+	std::map<SDL_JoystickID, InputConfig*> mInputConfigs;
+	InputConfig* mKeyboardInputConfig;
+	InputConfig* mCECInputConfig;
 
-    std::string getDeviceGUIDString(int deviceId);
-    InputConfig* getInputConfigByDevice(int deviceId);
+	std::map<SDL_JoystickID, int*> mPrevAxisValues;
 
-    bool parseEvent(const SDL_Event& event, Window* window);
+	bool initialized() const;
 
-    int getNumJoysticks() { return static_cast<int>(mJoysticks.size()); }
+	void addJoystickByDeviceIndex(int id);
+	void removeJoystickByJoystickID(SDL_JoystickID id);
+	bool loadInputConfig(InputConfig* config); // returns true if successfully loaded, false if not (or didn't exist)
 
-private:
-    bool initialized() const { return mKeyboardInputConfig != nullptr; }
+public:
+	virtual ~InputManager();
+
+	static InputManager* getInstance();
 
-    bool loadInputConfig(InputConfig* config);
-    void loadDefaultKBConfig();
-    void loadDefaultControllerConfig(SDL_JoystickID deviceIndex);
+	void writeDeviceConfig(InputConfig* config);
+	void doOnFinish();
+	static std::string getConfigPath();
+	static std::string getTemporaryConfigPath();
 
-    void addControllerByDeviceIndex(Window* window, int deviceIndex);
-    void removeControllerByJoystickID(Window* window, SDL_JoystickID joyID);
+	void init();
+	void deinit();
 
-    static InputManager* sInstance;
-    static const int DEADZONE_TRIGGERS = 18000;
-    static const int DEADZONE_THUMBSTICKS = 23000;
-    bool mConfigFileExists;
+	int getNumJoysticks();
+	int getAxisCountByDevice(int deviceId);
+	int getButtonCountByDevice(int deviceId);
+	int getNumConfiguredDevices();
 
-    std::map<SDL_JoystickID, SDL_Joystick*> mJoysticks;
-    std::map<SDL_JoystickID, SDL_GameController*> mControllers;
-    std::map<SDL_JoystickID, std::unique_ptr<InputConfig>> mInputConfigs;
+	std::string getDeviceGUIDString(int deviceId);
 
-    std::unique_ptr<InputConfig> mKeyboardInputConfig;
-    std::unique_ptr<InputConfig> mCECInputConfig;
+	InputConfig* getInputConfigByDevice(int deviceId);
 
-    std::map<std::pair<SDL_JoystickID, int>, int> mPrevAxisValues;
-    std::map<std::pair<SDL_JoystickID, int>, int> mPrevButtonValues;
+	bool parseEvent(const SDL_Event& ev, Window* window);
 };
 
 #endif // ES_CORE_INPUT_MANAGER_H
